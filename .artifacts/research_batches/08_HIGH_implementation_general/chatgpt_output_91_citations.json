[
  {
    "claim_id": "CODE-IMPL-132",
    "category": "B",
    "confidence": "HIGH",
    "rationale": "Implements an adaptive sliding mode control concept by estimating uncertainties, which is a theoretical control approach described in textbooks.",
    "code_summary": "Implements online estimation of system uncertainties and disturbance bounds...",
    "needs_citation": true,
    "concept": "Adaptive sliding mode control (uncertainty estimation)",
    "suggested_citation": "Slotine & Li (1991)",
    "bibtex_key": "slotine1991applied",
    "isbn": "978-0130408907",
    "book_title": "Applied Nonlinear Control",
    "reference_type": "book",
    "chapter_section": "Chapter 7: Sliding Control (Adaptive SMC)"
  },
  {
    "claim_id": "CODE-IMPL-135",
    "category": "A",
    "confidence": "HIGH",
    "rationale": "Implements the Recursive Least Squares (RLS) algorithm for parameter estimation, which is a well-known algorithm requiring citation.",
    "code_summary": "Update parameter estimates using RLS algorithm...",
    "needs_citation": true,
    "algorithm_name": "Recursive Least Squares (RLS) algorithm",
    "suggested_citation": "Ljung (1999)",
    "bibtex_key": "ljung1999system",
    "reference_type": "book",
    "isbn": "978-0136566953",
    "book_title": "System Identification: Theory for the User"
  },
  {
    "claim_id": "CODE-IMPL-150",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Initializes controllers depending on the hybrid mode, which is a pure implementation detail and does not involve any algorithm or theory needing citation.",
    "code_summary": "Initialize individual SMC controllers based on hybrid mode...",
    "needs_citation": false,
    "implementation_type": "initialization"
  },
  {
    "claim_id": "CODE-IMPL-152",
    "category": "A",
    "confidence": "HIGH",
    "rationale": "Implements the hybrid switching logic for multiple SMC controllers, an algorithmic approach in hybrid control that requires referencing hybrid system stability theory.",
    "code_summary": "Hybrid Switching Logic for Multi-Controller SMC...",
    "needs_citation": true,
    "algorithm_name": "Hybrid switching control logic",
    "suggested_citation": "Branicky (1998)",
    "bibtex_key": "branicky1998hybrid",
    "doi_or_url": "10.1109/9.664150",
    "paper_title": "Multiple Lyapunov functions and other analysis tools for switched and hybrid systems",
    "reference_type": "paper"
  },
  {
    "claim_id": "CODE-IMPL-155",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This is a specific implementation of a switching criterion based on control effort, which is an internal logic detail without a standard algorithm reference.",
    "code_summary": "Evaluate switching based on control effort...",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-157",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This implements a switching criterion based on the adaptation rate for adaptive controllers, which is a custom logic detail and does not correspond to a known algorithm requiring citation.",
    "code_summary": "Evaluate switching based on adaptation rate (for adaptive controllers)...",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-159",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This implements a time-based (round-robin) switching mechanism, a scheduling detail in the code not derived from a specific published algorithm, so no citation is needed.",
    "code_summary": "Evaluate switching based on time (round-robin or scheduled switching)...",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-121",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "It discusses the use of Python named tuples (a programming detail), which is purely an implementation detail and not related to control theory or algorithms requiring citations.",
    "code_summary": "use named tuples are\n    subclasses of `tuple`...",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-122",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This is a compatibility function for setting the dynamics model, which is a software interface detail and not an algorithm or concept that needs citation.",
    "code_summary": "Set dynamics model (for compatibility, not used in this implementation)...",
    "needs_citation": false,
    "implementation_type": "interface"
  },
  {
    "claim_id": "CODE-IMPL-181",
    "category": "A",
    "confidence": "HIGH",
    "rationale": "Implements the standard equivalent control calculation from sliding mode control theory, which is a known algorithm requiring a canonical reference.",
    "code_summary": "Computes the equivalent control component for sliding mode control (SMC).",
    "needs_citation": true,
    "algorithm_name": "Sliding Mode Equivalent Control method",
    "suggested_citation": "Utkin (1992)",
    "bibtex_key": "Utkin1992sliding",
    "doi_or_url": "10.1007/978-3-642-84379-2",
    "paper_title": "Sliding Modes in Control and Optimization",
    "reference_type": "paper"
  },
  {
    "claim_id": "CODE-IMPL-182",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Pure initialization code for equivalent control (setting parameters) with no new algorithm or theory involved.",
    "code_summary": "Initializes the equivalent control computation (e.g., setting regularization parameter).",
    "needs_citation": false,
    "implementation_type": "initialization"
  },
  {
    "claim_id": "CODE-IMPL-183",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This function only performs validation of controller gain values, which is an internal implementation detail without an external theory or algorithm.",
    "code_summary": "Validates SMC controller gain values in a centralized manner.",
    "needs_citation": false,
    "implementation_type": "validation"
  },
  {
    "claim_id": "CODE-IMPL-192",
    "category": "B",
    "confidence": "HIGH",
    "rationale": "Refers to the chattering effect in practice, which is a theoretical concept in sliding mode control and not a new algorithm implementation.",
    "code_summary": "Accounts for the chattering phenomenon as encountered in practical SMC usage.",
    "needs_citation": true,
    "concept": "Chattering phenomenon in Sliding Mode Control",
    "suggested_citation": "Utkin (1992)",
    "bibtex_key": "Utkin1992sliding",
    "isbn": "978-3642843976",
    "book_title": "Sliding Modes in Control and Optimization",
    "reference_type": "book",
    "chapter_section": "Chapter 1: Introduction to Sliding Mode Control (chattering phenomenon)"
  },
  {
    "claim_id": "CODE-IMPL-193",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Simply computes a derivative of the switching function, a straightforward implementation without invoking any specific control algorithm or theory concept.",
    "code_summary": "Computes the derivative of the sliding mode switching function.",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-194",
    "category": "B",
    "confidence": "HIGH",
    "rationale": "Describes a smooth switching function (using tanh) with an optimized slope to mitigate chattering, which is a control design concept from SMC theory rather than a named algorithm.",
    "code_summary": "Defines a hyperbolic tangent switching function with an optimized slope for smoother control action.",
    "needs_citation": true,
    "concept": "Boundary layer technique for chattering reduction",
    "suggested_citation": "Utkin (1992)",
    "bibtex_key": "Utkin1992sliding",
    "isbn": "978-3642843976",
    "book_title": "Sliding Modes in Control and Optimization",
    "reference_type": "book",
    "chapter_section": "Chapter 9: Control Under Uncertainty Conditions (boundary layer method)"
  },
  {
    "claim_id": "CODE-IMPL-195",
    "category": "B",
    "confidence": "HIGH",
    "rationale": "Mentions the chattering seen in real systems, highlighting a known SMC phenomenon; this is a theoretical concept explained in textbooks, not an implemented algorithm.",
    "code_summary": "Highlights the chattering effect as observed in real physical SMC systems.",
    "needs_citation": true,
    "concept": "Chattering phenomenon in Sliding Mode Control",
    "suggested_citation": "Utkin (1992)",
    "bibtex_key": "Utkin1992sliding",
    "isbn": "978-3642843976",
    "book_title": "Sliding Modes in Control and Optimization",
    "reference_type": "book",
    "chapter_section": "Chapter 1: Introduction to Sliding Mode Control (chattering phenomenon)"
  },
  {
    "claim_id": "CODE-IMPL-178",
    "category": "A",
    "confidence": "HIGH",
    "rationale": "Implements part of the classical sliding mode control law using six gain parameters, which is a specific control algorithm requiring citation of its original source.",
    "code_summary": "Uses six gain parameters in a specified order for the classical SMC law.",
    "needs_citation": true,
    "algorithm_name": "Classical Sliding Mode Control (SMC) algorithm",
    "suggested_citation": "Utkin (1977)",
    "bibtex_key": "Utkin1977Sliding",
    "doi_or_url": "10.1109/TAC.1977.1101446",
    "paper_title": "Variable Structure Systems with Sliding Modes",
    "reference_type": "paper"
  },
  {
    "claim_id": "CODE-IMPL-180",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This code simply resets the controller's internal state, which is a pure implementation detail not involving any novel algorithm or theory.",
    "code_summary": "Resets the state of the Classical SMC controller to its initial values.",
    "needs_citation": false,
    "implementation_type": "initialization"
  },
  {
    "claim_id": "CODE-IMPL-201",
    "category": "A",
    "confidence": "HIGH",
    "rationale": "This is implementing the core computations of the Super-Twisting sliding mode control algorithm (using Numba for speed), which is a specific known algorithm needing a reference to its original paper.",
    "code_summary": "Numba-accelerated core of the Super-Twisting SMC algorithm.",
    "needs_citation": true,
    "algorithm_name": "Super-Twisting Sliding Mode Control algorithm",
    "suggested_citation": "Levant (1993)",
    "bibtex_key": "Levant1993Twisting",
    "doi_or_url": "10.1016/0005-1098(93)90127-K",
    "paper_title": "Sliding order and sliding accuracy in sliding mode control",
    "reference_type": "paper"
  },
  {
    "claim_id": "CODE-IMPL-204",
    "category": "B",
    "confidence": "MEDIUM",
    "rationale": "The code deals with using a saturated sign function, which is intended to mitigate the chattering phenomenon in sliding mode control. This relates to a theoretical concept (chattering) explained in textbooks, not a new algorithm, so a textbook citation is appropriate.",
    "code_summary": "Initializes a Super-Twisting SMC controller, including an option to use a saturated sign function.",
    "needs_citation": true,
    "concept": "Chattering in sliding mode control",
    "suggested_citation": "Utkin (1992)",
    "bibtex_key": "Utkin1992Sliding",
    "isbn": "978-3642843976",
    "book_title": "Sliding Modes in Control and Optimization",
    "reference_type": "book",
    "chapter_section": "Chapter 11: Systems with High Gains and Discontinuous Controls"
  },
  {
    "claim_id": "CODE-IMPL-167",
    "category": "A",
    "confidence": "HIGH",
    "rationale": "This code performs a check on the super-twisting controller's gain values to ensure they meet the algorithm's requirements, which is part of implementing the super-twisting algorithm and thus needs the original algorithm reference.",
    "code_summary": "Performs a vectorized feasibility check to ensure the super-twisting SMC gains satisfy required conditions.",
    "needs_citation": true,
    "algorithm_name": "Super-Twisting Sliding Mode Control algorithm",
    "suggested_citation": "Levant (1993)",
    "bibtex_key": "Levant1993Twisting",
    "doi_or_url": "10.1016/0005-1098(93)90127-K",
    "paper_title": "Sliding order and sliding accuracy in sliding mode control",
    "reference_type": "paper"
  },
  {
    "claim_id": "CODE-IMPL-517",
    "category": "A",
    "confidence": "HIGH",
    "rationale": "The code references the super-twisting algorithm and handling of control outputs between time steps, indicating it's implementing the known super-twisting control method, which should be credited to its original source.",
    "code_summary": "Stores outputs according to the Super-Twisting algorithm that are needed to resume control at the next time step.",
    "needs_citation": true,
    "algorithm_name": "Super-Twisting Sliding Mode Control algorithm",
    "suggested_citation": "Levant (1993)",
    "bibtex_key": "Levant1993Twisting",
    "doi_or_url": "10.1016/0005-1098(93)90127-K",
    "paper_title": "Sliding order and sliding accuracy in sliding mode control",
    "reference_type": "paper"
  },
  {
    "claim_id": "CODE-IMPL-321",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Implements a factory pattern for optimizer instantiation, a code design feature not tied to a specific algorithm or theory.",
    "code_summary": "Factory method to create optimizers...",
    "needs_citation": false,
    "implementation_type": "factory"
  },
  {
    "claim_id": "CODE-IMPL-322",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This function retrieves a list of available optimization algorithms, which is a utility function and not tied to any algorithm's theory.",
    "code_summary": "Get list of available optimization algorithms...",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-323",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Provides a quick optimization routine as a convenience wrapper, which is an implementation detail rather than an algorithm implementation or theory.",
    "code_summary": "Quick optimization function...",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-325",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Defines a parameter space attribute in an optimization interface, which is a structural code element without implementing an algorithm or theory concept.",
    "code_summary": "parameter_space : ParameterSpace...",
    "needs_citation": false,
    "implementation_type": "interface"
  },
  {
    "claim_id": "CODE-IMPL-326",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Specifies an optimization problem attribute in the interface, which is a code implementation detail rather than an algorithm or theoretical concept.",
    "code_summary": "problem : OptimizationProblem...",
    "needs_citation": false,
    "implementation_type": "interface"
  },
  {
    "claim_id": "CODE-IMPL-327",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Uses an interface property to store or return the algorithm's name, a purely informational implementation detail not tied to a specific algorithmic method or theory.",
    "code_summary": "Name of the optimization algorithm...",
    "needs_citation": false,
    "implementation_type": "interface"
  },
  {
    "claim_id": "CODE-IMPL-328",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Indicates via an interface property whether the algorithm supports constraints, which is a feature flag in code and not an implemented algorithm or theoretical principle requiring citation.",
    "code_summary": "Whether algorithm supports constraints...",
    "needs_citation": false,
    "implementation_type": "interface"
  },
  {
    "claim_id": "CODE-IMPL-329",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Indicates via an interface property whether the algorithm supports parameter bounds, a code-level feature indicator not corresponding to a specific algorithm or theory needing citation.",
    "code_summary": "Whether algorithm supports parameter bounds...",
    "needs_citation": false,
    "implementation_type": "interface"
  },
  {
    "claim_id": "CODE-IMPL-330",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Marks whether an optimizer uses a population of candidates, which is a classification of algorithm type in code (population-based vs single-point) and not an implementation of an algorithm itself.",
    "code_summary": "uses a population of candidates...",
    "needs_citation": false,
    "implementation_type": "interface"
  },
  {
    "claim_id": "CODE-IMPL-331",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Defines an abstract interface method for updating a population based on fitness, representing a generic algorithm step placeholder rather than a concrete algorithm implementation or theoretical concept explanation.",
    "code_summary": "Update population based on fitness values...",
    "needs_citation": false,
    "implementation_type": "interface"
  },
  {
    "claim_id": "CODE-IMPL-332",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Pure implementation detail - initialization or utility function",
    "code_summary": "Initialize multi-objective problem...",
    "needs_citation": false,
    "implementation_type": "initialization"
  },
  {
    "claim_id": "CODE-IMPL-334",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Pure implementation detail - initialization or utility function",
    "code_summary": "Initialize composite objective...",
    "needs_citation": false,
    "implementation_type": "initialization"
  },
  {
    "claim_id": "CODE-IMPL-335",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Pure implementation detail - initialization or utility function",
    "code_summary": "Combine objective values according to method...",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-336",
    "category": "B",
    "confidence": "HIGH",
    "rationale": "Computes robustness objective using H-infinity norm, a control theory concept",
    "code_summary": "Compute robustness objective...",
    "needs_citation": true,
    "concept": "Robustness in control systems (H-infinity norm)",
    "suggested_citation": "Zhou & Doyle (1998)",
    "bibtex_key": "zhou1998essentials",
    "isbn": "978-0135258330",
    "book_title": "Essentials of Robust Control",
    "reference_type": "book",
    "chapter_section": "Chapter 2: Robust Control Performance"
  },
  {
    "claim_id": "CODE-IMPL-339",
    "category": "B",
    "confidence": "HIGH",
    "rationale": "Objective based on frequency response characteristics, a control theory concept",
    "code_summary": "Objective based on frequency response characteristics...",
    "needs_citation": true,
    "concept": "Frequency response analysis in control systems",
    "suggested_citation": "Ogata (2010)",
    "bibtex_key": "ogata2010modern",
    "isbn": "978-0136156734",
    "book_title": "Modern Control Engineering",
    "reference_type": "book",
    "chapter_section": "Chapter 7: Frequency Response Analysis"
  },
  {
    "claim_id": "CODE-IMPL-340",
    "category": "A",
    "confidence": "HIGH",
    "rationale": "Implements Pareto dominance check for multi-objective optimization",
    "code_summary": "Multi-objective optimization using Pareto dominance...",
    "needs_citation": true,
    "algorithm_name": "Pareto Dominance in Multi-Objective Optimization",
    "suggested_citation": "Deb (2001)",
    "bibtex_key": "deb2001multi",
    "isbn": "978-0471873396",
    "book_title": "Multi-Objective Optimization using Evolutionary Algorithms",
    "reference_type": "book"
  },
  {
    "claim_id": "CODE-IMPL-341",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Pure implementation detail - initialization or utility function",
    "code_summary": "Initialize Pareto multi-objective...",
    "needs_citation": false,
    "implementation_type": "initialization"
  },
  {
    "claim_id": "CODE-IMPL-342",
    "category": "A",
    "confidence": "HIGH",
    "rationale": "Implements weighted sum scalarization for multi-objective optimization",
    "code_summary": "Multi-objective optimization using weighted sum scalarization...",
    "needs_citation": true,
    "algorithm_name": "Weighted Sum Scalarization",
    "suggested_citation": "Marler & Arora (2004)",
    "bibtex_key": "marler2004survey",
    "doi_or_url": "10.1007/s00158-004-0370-0",
    "paper_title": "Survey of multi-objective optimization methods for engineering",
    "reference_type": "paper"
  },
  {
    "claim_id": "CODE-IMPL-343",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Pure implementation detail - initialization or utility function",
    "code_summary": "Initialize weighted sum multi-objective...",
    "needs_citation": false,
    "implementation_type": "initialization"
  },
  {
    "claim_id": "CODE-IMPL-344",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Normalizes objective values - pure implementation utility",
    "code_summary": "Normalize objective values based on selected method...",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-382",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This code implements the full double inverted pendulum (DIP) dynamics which is specific to the project and not a general algorithm or theory requiring citation.",
    "code_summary": "Full Fidelity DIP Dynamics Model",
    "needs_citation": false,
    "implementation_type": "initialization"
  },
  {
    "claim_id": "CODE-IMPL-384",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This is a compatibility interface method for legacy code; it does not implement any algorithm or theoretical concept that requires external citation.",
    "code_summary": "Compatibility method for legacy code expecting _rhs_core",
    "needs_citation": false,
    "implementation_type": "interface"
  },
  {
    "claim_id": "CODE-IMPL-386",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This code performs a physics calculation for the DIP's dynamics, which is a specific implementation detail and not a standard algorithm or control theory concept that would need a citation.",
    "code_summary": "Full-fidelity physics computation for DIP dynamics",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-387",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This code computes the right-hand side of the DIP dynamics equations as part of the model's implementation, which is not an externally defined algorithm or concept requiring a citation.",
    "code_summary": "Compute complete right-hand side of dynamics equation",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-390",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This defines a low-rank DIP dynamics model specific to the project; it is purely an implementation variation of the system model rather than a known algorithm or theoretical concept from literature.",
    "code_summary": "Low-rank DIP Dynamics Model",
    "needs_citation": false,
    "implementation_type": "initialization"
  },
  {
    "claim_id": "CODE-IMPL-393",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This code handles physics computations for the low-rank DIP model, which is an internal implementation detail and not a standard algorithm or theory requiring external reference.",
    "code_summary": "Low-rank DIP Physics Computer",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-370",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This code deals with a compatibility module for the plant's core dynamics, which is part of the software infrastructure and does not implement a specific algorithm or explain a theory concept, hence it falls under pure implementation (Category C).",
    "code_summary": "Compatibility module for core plant dynamics integration.",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-375",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "The code provides simplified computations of physics matrices for efficiency. This is an implementation detail for performance and doesn't correspond to any standard algorithm or theoretical concept that would need a literature reference, so it is categorized as a pure implementation (Category C).",
    "code_summary": "Computes simplified physics matrices for the DIP model to improve efficiency.",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-378",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This code defines or lists available numerical integration methods (like Euler or RK4) within a dynamics interface. It is part of the interface/infrastructure and does not itself implement these algorithms' logic or provide theoretical exposition, thus it is a pure implementation detail (Category C) and requires no citation.",
    "code_summary": "Defines available numerical integration methods for dynamics simulation.",
    "needs_citation": false,
    "implementation_type": "interface"
  },
  {
    "claim_id": "CODE-IMPL-379",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This is an interface method for computing system dynamics given state and input. It's an infrastructure element specifying how models should provide dynamics calculations, not a particular algorithm or theory concept. Therefore, it's purely an implementation detail (Category C) without need for external citation.",
    "code_summary": "Interface method to compute system dynamics from a given state and input.",
    "needs_citation": false,
    "implementation_type": "interface"
  },
  {
    "claim_id": "CODE-IMPL-397",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This code defines a simplified double inverted pendulum dynamics model. It's implementing the system's equations of motion in code. While it uses known physics, it doesn't implement a named algorithm or discuss theory beyond the model itself, making it a pure implementation (Category C) with no citation required.",
    "code_summary": "Defines a simplified double inverted pendulum (DIP) dynamics model.",
    "needs_citation": false,
    "implementation_type": "initialization"
  },
  {
    "claim_id": "CODE-IMPL-399",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This function computes the system's dynamics using a standard modular approach (likely assembling contributions like mass, coriolis, gravity). It's essentially code performing calculations and not invoking a published algorithm or explaining a theory concept. Thus it's a pure implementation detail (Category C) without a need for citation.",
    "code_summary": "Computes DIP dynamics using a standard modular calculation approach.",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-400",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This code computes the dynamics using a fast JIT-compiled approach for performance. It's a coding technique to speed up calculations, not a formal control algorithm from literature or a theoretical concept explanation. Therefore, it's a pure implementation optimization (Category C) with no citation needed.",
    "code_summary": "Computes DIP dynamics using a fast JIT-compiled approach for performance.",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-402",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This module handles simplified physics computations for the double inverted pendulum. It is implementing the physics calculations in code. It doesn't introduce a specific control algorithm from literature or a novel theoretical concept, so it's considered pure implementation (Category C) and does not require citation.",
    "code_summary": "Module for simplified physics computations of the double inverted pendulum.",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-403",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This function computes parts of the DIP dynamics using the simplified physics model (non-JIT). It's essentially a calculation function. It doesn't implement a named algorithm from research or describe a theoretical concept on its own, which makes it a pure implementation detail (Category C) that doesn't need a citation.",
    "code_summary": "Computes DIP dynamic physics using the simplified model (non-JIT).",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-404",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This is a JIT-compiled version of the dynamics computation, focusing on faster execution of the DIP physics calculations. It's a performance-oriented implementation and not tied to any standard algorithm or theoretical discussion, so it qualifies as a pure implementation (Category C) without the need for citation.",
    "code_summary": "JIT-compiled function for computing DIP dynamics using simplified physics.",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-437",
    "category": "A",
    "confidence": "HIGH",
    "rationale": "Implements the Dormand-Prince 4(5) Runge-Kutta integrator (RK45), a known numerical integration algorithm, which requires a citation to its standard reference.",
    "code_summary": "Legacy Dormand-Prince 4(5) step function for backward compatibility...",
    "needs_citation": true,
    "algorithm_name": "Dormand-Prince 4(5) method (RK45 adaptive integrator)",
    "suggested_citation": "Hairer et al. (1993)",
    "bibtex_key": "Hairer1993ODE",
    "doi_or_url": "10.1007/978-3-540-78862-1",
    "paper_title": "Solving Ordinary Differential Equations I: Nonstiff Problems",
    "reference_type": "paper"
  },
  {
    "claim_id": "CODE-IMPL-438",
    "category": "A",
    "confidence": "HIGH",
    "rationale": "Provides an original Runge-Kutta 4(5) (RK45) integration routine (Dormand-Prince method) as a fallback, which is an established integration algorithm requiring a canonical citation.",
    "code_summary": "Original RK45 implementation for fallback...",
    "needs_citation": true,
    "algorithm_name": "Dormand-Prince RK45 integration algorithm",
    "suggested_citation": "Hairer et al. (1993)",
    "bibtex_key": "Hairer1993ODE",
    "doi_or_url": "10.1007/978-3-540-78862-1",
    "paper_title": "Solving Ordinary Differential Equations I: Nonstiff Problems",
    "reference_type": "paper"
  },
  {
    "claim_id": "CODE-IMPL-451",
    "category": "A",
    "confidence": "HIGH",
    "rationale": "Implements both forward (explicit) and backward (implicit) Euler methods for numerical integration, which are standard algorithms and thus require citing a standard reference.",
    "code_summary": "Euler integration methods (explicit and implicit)...",
    "needs_citation": true,
    "algorithm_name": "Forward (explicit) and backward (implicit) Euler integration methods",
    "suggested_citation": "Hairer et al. (1993)",
    "bibtex_key": "Hairer1993ODE",
    "doi_or_url": "10.1007/978-3-540-78862-1",
    "paper_title": "Solving Ordinary Differential Equations I: Nonstiff Problems",
    "reference_type": "paper"
  },
  {
    "claim_id": "CODE-IMPL-452",
    "category": "A",
    "confidence": "HIGH",
    "rationale": "This code implements the forward (explicit) Euler integration algorithm, a well-known numerical method, so it needs a reference to its standard description.",
    "code_summary": "Forward (explicit) Euler integration method...",
    "needs_citation": true,
    "algorithm_name": "Forward Euler integration method (explicit Euler)",
    "suggested_citation": "Hairer et al. (1993)",
    "bibtex_key": "Hairer1993ODE",
    "doi_or_url": "10.1007/978-3-540-78862-1",
    "paper_title": "Solving Ordinary Differential Equations I: Nonstiff Problems",
    "reference_type": "paper"
  },
  {
    "claim_id": "CODE-IMPL-454",
    "category": "A",
    "confidence": "HIGH",
    "rationale": "Uses the forward Euler method to integrate, which is the explicit Euler algorithm and thus should be cited to a numerical integration reference.",
    "code_summary": "Integrate using forward Euler method...",
    "needs_citation": true,
    "algorithm_name": "Forward Euler integration method (explicit Euler)",
    "suggested_citation": "Hairer et al. (1993)",
    "bibtex_key": "Hairer1993ODE",
    "doi_or_url": "10.1007/978-3-540-78862-1",
    "paper_title": "Solving Ordinary Differential Equations I: Nonstiff Problems",
    "reference_type": "paper"
  },
  {
    "claim_id": "CODE-IMPL-455",
    "category": "A",
    "confidence": "HIGH",
    "rationale": "Implements the backward (implicit) Euler integration method, which is a specific algorithm in numerical ODE solving and requires a reference to a standard source.",
    "code_summary": "Backward (implicit) Euler integration method...",
    "needs_citation": true,
    "algorithm_name": "Backward Euler integration method (implicit Euler)",
    "suggested_citation": "Hairer et al. (1993)",
    "bibtex_key": "Hairer1993ODE",
    "doi_or_url": "10.1007/978-3-540-78862-1",
    "paper_title": "Solving Ordinary Differential Equations I: Nonstiff Problems",
    "reference_type": "paper"
  },
  {
    "claim_id": "CODE-IMPL-457",
    "category": "A",
    "confidence": "HIGH",
    "rationale": "Uses the backward Euler method for integration, which is the implicit Euler algorithm, necessitating a citation to the standard numerical integration reference.",
    "code_summary": "Integrate using backward Euler method...",
    "needs_citation": true,
    "algorithm_name": "Backward Euler integration method (implicit Euler)",
    "suggested_citation": "Hairer et al. (1993)",
    "bibtex_key": "Hairer1993ODE",
    "doi_or_url": "10.1007/978-3-540-78862-1",
    "paper_title": "Solving Ordinary Differential Equations I: Nonstiff Problems",
    "reference_type": "paper"
  },
  {
    "claim_id": "CODE-IMPL-458",
    "category": "A",
    "confidence": "HIGH",
    "rationale": "Introduces the modified Euler method (Heun's method), which is a known second-order integration algorithm, so a citation to a canonical source is needed.",
    "code_summary": "Modified Euler method (Heun's method)...",
    "needs_citation": true,
    "algorithm_name": "Heun's method (Modified Euler integrator)",
    "suggested_citation": "Hairer et al. (1993)",
    "bibtex_key": "Hairer1993ODE",
    "doi_or_url": "10.1007/978-3-540-78862-1",
    "paper_title": "Solving Ordinary Differential Equations I: Nonstiff Problems",
    "reference_type": "paper"
  },
  {
    "claim_id": "CODE-IMPL-460",
    "category": "A",
    "confidence": "HIGH",
    "rationale": "Uses the modified Euler (Heun's) method for integration, an established algorithm that should be cited to a standard numerical method reference.",
    "code_summary": "Integrate using modified Euler (Heun's) method...",
    "needs_citation": true,
    "algorithm_name": "Heun's method (Modified Euler integrator)",
    "suggested_citation": "Hairer et al. (1993)",
    "bibtex_key": "Hairer1993ODE",
    "doi_or_url": "10.1007/978-3-540-78862-1",
    "paper_title": "Solving Ordinary Differential Equations I: Nonstiff Problems",
    "reference_type": "paper"
  },
  {
    "claim_id": "CODE-IMPL-440",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This code solely initializes the base integrator class structure (software setup) without implementing any algorithm or theory, so no citation is required.",
    "code_summary": "Initialize base integrator...",
    "needs_citation": false,
    "implementation_type": "initialization"
  },
  {
    "claim_id": "CODE-IMPL-443",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This code initializes the data structure for integration results, a pure implementation detail not tied to a specific algorithm or theory, so no citation is needed.",
    "code_summary": "Initialize integration result...",
    "needs_citation": false,
    "implementation_type": "initialization"
  },
  {
    "claim_id": "CODE-IMPL-406",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This code deals with setting up and storing the simulation context, which is an implementation detail (initialization of simulation parameters) and not an algorithm or theory concept.",
    "code_summary": "Initializes and holds the context for a simulation run.",
    "needs_citation": false,
    "implementation_type": "initialization"
  },
  {
    "claim_id": "CODE-IMPL-410",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "The code is defining or documenting an 'integration method order' as a property in an interface, which is a software detail. It is not implementing a specific algorithm or explaining a theoretical concept, just representing a parameter, so it doesn't require an external citation.",
    "code_summary": "Specifies the order of the numerical integration method.",
    "needs_citation": false,
    "implementation_type": "interface"
  },
  {
    "claim_id": "CODE-IMPL-411",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This is an interface method to execute the simulation with a given strategy. It's a part of the simulation infrastructure (design of how simulation runs) rather than implementing a known algorithm or a control theory concept.",
    "code_summary": "Executes the simulation using the specified strategy.",
    "needs_citation": false,
    "implementation_type": "interface"
  },
  {
    "claim_id": "CODE-IMPL-415",
    "category": "C",
    "confidence": "MEDIUM",
    "rationale": "This function advances the simulation by one time step, which is a general implementation task in the simulation's time management. It likely calls an integration step but does not explicitly implement a known algorithm (the details are handled elsewhere). Therefore it's treated as a utility implementation detail rather than an algorithm needing citation.",
    "code_summary": "Advances the simulation by one time step.",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-420",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "The code serves as a router for simulation steps, which is part of the internal control flow of the simulation engine. It's infrastructure code that directs how each simulation step is processed, not a specific algorithm or theoretical concept from control theory.",
    "code_summary": "Routes a simulation step to the appropriate executor.",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-422",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This is a unified entry point for stepping the simulation, essentially providing a single interface for simulation steps. It is a design/structural aspect of the code (an interface to the simulation engine), not an implementation of a control algorithm or theory, so it doesn't need an external citation.",
    "code_summary": "Provides a unified entry point for performing a simulation step.",
    "needs_citation": false,
    "implementation_type": "interface"
  },
  {
    "claim_id": "CODE-IMPL-423",
    "category": "A",
    "confidence": "HIGH",
    "rationale": "This code implements the explicit Euler integration method to simulate a controller trajectory. The Euler method is a well-known numerical integration algorithm, so a citation to a canonical reference for the Euler method is required.",
    "code_summary": "Uses the explicit Euler method to simulate a single controller trajectory.",
    "needs_citation": true,
    "algorithm_name": "Explicit Euler method",
    "suggested_citation": "Hairer et al. (1993)",
    "bibtex_key": "hairer1993solving",
    "doi_or_url": "10.1007/978-3-540-78862-1",
    "paper_title": "Solving Ordinary Differential Equations I: Nonstiff Problems",
    "reference_type": "paper"
  },
  {
    "claim_id": "CODE-IMPL-473",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This method executes the simulation using a strategy defined by the orchestrator. It's specific to the orchestrator's design (how it runs simulations) and is part of the code's execution logic. It does not involve implementing a known algorithm from literature or explaining theory.",
    "code_summary": "Executes the simulation using an orchestrator-specific strategy.",
    "needs_citation": false,
    "implementation_type": "interface"
  },
  {
    "claim_id": "CODE-IMPL-474",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This code runs a single simulation in the context of a parallel orchestrator. It likely spawns or delegates to a sequential run for each simulation and is an implementation detail of the orchestrator. It doesn't correspond to a standard algorithm or theory concept, just how the parallel orchestrator manages simulations.",
    "code_summary": "Runs a single simulation using the sequential orchestrator strategy (in a parallel context).",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-476",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "This is a legacy simulation runner kept for backward compatibility. It's purely an implementation detail to maintain older interfaces and doesn't implement any new algorithm or require theoretical explanation. Therefore, it doesn't need any citation.",
    "code_summary": "Provides a legacy simulation runner for backward compatibility.",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-085",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Uses simulator default settings, pure initialization without algorithm.",
    "code_summary": "use default from simulator...",
    "needs_citation": false,
    "implementation_type": "initialization"
  },
  {
    "claim_id": "CODE-IMPL-115",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Calls the system dynamics function, a straightforward utility implementation.",
    "code_summary": "Robustly call continuous\u2011time dynamics: xdot = f(x,u)...",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-117",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Handles imports for compatibility, no algorithm or theory involved.",
    "code_summary": "Compatibility import for MPC controller...",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-446",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Integration code with fallback mechanism, implementation detail rather than a new algorithm.",
    "code_summary": "Safely integrate using fallback method...",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-448",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "States a property of the integration method; it's a code comment rather than an algorithmic implementation.",
    "code_summary": "Integration method order (exact for linear systems)...",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-449",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Performs zero-order-hold integration on nonlinear dynamics, a practical implementation detail.",
    "code_summary": "Integrate nonlinear system with ZOH control approximation...",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-477",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Defines data container classes for results; purely implementation code.",
    "code_summary": "Result container implementations for simulation data...",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-478",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Implements a generic recovery strategy, a software design component rather than a theoretical concept.",
    "code_summary": "Implement recovery strategy...",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-479",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Implements an emergency stop behavior; it's code for a specific action, not an algorithm from literature.",
    "code_summary": "Emergency stop recovery strategy...",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-480",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Implements state limiting logic; a practical code solution with no citation needed.",
    "code_summary": "State limiting recovery strategy...",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-481",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Registers recovery strategies in the system; typical interface code, not an algorithm concept.",
    "code_summary": "Register recovery strategy for specific violation type...",
    "needs_citation": false,
    "implementation_type": "utility"
  },
  {
    "claim_id": "CODE-IMPL-482",
    "category": "C",
    "confidence": "HIGH",
    "rationale": "Dispatches the recovery strategy; general implementation code.",
    "code_summary": "Apply appropriate recovery strategy...",
    "needs_citation": false,
    "implementation_type": "utility"
  }
]