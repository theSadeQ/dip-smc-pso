{
  "metadata": {
    "total_claims": 38,
    "by_priority": {
      "MEDIUM": 38
    }
  },
  "research_queue": {
    "MEDIUM": [
      "FORMAL-DEFINITION-002",
      "FORMAL-DEFINITION-003",
      "FORMAL-DEFINITION-006",
      "FORMAL-DEFINITION-007",
      "FORMAL-DEFINITION-009",
      "FORMAL-THEOREM-011",
      "FORMAL-DEFINITION-012",
      "FORMAL-DEFINITION-013",
      "FORMAL-DEFINITION-014",
      "FORMAL-DEFINITION-015",
      "FORMAL-ASSUMPTION-017",
      "FORMAL-DEFINITION-018",
      "CODE-IMPL-006",
      "CODE-IMPL-040",
      "CODE-IMPL-041",
      "CODE-IMPL-042",
      "CODE-IMPL-043",
      "CODE-IMPL-098",
      "CODE-IMPL-099",
      "CODE-IMPL-102",
      "CODE-IMPL-103",
      "CODE-IMPL-104",
      "CODE-IMPL-116",
      "CODE-IMPL-176",
      "CODE-IMPL-177",
      "CODE-IMPL-197",
      "CODE-IMPL-200",
      "CODE-IMPL-202",
      "CODE-IMPL-203",
      "CODE-IMPL-253",
      "CODE-IMPL-418",
      "CODE-IMPL-419",
      "CODE-IMPL-425",
      "CODE-IMPL-445",
      "CODE-IMPL-511",
      "CODE-IMPL-513",
      "CODE-IMPL-514",
      "CODE-IMPL-515"
    ],
    "CRITICAL": [],
    "HIGH": []
  },
  "claims": [
    {
      "id": "FORMAL-DEFINITION-002",
      "type": "definition",
      "number": null,
      "statement": "The sliding surface is defined as:",
      "proof": null,
      "file_path": "docs/mathematical_algorithm_validation.md",
      "line_number": 54,
      "has_citation": false,
      "confidence": 0.6,
      "suggested_keywords": [],
      "context": "\\end{align}\n```\n\n#### Sliding Surface Design\n\n**Definition**: The sliding surface is defined as:\n```latex\ns = \\lambda_1 e_1 + \\lambda_2 e_2 + \\dot{e}_1 + \\dot{e}_2\n```\n\nwhere:",
      "category": "theoretical",
      "priority": "MEDIUM"
    },
    {
      "id": "FORMAL-DEFINITION-003",
      "type": "definition",
      "number": null,
      "statement": "Parameter sensitivity matrix:",
      "proof": null,
      "file_path": "docs/mathematical_algorithm_validation.md",
      "line_number": 620,
      "has_citation": false,
      "confidence": 0.6,
      "suggested_keywords": [],
      "context": "\n### 7.1 Parameter Sensitivity Analysis\n\n#### Sensitivity to Controller Gains\n\n**Definition**: Parameter sensitivity matrix:\n```latex\nS_{ij} = \\frac{\\partial J}{\\partial p_i} \\frac{p_i}{J}\n```\n\nwhere $J$ is the performance index and $p_i$ are controller parameters.",
      "category": "theoretical",
      "priority": "MEDIUM"
    },
    {
      "id": "FORMAL-DEFINITION-006",
      "type": "definition",
      "number": 1,
      "statement": "The optimization problem is defined over a D-dimensional search space:",
      "proof": null,
      "file_path": "docs/theory/pso_optimization_complete.md",
      "line_number": 18,
      "has_citation": false,
      "confidence": 0.7,
      "suggested_keywords": [
        "convergence"
      ],
      "context": "- **Social learning** (social component)\n- **Collective convergence** toward optimal solutions\n\n### Mathematical Foundation\n\n**Definition 1 (Search Space)**: The optimization problem is defined over a D-dimensional search space:\n\n```{math}\n:label: eq:search_space\n\\Omega = \\{\\vec{\\theta} \\in \\mathbb{R}^D : \\vec{\\theta}^{min} \\leq \\vec{\\theta} \\leq \\vec{\\theta}^{max}\\}\n```",
      "category": "theoretical",
      "priority": "MEDIUM"
    },
    {
      "id": "FORMAL-DEFINITION-007",
      "type": "definition",
      "number": 2,
      "statement": "The fitness landscape is defined by:",
      "proof": null,
      "file_path": "docs/theory/pso_optimization_complete.md",
      "line_number": 27,
      "has_citation": false,
      "confidence": 0.6,
      "suggested_keywords": [],
      "context": "\\Omega = \\{\\vec{\\theta} \\in \\mathbb{R}^D : \\vec{\\theta}^{min} \\leq \\vec{\\theta} \\leq \\vec{\\theta}^{max}\\}\n```\n\nwhere $\\vec{\\theta}$ represents the parameter vector to be optimized.\n\n**Definition 2 (Objective Function)**: The fitness landscape is defined by:\n\n```{math}\n:label: eq:objective_function\nf: \\Omega \\rightarrow \\mathbb{R}, \\quad f(\\vec{\\theta}) \\mapsto \\text{performance metric}\n```",
      "category": "theoretical",
      "priority": "MEDIUM"
    },
    {
      "id": "FORMAL-DEFINITION-009",
      "type": "definition",
      "number": 3,
      "statement": "The swarm converges in mean square if:",
      "proof": null,
      "file_path": "docs/theory/pso_optimization_complete.md",
      "line_number": 106,
      "has_citation": false,
      "confidence": 0.7,
      "suggested_keywords": [
        "convergence"
      ],
      "context": "\n### Stochastic Analysis\n\nIn the presence of randomness, convergence analysis requires stochastic techniques.\n\n**Definition 3 (Mean Square Convergence)**: The swarm converges in mean square if:\n\n```{math}\n:label: eq:mean_square_convergence\n\\lim_{k \\rightarrow \\infty} \\mathbb{E}[\\|\\vec{x}_i^{(k)} - \\vec{x}^*\\|^2] = 0\n```",
      "category": "theoretical",
      "priority": "MEDIUM"
    },
    {
      "id": "FORMAL-THEOREM-011",
      "type": "theorem",
      "number": 3,
      "statement": "Averaged over all possible optimization problems, no optimization algorithm performs better than random search {cite}`wolpert1997no`.",
      "proof": null,
      "file_path": "docs/theory/pso_optimization_complete.md",
      "line_number": 119,
      "has_citation": true,
      "confidence": 0.6,
      "suggested_keywords": [
        "PSO",
        "convergence",
        "stability"
      ],
      "context": "\n**Theorem 2 (Stochastic Convergence)**: Under the stability condition and with decreasing inertia weight, PSO converges to the global optimum with probability 1 for unimodal functions.\n\n### No Free Lunch Theorem\n\n**Theorem 3 (No Free Lunch)**: Averaged over all possible optimization problems, no optimization algorithm performs better than random search {cite}`wolpert1997no`.\n\n**Implication**: PSO effectiveness depends on matching algorithm characteristics to problem structure.\n\n## Multi-Objective PSO for Control Design\n",
      "category": "theoretical",
      "priority": "MEDIUM"
    },
    {
      "id": "FORMAL-DEFINITION-012",
      "type": "definition",
      "number": 4,
      "statement": "Solution $\\vec{\\theta}_1$ dominates $\\vec{\\theta}_2$ (denoted $\\vec{\\theta}_1 \\prec \\vec{\\theta}_2$) if:",
      "proof": null,
      "file_path": "docs/theory/pso_optimization_complete.md",
      "line_number": 184,
      "has_citation": false,
      "confidence": 0.6,
      "suggested_keywords": [],
      "context": "\nwhere $w_i \\geq 0$ and $\\sum_{i=1}^m w_i = 1$.\n\n### Pareto Optimality\n\n**Definition 4 (Pareto Dominance)**: Solution $\\vec{\\theta}_1$ dominates $\\vec{\\theta}_2$ (denoted $\\vec{\\theta}_1 \\prec \\vec{\\theta}_2$) if:\n\n```{math}\n:label: eq:pareto_dominance\nf_i(\\vec{\\theta}_1) \\leq f_i(\\vec{\\theta}_2) \\quad \\forall i \\in \\{1, \\ldots, m\\}\n```",
      "category": "theoretical",
      "priority": "MEDIUM"
    },
    {
      "id": "FORMAL-DEFINITION-013",
      "type": "definition",
      "number": 5,
      "statement": "The Pareto optimal set is:",
      "proof": null,
      "file_path": "docs/theory/pso_optimization_complete.md",
      "line_number": 193,
      "has_citation": false,
      "confidence": 0.6,
      "suggested_keywords": [],
      "context": "f_i(\\vec{\\theta}_1) \\leq f_i(\\vec{\\theta}_2) \\quad \\forall i \\in \\{1, \\ldots, m\\}\n```\n\nwith strict inequality for at least one objective.\n\n**Definition 5 (Pareto Optimal Set)**: The Pareto optimal set is:\n\n```{math}\n:label: eq:pareto_set\n\\mathcal{P} = \\{\\vec{\\theta} \\in \\Omega : \\nexists \\vec{\\theta}' \\in \\Omega \\text{ such that } \\vec{\\theta}' \\prec \\vec{\\theta}\\}\n```",
      "category": "theoretical",
      "priority": "MEDIUM"
    },
    {
      "id": "FORMAL-DEFINITION-014",
      "type": "definition",
      "number": 1,
      "statement": "A sliding surface $\\mathcal{S}$ is a subset of the state space defined by:",
      "proof": null,
      "file_path": "docs/theory/smc_theory_complete.md",
      "line_number": 11,
      "has_citation": false,
      "confidence": 0.7,
      "suggested_keywords": [
        "convergence",
        "sliding mode",
        "SMC",
        "Utkin",
        "finite-time",
        "robust"
      ],
      "context": "\nSliding Mode Control (SMC) is a robust control methodology that provides finite-time convergence and inherent disturbance rejection capabilities {cite}`utkin1999sliding`. The fundamental principle is to constrain the system trajectory to evolve on a lower-dimensional sliding surface where desired dynamics are enforced.\n\n### Fundamental Concepts\n\n**Definition 1 (Sliding Surface)**: A sliding surface $\\mathcal{S}$ is a subset of the state space defined by:\n\n```{math}\n:label: eq:sliding_surface_definition\n\\mathcal{S} = \\{\\vec{x} \\in \\mathbb{R}^n : s(\\vec{x}, t) = 0\\}\n```",
      "category": "theoretical",
      "priority": "MEDIUM"
    },
    {
      "id": "FORMAL-DEFINITION-015",
      "type": "definition",
      "number": 2,
      "statement": "The system is said to be in sliding mode when:",
      "proof": null,
      "file_path": "docs/theory/smc_theory_complete.md",
      "line_number": 24,
      "has_citation": false,
      "confidence": 0.6,
      "suggested_keywords": [
        "sliding mode",
        "SMC"
      ],
      "context": "\n```{note}\n**Implementation Note**: The sliding surface calculation is implemented in {py:obj}`src.controllers.classic_smc.ClassicalSMC.compute_sliding_surface` using the equations defined above.\n```\n\n**Definition 2 (Sliding Mode)**: The system is said to be in sliding mode when:\n1. The trajectory reaches the sliding surface: $s(\\vec{x}, t) = 0$\n2. The trajectory remains on the surface: $\\dot{s}(\\vec{x}, t) = 0$\n\n## Sliding Surface Design for DIP System\n",
      "category": "theoretical",
      "priority": "MEDIUM"
    },
    {
      "id": "FORMAL-ASSUMPTION-017",
      "type": "assumption",
      "number": 1,
      "statement": "The matrix $\\mat{S}\\vec{g}(\\vec{x})$ is invertible for all $\\vec{x}$ in the domain of interest.",
      "proof": null,
      "file_path": "docs/theory/smc_theory_complete.md",
      "line_number": 106,
      "has_citation": false,
      "confidence": 0.7,
      "suggested_keywords": [
        "robust"
      ],
      "context": "```{math}\n:label: eq:equivalent_control\nu_{eq} = (\\mat{S}\\vec{g}(\\vec{x}))^{-1}[\\dot{\\vec{x}}_r - \\mat{S}\\vec{f}(\\vec{x})]\n```\n\n**Assumption 1**: The matrix $\\mat{S}\\vec{g}(\\vec{x})$ is invertible for all $\\vec{x}$ in the domain of interest.\n\n### Switching Control Design\n\nThe switching control provides robustness against uncertainties and disturbances:\n",
      "category": "theoretical",
      "priority": "MEDIUM"
    },
    {
      "id": "FORMAL-DEFINITION-018",
      "type": "definition",
      "number": 3,
      "statement": "The system trajectory reaches the sliding surface in finite time if:",
      "proof": null,
      "file_path": "docs/theory/smc_theory_complete.md",
      "line_number": 123,
      "has_citation": false,
      "confidence": 0.7,
      "suggested_keywords": [
        "chattering",
        "reaching condition",
        "boundary layer"
      ],
      "context": "- $\\eta > 0$ - switching gain\n- $\\epsilon > 0$ - boundary layer thickness (chattering reduction)\n\n### Reaching Condition\n\n**Definition 3 (Reaching Condition)**: The system trajectory reaches the sliding surface in finite time if:\n\n```{math}\n:label: eq:reaching_condition\ns \\cdot \\dot{s} \\leq -\\alpha |s|\n```",
      "category": "theoretical",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-006",
      "type": "implementation",
      "scope": "module:class:FDIsystem",
      "claim_text": "Lightweight, modular Fault Detection and Isolation (FDI) system with",
      "algorithm_name": "to operating conditions",
      "source_attribution": "218697608892619\u00e2\u20ac\u00a0L682-L687",
      "file_path": "src\\analysis\\fault_detection\\fdi.py",
      "line_number": 36,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.75,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-040",
      "type": "implementation",
      "scope": "module",
      "claim_text": "Linearisation and controllability/observability analysis utilities",
      "algorithm_name": "of state variables",
      "source_attribution": "920100172589331\u00e2\u20ac\u00a0L79-L84",
      "file_path": "src\\analysis\\performance\\control_analysis.py",
      "line_number": 1,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.75,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-041",
      "type": "implementation",
      "scope": "module:function:controllability_matrix",
      "claim_text": "Construct the controllability matrix of an LTI system",
      "algorithm_name": "equal to ``n``",
      "source_attribution": "920100172589331\u00e2\u20ac\u00a0L79-L84",
      "file_path": "src\\analysis\\performance\\control_analysis.py",
      "line_number": 49,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.75,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-042",
      "type": "implementation",
      "scope": "module:function:observability_matrix",
      "claim_text": "Construct the observability matrix of an LTI system",
      "algorithm_name": "equal to ``n``",
      "source_attribution": "920100172589331\u00e2\u20ac\u00a0L79-L84",
      "file_path": "src\\analysis\\performance\\control_analysis.py",
      "line_number": 76,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.75,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-043",
      "type": "implementation",
      "scope": "module:function:check_controllability_observability",
      "claim_text": "Check controllability and observability of an LTI system",
      "algorithm_name": "rank test passes",
      "source_attribution": "920100172589331\u00e2\u20ac\u00a0L79-L84",
      "file_path": "src\\analysis\\performance\\control_analysis.py",
      "line_number": 141,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.75,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-098",
      "type": "implementation",
      "scope": "module",
      "claim_text": "Centralised logging configuration with provenance stamping",
      "algorithm_name": "satisfying reproducibility guidelines",
      "source_attribution": "985132039892507\u00e2\u20ac\u00a0L364-L377",
      "file_path": "src\\config\\logging.py",
      "line_number": 1,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.75,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-099",
      "type": "implementation",
      "scope": "module:function:configure_provenance_logging",
      "claim_text": "Configure the root logger with provenance stamping",
      "algorithm_name": "be reproduced exactly",
      "source_attribution": "985132039892507\u00e2\u20ac\u00a0L364-L377",
      "file_path": "src\\config\\logging.py",
      "line_number": 116,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.75,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-102",
      "type": "implementation",
      "scope": "module:function:require_positive",
      "claim_text": "Validate that a numeric value is positive (or non\u00e2\u20ac\u2018negative)",
      "algorithm_name": "adaptive control laws",
      "source_attribution": "462167782799487\u00e2\u20ac\u00a0L186-L195",
      "file_path": "src\\controllers\\base\\control_primitives.py",
      "line_number": 14,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.75,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-103",
      "type": "implementation",
      "scope": "module:function:require_in_range",
      "claim_text": "Validate that a numeric value lies within a closed or open interval",
      "algorithm_name": "to ensure stability",
      "source_attribution": "462167782799487\u00e2\u20ac\u00a0L186-L195",
      "file_path": "src\\controllers\\base\\control_primitives.py",
      "line_number": 62,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.75,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-104",
      "type": "implementation",
      "scope": "module:function:saturate",
      "claim_text": "based on the\nexpected amplitude of measurement noise and the desired steady\u00e2\u20ac\u2018state",
      "algorithm_name": "the\nexpected amplitude",
      "source_attribution": "measurement noise and the desired steady\u00e2\u20ac\u2018state",
      "file_path": "src\\controllers\\base\\control_primitives.py",
      "line_number": 110,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.8,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-116",
      "type": "implementation",
      "scope": "module:function:_numeric_linearize_continuous",
      "claim_text": "Finite\u00e2\u20ac\u2018difference linearization around (x_eq, u_eq) using a central",
      "algorithm_name": "one\u00e2\u20ac\u2018sided (forward) differences",
      "source_attribution": "738473614585036\u00e2\u20ac\u00a0L239-L256",
      "file_path": "src\\controllers\\mpc\\mpc_controller.py",
      "line_number": 72,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.75,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-176",
      "type": "implementation",
      "scope": "module:class:ClassicalSMC",
      "claim_text": "implements the conventional first\u00e2\u20ac\u2018order sliding\u00e2\u20ac\u2018mode law\nconsisting of a model\u00e2\u20ac\u2018based equivalent control ``u_eq`` and a robust",
      "algorithm_name": "the conventional first\u00e2\u20ac\u2018order sliding\u00e2\u20ac\u2018mode law\nconsisting",
      "source_attribution": "a model\u00e2\u20ac\u2018based equivalent control ``u_eq`` and a robust",
      "file_path": "src\\controllers\\smc\\classic_smc.py",
      "line_number": 21,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.8,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-177",
      "type": "implementation",
      "scope": "module:class:ClassicalSMC",
      "claim_text": "uses a continuous approximation to\nthe sign function (either a hyperbolic tangent or a piecewise\u00e2\u20ac\u2018linear\nsaturation) within a boundary layer of width ``epsilon`` to attenuate",
      "algorithm_name": "a continuous approximation to\nthe sign function (either a hyperbolic tangent or a piecewise\u00e2\u20ac\u2018linear\nsaturation) within a boundary layer",
      "source_attribution": "width ``epsilon`` to attenuate",
      "file_path": "src\\controllers\\smc\\classic_smc.py",
      "line_number": 21,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.8,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-197",
      "type": "implementation",
      "scope": "module:class:HybridAdaptiveSTASMC",
      "claim_text": "Hybrid Adaptive Super\u00e2\u20ac\u201cTwisting SMC for a double\u00e2\u20ac\u2018inverted pendulum",
      "algorithm_name": "simplifies stability proofs",
      "source_attribution": "895515998216162\u00e2\u20ac\u00a0L326-L329",
      "file_path": "src\\controllers\\smc\\hybrid_adaptive_sta_smc.py",
      "line_number": 26,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.75,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-200",
      "type": "implementation",
      "scope": "module:class:HybridAdaptiveSTASMC:function:_compute_equivalent_control",
      "claim_text": "Compute an approximate equivalent control based on the system",
      "algorithm_name": "is nearly singular",
      "source_attribution": "385796022798831\u00e2\u20ac\u00a0L145-L149",
      "file_path": "src\\controllers\\smc\\hybrid_adaptive_sta_smc.py",
      "line_number": 442,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.75,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-202",
      "type": "implementation",
      "scope": "module:function:_sta_smc_core",
      "claim_text": "Numba-accelerated core using precomputed sigma and its saturated sign",
      "algorithm_name": "multiplied by ``Kaw``",
      "source_attribution": "789743582768797\u00e2\u20ac\u00a0L224-L249",
      "file_path": "src\\controllers\\smc\\sta_smc.py",
      "line_number": 89,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.75,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-203",
      "type": "implementation",
      "scope": "module:class:SuperTwistingSMC",
      "claim_text": "uses a continuous saturation function within a boundary\n layer ``\u00ce\u00b5`` to approximate the sign of the sliding variable \u00cf\u0192,",
      "algorithm_name": "a continuous saturation function within a boundary\n layer ``\u00ce\u00b5`` to approximate the sign",
      "source_attribution": "the sliding variable \u00cf\u0192,",
      "file_path": "src\\controllers\\smc\\sta_smc.py",
      "line_number": 129,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.8,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-253",
      "type": "implementation",
      "scope": "module:function:create_control_problem",
      "claim_text": "Create a control optimization problem",
      "algorithm_name": null,
      "source_attribution": null,
      "file_path": "src\\optimization\\__init__.py",
      "line_number": 158,
      "has_citation": true,
      "citation_format": "numbered",
      "confidence": 0.75,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-418",
      "type": "implementation",
      "scope": "module",
      "claim_text": "uses on a single step of the Dormand\u00e2\u20ac\u201cPrince",
      "algorithm_name": "on a single step",
      "source_attribution": "the Dormand\u00e2\u20ac\u201cPrince",
      "file_path": "src\\simulation\\engines\\adaptive_integrator.py",
      "line_number": 1,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.8,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-419",
      "type": "implementation",
      "scope": "module:function:rk45_step",
      "claim_text": "Perform a single Dormand\u00e2\u20ac\u201cPrince 4(5) integration step",
      "algorithm_name": "the Butcher tableau",
      "source_attribution": "313837333132264\u00e2\u20ac\u00a0L58-L82",
      "file_path": "src\\simulation\\engines\\adaptive_integrator.py",
      "line_number": 37,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.75,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-425",
      "type": "implementation",
      "scope": "module:function:simulate",
      "claim_text": "Simulate a dynamical system forward in time",
      "algorithm_name": null,
      "source_attribution": null,
      "file_path": "src\\simulation\\engines\\vector_sim.py",
      "line_number": 38,
      "has_citation": true,
      "citation_format": "numbered",
      "confidence": 0.75,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-445",
      "type": "implementation",
      "scope": "module:function:create_compatible_dynamics",
      "claim_text": "Create a dynamics model compatible with simulation engines",
      "algorithm_name": null,
      "source_attribution": null,
      "file_path": "src\\simulation\\integrators\\compatibility.py",
      "line_number": 146,
      "has_citation": true,
      "citation_format": "numbered",
      "confidence": 0.75,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-511",
      "type": "implementation",
      "scope": "module",
      "claim_text": "Global seeding utilities for reproducible simulations",
      "algorithm_name": "numbers of processors",
      "source_attribution": "675644021986605\u00e2\u20ac\u00a0L385-L388",
      "file_path": "src\\utils\\reproducibility\\seed.py",
      "line_number": 1,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.75,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-513",
      "type": "implementation",
      "scope": "module:function:set_global_seed",
      "claim_text": "According to reproducibility guidelines in\ncomputational science, when random number generation is part of a",
      "algorithm_name": "reproducibility guidelines",
      "source_attribution": "computational science, when random number generation is part of a",
      "file_path": "src\\utils\\reproducibility\\seed.py",
      "line_number": 86,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.8,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-514",
      "type": "implementation",
      "scope": "module:function:create_rng",
      "claim_text": "Create a local NumPy random number generator",
      "algorithm_name": "or optimisation algorithms",
      "source_attribution": "675644021986605\u00e2\u20ac\u00a0L385-L388",
      "file_path": "src\\utils\\reproducibility\\seed.py",
      "line_number": 135,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.75,
      "category": "implementation",
      "priority": "MEDIUM"
    },
    {
      "id": "CODE-IMPL-515",
      "type": "implementation",
      "scope": "module",
      "claim_text": "use a named tuple inherits\nfrom ``tuple``) while also exposing descriptive attribute names to clarify",
      "algorithm_name": "a named tuple inherits",
      "source_attribution": "``tuple``) while also exposing descriptive attribute names to clarify",
      "file_path": "src\\utils\\types\\control_outputs.py",
      "line_number": 1,
      "has_citation": true,
      "citation_format": "bracket",
      "confidence": 0.8,
      "category": "implementation",
      "priority": "MEDIUM"
    }
  ]
}