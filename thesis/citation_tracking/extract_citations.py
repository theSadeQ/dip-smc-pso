#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Citation Extraction Helper Script

PURPOSE:
    Automate PDF citation tracking by:
    1. Listing available PDFs in sources_archive
    2. Providing quick commands to request AI extraction
    3. Verifying tracking file completeness
    4. Generating citation statistics

USAGE:
    python extract_citations.py --list              # List all PDFs
    python extract_citations.py --suggest Levant    # Suggest AI commands for Levant2007
    python extract_citations.py --verify Levant2007 # Check tracking file completeness
    python extract_citations.py --stats             # Show citation statistics

WORKFLOW:
    1. Run --list to see all PDFs
    2. Run --suggest <name> to get AI extraction commands
    3. Copy command and paste to Claude
    4. Claude creates/updates tracking file
    5. Run --verify to check completeness

AUTHOR: Auto-generated by Claude AI
DATE: 2025-12-06
"""

import os
import sys
import argparse
from pathlib import Path
from typing import List, Dict, Optional

# Directories (relative to script location)
SCRIPT_DIR = Path(__file__).parent
SOURCES_DIR = SCRIPT_DIR.parent / "sources_archive" / "manuelly downloaded"
TRACKING_DIR = SCRIPT_DIR
TEMPLATE_FILE = TRACKING_DIR / "TEMPLATE_tracking.md"
INDEX_FILE = TRACKING_DIR / "INDEX.md"


def list_pdfs() -> List[Dict[str, str]]:
    """List all PDFs in sources_archive."""
    if not SOURCES_DIR.exists():
        print(f"[ERROR] Sources directory not found: {SOURCES_DIR}")
        return []

    pdfs = []
    for pdf_file in sorted(SOURCES_DIR.glob("*.pdf")):
        size_mb = pdf_file.stat().st_size / (1024 * 1024)
        pdfs.append({
            "filename": pdf_file.name,
            "path": str(pdf_file),
            "size_mb": f"{size_mb:.1f} MB"
        })

    return pdfs


def print_pdf_list():
    """Print formatted list of all PDFs."""
    pdfs = list_pdfs()

    if not pdfs:
        print("[ERROR] No PDFs found in sources_archive")
        return

    print(f"\n[OK] Found {len(pdfs)} PDFs in sources_archive\n")
    print("=" * 80)
    print(f"{'#':<4} {'Filename':<50} {'Size':<10}")
    print("=" * 80)

    for i, pdf in enumerate(pdfs, 1):
        print(f"{i:<4} {pdf['filename']:<50} {pdf['size_mb']:<10}")

    print("=" * 80)
    print(f"\nTotal: {len(pdfs)} PDFs")
    print("\nNext steps:")
    print("  1. python extract_citations.py --suggest <name>")
    print("  2. Copy suggested command to Claude")
    print("  3. Claude creates tracking file")
    print("\nExample: python extract_citations.py --suggest levant")


def suggest_commands(pdf_name: str):
    """Suggest AI commands for extracting citations from a PDF."""
    pdfs = list_pdfs()

    # Find matching PDF (case-insensitive partial match)
    matches = [p for p in pdfs if pdf_name.lower() in p["filename"].lower()]

    if not matches:
        print(f"[ERROR] No PDF found matching '{pdf_name}'")
        print(f"\nAvailable PDFs:")
        for pdf in pdfs[:5]:
            print(f"  - {pdf['filename']}")
        print(f"  ... and {len(pdfs) - 5} more")
        return

    if len(matches) > 1:
        print(f"[WARNING] Multiple PDFs match '{pdf_name}':")
        for m in matches:
            print(f"  - {m['filename']}")
        print("\nPlease be more specific.")
        return

    pdf = matches[0]
    filename = pdf["filename"]

    # Try to extract BibTeX key from filename
    # Common patterns: levant2007.pdf, Khalil2002.pdf, etc.
    bibtex_key = Path(filename).stem
    if bibtex_key.endswith("..."):  # Z-Library truncated names
        bibtex_key = "Unknown" + "Year"

    print(f"\n[OK] Found PDF: {filename} ({pdf['size_mb']})")
    print(f"[INFO] Suggested BibTeX key: {bibtex_key}")
    print("\n" + "=" * 80)
    print("COPY-PASTE COMMANDS TO CLAUDE:")
    print("=" * 80)

    print("\n### Step 1: Read PDF and Extract Structure")
    print(f'Read("thesis/sources_archive/manuelly downloaded/{filename}")')

    print("\n### Step 2: Create Tracking File")
    print(f'"Create citation tracking file for {bibtex_key} using template"')

    print("\n### Step 3: Extract Specific Content (choose what you need)")
    print(f'"Extract all theorems from {bibtex_key} with page numbers"')
    print(f'"Extract all equations from {bibtex_key}"')
    print(f'"Find all figures/tables in {bibtex_key}"')
    print(f'"List all sections in {bibtex_key} with page ranges"')

    print("\n### Step 4: Topic-Specific Extraction")
    print(f'"Find super-twisting algorithm in {bibtex_key}"  # Example topic')
    print(f'"Find Lyapunov stability theorems in {bibtex_key}"  # Example topic')
    print(f'"Find PSO algorithm in {bibtex_key}"  # Example topic')

    print("\n### Step 5: Generate Quick Reference")
    print(f'"Create quick reference table for {bibtex_key} with all key content"')

    print("\n" + "=" * 80)
    print("EXPECTED OUTPUT:")
    print("=" * 80)
    print(f"- Tracking file: thesis/citation_tracking/{bibtex_key}_tracking.md")
    print(f"- Contains: Sections, theorems, equations, figures, ready-to-use LaTeX citations")
    print(f"- Status: INDEX.md updated with tracking status")

    print("\n" + "=" * 80)
    print("VERIFICATION:")
    print("=" * 80)
    print(f"python extract_citations.py --verify {bibtex_key}")


def verify_tracking(bibtex_key: str):
    """Verify tracking file completeness."""
    tracking_file = TRACKING_DIR / f"{bibtex_key}_tracking.md"

    if not tracking_file.exists():
        print(f"[ERROR] Tracking file not found: {tracking_file}")
        print(f"\n[HINT] Create it first:")
        print(f'  "Create tracking file for {bibtex_key}"')
        return

    print(f"[OK] Tracking file found: {tracking_file}")

    # Read tracking file
    content = tracking_file.read_text(encoding="utf-8")

    # Check for template markers (indicates incomplete file)
    checks = {
        "BibTeX key filled": "AuthorYear" not in content[:500],
        "Sections extracted": "Section 1:" in content or "Chapter 1:" in content,
        "Quick reference table": "Quick Reference Table" in content,
        "BibTeX entry added": "@article{" in content or "@book{" in content,
        "Citations linked to thesis": "Used in Thesis: Section" in content,
    }

    print("\n" + "=" * 80)
    print("COMPLETENESS CHECK:")
    print("=" * 80)

    passed = 0
    total = len(checks)

    for check_name, check_result in checks.items():
        status = "[OK]" if check_result else "[PENDING]"
        print(f"{status} {check_name}")
        if check_result:
            passed += 1

    print("=" * 80)
    print(f"Score: {passed}/{total} ({passed/total*100:.0f}%)")

    if passed == total:
        print("\n[OK] Tracking file is complete and ready to use!")
    elif passed >= total * 0.6:
        print("\n[WARNING] Tracking file is partially complete. Consider:")
        print("  - Adding more detailed content")
        print("  - Linking citations to thesis sections")
        print("  - Verifying BibTeX entry")
    else:
        print("\n[ERROR] Tracking file is mostly template. Please:")
        print(f'  1. Ask Claude: "Populate tracking file for {bibtex_key}"')
        print(f"  2. Wait for AI to extract content from PDF")
        print(f"  3. Run verification again")


def show_statistics():
    """Show citation tracking statistics."""
    pdfs = list_pdfs()
    tracking_files = list(TRACKING_DIR.glob("*_tracking.md"))

    # Exclude template
    tracking_files = [f for f in tracking_files if "TEMPLATE" not in f.name]

    total_pdfs = len(pdfs)
    tracked_pdfs = len(tracking_files)
    untracked = total_pdfs - tracked_pdfs

    print("\n" + "=" * 80)
    print("CITATION TRACKING STATISTICS")
    print("=" * 80)

    print(f"\nTotal PDFs in sources_archive: {total_pdfs}")
    print(f"Tracked PDFs: {tracked_pdfs} ({tracked_pdfs/total_pdfs*100:.1f}%)")
    print(f"Untracked PDFs: {untracked} ({untracked/total_pdfs*100:.1f}%)")

    if tracked_pdfs > 0:
        print(f"\n[OK] Tracked files:")
        for tf in sorted(tracking_files):
            bibtex_key = tf.stem.replace("_tracking", "")
            print(f"  - {bibtex_key}")

    if untracked > 0:
        print(f"\n[INFO] Next PDFs to track (suggestions):")
        # Suggest high-priority PDFs
        priority_keywords = ["levant", "khalil", "utkin", "slotine", "quanser", "clerc"]
        suggested = []

        for pdf in pdfs:
            bibtex_key = Path(pdf["filename"]).stem
            if not (TRACKING_DIR / f"{bibtex_key}_tracking.md").exists():
                # Check if high priority
                is_priority = any(kw in pdf["filename"].lower() for kw in priority_keywords)
                if is_priority:
                    suggested.append((bibtex_key, pdf["filename"], "[HIGH]"))
                else:
                    suggested.append((bibtex_key, pdf["filename"], "[LOW]"))

        # Show high priority first
        suggested.sort(key=lambda x: (x[2], x[0]))

        for i, (key, fname, priority) in enumerate(suggested[:5], 1):
            print(f"  {i}. {priority} {fname}")
            print(f"     Command: python extract_citations.py --suggest {key[:10]}")

    print("\n" + "=" * 80)
    print("NEXT STEPS:")
    print("=" * 80)
    print("  1. python extract_citations.py --suggest <name>  # Get AI commands")
    print("  2. Copy-paste commands to Claude")
    print("  3. python extract_citations.py --verify <key>    # Check completeness")


def main():
    parser = argparse.ArgumentParser(
        description="Citation Extraction Helper for Thesis PDFs",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python extract_citations.py --list
  python extract_citations.py --suggest levant
  python extract_citations.py --verify Levant2007
  python extract_citations.py --stats

Workflow:
  1. List all PDFs
  2. Suggest AI commands for a specific PDF
  3. Copy commands to Claude
  4. Claude creates tracking file
  5. Verify completeness
  6. Use citations in thesis
        """
    )

    parser.add_argument(
        "--list",
        action="store_true",
        help="List all PDFs in sources_archive"
    )

    parser.add_argument(
        "--suggest",
        metavar="PDF_NAME",
        help="Suggest AI commands for extracting citations from PDF"
    )

    parser.add_argument(
        "--verify",
        metavar="BIBTEX_KEY",
        help="Verify tracking file completeness"
    )

    parser.add_argument(
        "--stats",
        action="store_true",
        help="Show citation tracking statistics"
    )

    args = parser.parse_args()

    # If no args, show help
    if not any([args.list, args.suggest, args.verify, args.stats]):
        parser.print_help()
        return

    # Execute commands
    if args.list:
        print_pdf_list()

    if args.suggest:
        suggest_commands(args.suggest)

    if args.verify:
        verify_tracking(args.verify)

    if args.stats:
        show_statistics()


if __name__ == "__main__":
    main()
