{
  "overall_documentation_score": 0.734,
  "coverage_completeness": 0.76,
  "accuracy_validation": 0.8300000000000001,
  "usability_assessment": 0.77,
  "documentation_quality": [
    {
      "component": "PSO Integration Workflow",
      "coverage_score": 0.8,
      "accuracy_score": 1.0,
      "completeness_score": 0.6,
      "usability_score": 0.85,
      "recommendations": [
        "Expand PSO workflow documentation coverage",
        "Complete missing workflow component documentation"
      ]
    },
    {
      "component": "Configuration Parameters",
      "coverage_score": 1.0,
      "accuracy_score": 0.5,
      "completeness_score": 0.6,
      "usability_score": 0.75,
      "recommendations": [
        "Validate accuracy of parameter bounds documentation",
        "Complete parameter description documentation"
      ]
    },
    {
      "component": "API Interfaces",
      "coverage_score": 1.0,
      "accuracy_score": 1.0,
      "completeness_score": 0.6,
      "usability_score": 0.8,
      "recommendations": [
        "Complete API documentation elements"
      ]
    },
    {
      "component": "Optimization Best Practices",
      "coverage_score": 0.6,
      "accuracy_score": 0.85,
      "completeness_score": 0.4,
      "usability_score": 0.75,
      "recommendations": [
        "Expand best practices documentation coverage",
        "Add practical examples and troubleshooting guides"
      ]
    },
    {
      "component": "Troubleshooting & FAQ",
      "coverage_score": 0.4,
      "accuracy_score": 0.8,
      "completeness_score": 0.4,
      "usability_score": 0.7,
      "recommendations": [
        "Expand troubleshooting documentation for common issues",
        "Complete troubleshooting information structure"
      ]
    }
  ],
  "generated_documentation": {
    "pso_integration_workflow_guide.md": "# PSO Integration Workflow Guide\n\n## Overview\nThis guide describes the complete workflow for integrating PSO optimization with SMC controllers.\n\n## Workflow Steps\n\n### 1. Initialize PSO Environment\n```python\nfrom src.controllers.factory import SMCType, create_smc_for_pso, get_gain_bounds_for_pso, validate_smc_gains\nfrom src.plant.configurations import ConfigurationFactory\n\n# Initialize plant configuration\nplant_config = ConfigurationFactory.create_default_config(\"simplified\")\n```\n\n### 2. Define Controller Type and Get Bounds\n```python\n# Select SMC controller type\nsmc_type = SMCType.CLASSICAL\n\n# Get optimization bounds for the controller\nbounds = get_gain_bounds_for_pso(smc_type)\nlower_bounds, upper_bounds = bounds\n```\n\n### 3. Create Fitness Function\n```python\ndef fitness_function(gains):\n    # Validate gains\n    if not validate_smc_gains(smc_type, gains):\n        return float('inf')  # Invalid gains penalty\n\n    # Create controller\n    controller = create_smc_for_pso(smc_type, gains, plant_config)\n\n    # Evaluate performance\n    # ... implementation specific to your optimization goals\n\n    return cost_value\n```\n\n### 4. Execute PSO Optimization\n```python\n# Use your preferred PSO library (e.g., PySwarms)\nimport pyswarms as ps\n\n# Configure PSO\noptions = {'c1': 2.0, 'c2': 2.0, 'w': 0.9}\noptimizer = ps.single.GlobalBestPSO(\n    n_particles=30,\n    dimensions=len(lower_bounds),\n    options=options,\n    bounds=(lower_bounds, upper_bounds)\n)\n\n# Run optimization\nbest_cost, best_gains = optimizer.optimize(fitness_function, iters=100)\n```\n\n### 5. Validate and Deploy Results\n```python\n# Validate optimized gains\nif validate_smc_gains(smc_type, best_gains):\n    # Create optimized controller\n    optimized_controller = create_smc_for_pso(smc_type, best_gains, plant_config)\n\n    # Test performance\n    state = np.array([0.1, 0.2, 0.3, 0.0, 0.0, 0.0])\n    control = optimized_controller.compute_control(state)\n\n    print(f\"Optimization successful! Best cost: {best_cost}\")\n    print(f\"Optimized gains: {best_gains}\")\nelse:\n    print(\"Optimization failed - invalid gains\")\n```\n\n## Best Practices\n- Always validate gains before and after optimization\n- Use appropriate fitness function design\n- Monitor convergence criteria\n- Test optimized controllers thoroughly\n",
    "configuration_parameter_documentation.md": "# Configuration Parameter Documentation\n\n## SMC Gain Specifications\n\n### Classical SMC (SMCType.CLASSICAL)\n- **Parameters**: 6 gains [k1, k2, lam1, lam2, K, kd]\n- **Bounds**: Typically [0.1, 50.0] for most gains\n- **Description**:\n  - k1, k2: Sliding surface gains for pendulum 1 and 2\n  - lam1, lam2: Sliding surface velocity gains\n  - K: Switching gain magnitude\n  - kd: Derivative gain for smoothing\n\n### Adaptive SMC (SMCType.ADAPTIVE)\n- **Parameters**: 5 gains [k1, k2, lam1, lam2, gamma]\n- **Bounds**: [0.1, 50.0] for k gains, [1.0, 200.0] for gamma\n- **Description**:\n  - k1, k2, lam1, lam2: Same as classical SMC\n  - gamma: Adaptation rate parameter\n\n## Parameter Tuning Guidelines\n\n### Sliding Surface Gains (k1, k2)\n- **Range**: [1.0, 50.0]\n- **Effect**: Higher values provide faster response but may cause chattering\n- **Tuning**: Start with moderate values (5-15), increase for better tracking\n\n### Velocity Gains (lam1, lam2)\n- **Range**: [0.1, 20.0]\n- **Effect**: Damping in sliding surface\n- **Tuning**: Increase to reduce overshoot, decrease for faster response\n\n### Switching Gain (K)\n- **Range**: [1.0, 200.0]\n- **Effect**: Robustness to uncertainties\n- **Tuning**: Increase to handle disturbances, minimize to reduce chattering\n\n## Configuration Best Practices\n1. Start with default values from literature\n2. Use PSO optimization for fine-tuning\n3. Validate stability after parameter changes\n4. Consider physical system limitations\n",
    "api_documentation_pso_interfaces.md": "# PSO Integration API Documentation\n\n## Core Functions\n\n### create_smc_for_pso\n```python\ndef create_smc_for_pso(\n    smc_type: SMCType,\n    gains: List[float],\n    plant_config: Any,\n    max_force: float = 100.0,\n    dt: float = 0.01\n) -> PSOControllerWrapper\n```\n\n**Purpose**: Create SMC controller optimized for PSO integration\n\n**Parameters**:\n- `smc_type`: Type of SMC controller (SMCType enum)\n- `gains`: List of gain parameters specific to controller type\n- `plant_config`: Plant configuration object\n- `max_force`: Maximum control force (optional)\n- `dt`: Control time step (optional)\n\n**Returns**: PSOControllerWrapper with simplified interface\n\n**Example**:\n```python\ncontroller = create_smc_for_pso(\n    SMCType.CLASSICAL,\n    [10.0, 5.0, 8.0, 3.0, 15.0, 2.0],\n    plant_config\n)\n```\n\n### get_gain_bounds_for_pso\n```python\ndef get_gain_bounds_for_pso(smc_type: SMCType) -> Tuple[List[float], List[float]]\n```\n\n**Purpose**: Get optimization bounds for SMC controller gains\n\n**Parameters**:\n- `smc_type`: Type of SMC controller\n\n**Returns**: Tuple of (lower_bounds, upper_bounds)\n\n**Example**:\n```python\nbounds = get_gain_bounds_for_pso(SMCType.CLASSICAL)\nlower, upper = bounds\n```\n\n### validate_smc_gains\n```python\ndef validate_smc_gains(smc_type: SMCType, gains: List[float]) -> bool\n```\n\n**Purpose**: Validate if gains are within acceptable bounds\n\n**Parameters**:\n- `smc_type`: Type of SMC controller\n- `gains`: List of gain values to validate\n\n**Returns**: True if gains are valid, False otherwise\n\n**Example**:\n```python\nvalid = validate_smc_gains(SMCType.CLASSICAL, [10.0, 5.0, 8.0, 3.0, 15.0, 2.0])\n```\n\n## PSOControllerWrapper Methods\n\n### compute_control\n```python\ndef compute_control(self, state: np.ndarray) -> np.ndarray\n```\n\n**Purpose**: Compute control output for given state\n\n**Parameters**:\n- `state`: System state vector (6 elements for DIP)\n\n**Returns**: Control force as 1D numpy array\n\n**Example**:\n```python\nstate = np.array([0.1, 0.2, 0.3, 0.0, 0.0, 0.0])\ncontrol = controller.compute_control(state)\n```\n\n## Error Handling\n- Invalid gains return high fitness penalty in PSO\n- Invalid SMC type raises ValueError\n- Malformed state inputs raise appropriate exceptions\n",
    "optimization_best_practices_guide.md": "# PSO Optimization Best Practices Guide\n\n## PSO Parameter Selection\n\n### Population Size\n- **Recommended**: 20-50 particles\n- **Rule of thumb**: 2-3 times the number of dimensions\n- **Trade-off**: Larger populations explore better but cost more\n\n### Inertia Weight (w)\n- **Recommended**: 0.4-0.9\n- **Strategy**: Start high (0.9) and decrease over iterations\n- **Effect**: Controls exploration vs exploitation balance\n\n### Cognitive Parameter (c1)\n- **Recommended**: 1.5-2.5\n- **Default**: 2.0\n- **Effect**: Particle attraction to personal best\n\n### Social Parameter (c2)\n- **Recommended**: 1.5-2.5\n- **Default**: 2.0\n- **Effect**: Particle attraction to global best\n\n## Fitness Function Design\n\n### Objectives\n1. **Control Performance**: Minimize tracking error\n2. **Control Effort**: Minimize energy consumption\n3. **Stability**: Ensure closed-loop stability\n4. **Robustness**: Handle uncertainties\n\n### Multi-Objective Considerations\n```python\ndef fitness_function(gains):\n    # Performance component\n    tracking_error = evaluate_tracking_performance(gains)\n\n    # Efficiency component\n    control_effort = evaluate_control_effort(gains)\n\n    # Stability penalty\n    stability_penalty = check_stability(gains)\n\n    # Combined fitness\n    return w1 * tracking_error + w2 * control_effort + w3 * stability_penalty\n```\n\n## Convergence Criteria\n\n### Stopping Conditions\n1. **Maximum Iterations**: 50-200 iterations typically sufficient\n2. **Fitness Threshold**: Problem-specific acceptable performance\n3. **Stagnation**: No improvement for 20-50 iterations\n4. **Time Limit**: Practical computational constraints\n\n### Monitoring Convergence\n- Track best fitness over iterations\n- Monitor population diversity\n- Check for premature convergence\n\n## Performance Optimization\n\n### Computational Efficiency\n- Vectorize fitness evaluations when possible\n- Use parallel processing for population evaluation\n- Cache expensive computations\n\n### Memory Management\n- Limit population history storage\n- Clean up temporary variables\n- Monitor memory usage for long runs\n\n## Common Pitfalls\n\n### Problem Formulation\n- **Overly complex fitness functions**: Keep it simple and interpretable\n- **Poor constraint handling**: Use penalty methods or repair mechanisms\n- **Inadequate bounds**: Ensure bounds reflect physical limitations\n\n### Algorithm Configuration\n- **Too few particles**: May miss global optimum\n- **Too many iterations**: Diminishing returns vs computational cost\n- **Poor parameter tuning**: Test different configurations\n\n### Validation\n- **Single test scenario**: Test on multiple operating conditions\n- **Overfitting**: Validate on unseen test cases\n- **Simulation vs reality gap**: Account for model uncertainties\n",
    "troubleshooting_and_faq.md": "# PSO Integration Troubleshooting Guide\n\n## Common Issues and Solutions\n\n### 1. PSO Convergence Failures\n\n**Symptoms**:\n- PSO doesn't find good solutions\n- Fitness remains high after many iterations\n- Solutions are infeasible\n\n**Possible Causes**:\n- Poor fitness function design\n- Inadequate PSO parameters\n- Restrictive bounds\n\n**Solutions**:\n- Simplify fitness function\n- Increase population size or iterations\n- Review and adjust bounds\n- Check for numerical issues\n\n### 2. Invalid Gain Validation Errors\n\n**Symptoms**:\n- `validate_smc_gains()` returns False\n- High penalty values in fitness function\n\n**Possible Causes**:\n- Gains outside specified bounds\n- Wrong number of gains for SMC type\n- NaN or infinite values\n\n**Solutions**:\n```python\n# Check gain bounds\nbounds = get_gain_bounds_for_pso(smc_type)\nprint(f\"Expected bounds: {bounds}\")\n\n# Verify gain count\nexpected_count = len(bounds[0])\nprint(f\"Expected {expected_count} gains, got {len(gains)}\")\n\n# Check for invalid values\nif any(np.isnan(gains)) or any(np.isinf(gains)):\n    print(\"Invalid gain values detected\")\n```\n\n### 3. Controller Creation Failures\n\n**Symptoms**:\n- `create_smc_for_pso()` raises exceptions\n- Controller object is None\n\n**Possible Causes**:\n- Invalid plant configuration\n- Incompatible gain specifications\n- Missing dependencies\n\n**Solutions**:\n- Verify plant configuration is valid\n- Check SMC type and gain compatibility\n- Test with known good parameters\n\n### 4. Performance Optimization Issues\n\n**Symptoms**:\n- PSO runs very slowly\n- Memory usage grows over time\n- System becomes unresponsive\n\n**Possible Causes**:\n- Inefficient fitness function\n- Memory leaks in optimization loop\n- Excessive logging or debugging\n\n**Solutions**:\n- Profile fitness function performance\n- Use vectorized operations where possible\n- Limit data storage during optimization\n- Implement periodic garbage collection\n\n## Debugging Strategies\n\n### Step-by-Step Debugging\n1. **Test individual components**:\n   ```python\n   # Test bounds retrieval\n   bounds = get_gain_bounds_for_pso(SMCType.CLASSICAL)\n\n   # Test gain validation\n   valid = validate_smc_gains(SMCType.CLASSICAL, test_gains)\n\n   # Test controller creation\n   controller = create_smc_for_pso(SMCType.CLASSICAL, test_gains, config)\n   ```\n\n2. **Validate fitness function**:\n   ```python\n   # Test with known gains\n   test_gains = [10.0, 5.0, 8.0, 3.0, 15.0, 2.0]\n   fitness = fitness_function(test_gains)\n   print(f\"Test fitness: {fitness}\")\n   ```\n\n3. **Check PSO configuration**:\n   ```python\n   # Verify PSO parameters\n   print(f\"Population size: {n_particles}\")\n   print(f\"Dimensions: {dimensions}\")\n   print(f\"Bounds: {bounds}\")\n   ```\n\n### Logging and Monitoring\n```python\nimport logging\n\n# Enable debug logging\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\n# Log PSO progress\ndef fitness_function_with_logging(gains):\n    logger.debug(f\"Evaluating gains: {gains}\")\n    fitness = compute_fitness(gains)\n    logger.debug(f\"Fitness: {fitness}\")\n    return fitness\n```\n\n## FAQ\n\n### Q: How many PSO iterations should I use?\n**A**: Start with 50-100 iterations. Monitor convergence and adjust based on problem complexity.\n\n### Q: What if PSO finds invalid gains?\n**A**: Implement constraint handling in your PSO algorithm or use penalty methods in the fitness function.\n\n### Q: How do I handle multiple objectives?\n**A**: Use weighted sum, Pareto optimization, or convert to single objective with constraints.\n\n### Q: PSO is too slow, how can I speed it up?\n**A**: Reduce population size, simplify fitness function, use parallel evaluation, or implement early stopping.\n\n### Q: How do I validate optimized controllers?\n**A**: Test on multiple scenarios, verify stability margins, and compare against baseline controllers.\n\n## Contact and Support\n- Check documentation and examples first\n- Review common issues in this guide\n- Test with simplified configurations\n- Report persistent issues with minimal reproducible examples\n"
  },
  "recommendations": [
    "Complete troubleshooting information structure",
    "Complete parameter description documentation",
    "Expand PSO workflow documentation coverage",
    "Expand best practices documentation coverage",
    "Add practical examples and troubleshooting guides",
    "Validate accuracy of parameter bounds documentation",
    "Complete missing workflow component documentation",
    "Complete API documentation elements",
    "Expand troubleshooting documentation for common issues"
  ],
  "production_ready": false
}