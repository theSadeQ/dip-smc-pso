{
  "total_files_scanned": 23,
  "files_with_divisions": {
    "src/controllers/smc/core/switching_functions.py": {
      "domain": "controllers",
      "division_count": 3,
      "safe_count": 0,
      "unsafe_count": 3,
      "divisions": [
        {
          "line": 167,
          "numerator": "2",
          "denominator": "1 + exp(-slope*s/\u03b5",
          "has_epsilon_protection": false,
          "code": "Formula: 2/(1 + exp(-slope*s/\u03b5)) - 1"
        },
        {
          "line": 197,
          "numerator": "0",
          "denominator": "1.0 + exp_term",
          "has_epsilon_protection": false,
          "code": "return 2.0 / (1.0 + exp_term) - 1.0"
        },
        {
          "line": 222,
          "numerator": "exp_term",
          "denominator": "1.0 + exp_term",
          "has_epsilon_protection": false,
          "code": "return (4.0 / epsilon) * exp_term / (1.0 + exp_term)**2"
        }
      ]
    },
    "src/controllers/smc/algorithms/classical/boundary_layer.py": {
      "domain": "controllers",
      "division_count": 3,
      "safe_count": 2,
      "unsafe_count": 1,
      "divisions": [
        {
          "line": 191,
          "numerator": "hf_power",
          "denominator": "total_power + 1e-12",
          "has_epsilon_protection": true,
          "code": "freq_domain_index = hf_power / (total_power + 1e-12)"
        },
        {
          "line": 264,
          "numerator": "0",
          "denominator": "1.0 + total_variation",
          "has_epsilon_protection": false,
          "code": "smoothness_index = 1.0 / (1.0 + total_variation)"
        },
        {
          "line": 273,
          "numerator": "hf_power",
          "denominator": "total_power + 1e-12",
          "has_epsilon_protection": true,
          "code": "hf_ratio = hf_power / (total_power + 1e-12)"
        }
      ]
    },
    "src/controllers/smc/algorithms/super_twisting/config.py": {
      "domain": "controllers",
      "division_count": 1,
      "safe_count": 0,
      "unsafe_count": 1,
      "divisions": [
        {
          "line": 166,
          "numerator": "2",
          "denominator": "K2^0.5",
          "has_epsilon_protection": false,
          "code": "# T_conv \u2248 2 / (K2^0.5) for standard Super-Twisting"
        }
      ]
    },
    "src/controllers/smc/algorithms/hybrid/switching_logic.py": {
      "domain": "controllers",
      "division_count": 2,
      "safe_count": 0,
      "unsafe_count": 2,
      "divisions": [
        {
          "line": 308,
          "numerator": "tracking_error",
          "denominator": "2 * error_threshold",
          "has_epsilon_protection": false,
          "code": "confidence = min(1.0, tracking_error / (2 * error_threshold))"
        },
        {
          "line": 332,
          "numerator": "adaptation_rate",
          "denominator": "2 * high_adaptation_threshold",
          "has_epsilon_protection": false,
          "code": "confidence = min(1.0, adaptation_rate / (2 * high_adaptation_threshold))"
        }
      ]
    },
    "src/controllers/smc/algorithms/hybrid/controller.py": {
      "domain": "controllers",
      "division_count": 1,
      "safe_count": 0,
      "unsafe_count": 1,
      "divisions": [
        {
          "line": 56,
          "numerator": "dt",
          "denominator": "self.tau + dt",
          "has_epsilon_protection": false,
          "code": "alpha = dt / (self.tau + dt)"
        }
      ]
    },
    "src/controllers/smc/algorithms/adaptive/parameter_estimation.py": {
      "domain": "controllers",
      "division_count": 1,
      "safe_count": 1,
      "unsafe_count": 0,
      "divisions": [
        {
          "line": 275,
          "numerator": "numerator",
          "denominator": "denominator + 1e-10",
          "has_epsilon_protection": true,
          "code": "K = numerator / (denominator + 1e-10)  # Small regularization"
        }
      ]
    },
    "src/controllers/smc/sta_smc.py": {
      "domain": "controllers",
      "division_count": 1,
      "safe_count": 0,
      "unsafe_count": 1,
      "divisions": [
        {
          "line": 53,
          "numerator": "sigma",
          "denominator": "|sigma|+eps",
          "has_epsilon_protection": false,
          "code": "# ---- FIX CS\u201101: robust saturation instead of \"sigma/(|sigma|+eps)\" ----"
        }
      ]
    },
    "src/controllers/smc/hybrid_adaptive_sta_smc.py": {
      "domain": "controllers",
      "division_count": 4,
      "safe_count": 0,
      "unsafe_count": 4,
      "divisions": [
        {
          "line": 371,
          "numerator": "abs_s",
          "denominator": "abs_s + self.taper_eps",
          "has_epsilon_protection": false,
          "code": "return abs_s / (abs_s + self.taper_eps)"
        },
        {
          "line": 564,
          "numerator": "0",
          "denominator": "1.0 + 0.01 * max(0, len(history.get(\"k1\", []",
          "has_epsilon_protection": false,
          "code": "time_factor = 1.0 / (1.0 + 0.01 * max(0, len(history.get(\"k1\", [])) - 1000))"
        },
        {
          "line": 570,
          "numerator": "k1_prev",
          "denominator": "10.0 * self.dt",
          "has_epsilon_protection": false,
          "code": "k1_dot = max(k1_dot - self.gain_leak, -k1_prev / (10.0 * self.dt))"
        },
        {
          "line": 571,
          "numerator": "k2_prev",
          "denominator": "10.0 * self.dt",
          "has_epsilon_protection": false,
          "code": "k2_dot = max(k2_dot - self.gain_leak, -k2_prev / (10.0 * self.dt))"
        }
      ]
    },
    "src/controllers/factory/pso_integration.py": {
      "domain": "controllers",
      "division_count": 1,
      "safe_count": 0,
      "unsafe_count": 1,
      "divisions": [
        {
          "line": 262,
          "numerator": "0",
          "denominator": "1.0 + np.var(self._control_efforts",
          "has_epsilon_protection": false,
          "code": "stability_margin = 1.0 / (1.0 + np.var(self._control_efforts)) if len(self._control_efforts) > 1 else 1.0"
        }
      ]
    },
    "src/plant/models/lowrank/config.py": {
      "domain": "plant",
      "division_count": 2,
      "safe_count": 0,
      "unsafe_count": 2,
      "divisions": [
        {
          "line": 175,
          "numerator": "g1",
          "denominator": "self.effective_inertia1 * self.pendulum1_length",
          "has_epsilon_protection": false,
          "code": "A[4, 3] = self.g1 / (self.effective_inertia1 * self.pendulum1_length)  # cart coupling"
        },
        {
          "line": 180,
          "numerator": "g2",
          "denominator": "self.effective_inertia2 * self.pendulum2_length",
          "has_epsilon_protection": false,
          "code": "A[5, 3] = self.g2 / (self.effective_inertia2 * self.pendulum2_length)  # cart coupling"
        }
      ]
    },
    "src/plant/models/full/dynamics.py": {
      "domain": "plant",
      "division_count": 2,
      "safe_count": 2,
      "unsafe_count": 0,
      "divisions": [
        {
          "line": 248,
          "numerator": "kinetic",
          "denominator": "total + 1e-12",
          "has_epsilon_protection": true,
          "code": "'energy_ratio': kinetic / (total + 1e-12)  # Avoid division by zero"
        },
        {
          "line": 280,
          "numerator": "max_eigenval",
          "denominator": "min_eigenval + 1e-12",
          "has_epsilon_protection": true,
          "code": "'eigenvalue_ratio': max_eigenval / (min_eigenval + 1e-12),"
        }
      ]
    },
    "src/optimization/validation/pso_bounds_validator.py": {
      "domain": "optimization",
      "division_count": 1,
      "safe_count": 0,
      "unsafe_count": 1,
      "divisions": [
        {
          "line": 339,
          "numerator": "r",
          "denominator": "abs(b_min",
          "has_epsilon_protection": false,
          "code": "normalized_ranges = [r / (abs(b_min) + abs(b_max) + 1e-6)"
        }
      ]
    },
    "src/optimization/validation/pso_bounds_optimizer.py": {
      "domain": "optimization",
      "division_count": 2,
      "safe_count": 0,
      "unsafe_count": 2,
      "divisions": [
        {
          "line": 345,
          "numerator": "0",
          "denominator": "param_sensitivity + 0.1",
          "has_epsilon_protection": false,
          "code": "sensitivity_scaling = 1.0 / (param_sensitivity + 0.1)"
        },
        {
          "line": 516,
          "numerator": "0",
          "denominator": "1.0 + performance['final_cost']",
          "has_epsilon_protection": false,
          "code": "normalized_cost = 1.0 / (1.0 + performance['final_cost'])  # Inverse for cost"
        }
      ]
    },
    "src/optimization/validation/enhanced_convergence_analyzer.py": {
      "domain": "optimization",
      "division_count": 4,
      "safe_count": 0,
      "unsafe_count": 4,
      "divisions": [
        {
          "line": 407,
          "numerator": "0",
          "denominator": "1.0 + cv * 100",
          "has_epsilon_protection": false,
          "code": "stagnation_score = 1.0 / (1.0 + cv * 100)"
        },
        {
          "line": 497,
          "numerator": "0",
          "denominator": "1.0 + abs(diversity_trend",
          "has_epsilon_protection": false,
          "code": "diversity_factor = 1.0 / (1.0 + abs(diversity_trend) * 100)"
        },
        {
          "line": 533,
          "numerator": "interval_width",
          "denominator": "abs(mean_fitness",
          "has_epsilon_protection": false,
          "code": "normalized_width = interval_width / (abs(mean_fitness) + 1e-6)"
        },
        {
          "line": 534,
          "numerator": "0",
          "denominator": "1.0 + normalized_width",
          "has_epsilon_protection": false,
          "code": "confidence = 1.0 / (1.0 + normalized_width)"
        }
      ]
    },
    "src/optimization/objectives/system/overshoot.py": {
      "domain": "optimization",
      "division_count": 1,
      "safe_count": 1,
      "unsafe_count": 0,
      "divisions": [
        {
          "line": 327,
          "numerator": "control_peak",
          "denominator": "control_mean + 1e-6",
          "has_epsilon_protection": true,
          "code": "control_overshoot_ratio = control_peak / (control_mean + 1e-6)"
        }
      ]
    },
    "src/optimization/objectives/multi/weighted_sum.py": {
      "domain": "optimization",
      "division_count": 2,
      "safe_count": 0,
      "unsafe_count": 2,
      "divisions": [
        {
          "line": 453,
          "numerator": "obj_ranges",
          "denominator": "np.sum(obj_ranges",
          "has_epsilon_protection": false,
          "code": "range_weights = obj_ranges / (np.sum(obj_ranges) + 1e-12)"
        },
        {
          "line": 454,
          "numerator": "trends",
          "denominator": "np.sum(trends",
          "has_epsilon_protection": false,
          "code": "trend_weights = trends / (np.sum(trends) + 1e-12)"
        }
      ]
    },
    "src/optimization/objectives/multi/pareto.py": {
      "domain": "optimization",
      "division_count": 1,
      "safe_count": 0,
      "unsafe_count": 1,
      "divisions": [
        {
          "line": 413,
          "numerator": "total_distance",
          "denominator": "len(objectives_array",
          "has_epsilon_protection": false,
          "code": "return total_distance / (len(objectives_array) - 1)"
        }
      ]
    },
    "src/optimization/objectives/control/robustness.py": {
      "domain": "optimization",
      "division_count": 1,
      "safe_count": 1,
      "unsafe_count": 0,
      "divisions": [
        {
          "line": 417,
          "numerator": "0",
          "denominator": "settling_time + 1e-6",
          "has_epsilon_protection": true,
          "code": "return 1.0 / (settling_time + 1e-6)"
        }
      ]
    },
    "src/optimization/objectives/control/energy.py": {
      "domain": "optimization",
      "division_count": 2,
      "safe_count": 2,
      "unsafe_count": 0,
      "divisions": [
        {
          "line": 210,
          "numerator": "0",
          "denominator": "tracking_error * energy + 1e-12",
          "has_epsilon_protection": true,
          "code": "efficiency = 1.0 / (tracking_error * energy + 1e-12)"
        },
        {
          "line": 213,
          "numerator": "0",
          "denominator": "energy + 1e-12",
          "has_epsilon_protection": true,
          "code": "efficiency = 1.0 / (energy + 1e-12)"
        }
      ]
    },
    "src/optimization/core/results_manager.py": {
      "domain": "optimization",
      "division_count": 1,
      "safe_count": 1,
      "unsafe_count": 0,
      "divisions": [
        {
          "line": 416,
          "numerator": "std_distance",
          "denominator": "mean_distance + 1e-10",
          "has_epsilon_protection": true,
          "code": "return float(std_distance / (mean_distance + 1e-10))"
        }
      ]
    },
    "src/optimization/algorithms/evolutionary/genetic.py": {
      "domain": "optimization",
      "division_count": 1,
      "safe_count": 0,
      "unsafe_count": 1,
      "divisions": [
        {
          "line": 425,
          "numerator": "0",
          "denominator": "eta + 1.0",
          "has_epsilon_protection": false,
          "code": "mut_pow = 1.0 / (eta + 1.0)"
        }
      ]
    },
    "src/utils/visualization/movie_generator.py": {
      "domain": "utils",
      "division_count": 1,
      "safe_count": 0,
      "unsafe_count": 1,
      "divisions": [
        {
          "line": 284,
          "numerator": "frame",
          "denominator": "frames * 0.3",
          "has_epsilon_protection": false,
          "code": "alpha = min(1.0, frame / (frames * 0.3))"
        }
      ]
    },
    "src/utils/analysis/statistics.py": {
      "domain": "utils",
      "division_count": 3,
      "safe_count": 0,
      "unsafe_count": 3,
      "divisions": [
        {
          "line": 145,
          "numerator": "2",
          "denominator": "n1-1",
          "has_epsilon_protection": false,
          "code": "denominator = (var1/n1)**2/(n1-1) + (var2/n2)**2/(n2-1)"
        },
        {
          "line": 145,
          "numerator": "2",
          "denominator": "n2-1",
          "has_epsilon_protection": false,
          "code": "denominator = (var1/n1)**2/(n1-1) + (var2/n2)**2/(n2-1)"
        },
        {
          "line": 222,
          "numerator": "SSB",
          "denominator": "SSB + SSW",
          "has_epsilon_protection": false,
          "code": "eta_squared = SSB / (SSB + SSW)"
        }
      ]
    }
  },
  "critical_files": [
    "src/controllers/smc/core/switching_functions.py",
    "src/controllers/smc/algorithms/classical/boundary_layer.py",
    "src/controllers/smc/algorithms/super_twisting/config.py",
    "src/controllers/smc/algorithms/hybrid/switching_logic.py",
    "src/controllers/smc/algorithms/hybrid/controller.py",
    "src/controllers/smc/algorithms/adaptive/parameter_estimation.py",
    "src/controllers/smc/sta_smc.py",
    "src/controllers/smc/hybrid_adaptive_sta_smc.py",
    "src/controllers/factory/pso_integration.py",
    "src/plant/models/lowrank/config.py",
    "src/plant/models/full/dynamics.py"
  ],
  "fixes_needed": [],
  "safe_operations_found": [
    {
      "file": "src/controllers/smc/algorithms/classical/boundary_layer.py",
      "line": 191,
      "numerator": "hf_power",
      "denominator": "total_power + 1e-12",
      "has_epsilon_protection": true,
      "code": "freq_domain_index = hf_power / (total_power + 1e-12)"
    },
    {
      "file": "src/controllers/smc/algorithms/classical/boundary_layer.py",
      "line": 273,
      "numerator": "hf_power",
      "denominator": "total_power + 1e-12",
      "has_epsilon_protection": true,
      "code": "hf_ratio = hf_power / (total_power + 1e-12)"
    },
    {
      "file": "src/controllers/smc/algorithms/adaptive/parameter_estimation.py",
      "line": 275,
      "numerator": "numerator",
      "denominator": "denominator + 1e-10",
      "has_epsilon_protection": true,
      "code": "K = numerator / (denominator + 1e-10)  # Small regularization"
    },
    {
      "file": "src/plant/models/full/dynamics.py",
      "line": 248,
      "numerator": "kinetic",
      "denominator": "total + 1e-12",
      "has_epsilon_protection": true,
      "code": "'energy_ratio': kinetic / (total + 1e-12)  # Avoid division by zero"
    },
    {
      "file": "src/plant/models/full/dynamics.py",
      "line": 280,
      "numerator": "max_eigenval",
      "denominator": "min_eigenval + 1e-12",
      "has_epsilon_protection": true,
      "code": "'eigenvalue_ratio': max_eigenval / (min_eigenval + 1e-12),"
    },
    {
      "file": "src/optimization/objectives/system/overshoot.py",
      "line": 327,
      "numerator": "control_peak",
      "denominator": "control_mean + 1e-6",
      "has_epsilon_protection": true,
      "code": "control_overshoot_ratio = control_peak / (control_mean + 1e-6)"
    },
    {
      "file": "src/optimization/objectives/control/robustness.py",
      "line": 417,
      "numerator": "0",
      "denominator": "settling_time + 1e-6",
      "has_epsilon_protection": true,
      "code": "return 1.0 / (settling_time + 1e-6)"
    },
    {
      "file": "src/optimization/objectives/control/energy.py",
      "line": 210,
      "numerator": "0",
      "denominator": "tracking_error * energy + 1e-12",
      "has_epsilon_protection": true,
      "code": "efficiency = 1.0 / (tracking_error * energy + 1e-12)"
    },
    {
      "file": "src/optimization/objectives/control/energy.py",
      "line": 213,
      "numerator": "0",
      "denominator": "energy + 1e-12",
      "has_epsilon_protection": true,
      "code": "efficiency = 1.0 / (energy + 1e-12)"
    },
    {
      "file": "src/optimization/core/results_manager.py",
      "line": 416,
      "numerator": "std_distance",
      "denominator": "mean_distance + 1e-10",
      "has_epsilon_protection": true,
      "code": "return float(std_distance / (mean_distance + 1e-10))"
    }
  ],
  "unsafe_operations_found": [
    {
      "file": "src/controllers/smc/core/switching_functions.py",
      "line": 167,
      "numerator": "2",
      "denominator": "1 + exp(-slope*s/\u03b5",
      "has_epsilon_protection": false,
      "code": "Formula: 2/(1 + exp(-slope*s/\u03b5)) - 1"
    },
    {
      "file": "src/controllers/smc/core/switching_functions.py",
      "line": 197,
      "numerator": "0",
      "denominator": "1.0 + exp_term",
      "has_epsilon_protection": false,
      "code": "return 2.0 / (1.0 + exp_term) - 1.0"
    },
    {
      "file": "src/controllers/smc/core/switching_functions.py",
      "line": 222,
      "numerator": "exp_term",
      "denominator": "1.0 + exp_term",
      "has_epsilon_protection": false,
      "code": "return (4.0 / epsilon) * exp_term / (1.0 + exp_term)**2"
    },
    {
      "file": "src/controllers/smc/algorithms/classical/boundary_layer.py",
      "line": 264,
      "numerator": "0",
      "denominator": "1.0 + total_variation",
      "has_epsilon_protection": false,
      "code": "smoothness_index = 1.0 / (1.0 + total_variation)"
    },
    {
      "file": "src/controllers/smc/algorithms/super_twisting/config.py",
      "line": 166,
      "numerator": "2",
      "denominator": "K2^0.5",
      "has_epsilon_protection": false,
      "code": "# T_conv \u2248 2 / (K2^0.5) for standard Super-Twisting"
    },
    {
      "file": "src/controllers/smc/algorithms/hybrid/switching_logic.py",
      "line": 308,
      "numerator": "tracking_error",
      "denominator": "2 * error_threshold",
      "has_epsilon_protection": false,
      "code": "confidence = min(1.0, tracking_error / (2 * error_threshold))"
    },
    {
      "file": "src/controllers/smc/algorithms/hybrid/switching_logic.py",
      "line": 332,
      "numerator": "adaptation_rate",
      "denominator": "2 * high_adaptation_threshold",
      "has_epsilon_protection": false,
      "code": "confidence = min(1.0, adaptation_rate / (2 * high_adaptation_threshold))"
    },
    {
      "file": "src/controllers/smc/algorithms/hybrid/controller.py",
      "line": 56,
      "numerator": "dt",
      "denominator": "self.tau + dt",
      "has_epsilon_protection": false,
      "code": "alpha = dt / (self.tau + dt)"
    },
    {
      "file": "src/controllers/smc/sta_smc.py",
      "line": 53,
      "numerator": "sigma",
      "denominator": "|sigma|+eps",
      "has_epsilon_protection": false,
      "code": "# ---- FIX CS\u201101: robust saturation instead of \"sigma/(|sigma|+eps)\" ----"
    },
    {
      "file": "src/controllers/smc/hybrid_adaptive_sta_smc.py",
      "line": 371,
      "numerator": "abs_s",
      "denominator": "abs_s + self.taper_eps",
      "has_epsilon_protection": false,
      "code": "return abs_s / (abs_s + self.taper_eps)"
    },
    {
      "file": "src/controllers/smc/hybrid_adaptive_sta_smc.py",
      "line": 564,
      "numerator": "0",
      "denominator": "1.0 + 0.01 * max(0, len(history.get(\"k1\", []",
      "has_epsilon_protection": false,
      "code": "time_factor = 1.0 / (1.0 + 0.01 * max(0, len(history.get(\"k1\", [])) - 1000))"
    },
    {
      "file": "src/controllers/smc/hybrid_adaptive_sta_smc.py",
      "line": 570,
      "numerator": "k1_prev",
      "denominator": "10.0 * self.dt",
      "has_epsilon_protection": false,
      "code": "k1_dot = max(k1_dot - self.gain_leak, -k1_prev / (10.0 * self.dt))"
    },
    {
      "file": "src/controllers/smc/hybrid_adaptive_sta_smc.py",
      "line": 571,
      "numerator": "k2_prev",
      "denominator": "10.0 * self.dt",
      "has_epsilon_protection": false,
      "code": "k2_dot = max(k2_dot - self.gain_leak, -k2_prev / (10.0 * self.dt))"
    },
    {
      "file": "src/controllers/factory/pso_integration.py",
      "line": 262,
      "numerator": "0",
      "denominator": "1.0 + np.var(self._control_efforts",
      "has_epsilon_protection": false,
      "code": "stability_margin = 1.0 / (1.0 + np.var(self._control_efforts)) if len(self._control_efforts) > 1 else 1.0"
    },
    {
      "file": "src/plant/models/lowrank/config.py",
      "line": 175,
      "numerator": "g1",
      "denominator": "self.effective_inertia1 * self.pendulum1_length",
      "has_epsilon_protection": false,
      "code": "A[4, 3] = self.g1 / (self.effective_inertia1 * self.pendulum1_length)  # cart coupling"
    },
    {
      "file": "src/plant/models/lowrank/config.py",
      "line": 180,
      "numerator": "g2",
      "denominator": "self.effective_inertia2 * self.pendulum2_length",
      "has_epsilon_protection": false,
      "code": "A[5, 3] = self.g2 / (self.effective_inertia2 * self.pendulum2_length)  # cart coupling"
    },
    {
      "file": "src/optimization/validation/pso_bounds_validator.py",
      "line": 339,
      "numerator": "r",
      "denominator": "abs(b_min",
      "has_epsilon_protection": false,
      "code": "normalized_ranges = [r / (abs(b_min) + abs(b_max) + 1e-6)"
    },
    {
      "file": "src/optimization/validation/pso_bounds_optimizer.py",
      "line": 345,
      "numerator": "0",
      "denominator": "param_sensitivity + 0.1",
      "has_epsilon_protection": false,
      "code": "sensitivity_scaling = 1.0 / (param_sensitivity + 0.1)"
    },
    {
      "file": "src/optimization/validation/pso_bounds_optimizer.py",
      "line": 516,
      "numerator": "0",
      "denominator": "1.0 + performance['final_cost']",
      "has_epsilon_protection": false,
      "code": "normalized_cost = 1.0 / (1.0 + performance['final_cost'])  # Inverse for cost"
    },
    {
      "file": "src/optimization/validation/enhanced_convergence_analyzer.py",
      "line": 407,
      "numerator": "0",
      "denominator": "1.0 + cv * 100",
      "has_epsilon_protection": false,
      "code": "stagnation_score = 1.0 / (1.0 + cv * 100)"
    },
    {
      "file": "src/optimization/validation/enhanced_convergence_analyzer.py",
      "line": 497,
      "numerator": "0",
      "denominator": "1.0 + abs(diversity_trend",
      "has_epsilon_protection": false,
      "code": "diversity_factor = 1.0 / (1.0 + abs(diversity_trend) * 100)"
    },
    {
      "file": "src/optimization/validation/enhanced_convergence_analyzer.py",
      "line": 533,
      "numerator": "interval_width",
      "denominator": "abs(mean_fitness",
      "has_epsilon_protection": false,
      "code": "normalized_width = interval_width / (abs(mean_fitness) + 1e-6)"
    },
    {
      "file": "src/optimization/validation/enhanced_convergence_analyzer.py",
      "line": 534,
      "numerator": "0",
      "denominator": "1.0 + normalized_width",
      "has_epsilon_protection": false,
      "code": "confidence = 1.0 / (1.0 + normalized_width)"
    },
    {
      "file": "src/optimization/objectives/multi/weighted_sum.py",
      "line": 453,
      "numerator": "obj_ranges",
      "denominator": "np.sum(obj_ranges",
      "has_epsilon_protection": false,
      "code": "range_weights = obj_ranges / (np.sum(obj_ranges) + 1e-12)"
    },
    {
      "file": "src/optimization/objectives/multi/weighted_sum.py",
      "line": 454,
      "numerator": "trends",
      "denominator": "np.sum(trends",
      "has_epsilon_protection": false,
      "code": "trend_weights = trends / (np.sum(trends) + 1e-12)"
    },
    {
      "file": "src/optimization/objectives/multi/pareto.py",
      "line": 413,
      "numerator": "total_distance",
      "denominator": "len(objectives_array",
      "has_epsilon_protection": false,
      "code": "return total_distance / (len(objectives_array) - 1)"
    },
    {
      "file": "src/optimization/algorithms/evolutionary/genetic.py",
      "line": 425,
      "numerator": "0",
      "denominator": "eta + 1.0",
      "has_epsilon_protection": false,
      "code": "mut_pow = 1.0 / (eta + 1.0)"
    },
    {
      "file": "src/utils/visualization/movie_generator.py",
      "line": 284,
      "numerator": "frame",
      "denominator": "frames * 0.3",
      "has_epsilon_protection": false,
      "code": "alpha = min(1.0, frame / (frames * 0.3))"
    },
    {
      "file": "src/utils/analysis/statistics.py",
      "line": 145,
      "numerator": "2",
      "denominator": "n1-1",
      "has_epsilon_protection": false,
      "code": "denominator = (var1/n1)**2/(n1-1) + (var2/n2)**2/(n2-1)"
    },
    {
      "file": "src/utils/analysis/statistics.py",
      "line": 145,
      "numerator": "2",
      "denominator": "n2-1",
      "has_epsilon_protection": false,
      "code": "denominator = (var1/n1)**2/(n1-1) + (var2/n2)**2/(n2-1)"
    },
    {
      "file": "src/utils/analysis/statistics.py",
      "line": 222,
      "numerator": "SSB",
      "denominator": "SSB + SSW",
      "has_epsilon_protection": false,
      "code": "eta_squared = SSB / (SSB + SSW)"
    }
  ],
  "acceptance_criteria_status": {
    "all_divisions_protected": false,
    "epsilon_threshold_1e12": false,
    "graceful_near_zero_handling": false,
    "zero_linalg_errors": false
  },
  "summary": {
    "total_divisions_found": 41,
    "safe_divisions": 10,
    "unsafe_divisions": 31,
    "files_needing_fixes": 17,
    "critical_files_count": 11
  }
}