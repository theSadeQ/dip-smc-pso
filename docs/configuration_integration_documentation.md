#==========================================================================================\\\
#================ docs/configuration_integration_documentation.md ===================\\\
#==========================================================================================\\\ # Configuration Integration Documentation ## Overview This document provides guidance on integrating the configuration system with the Enterprise Controller Factory. The DIP SMC-PSO project features a sophisticated configuration architecture that supports multiple sources, type safety, validation, and integration with controller creation workflows. ## Table of Contents 1. [Configuration Architecture](#configuration-architecture)
2. [Configuration Sources and Priority](#configuration-sources-and-priority)
3. [YAML Configuration Structure](#yaml-configuration-structure)
4. [Type-Safe Configuration Classes](#type-safe-configuration-classes)
5. [Configuration Resolution Patterns](#configuration-resolution-patterns)
6. [Validation and Error Handling](#validation-and-error-handling)
7. [Advanced Configuration Scenarios](#advanced-configuration-scenarios)
8. [Migration and Deprecation Handling](#migration-and-deprecation-handling)
9. [Best Practices](#best-practices)
10. [Examples and Use Cases](#examples-and-use-cases) --- ## Configuration Architecture ### System Overview The configuration integration system provides a unified approach to managing controller parameters from multiple sources with strict type safety and validation: ```
Configuration Integration Architecture
├── Configuration Sources
│ ├── YAML Configuration Files (config.yaml)
│ ├── Python Configuration Objects (Pydantic models)
│ ├── Explicit Parameters (function arguments)
│ └── Environment Variables (optional)
├── Configuration Processing
│ ├── Multi-Source Resolution (priority-based)
│ ├── Type Validation (Pydantic integration)
│ ├── Parameter Migration (deprecation handling)
│ └── Fallback Mechanisms (graceful degradation)
├── Factory Integration
│ ├── Automatic Parameter Extraction
│ ├── Controller-Specific Configuration
│ ├── PSO Optimization Integration
│ └── Dynamic Configuration Updates
└── Validation and Monitoring ├── Real-Time Validation ├── Configuration Drift Detection ├── Parameter Constraint Checking └── Performance Impact Monitoring
``` ### Design Principles 1. **Type Safety**: Pydantic-based validation with compile-time error detection
2. **Priority-Based Resolution**: Clear precedence rules for conflicting parameters
3. **Backward Compatibility**: migration from legacy configurations
4. **Validation-First**: All parameters validated before controller creation
5. **Performance Optimized**: Minimal overhead for configuration processing
6. **Extensibility**: Easy addition of new configuration sources and parameters --- ## Configuration Sources and Priority ### Priority Resolution Order The factory system resolves configuration parameters using a clear priority hierarchy: 1. **Explicit Function Parameters** (Highest Priority)
2. **Configuration Object Attributes**
3. **YAML Configuration File Values**
4. **Registry Default Values** (Lowest Priority) ```python
def demonstrate_configuration_priority(): """Demonstrate configuration priority resolution.""" from src.config import load_config from src.controllers.factory import create_controller # Load YAML configuration config = load_config("config.yaml") # Contains gains: [10, 8, 5, 3, 20, 2] # Priority 1: Explicit parameters override everything controller = create_controller( 'classical_smc', config=config, gains=[25, 20, 15, 10, 40, 6] # These gains will be used (Priority 1) ) print(f"Priority 1 - Explicit gains: {controller.gains}") # Priority 2: Configuration object when no explicit parameters controller = create_controller( 'classical_smc', config=config # Uses gains from config.yaml (Priority 2) ) print(f"Priority 2 - Config gains: {controller.gains}") # Priority 3: Registry defaults when no config provided controller = create_controller('classical_smc') # Uses registry defaults (Priority 3) print(f"Priority 3 - Default gains: {controller.gains}") demonstrate_configuration_priority()
``` ### Configuration Source Details #### 1. Explicit Function Parameters
```python
# Highest priority - always used when provided
controller = create_controller( 'classical_smc', gains=[20, 15, 12, 8, 35, 5], # Explicit gains max_force=150.0, # Explicit max_force boundary_layer=0.02 # Explicit boundary_layer
)
``` #### 2. Configuration Object Attributes
```python
# example-metadata:
# runnable: false # Second priority - extracted from configuration objects
class CustomConfig: def __init__(self): self.controllers = { 'classical_smc': { 'gains': [18, 12, 10, 6, 30, 4], 'max_force': 120.0, 'boundary_layer': 0.015 } } config = CustomConfig()
controller = create_controller('classical_smc', config=config)
``` #### 3. YAML Configuration Files
```yaml
# config.yaml - Third priority
controllers: classical_smc: gains: [15, 10, 8, 5, 25, 3] max_force: 100.0 boundary_layer: 0.01 dt: 0.001
``` #### 4. Registry Defaults
```python
# example-metadata:
# runnable: false # Fourth priority - built-in defaults
CONTROLLER_REGISTRY = { 'classical_smc': { 'default_gains': [20.0, 15.0, 12.0, 8.0, 35.0, 5.0], # ... other defaults }
}
``` --- ## YAML Configuration Structure ### Complete Configuration Schema The project uses a hierarchical YAML configuration structure: ```yaml
# config.yaml - Complete configuration example # Global settings
global_seed: 42 # Physics parameters for the double-inverted pendulum
physics: # Pendulum masses [kg] m1: 0.5 # Upper pendulum mass m2: 0.5 # Lower pendulum mass M: 2.0 # Cart mass # Pendulum lengths [m] l1: 0.5 # Upper pendulum length l2: 0.5 # Lower pendulum length # Friction coefficients b1: 0.1 # Upper pendulum friction b2: 0.1 # Lower pendulum friction # Moments of inertia [kg⋅m²] I1: 0.1 # Upper pendulum inertia I2: 0.1 # Lower pendulum inertia # Simulation parameters
simulation: duration: 5.0 # Simulation time [s] dt: 0.001 # Integration timestep [s] initial_state: # Initial conditions [θ1, θ2, x, θ̇1, θ̇2, ẋ] - 0.1 # Initial angle 1 [rad] - 0.05 # Initial angle 2 [rad] - 0.0 # Initial cart position [m] - 0.0 # Initial angular velocity 1 [rad/s] - 0.0 # Initial angular velocity 2 [rad/s] - 0.0 # Initial cart velocity [m/s] use_full_dynamics: false # Use simplified (false) or full (true) dynamics # Controller configurations
controllers: classical_smc: # Gains: [k1, k2, λ1, λ2, K, kd] gains: [20.0, 15.0, 12.0, 8.0, 35.0, 5.0] max_force: 150.0 # Control saturation limit [N] boundary_layer: 0.02 # Chattering reduction parameter dt: 0.001 # Control timestep [s] switch_method: "tanh" # Switching function type regularization: 1e-10 # Numerical regularization sta_smc: # Gains: [K1, K2, k1, k2, λ1, λ2] gains: [25.0, 15.0, 20.0, 12.0, 8.0, 6.0] max_force: 150.0 dt: 0.001 boundary_layer: 0.01 power_exponent: 0.5 # Super-twisting power parameter regularization: 1e-6 switch_method: "tanh" damping_gain: 0.0 adaptive_smc: # Gains: [k1, k2, λ1, λ2, γ] gains: [25.0, 18.0, 15.0, 10.0, 4.0] max_force: 150.0 dt: 0.001 leak_rate: 0.01 # Adaptation leak rate dead_zone: 0.05 # Dead zone for adaptation adapt_rate_limit: 10.0 # Maximum adaptation rate K_min: 0.1 # Minimum adaptive gain K_max: 100.0 # Maximum adaptive gain K_init: 10.0 # Initial adaptive gain alpha: 0.5 # Adaptation smoothing parameter boundary_layer: 0.01 smooth_switch: true hybrid_adaptive_sta_smc: # Gains: [k1, k2, λ1, λ2] gains: [18.0, 12.0, 10.0, 8.0] max_force: 150.0 dt: 0.001 hybrid_mode: "classical_adaptive" # Hybrid operation mode k1_init: 4.0 # Initial adaptive gain 1 k2_init: 0.4 # Initial adaptive gain 2 leak_rate: 0.01 dead_zone: 0.05 classical_config: # Sub-controller configuration gains: [20.0, 15.0, 12.0, 8.0, 35.0, 5.0] max_force: 150.0 boundary_layer: 0.02 dt: 0.001 adaptive_config: # Sub-controller configuration gains: [25.0, 18.0, 15.0, 10.0, 4.0] max_force: 150.0 dt: 0.001 # PSO optimization parameters
pso: n_particles: 30 # Swarm size max_iter: 100 # Maximum iterations w: 0.9 # Inertia weight c1: 2.0 # Cognitive coefficient c2: 2.0 # Social coefficient bounds: # Parameter bounds for optimization classical_smc: lower: [1.0, 1.0, 1.0, 1.0, 5.0, 0.1] upper: [30.0, 30.0, 20.0, 20.0, 50.0, 10.0] adaptive_smc: lower: [2.0, 2.0, 1.0, 1.0, 0.5] upper: [40.0, 40.0, 25.0, 25.0, 10.0] # Cost function configuration
cost_function: weights: ise: 0.4 # Integral squared error weight control_effort: 0.3 # Control effort weight settling_time: 0.2 # Settling time weight overshoot: 0.1 # Overshoot penalty weight normalization: enable: true threshold: 1e-12 # Hardware-in-the-loop configuration
hil: enabled: false plant_server: host: "localhost" port: 8888 update_rate: 1000 # Hz controller_client: host: "localhost" port: 8888 timeout: 1.0 # seconds # Logging and monitoring
logging: level: "INFO" file: "simulation.log" format: "%(asctime)s - %(name)s - %(levelname)s - %(message)s" monitoring: performance_tracking: true memory_monitoring: true control_saturation_alerts: true
``` ### Configuration Validation The YAML configuration is validated using Pydantic models: ```python
# example-metadata:
# runnable: false from pydantic import BaseModel, Field, validator
from typing import List, Dict, Optional, Literal class PhysicsConfig(BaseModel): """Physics parameters for the double-inverted pendulum.""" m1: float = Field(..., gt=0, description="Upper pendulum mass [kg]") m2: float = Field(..., gt=0, description="Lower pendulum mass [kg]") M: float = Field(..., gt=0, description="Cart mass [kg]") l1: float = Field(..., gt=0, description="Upper pendulum length [m]") l2: float = Field(..., gt=0, description="Lower pendulum length [m]") b1: float = Field(..., ge=0, description="Upper pendulum friction") b2: float = Field(..., ge=0, description="Lower pendulum friction") I1: float = Field(..., gt=0, description="Upper pendulum inertia [kg⋅m²]") I2: float = Field(..., gt=0, description="Lower pendulum inertia [kg⋅m²]") class SimulationConfig(BaseModel): """Simulation parameters.""" duration: float = Field(..., gt=0, description="Simulation time [s]") dt: float = Field(..., gt=0, le=0.01, description="Integration timestep [s]") initial_state: List[float] = Field(..., min_items=6, max_items=6) use_full_dynamics: bool = Field(False, description="Use full nonlinear dynamics") @validator('initial_state') def validate_initial_state(cls, v): """Validate initial state vector.""" if len(v) != 6: raise ValueError("Initial state must have 6 components") # Check angle limits (±π) if abs(v[0]) > 3.14159 or abs(v[1]) > 3.14159: raise ValueError("Initial angles must be within ±π radians") return v class ClassicalSMCConfig(BaseModel): """Classical SMC controller configuration.""" gains: List[float] = Field(..., min_items=6, max_items=6) max_force: float = Field(..., gt=0) boundary_layer: float = Field(..., gt=0) dt: float = Field(..., gt=0) switch_method: Literal["tanh", "linear", "sign"] = "tanh" regularization: float = Field(1e-10, gt=0) @validator('gains') def validate_gains(cls, v): """Validate SMC gains for stability.""" if not all(g > 0 for g in v): raise ValueError("All SMC gains must be positive") k1, k2, lam1, lam2, K, kd = v # Stability constraints if lam1 <= 0 or lam2 <= 0: raise ValueError("Surface coefficients λ1, λ2 must be positive") if K <= 0: raise ValueError("Switching gain K must be positive") # Practical constraints if K > 200: raise ValueError("Switching gain K too large (>200), may cause excessive chattering") return v class ConfigSchema(BaseModel): """Complete configuration schema.""" global_seed: Optional[int] = Field(None, ge=0) physics: PhysicsConfig simulation: SimulationConfig controllers: Dict[str, Dict] = Field(default_factory=dict) pso: Optional[Dict] = Field(default_factory=dict) cost_function: Optional[Dict] = Field(default_factory=dict) hil: Optional[Dict] = Field(default_factory=dict) logging: Optional[Dict] = Field(default_factory=dict) monitoring: Optional[Dict] = Field(default_factory=dict)
``` --- ## Type-Safe Configuration Classes ### Controller-Specific Configuration Classes Each controller type has a dedicated configuration class with domain-specific validation: #### Classical SMC Configuration ```python
from dataclasses import dataclass, field
from typing import List, Optional, Literal
import numpy as np @dataclass(frozen=True)
class ClassicalSMCConfig: """Type-safe configuration for Classical SMC controller.""" # Required parameters gains: List[float] = field() # [k1, k2, λ1, λ2, K, kd] max_force: float = field() # Control saturation limit [N] boundary_layer: float = field() # Chattering reduction thickness # Optional parameters with defaults dt: float = field(default=0.01) # Control timestep [s] switch_method: Literal["tanh", "linear", "sign"] = field(default="tanh") regularization: float = field(default=1e-10) # Matrix regularization boundary_layer_slope: float = field(default=0.0) # Adaptive boundary layer controllability_threshold: Optional[float] = field(default=None) # Optional dynamics model dynamics_model: Optional[object] = field(default=None, compare=False) def __post_init__(self): """Validate configuration after creation.""" self._validate_gains() self._validate_control_parameters() self._validate_stability_requirements() def _validate_gains(self): """Validate gain array for classical SMC.""" if len(self.gains) != 6: raise ValueError("Classical SMC requires exactly 6 gains: [k1, k2, λ1, λ2, K, kd]") if not all(isinstance(g, (int, float)) and np.isfinite(g) for g in self.gains): raise ValueError("All gains must be finite numbers") if not all(g > 0 for g in self.gains): raise ValueError("All gains must be positive for stability") k1, k2, lam1, lam2, K, kd = self.gains # Control theory constraints if lam1 <= 0 or lam2 <= 0: raise ValueError("Surface coefficients λ1, λ2 must be positive (Hurwitz stability)") if K <= 0: raise ValueError("Switching gain K must be positive (reaching condition)") # Practical constraints if K > 200: raise ValueError("Switching gain K > 200 may cause excessive chattering") if lam1/k1 > 50 or lam2/k2 > 50: raise ValueError("Surface coefficient ratios too large (λ/k > 50)") def _validate_control_parameters(self): """Validate control-specific parameters.""" if self.max_force <= 0: raise ValueError("max_force must be positive") if self.boundary_layer <= 0: raise ValueError("boundary_layer must be positive") if self.dt <= 0: raise ValueError("dt must be positive") if self.regularization <= 0: raise ValueError("regularization must be positive") def _validate_stability_requirements(self): """Validate control theory stability requirements.""" k1, k2, lam1, lam2, K, kd = self.gains # Lyapunov stability condition: surface must be stable # For s = λ1*e1 + λ2*e2 + ė1 + ė2, we need λ1, λ2 > 0 # Reaching condition: K must overcome uncertainties # Conservative estimate: K > max(k1, k2) for robustness min_K = max(k1, k2) if K < min_K: print(f"Warning: K={K} < max(k1,k2)={min_K}, may not satisfy reaching condition") # Chattering bound: K should not be excessively large if K > 10 * min_K: print(f"Warning: K={K} >> max(k1,k2)={min_K}, expect significant chattering")
``` #### Adaptive SMC Configuration ```python
# example-metadata:
# runnable: false @dataclass(frozen=True)
class AdaptiveSMCConfig: """Type-safe configuration for Adaptive SMC controller.""" # Required parameters gains: List[float] = field() # [k1, k2, λ1, λ2, γ] max_force: float = field() # Control saturation limit dt: float = field() # Control timestep # Adaptive parameters leak_rate: float = field(default=0.01) # σ-modification leak rate dead_zone: float = field(default=0.05) # Adaptation dead zone adapt_rate_limit: float = field(default=10.0) # Maximum adaptation rate K_min: float = field(default=0.1) # Minimum adaptive gain K_max: float = field(default=100.0) # Maximum adaptive gain K_init: float = field(default=10.0) # Initial adaptive gain alpha: float = field(default=0.5) # Adaptation smoothing boundary_layer: float = field(default=0.01) # Chattering reduction smooth_switch: bool = field(default=True) # Smooth switching # Optional dynamics model dynamics_model: Optional[object] = field(default=None, compare=False) def __post_init__(self): """Validate adaptive SMC configuration.""" self._validate_gains() self._validate_adaptive_parameters() self._validate_adaptation_stability() def _validate_gains(self): """Validate gain array for adaptive SMC.""" if len(self.gains) != 5: raise ValueError("Adaptive SMC requires exactly 5 gains: [k1, k2, λ1, λ2, γ]") if not all(g > 0 for g in self.gains): raise ValueError("All gains must be positive") k1, k2, lam1, lam2, gamma = self.gains # Adaptation rate constraints if gamma <= 0: raise ValueError("Adaptation rate γ must be positive") if gamma > 50: raise ValueError("Adaptation rate γ > 50 may cause instability") # Surface stability if lam1 <= 0 or lam2 <= 0: raise ValueError("Surface coefficients must be positive") def _validate_adaptive_parameters(self): """Validate adaptation-specific parameters.""" if not 0 < self.leak_rate < 1: raise ValueError("leak_rate must be in (0, 1)") if self.dead_zone <= 0: raise ValueError("dead_zone must be positive") if self.adapt_rate_limit <= 0: raise ValueError("adapt_rate_limit must be positive") if not 0 < self.K_min < self.K_max: raise ValueError("Must have 0 < K_min < K_max") if not self.K_min <= self.K_init <= self.K_max: raise ValueError("K_init must be in [K_min, K_max]") def _validate_adaptation_stability(self): """Validate adaptation stability requirements.""" k1, k2, lam1, lam2, gamma = self.gains # Ensure adaptation is not too aggressive relative to surface dynamics surface_time_constant = min(1/lam1, 1/lam2) adaptation_time_constant = 1/gamma if adaptation_time_constant < 0.1 * surface_time_constant: print(f"Warning: Fast adaptation (τ_adapt={adaptation_time_constant:.3f}) " f"relative to surface dynamics (τ_surface={surface_time_constant:.3f})")
``` #### Super-Twisting SMC Configuration ```python
# example-metadata:
# runnable: false @dataclass(frozen=True)
class SuperTwistingSMCConfig: """Type-safe configuration for Super-Twisting SMC controller.""" # Required parameters gains: List[float] = field() # [K1, K2, k1, k2, λ1, λ2] max_force: float = field() # Control saturation limit dt: float = field() # Control timestep # Super-twisting specific parameters power_exponent: float = field(default=0.5) # Fractional power (0 < α < 1) regularization: float = field(default=1e-6) # Singularity avoidance boundary_layer: float = field(default=0.01) # Chattering reduction switch_method: Literal["tanh", "linear", "sign"] = field(default="tanh") damping_gain: float = field(default=0.0) # Additional damping # Optional dynamics model dynamics_model: Optional[object] = field(default=None, compare=False) def __post_init__(self): """Validate super-twisting configuration.""" self._validate_gains() self._validate_twisting_parameters() self._validate_convergence_conditions() def _validate_gains(self): """Validate gain array for super-twisting SMC.""" if len(self.gains) != 6: raise ValueError("Super-twisting SMC requires 6 gains: [K1, K2, k1, k2, λ1, λ2]") if not all(g > 0 for g in self.gains): raise ValueError("All gains must be positive") K1, K2, k1, k2, lam1, lam2 = self.gains # Super-twisting stability conditions if K1 <= 0 or K2 <= 0: raise ValueError("Algorithmic gains K1, K2 must be positive") # Surface gains if lam1 <= 0 or lam2 <= 0: raise ValueError("Surface coefficients must be positive") def _validate_twisting_parameters(self): """Validate super-twisting specific parameters.""" if not 0 < self.power_exponent < 1: raise ValueError("Power exponent must be in (0, 1) for finite-time convergence") if self.regularization <= 0: raise ValueError("Regularization must be positive") if self.boundary_layer <= 0: raise ValueError("Boundary layer must be positive") if self.damping_gain < 0: raise ValueError("Damping gain must be non-negative") def _validate_convergence_conditions(self): """Validate finite-time convergence conditions.""" K1, K2, k1, k2, lam1, lam2 = self.gains # Super-twisting convergence requires specific gain relationships # Sufficient condition: K1 > √(2)*uncertainty_bound # and K2 > uncertainty_bound for some uncertainty bound # Check gain ratios for practical convergence if K2 > 2 * K1: print(f"Warning: K2={K2} > 2*K1={2*K1}, may cause oscillations") if K1 < max(k1, k2): print(f"Warning: K1={K1} < max(k1,k2), may not achieve finite-time convergence")
``` --- ## Configuration Resolution Patterns ### Multi-Source Parameter Resolution The factory implements sophisticated parameter resolution to handle multiple configuration sources: ```python
# example-metadata:
# runnable: false def _resolve_controller_gains( gains: Optional[Union[List[float], np.ndarray]], config: Optional[Any], controller_type: str, controller_info: Dict[str, Any]
) -> List[float]: """Resolve controller gains from multiple sources with priority.""" # Priority 1: Explicit gains parameter if gains is not None: if isinstance(gains, np.ndarray): gains = gains.tolist() return gains # Priority 2: Configuration object extraction if config is not None: extracted_gains = _extract_gains_from_config(config, controller_type) if extracted_gains is not None: return extracted_gains # Priority 3: Registry defaults return controller_info['default_gains'] def _extract_gains_from_config(config: Any, controller_type: str) -> Optional[List[float]]: """Extract gains from configuration object using multiple patterns.""" extraction_patterns = [ # Pattern 1: config.controllers.controller_type.gains lambda: getattr(getattr(config.controllers, controller_type, None), 'gains', None), # Pattern 2: config.controllers[controller_type]['gains'] lambda: config.controllers[controller_type]['gains'] if isinstance(config.controllers, dict) else None, # Pattern 3: config.controller_defaults.controller_type.gains lambda: getattr(getattr(config.controller_defaults, controller_type, None), 'gains', None), # Pattern 4: config.controller_defaults[controller_type]['gains'] lambda: config.controller_defaults[controller_type]['gains'] if isinstance(config.controller_defaults, dict) else None, ] for pattern in extraction_patterns: try: gains = pattern() if gains is not None and isinstance(gains, (list, tuple)) and len(gains) > 0: return list(gains) except (AttributeError, KeyError, TypeError): continue return None
``` ### Configuration Pattern Examples #### Pattern 1: Pydantic Model Configuration ```python
from pydantic import BaseModel
from typing import Dict, Any class ControllerConfig(BaseModel): gains: List[float] max_force: float boundary_layer: float dt: float class ProjectConfig(BaseModel): controllers: Dict[str, ControllerConfig] physics: Dict[str, float] simulation: Dict[str, Any] # Usage
config_data = { 'controllers': { 'classical_smc': { 'gains': [20, 15, 12, 8, 35, 5], 'max_force': 150.0, 'boundary_layer': 0.02, 'dt': 0.001 } }, 'physics': {'m1': 0.5, 'm2': 0.5, 'M': 2.0}, 'simulation': {'duration': 5.0, 'dt': 0.001}
} config = ProjectConfig(**config_data)
controller = create_controller('classical_smc', config=config)
``` #### Pattern 2: Nested Dictionary Configuration ```python
# example-metadata:
# runnable: false # Nested dictionary configuration
config = { 'controllers': { 'classical_smc': { 'gains': [18, 12, 10, 6, 30, 4], 'max_force': 120.0, 'boundary_layer': 0.015, 'dt': 0.001 }, 'adaptive_smc': { 'gains': [22, 16, 12, 8, 3.5], 'max_force': 140.0, 'dt': 0.001, 'leak_rate': 0.015 } }
} # Use with factory
controller = create_controller('classical_smc', config=config)
``` #### Pattern 3: Attribute-Based Configuration ```python
# example-metadata:
# runnable: false class AttributeConfig: """Configuration using attributes.""" def __init__(self): # Create controller configurations as attributes self.classical_smc = type('Config', (), { 'gains': [25, 20, 15, 10, 40, 6], 'max_force': 160.0, 'boundary_layer': 0.025, 'dt': 0.001 })() self.adaptive_smc = type('Config', (), { 'gains': [30, 22, 18, 12, 5.0], 'max_force': 160.0, 'dt': 0.001, 'leak_rate': 0.02 })() # Initialize controllers namespace
config = type('Config', (), {})()
config.controllers = AttributeConfig() controller = create_controller('classical_smc', config=config)
``` ### Dynamic Configuration Updates ```python
class DynamicConfigurationManager: """Manage dynamic configuration updates.""" def __init__(self, config_file="config.yaml"): self.config_file = config_file self.config = self._load_config() self.controller_cache = {} self.observers = [] def _load_config(self): """Load configuration from file.""" from src.config import load_config return load_config(self.config_file) def update_controller_config(self, controller_type: str, **updates): """Update controller configuration dynamically.""" # Update configuration if controller_type not in self.config.controllers: self.config.controllers[controller_type] = {} for key, value in updates.items(): self.config.controllers[controller_type][key] = value # Invalidate cached controllers if controller_type in self.controller_cache: del self.controller_cache[controller_type] # Notify observers self._notify_observers(controller_type, updates) def get_controller(self, controller_type: str): """Get controller with current configuration.""" if controller_type not in self.controller_cache: # Create controller with current config controller = create_controller(controller_type, config=self.config) self.controller_cache[controller_type] = controller return self.controller_cache[controller_type] def register_observer(self, callback): """Register configuration change observer.""" self.observers.append(callback) def _notify_observers(self, controller_type: str, updates: Dict[str, Any]): """Notify observers of configuration changes.""" for observer in self.observers: try: observer(controller_type, updates) except Exception as e: print(f"Observer notification failed: {e}") def save_config(self): """Save current configuration to file.""" import yaml # Convert config to dictionary config_dict = self.config.model_dump() if hasattr(self.config, 'model_dump') else vars(self.config) with open(self.config_file, 'w') as f: yaml.dump(config_dict, f, default_flow_style=False) # Usage
config_manager = DynamicConfigurationManager() # Update configuration
config_manager.update_controller_config( 'classical_smc', gains=[22, 16, 14, 9, 38, 5.5], max_force=160.0
) # Get updated controller
controller = config_manager.get_controller('classical_smc') # Register change observer
def config_change_handler(controller_type, updates): print(f"Configuration updated for {controller_type}: {updates}") config_manager.register_observer(config_change_handler)
``` --- ## Validation and Error Handling ### Configuration Validation ```python
# example-metadata:
# runnable: false class ConfigurationValidator: """configuration validation system.""" def __init__(self): self.validation_rules = self._initialize_validation_rules() self.validation_errors = [] self.validation_warnings = [] def _initialize_validation_rules(self): """Initialize controller-specific validation rules.""" return { 'classical_smc': self._validate_classical_smc, 'adaptive_smc': self._validate_adaptive_smc, 'sta_smc': self._validate_sta_smc, 'hybrid_adaptive_sta_smc': self._validate_hybrid_smc, 'mpc_controller': self._validate_mpc } def validate_configuration(self, controller_type: str, config: Dict[str, Any]) -> bool: """Validate configuration for specific controller type.""" self.validation_errors.clear() self.validation_warnings.clear() try: # Basic validation self._validate_basic_structure(config) # Controller-specific validation if controller_type in self.validation_rules: self.validation_rules[controller_type](config) else: self.validation_warnings.append(f"No specific validation rules for {controller_type}") # Cross-parameter validation self._validate_cross_parameters(config) return len(self.validation_errors) == 0 except Exception as e: self.validation_errors.append(f"Validation failed: {e}") return False def _validate_basic_structure(self, config: Dict[str, Any]): """Validate basic configuration structure.""" required_fields = ['gains', 'max_force', 'dt'] for field in required_fields: if field not in config: self.validation_errors.append(f"Missing required field: {field}") def _validate_classical_smc(self, config: Dict[str, Any]): """Validate Classical SMC configuration.""" gains = config.get('gains', []) # Gain count validation if len(gains) != 6: self.validation_errors.append("Classical SMC requires 6 gains") return k1, k2, lam1, lam2, K, kd = gains # Positivity constraints if not all(g > 0 for g in gains): self.validation_errors.append("All gains must be positive") # Stability constraints if lam1 <= 0 or lam2 <= 0: self.validation_errors.append("Surface coefficients λ1, λ2 must be positive") # Practical constraints if K > 200: self.validation_warnings.append("High switching gain K may cause chattering") if lam1/k1 > 50 or lam2/k2 > 50: self.validation_warnings.append("High surface coefficient ratios") # Boundary layer validation boundary_layer = config.get('boundary_layer', 0) if boundary_layer <= 0: self.validation_errors.append("Boundary layer must be positive") if boundary_layer > 0.1: self.validation_warnings.append("Large boundary layer may reduce tracking accuracy") def _validate_adaptive_smc(self, config: Dict[str, Any]): """Validate Adaptive SMC configuration.""" gains = config.get('gains', []) # Gain count validation if len(gains) != 5: self.validation_errors.append("Adaptive SMC requires 5 gains") return k1, k2, lam1, lam2, gamma = gains # Adaptation rate validation if gamma <= 0: self.validation_errors.append("Adaptation rate γ must be positive") if gamma > 50: self.validation_warnings.append("High adaptation rate may cause instability") # Leak rate validation leak_rate = config.get('leak_rate', 0.01) if not 0 < leak_rate < 1: self.validation_errors.append("Leak rate must be in (0, 1)") # Dead zone validation dead_zone = config.get('dead_zone', 0.05) if dead_zone <= 0: self.validation_errors.append("Dead zone must be positive") # Adaptive gain bounds K_min = config.get('K_min', 0.1) K_max = config.get('K_max', 100.0) K_init = config.get('K_init', 10.0) if not 0 < K_min < K_max: self.validation_errors.append("Must have 0 < K_min < K_max") if not K_min <= K_init <= K_max: self.validation_errors.append("K_init must be in [K_min, K_max]") def _validate_sta_smc(self, config: Dict[str, Any]): """Validate Super-Twisting SMC configuration.""" gains = config.get('gains', []) if len(gains) != 6: self.validation_errors.append("Super-twisting SMC requires 6 gains") return K1, K2, k1, k2, lam1, lam2 = gains # Algorithmic gains if K1 <= 0 or K2 <= 0: self.validation_errors.append("Algorithmic gains K1, K2 must be positive") # Convergence conditions if K2 > 2 * K1: self.validation_warnings.append("K2 > 2*K1 may cause oscillations") if K1 < max(k1, k2): self.validation_warnings.append("K1 < max(k1,k2) may not achieve finite-time convergence") # Power exponent power_exponent = config.get('power_exponent', 0.5) if not 0 < power_exponent < 1: self.validation_errors.append("Power exponent must be in (0, 1)") def _validate_hybrid_smc(self, config: Dict[str, Any]): """Validate Hybrid SMC configuration.""" gains = config.get('gains', []) if len(gains) != 4: self.validation_errors.append("Hybrid SMC requires 4 gains") # Check sub-configurations classical_config = config.get('classical_config') adaptive_config = config.get('adaptive_config') if classical_config is None: self.validation_errors.append("Missing classical_config for hybrid controller") else: self._validate_classical_smc(classical_config) if adaptive_config is None: self.validation_errors.append("Missing adaptive_config for hybrid controller") else: self._validate_adaptive_smc(adaptive_config) # Hybrid mode validation hybrid_mode = config.get('hybrid_mode', 'classical_adaptive') valid_modes = ['classical_adaptive', 'sta_adaptive', 'dynamic_switching'] if hybrid_mode not in valid_modes: self.validation_errors.append(f"Invalid hybrid_mode: {hybrid_mode}") def _validate_mpc(self, config: Dict[str, Any]): """Validate MPC configuration.""" # Horizon validation horizon = config.get('horizon', 10) if not isinstance(horizon, int) or horizon < 1: self.validation_errors.append("Horizon must be positive integer") if horizon > 50: self.validation_warnings.append("Large horizon may cause computational issues") # Weight validation weights = ['q_x', 'q_theta', 'r_u'] for weight in weights: value = config.get(weight, 1.0) if not isinstance(value, (int, float)) or value < 0: self.validation_errors.append(f"{weight} must be non-negative number") def _validate_cross_parameters(self, config: Dict[str, Any]): """Validate relationships between parameters.""" max_force = config.get('max_force', 150.0) dt = config.get('dt', 0.001) # Timestep validation if dt > 0.01: self.validation_warnings.append("Large timestep (>0.01s) may cause numerical issues") if dt < 1e-5: self.validation_warnings.append("Very small timestep may be computationally expensive") # Force limits if max_force > 500: self.validation_warnings.append("Very high force limit may be unrealistic") if max_force < 10: self.validation_warnings.append("Low force limit may prevent effective control") def get_validation_report(self) -> Dict[str, Any]: """Get validation report.""" return { 'valid': len(self.validation_errors) == 0, 'errors': self.validation_errors.copy(), 'warnings': self.validation_warnings.copy(), 'error_count': len(self.validation_errors), 'warning_count': len(self.validation_warnings) } # Usage
validator = ConfigurationValidator() # Validate configuration
config = { 'gains': [20, 15, 12, 8, 35, 5], 'max_force': 150.0, 'boundary_layer': 0.02, 'dt': 0.001
} is_valid = validator.validate_configuration('classical_smc', config)
report = validator.get_validation_report() if not is_valid: print("Configuration validation failed:") for error in report['errors']: print(f" ❌ {error}") if report['warnings']: print("Configuration warnings:") for warning in report['warnings']: print(f" ⚠️ {warning}")
``` --- ## Advanced Configuration Scenarios ### Environment-Based Configuration ```python
import os
from typing import Dict, Any, Optional class EnvironmentConfigurationManager: """Manage environment-based configuration overrides.""" def __init__(self, base_config_file: str = "config.yaml"): self.base_config = self._load_base_config(base_config_file) self.environment = os.getenv('DIP_ENV', 'development') self.env_overrides = self._load_environment_overrides() def _load_base_config(self, config_file: str): """Load base configuration.""" from src.config import load_config return load_config(config_file) def _load_environment_overrides(self) -> Dict[str, Any]: """Load environment-specific overrides.""" env_configs = { 'development': { 'simulation': {'duration': 2.0}, # Shorter for testing 'logging': {'level': 'DEBUG'}, 'pso': {'n_particles': 10, 'max_iter': 20} # Faster optimization }, 'testing': { 'simulation': {'duration': 1.0, 'dt': 0.01}, # Fast testing 'logging': {'level': 'WARNING'}, 'controllers': { 'classical_smc': {'gains': [10, 8, 6, 4, 20, 2]} # Conservative gains } }, 'production': { 'logging': {'level': 'INFO'}, 'monitoring': {'performance_tracking': True}, 'pso': {'n_particles': 50, 'max_iter': 200} # Thorough optimization }, 'hil': { 'hil': {'enabled': True}, 'simulation': {'dt': 0.001}, # High precision for HIL 'controllers': { 'classical_smc': {'dt': 0.001} # Match simulation timestep } } } return env_configs.get(self.environment, {}) def get_merged_config(self) -> Any: """Get configuration with environment overrides applied.""" merged_config = self._deep_merge( self._config_to_dict(self.base_config), self.env_overrides ) # Apply environment variable overrides env_var_overrides = self._extract_env_var_overrides() if env_var_overrides: merged_config = self._deep_merge(merged_config, env_var_overrides) # Convert back to config object return self._dict_to_config(merged_config) def _extract_env_var_overrides(self) -> Dict[str, Any]: """Extract configuration overrides from environment variables.""" overrides = {} # Environment variable patterns: # DIP_CONTROLLER_CLASSICAL_GAINS=20,15,12,8,35,5 # DIP_SIMULATION_DURATION=5.0 # DIP_PSO_N_PARTICLES=30 for key, value in os.environ.items(): if key.startswith('DIP_'): # Parse nested key: DIP_CONTROLLER_CLASSICAL_GAINS -> controllers.classical_smc.gains parts = key[4:].lower().split('_') # Remove 'DIP_' prefix if len(parts) >= 2: config_dict = overrides # Navigate/create nested structure for part in parts[:-1]: if part not in config_dict: config_dict[part] = {} config_dict = config_dict[part] # Set value with type conversion final_key = parts[-1] config_dict[final_key] = self._convert_env_value(value) return overrides def _convert_env_value(self, value: str) -> Any: """Convert environment variable string to appropriate type.""" # Boolean conversion if value.lower() in ('true', 'false'): return value.lower() == 'true' # List conversion (comma-separated) if ',' in value: try: return [float(x.strip()) for x in value.split(',')] except ValueError: return [x.strip() for x in value.split(',')] # Numeric conversion try: if '.' in value: return float(value) else: return int(value) except ValueError: pass # String value return value def _deep_merge(self, base: Dict[str, Any], override: Dict[str, Any]) -> Dict[str, Any]: """Deep merge two dictionaries.""" result = base.copy() for key, value in override.items(): if key in result and isinstance(result[key], dict) and isinstance(value, dict): result[key] = self._deep_merge(result[key], value) else: result[key] = value return result def _config_to_dict(self, config: Any) -> Dict[str, Any]: """Convert configuration object to dictionary.""" if hasattr(config, 'model_dump'): return config.model_dump() elif hasattr(config, '__dict__'): return vars(config) else: return config def _dict_to_config(self, config_dict: Dict[str, Any]) -> Any: """Convert dictionary back to configuration object.""" # Create a simple namespace object class ConfigNamespace: def __init__(self, **kwargs): for key, value in kwargs.items(): if isinstance(value, dict): setattr(self, key, ConfigNamespace(**value)) else: setattr(self, key, value) return ConfigNamespace(**config_dict) # Usage
env_manager = EnvironmentConfigurationManager() # Set environment
os.environ['DIP_ENV'] = 'production'
os.environ['DIP_PSO_N_PARTICLES'] = '40'
os.environ['DIP_CONTROLLER_CLASSICAL_GAINS'] = '22,16,14,9,38,5.5' # Get merged configuration
config = env_manager.get_merged_config() # Use with factory
controller = create_controller('classical_smc', config=config)
``` ### Configuration Templating System ```python
from jinja2 import Template
import yaml
from typing import Dict, Any class ConfigurationTemplateManager: """Manage configuration templates with parameter substitution.""" def __init__(self): self.templates = self._load_templates() self.parameter_sets = self._load_parameter_sets() def _load_templates(self) -> Dict[str, Template]: """Load configuration templates.""" templates = {} # Base controller template templates['controller_template'] = Template("""
controllers: {{ controller_type }}: gains: {{ gains }} max_force: {{ max_force | default(150.0) }} dt: {{ dt | default(0.001) }} {% if controller_type == 'classical_smc' %} boundary_layer: {{ boundary_layer | default(0.02) }} switch_method: "{{ switch_method | default('tanh') }}" {% elif controller_type == 'adaptive_smc' %} leak_rate: {{ leak_rate | default(0.01) }} dead_zone: {{ dead_zone | default(0.05) }} K_min: {{ K_min | default(0.1) }} K_max: {{ K_max | default(100.0) }} {% elif controller_type == 'sta_smc' %} power_exponent: {{ power_exponent | default(0.5) }} regularization: {{ regularization | default(1e-6) }} {% endif %} """) # PSO template templates['pso_template'] = Template("""
pso: n_particles: {{ n_particles | default(30) }} max_iter: {{ max_iter | default(100) }} w: {{ inertia_weight | default(0.9) }} c1: {{ cognitive_coeff | default(2.0) }} c2: {{ social_coeff | default(2.0) }} bounds: {{ controller_type }}: lower: {{ lower_bounds }} upper: {{ upper_bounds }} """) # Complete system template templates['system_template'] = Template("""
# Generated configuration for {{ system_name }}
global_seed: {{ seed | default(42) }} physics: m1: {{ physics.m1 | default(0.5) }} m2: {{ physics.m2 | default(0.5) }} M: {{ physics.M | default(2.0) }} l1: {{ physics.l1 | default(0.5) }} l2: {{ physics.l2 | default(0.5) }} b1: {{ physics.b1 | default(0.1) }} b2: {{ physics.b2 | default(0.1) }} I1: {{ physics.I1 | default(0.1) }} I2: {{ physics.I2 | default(0.1) }} simulation: duration: {{ simulation.duration | default(5.0) }} dt: {{ simulation.dt | default(0.001) }} initial_state: {{ simulation.initial_state | default([0.1, 0.05, 0.0, 0.0, 0.0, 0.0]) }} use_full_dynamics: {{ simulation.use_full_dynamics | default(false) }} {{ controller_config }} {{ pso_config }} cost_function: weights: ise: {{ cost_weights.ise | default(0.4) }} control_effort: {{ cost_weights.control_effort | default(0.3) }} settling_time: {{ cost_weights.settling_time | default(0.2) }} overshoot: {{ cost_weights.overshoot | default(0.1) }} """) return templates def _load_parameter_sets(self) -> Dict[str, Dict[str, Any]]: """Load predefined parameter sets.""" return { 'conservative': { 'gains': { 'classical_smc': [15, 10, 8, 5, 25, 3], 'adaptive_smc': [18, 12, 10, 6, 2.5], 'sta_smc': [20, 12, 15, 8, 6, 4] }, 'max_force': 100.0, 'boundary_layer': 0.03, 'pso': {'n_particles': 20, 'max_iter': 50} }, 'aggressive': { 'gains': { 'classical_smc': [30, 25, 20, 15, 60, 8], 'adaptive_smc': [35, 28, 22, 18, 8.0], 'sta_smc': [40, 25, 30, 20, 15, 10] }, 'max_force': 200.0, 'boundary_layer': 0.01, 'pso': {'n_particles': 50, 'max_iter': 150} }, 'research': { 'gains': { 'classical_smc': [20, 15, 12, 8, 35, 5], 'adaptive_smc': [25, 18, 15, 10, 4], 'sta_smc': [25, 15, 20, 12, 8, 6] }, 'max_force': 150.0, 'boundary_layer': 0.02, 'pso': {'n_particles': 40, 'max_iter': 100} } } def generate_configuration(self, controller_type: str, parameter_set: str = 'research', custom_params: Optional[Dict[str, Any]] = None, output_file: Optional[str] = None) -> str: """Generate configuration from template.""" # Get base parameters base_params = self.parameter_sets.get(parameter_set, self.parameter_sets['research']) # Merge with custom parameters if custom_params: params = self._deep_merge(base_params, custom_params) else: params = base_params # Get controller-specific gains controller_gains = params['gains'].get(controller_type, [20, 15, 12, 8, 35, 5]) # Generate controller configuration controller_template_params = { 'controller_type': controller_type, 'gains': controller_gains, 'max_force': params.get('max_force', 150.0), 'boundary_layer': params.get('boundary_layer', 0.02) } controller_config = self.templates['controller_template'].render(**controller_template_params) # Generate PSO configuration from src.controllers.factory import get_gain_bounds_for_pso, SMCType try: smc_type = getattr(SMCType, controller_type.upper().replace('_SMC', '')) lower_bounds, upper_bounds = get_gain_bounds_for_pso(smc_type) except: lower_bounds = [1.0] * len(controller_gains) upper_bounds = [50.0] * len(controller_gains) pso_template_params = { 'controller_type': controller_type, 'n_particles': params.get('pso', {}).get('n_particles', 30), 'max_iter': params.get('pso', {}).get('max_iter', 100), 'lower_bounds': lower_bounds, 'upper_bounds': upper_bounds } pso_config = self.templates['pso_template'].render(**pso_template_params) # Generate complete system configuration system_template_params = { 'system_name': f"{controller_type.upper()} Control System", 'controller_config': controller_config, 'pso_config': pso_config, 'physics': params.get('physics', {}), 'simulation': params.get('simulation', {}), 'cost_weights': params.get('cost_weights', {}) } system_config = self.templates['system_template'].render(**system_template_params) # Save to file if requested if output_file: with open(output_file, 'w') as f: f.write(system_config) return system_config def _deep_merge(self, base: Dict[str, Any], override: Dict[str, Any]) -> Dict[str, Any]: """Deep merge dictionaries.""" result = base.copy() for key, value in override.items(): if key in result and isinstance(result[key], dict) and isinstance(value, dict): result[key] = self._deep_merge(result[key], value) else: result[key] = value return result # Usage
template_manager = ConfigurationTemplateManager() # Generate conservative classical SMC configuration
config_yaml = template_manager.generate_configuration( controller_type='classical_smc', parameter_set='conservative', custom_params={ 'physics': {'m1': 0.6, 'm2': 0.4}, 'simulation': {'duration': 3.0} }, output_file='conservative_classical_config.yaml'
) print("Generated configuration:")
print(config_yaml)
``` --- ## Migration and Deprecation Handling ### Automatic Parameter Migration ```python
# example-metadata:
# runnable: false class ConfigurationMigrationManager: """Handle configuration parameter migrations and deprecations.""" def __init__(self): self.migration_rules = self._initialize_migration_rules() self.deprecation_warnings = [] def _initialize_migration_rules(self) -> Dict[str, Dict[str, Any]]: """Initialize parameter migration rules.""" return { # Version 1.0 -> 2.0 migrations 'v1_to_v2': { 'parameter_mappings': { 'use_equivalent': 'enable_equivalent_control', 'k_gain': 'switching_gain', 'lambda_gains': 'surface_gains', 'sat_limit': 'max_force', 'dt_control': 'dt', 'boundary_thickness': 'boundary_layer' }, 'structure_changes': { 'controllers': { 'old_path': 'smc_configs', 'new_path': 'controllers' } }, 'value_transformations': { 'switching_gain': lambda x: max(x, 5.0), # Ensure minimum value 'boundary_layer': lambda x: min(x, 0.1) # Ensure maximum value } }, # Version 2.0 -> 3.0 migrations 'v2_to_v3': { 'parameter_mappings': { 'smc_classical': 'classical_smc', 'smc_adaptive': 'adaptive_smc', 'smc_sta': 'sta_smc' }, 'new_required_parameters': { 'classical_smc': { 'switch_method': 'tanh', 'regularization': 1e-10 }, 'adaptive_smc': { 'smooth_switch': True, 'alpha': 0.5 } } } } def migrate_configuration(self, config: Dict[str, Any], from_version: str = 'v1', to_version: str = 'v3') -> Dict[str, Any]: """Migrate configuration between versions.""" self.deprecation_warnings.clear() migrated_config = config.copy() # Apply migrations in sequence if from_version == 'v1' and to_version in ['v2', 'v3']: migrated_config = self._apply_migration(migrated_config, 'v1_to_v2') if (from_version in ['v1', 'v2']) and to_version == 'v3': migrated_config = self._apply_migration(migrated_config, 'v2_to_v3') return migrated_config def _apply_migration(self, config: Dict[str, Any], migration_key: str) -> Dict[str, Any]: """Apply specific migration rules.""" rules = self.migration_rules[migration_key] migrated = config.copy() # Apply parameter mappings if 'parameter_mappings' in rules: migrated = self._apply_parameter_mappings(migrated, rules['parameter_mappings']) # Apply structure changes if 'structure_changes' in rules: migrated = self._apply_structure_changes(migrated, rules['structure_changes']) # Apply value transformations if 'value_transformations' in rules: migrated = self._apply_value_transformations(migrated, rules['value_transformations']) # Add new required parameters if 'new_required_parameters' in rules: migrated = self._add_required_parameters(migrated, rules['new_required_parameters']) return migrated def _apply_parameter_mappings(self, config: Dict[str, Any], mappings: Dict[str, str]) -> Dict[str, Any]: """Apply parameter name mappings.""" migrated = config.copy() def migrate_nested(obj, path=""): if isinstance(obj, dict): new_obj = {} for key, value in obj.items(): current_path = f"{path}.{key}" if path else key if key in mappings: new_key = mappings[key] new_obj[new_key] = migrate_nested(value, f"{path}.{new_key}" if path else new_key) self.deprecation_warnings.append( f"Parameter '{key}' deprecated, migrated to '{new_key}'" ) else: new_obj[key] = migrate_nested(value, current_path) return new_obj else: return obj return migrate_nested(migrated) def _apply_structure_changes(self, config: Dict[str, Any], changes: Dict[str, Dict[str, str]]) -> Dict[str, Any]: """Apply structural changes to configuration.""" migrated = config.copy() for change_name, change_rule in changes.items(): old_path = change_rule['old_path'] new_path = change_rule['new_path'] if old_path in migrated: # Move data from old path to new path migrated[new_path] = migrated.pop(old_path) self.deprecation_warnings.append( f"Configuration section '{old_path}' moved to '{new_path}'" ) return migrated def _apply_value_transformations(self, config: Dict[str, Any], transformations: Dict[str, callable]) -> Dict[str, Any]: """Apply value transformations.""" def transform_nested(obj): if isinstance(obj, dict): new_obj = {} for key, value in obj.items(): if key in transformations: try: new_obj[key] = transformations[key](value) self.deprecation_warnings.append( f"Value transformation applied to '{key}'" ) except Exception as e: new_obj[key] = value self.deprecation_warnings.append( f"Value transformation failed for '{key}': {e}" ) else: new_obj[key] = transform_nested(value) return new_obj else: return obj return transform_nested(config) def _add_required_parameters(self, config: Dict[str, Any], required_params: Dict[str, Dict[str, Any]]) -> Dict[str, Any]: """Add new required parameters with default values.""" migrated = config.copy() # Ensure controllers section exists if 'controllers' not in migrated: migrated['controllers'] = {} for controller_type, params in required_params.items(): if controller_type not in migrated['controllers']: migrated['controllers'][controller_type] = {} controller_config = migrated['controllers'][controller_type] for param_name, default_value in params.items(): if param_name not in controller_config: controller_config[param_name] = default_value self.deprecation_warnings.append( f"Added required parameter '{param_name}' to {controller_type}" ) return migrated def check_deprecated_config(self, controller_type: str, params: Dict[str, Any]) -> Dict[str, Any]: """Check for and handle deprecated parameters.""" # Current deprecation mappings current_deprecations = { 'use_equivalent': 'enable_equivalent_control', 'k_gain': 'switching_gain', 'lambda_gains': 'surface_gains', 'sat_limit': 'max_force', 'boundary_thickness': 'boundary_layer' } migrated_params = params.copy() for old_param, new_param in current_deprecations.items(): if old_param in migrated_params: migrated_params[new_param] = migrated_params.pop(old_param) self.deprecation_warnings.append( f"Parameter '{old_param}' is deprecated. Use '{new_param}' instead." ) return migrated_params def get_deprecation_warnings(self) -> List[str]: """Get list of deprecation warnings.""" return self.deprecation_warnings.copy() # Usage
migration_manager = ConfigurationMigrationManager() # Migrate old configuration
old_config = { 'smc_configs': { 'smc_classical': { 'k_gain': 35.0, 'lambda_gains': [12.0, 8.0], 'sat_limit': 150.0, 'boundary_thickness': 0.02 } }
} migrated_config = migration_manager.migrate_configuration( old_config, from_version='v1', to_version='v3'
) print("Migrated configuration:")
print(yaml.dump(migrated_config, default_flow_style=False)) print("\nDeprecation warnings:")
for warning in migration_manager.get_deprecation_warnings(): print(f" ⚠️ {warning}")
``` --- ## Best Practices ### Configuration Best Practices Summary 1. **Type Safety First** ```python # ✅ Good: Use type-safe configuration classes @dataclass(frozen=True) class ControllerConfig: gains: List[float] max_force: float # ❌ Bad: Untyped dictionary configurations config = {'gains': 'should be list', 'max_force': 'not a number'} ``` 2. **Validation at All Levels** ```python # ✅ Good: Multi-level validation def validate_config(config): # 1. Type validation assert isinstance(config.gains, list) # 2. Domain validation assert all(g > 0 for g in config.gains) # 3. Physics validation assert config.max_force > max(config.gains) ``` 3. **Clear Priority Rules** ```python # ✅ Good: Explicit priority handling gains = ( explicit_gains or # Priority 1 config_gains or # Priority 2 registry_defaults # Priority 3 ) ``` 4. **Graceful Degradation** ```python # ✅ Good: Fallback mechanisms try: config = create_full_config(**params) except ConfigError: config = create_minimal_config(**essential_params) ``` 5. **Documentation and Examples** ```yaml # ✅ Good: Well-documented configuration controllers: classical_smc: # Gains: [k1, k2, λ1, λ2, K, kd] # k1, k2: Position feedback gains (affects settling time) # λ1, λ2: Surface coefficients (must be positive for stability) # K: Switching gain (higher values reduce steady-state error but increase chattering) # kd: Derivative gain (improves damping) gains: [20.0, 15.0, 12.0, 8.0, 35.0, 5.0] ``` --- ## Examples and Use Cases ### Complete Configuration Integration Example ```python
#!/usr/bin/env python3
"""Complete configuration integration example.""" import yaml
from pathlib import Path
from typing import Dict, Any, Optional class ComprehensiveConfigurationExample: """Demonstrate configuration integration.""" def __init__(self): self.config_manager = self._setup_configuration_manager() def _setup_configuration_manager(self): """Setup configuration management system.""" class ConfigManager: def __init__(self): self.base_config = self._load_base_config() self.validator = ConfigurationValidator() self.migrator = ConfigurationMigrationManager() def _load_base_config(self): """Load base configuration.""" config_path = Path("config.yaml") if config_path.exists(): from src.config import load_config return load_config(config_path) else: return self._create_default_config() def _create_default_config(self): """Create default configuration.""" return { 'physics': { 'm1': 0.5, 'm2': 0.5, 'M': 2.0, 'l1': 0.5, 'l2': 0.5, 'b1': 0.1, 'b2': 0.1, 'I1': 0.1, 'I2': 0.1 }, 'simulation': { 'duration': 5.0, 'dt': 0.001, 'initial_state': [0.1, 0.05, 0.0, 0.0, 0.0, 0.0] }, 'controllers': { 'classical_smc': { 'gains': [20.0, 15.0, 12.0, 8.0, 35.0, 5.0], 'max_force': 150.0, 'boundary_layer': 0.02, 'dt': 0.001 } } } def get_controller_config(self, controller_type: str, **overrides) -> Dict[str, Any]: """Get validated controller configuration.""" # Get base configuration base_controller_config = self.base_config['controllers'].get(controller_type, {}) # Apply overrides controller_config = {**base_controller_config, **overrides} # Migrate deprecated parameters controller_config = self.migrator.check_deprecated_config( controller_type, controller_config ) # Validate configuration if not self.validator.validate_configuration(controller_type, controller_config): report = self.validator.get_validation_report() raise ValueError(f"Configuration validation failed: {report['errors']}") return controller_config return ConfigManager() def demonstration_1_basic_usage(self): """Demonstrate basic configuration usage.""" print("=== Demonstration 1: Basic Configuration Usage ===") # Get configuration for different controllers for controller_type in ['classical_smc', 'adaptive_smc', 'sta_smc']: try: config = self.config_manager.get_controller_config(controller_type) print(f"\n{controller_type.upper()} Configuration:") print(f" Gains: {config.get('gains', 'Not specified')}") print(f" Max Force: {config.get('max_force', 'Not specified')}") print(f" Timestep: {config.get('dt', 'Not specified')}") # Create controller with configuration controller = create_controller(controller_type, **config) print(f" ✅ Controller created successfully") except Exception as e: print(f" ❌ Failed to create {controller_type}: {e}") def demonstration_2_parameter_override(self): """Demonstrate parameter override patterns.""" print("\n=== Demonstration 2: Parameter Override Patterns ===") # Original configuration print("Original gains:", self.config_manager.base_config['controllers']['classical_smc']['gains']) # Override with explicit parameters config = self.config_manager.get_controller_config( 'classical_smc', gains=[25, 20, 15, 10, 40, 6], max_force=160.0 ) print("Overridden gains:", config['gains']) print("Overridden max_force:", config['max_force']) # Create controller with overrides controller = create_controller('classical_smc', **config) print("✅ Controller created with overrides") def demonstration_3_validation_and_migration(self): """Demonstrate validation and migration features.""" print("\n=== Demonstration 3: Validation and Migration ===") # Test deprecated parameter migration old_config = { 'k_gain': 35.0, # Deprecated 'lambda_gains': [12.0, 8.0], # Deprecated 'sat_limit': 150.0, # Deprecated 'boundary_thickness': 0.02, # Deprecated 'dt': 0.001 } print("Old configuration (with deprecated parameters):") for key, value in old_config.items(): print(f" {key}: {value}") # Apply migration migrated_config = self.config_manager.migrator.check_deprecated_config( 'classical_smc', old_config ) print("\nMigrated configuration:") for key, value in migrated_config.items(): print(f" {key}: {value}") print("\nMigration warnings:") for warning in self.config_manager.migrator.get_deprecation_warnings(): print(f" ⚠️ {warning}") def demonstration_4_environment_configuration(self): """Demonstrate environment-based configuration.""" print("\n=== Demonstration 4: Environment Configuration ===") # Simulate different environments environments = ['development', 'testing', 'production'] for env in environments: print(f"\nEnvironment: {env}") # Environment-specific overrides env_overrides = { 'development': {'gains': [15, 10, 8, 5, 25, 3]}, # Conservative 'testing': {'gains': [20, 15, 12, 8, 35, 5]}, # Standard 'production': {'gains': [25, 20, 15, 10, 45, 7]} # Aggressive } config = self.config_manager.get_controller_config( 'classical_smc', **env_overrides.get(env, {}) ) print(f" Gains: {config['gains']}") # Validate for specific environment validator = ConfigurationValidator() is_valid = validator.validate_configuration('classical_smc', config) if is_valid: print(f" ✅ Configuration valid for {env}") else: print(f" ❌ Configuration invalid for {env}") for error in validator.get_validation_report()['errors']: print(f" Error: {error}") def demonstration_5_pso_integration(self): """Demonstrate PSO integration with configuration.""" print("\n=== Demonstration 5: PSO Integration ===") # Create PSO-optimized configuration base_config = self.config_manager.get_controller_config('classical_smc') print("Base configuration for PSO:") print(f" Initial gains: {base_config['gains']}") # Create PSO factory with configuration from src.controllers.factory import create_pso_controller_factory, SMCType factory = create_pso_controller_factory( SMCType.CLASSICAL, **{k: v for k, v in base_config.items() if k != 'gains'} ) print(f" PSO factory created: {factory.n_gains} gains required") # Simulate PSO optimization import numpy as np # Generate random gain variations base_gains = np.array(base_config['gains']) for i in range(3): # Add random variation variation = 0.1 * np.random.randn(len(base_gains)) test_gains = base_gains * (1 + variation) test_gains = np.clip(test_gains, 0.1, 100.0) # Keep positive print(f"\n PSO Iteration {i+1}:") print(f" Test gains: {test_gains.tolist()}") try: controller = factory(test_gains) print(f" ✅ Controller created successfully") # Simulate fitness evaluation fitness = np.sum(test_gains**2) # Simple fitness function print(f" Fitness: {fitness:.2f}") except Exception as e: print(f" ❌ Controller creation failed: {e}") def run_all_demonstrations(self): """Run all configuration demonstrations.""" print("Configuration Integration Demonstrations") print("=" * 50) try: self.demonstration_1_basic_usage() self.demonstration_2_parameter_override() self.demonstration_3_validation_and_migration() self.demonstration_4_environment_configuration() self.demonstration_5_pso_integration() print("\n" + "=" * 50) print("All demonstrations completed successfully!") except Exception as e: print(f"\nDemonstration failed: {e}") import traceback traceback.print_exc() # Run demonstrations
if __name__ == "__main__": demo = ComprehensiveConfigurationExample() demo.run_all_demonstrations()
``` --- This configuration integration documentation provides complete coverage of the configuration system, from basic usage patterns to advanced scenarios like environment-based configuration and automated migration. The documentation ensures that developers can effectively use the sophisticated configuration architecture while maintaining type safety, validation, and backward compatibility.