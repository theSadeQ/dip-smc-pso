# Testing and Validation Documentation ## Overview This document provides testing and validation strategies for the SMC Controller Factory system. The testing framework ensures robust operation, factory integration quality, and performance validation to support the GitHub Issue #6 resolution with 95%+ test coverage and enterprise-grade quality assurance. ## Testing Architecture ### Multi-Level Testing Strategy ```
┌─────────────────────────────────────────────────────────────────┐
│ TESTING PYRAMID │
├─────────────────────────────────────────────────────────────────┤
│ E2E Tests │ Complete Workflow Validation │
│ (Integration) │ - PSO optimization workflows │
│ │ - Real-time HIL simulation │
├─────────────────────────────────────────────────────────────────┤
│ Integration Tests │ Component Integration Validation │
│ (System) │ - Factory-Controller integration │
│ │ - Controller-Plant compatibility │
│ │ - Multi-threading safety │
├─────────────────────────────────────────────────────────────────┤
│ Unit Tests │ Individual Component Testing │
│ (Component) │ - Parameter validation │
│ │ - Configuration resolution │
│ │ - Error handling │
├─────────────────────────────────────────────────────────────────┤
│ Property Tests │ Mathematical Property Validation │
│ (Behavior) │ - Control law stability │
│ │ - Gain parameter constraints │
│ │ - Convergence properties │
└─────────────────────────────────────────────────────────────────┘
``` ### Test Suite Organization ```
tests/
├── test_controllers/
│ ├── factory/
│ │ ├── test_controller_factory.py # Factory creation tests
│ │ ├── test_parameter_validation.py # Parameter validation tests
│ │ ├── test_deprecation_handling.py # Deprecation system tests
│ │ ├── test_thread_safety.py # Concurrency tests
│ │ └── test_pso_integration.py # PSO workflow tests
│ ├── integration/
│ │ ├── test_factory_plant_integration.py # Plant model integration
│ │ ├── test_controller_performance.py # Performance validation
│ │ └── test_robustness_analysis.py # Robustness testing
│ └── property_based/
│ ├── test_stability_properties.py # Mathematical properties
│ ├── test_gain_constraints.py # Parameter constraint validation
│ └── test_convergence_analysis.py # Convergence behavior tests
├── benchmarks/
│ ├── test_factory_performance.py # Performance benchmarking
│ ├── test_memory_efficiency.py # Memory usage validation
│ └── test_real_time_constraints.py # Real-time performance
└── fixtures/ ├── plant_configurations.py # Test plant configurations ├── controller_test_data.py # Test controller parameters └── validation_scenarios.py # Standard test scenarios
``` ## Unit Testing Framework ### Factory Creation and Configuration Tests ```python
import pytest
import numpy as np
from unittest.mock import Mock, patch
from typing import Dict, Any, List from src.controllers.factory import ( create_controller, SMCFactory, SMCType, SMCConfig, _resolve_controller_gains, _validate_controller_gains, _extract_controller_parameters, CONTROLLER_REGISTRY
) class TestControllerFactoryCore: """Core factory functionality testing.""" def setup_method(self): """Setup test fixtures for each test method.""" self.plant_config = self._create_test_plant_config() self.valid_gain_sets = { 'classical_smc': [20.0, 15.0, 12.0, 8.0, 35.0, 5.0], 'adaptive_smc': [25.0, 18.0, 15.0, 10.0, 4.0], 'sta_smc': [35.0, 20.0, 25.0, 18.0, 12.0, 8.0], 'hybrid_adaptive_sta_smc': [18.0, 12.0, 10.0, 8.0] } def _create_test_plant_config(self) -> Any: """Create standardized test plant configuration.""" from src.plant.configurations import ConfigurationFactory return ConfigurationFactory.create_default_config("simplified") @pytest.mark.parametrize("controller_type,expected_gains", [ ('classical_smc', 6), ('adaptive_smc', 5), ('sta_smc', 6), ('hybrid_adaptive_sta_smc', 4) ]) def test_controller_creation_success(self, controller_type: str, expected_gains: int): """Test successful controller creation for all types.""" gains = self.valid_gain_sets[controller_type] controller = create_controller( controller_type=controller_type, config=self.plant_config, gains=gains ) assert controller is not None assert hasattr(controller, 'compute_control') assert hasattr(controller, 'gains') assert len(controller.gains) == expected_gains def test_controller_registry_completeness(self): """Test that controller registry is complete and well-formed.""" required_keys = [ 'class', 'config_class', 'default_gains', 'gain_count', 'description', 'supports_dynamics', 'required_params' ] for controller_type, info in CONTROLLER_REGISTRY.items(): for key in required_keys: assert key in info, f"Missing key '{key}' in registry for {controller_type}" # Validate default gains structure assert len(info['default_gains']) == info['gain_count'] assert all(isinstance(g, (int, float)) for g in info['default_gains']) assert all(g > 0 for g in info['default_gains']) def test_parameter_resolution_hierarchy(self): """Test parameter resolution follows correct hierarchy.""" controller_type = 'classical_smc' controller_info = CONTROLLER_REGISTRY[controller_type] # Test 1: Explicit gains take priority explicit_gains = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0] resolved_gains = _resolve_controller_gains( gains=explicit_gains, config=None, controller_type=controller_type, controller_info=controller_info ) assert resolved_gains == explicit_gains # Test 2: Config gains when no explicit gains config_mock = Mock() config_mock.controllers = { controller_type: {'gains': [7.0, 8.0, 9.0, 10.0, 11.0, 12.0]} } resolved_gains = _resolve_controller_gains( gains=None, config=config_mock, controller_type=controller_type, controller_info=controller_info ) assert resolved_gains == [7.0, 8.0, 9.0, 10.0, 11.0, 12.0] # Test 3: Default gains as fallback resolved_gains = _resolve_controller_gains( gains=None, config=None, controller_type=controller_type, controller_info=controller_info ) assert resolved_gains == controller_info['default_gains'] @pytest.mark.parametrize("invalid_gains,expected_error", [ ([], ValueError), # Empty gains ([1.0, 2.0], ValueError), # Too few gains ([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0], ValueError), # Too many gains ([np.nan, 2.0, 3.0, 4.0, 5.0, 6.0], ValueError), # NaN gain ([np.inf, 2.0, 3.0, 4.0, 5.0, 6.0], ValueError), # Infinite gain ([-1.0, 2.0, 3.0, 4.0, 5.0, 6.0], ValueError), # Negative gain ([0.0, 2.0, 3.0, 4.0, 5.0, 6.0], ValueError), # Zero gain (['a', 2.0, 3.0, 4.0, 5.0, 6.0], ValueError), # Non-numeric gain ]) def test_gain_validation_errors(self, invalid_gains: List, expected_error: type): """Test gain validation properly catches invalid inputs.""" controller_info = CONTROLLER_REGISTRY['classical_smc'] with pytest.raises(expected_error): _validate_controller_gains(invalid_gains, controller_info) def test_configuration_parameter_extraction(self): """Test configuration parameter extraction from various formats.""" # Test with Pydantic-like config pydantic_config = Mock() pydantic_config.controllers = { 'classical_smc': Mock() } pydantic_config.controllers['classical_smc'].model_dump.return_value = { 'gains': [1.0, 2.0, 3.0, 4.0, 5.0, 6.0], 'max_force': 100.0, 'boundary_layer': 0.02 } params = _extract_controller_parameters( pydantic_config, 'classical_smc', CONTROLLER_REGISTRY['classical_smc'] ) assert 'gains' in params assert 'max_force' in params assert 'boundary_layer' in params # Test with dictionary config dict_config = Mock() dict_config.controllers = { 'classical_smc': { 'gains': [7.0, 8.0, 9.0, 10.0, 11.0, 12.0], 'max_force': 150.0 } } params = _extract_controller_parameters( dict_config, 'classical_smc', CONTROLLER_REGISTRY['classical_smc'] ) assert params['gains'] == [7.0, 8.0, 9.0, 10.0, 11.0, 12.0] assert params['max_force'] == 150.0 def test_thread_safety_basic(self): """Test basic thread safety of factory operations.""" import threading import time results = [] errors = [] def create_controller_threaded(thread_id: int): try: for i in range(5): gains = [10.0 + thread_id, 5.0, 8.0, 3.0, 15.0, 2.0] controller = create_controller( 'classical_smc', self.plant_config, gains ) assert controller is not None time.sleep(0.001) # Small delay to increase contention results.append(True) except Exception as e: errors.append(f"Thread {thread_id}: {str(e)}") results.append(False) # Create and run multiple threads threads = [] for i in range(3): thread = threading.Thread(target=create_controller_threaded, args=(i,)) threads.append(thread) thread.start() # Wait for completion for thread in threads: thread.join(timeout=10.0) # Verify results assert not errors, f"Thread safety errors: {errors}" assert all(results), "Some threads failed" def test_error_recovery_mechanisms(self): """Test error recovery and graceful degradation.""" # Test with invalid config that should trigger fallback invalid_config = Mock() invalid_config.controllers = None # This should cause extraction to fail # Should still create controller using default parameters controller = create_controller( 'classical_smc', invalid_config, [10.0, 5.0, 8.0, 3.0, 15.0, 2.0] ) assert controller is not None def test_memory_usage_validation(self): """Test that factory doesn't leak memory during intensive use.""" import gc import weakref # Create many controllers and track weak references weak_refs = [] for i in range(20): gains = [10.0 + i, 5.0, 8.0, 3.0, 15.0, 2.0] controller = create_controller( 'classical_smc', self.plant_config, gains ) weak_refs.append(weakref.ref(controller)) del controller # Force garbage collection gc.collect() # Check that controllers were properly cleaned up alive_refs = [ref for ref in weak_refs if ref() is not None] assert len(alive_refs) <= 3, f"Memory leak detected: {len(alive_refs)} controllers still alive"
``` ### Parameter Validation Testing ```python
class TestParameterValidation: """parameter validation testing.""" def setup_method(self): """Setup validation test environment.""" self.validator = ParameterValidator() @pytest.mark.parametrize("controller_type,valid_gains", [ ('classical_smc', [20.0, 15.0, 12.0, 8.0, 35.0, 5.0]), ('adaptive_smc', [25.0, 18.0, 15.0, 10.0, 4.0]), ('sta_smc', [35.0, 20.0, 25.0, 18.0, 12.0, 8.0]), ('hybrid_adaptive_sta_smc', [18.0, 12.0, 10.0, 8.0]) ]) def test_valid_gain_validation(self, controller_type: str, valid_gains: List[float]): """Test validation passes for valid gain configurations.""" controller_info = CONTROLLER_REGISTRY[controller_type] # Should not raise any exceptions _validate_controller_gains(valid_gains, controller_info) # Test with numpy array input _validate_controller_gains(np.array(valid_gains), controller_info) def test_adaptive_smc_gamma_validation(self): """Test specific validation for adaptive SMC gamma parameter.""" # Valid gamma values valid_configs = [ [10.0, 5.0, 8.0, 3.0, 2.0], # Normal gamma [10.0, 5.0, 8.0, 3.0, 0.5], # Low gamma [10.0, 5.0, 8.0, 3.0, 8.0], # High gamma ] for gains in valid_configs: controller_info = CONTROLLER_REGISTRY['adaptive_smc'] _validate_controller_gains(gains, controller_info) # Invalid gamma values should trigger warnings but not errors # (Warnings are handled at higher level) extreme_gamma_gains = [10.0, 5.0, 8.0, 3.0, 15.0] # Very high gamma controller_info = CONTROLLER_REGISTRY['adaptive_smc'] _validate_controller_gains(extreme_gamma_gains, controller_info) def test_super_twisting_k1_k2_relationship(self): """Test STA-SMC K1/K2 relationship validation.""" # Optimal relationship: K1 > K2 optimal_gains = [35.0, 20.0, 25.0, 18.0, 12.0, 8.0] # K1=35 > K2=20 controller_info = CONTROLLER_REGISTRY['sta_smc'] _validate_controller_gains(optimal_gains, controller_info) # Suboptimal but valid: K1 <= K2 (should warn but not fail) suboptimal_gains = [20.0, 25.0, 25.0, 18.0, 12.0, 8.0] # K1=20 < K2=25 _validate_controller_gains(suboptimal_gains, controller_info) def test_parameter_bounds_validation(self): """Test parameter bounds checking.""" from src.controllers.factory.smc_factory import validate_parameter_ranges # Test within bounds controller_type = 'classical_smc' gains = [20.0, 15.0, 12.0, 8.0, 35.0, 5.0] bounds = [(5.0, 50.0), (5.0, 40.0), (3.0, 30.0), (3.0, 25.0), (10.0, 80.0), (1.0, 15.0)] # Should not raise exception validate_parameter_ranges(gains, controller_type, bounds) # Test outside bounds out_of_bounds_gains = [100.0, 15.0, 12.0, 8.0, 35.0, 5.0] # First gain too high with pytest.raises(ValueError): validate_parameter_ranges(out_of_bounds_gains, controller_type, bounds) def test_configuration_migration_validation(self): """Test validation of migrated configurations.""" # Test deprecated parameter handling deprecated_config = { 'gains': [10.0, 5.0, 8.0, 3.0, 15.0, 2.0], 'max_force': 100.0, 'gamma': 0.1, # Should be deprecated for classical_smc } # Should handle gracefully without crashing from src.controllers.factory.deprecation import check_deprecated_config migrated_config = check_deprecated_config('classical_smc', deprecated_config) # Gamma should be removed for classical_smc assert 'gamma' not in migrated_config def test_hybrid_smc_sub_configuration_validation(self): """Test validation of hybrid SMC sub-configurations.""" # Create valid sub-configurations from src.controllers.smc.algorithms.classical.config import ClassicalSMCConfig from src.controllers.smc.algorithms.adaptive.config import AdaptiveSMCConfig classical_config = ClassicalSMCConfig( gains=[20.0, 15.0, 12.0, 8.0, 35.0, 5.0], max_force=150.0, dt=0.001, boundary_layer=0.02 ) adaptive_config = AdaptiveSMCConfig( gains=[25.0, 18.0, 15.0, 10.0, 4.0], max_force=150.0, dt=0.001 ) # Test hybrid controller creation with sub-configs controller = create_controller( 'hybrid_adaptive_sta_smc', config={ 'classical_config': classical_config, 'adaptive_config': adaptive_config }, gains=[18.0, 12.0, 10.0, 8.0] ) assert controller is not None
``` ## Integration Testing Framework ### Factory-Plant Integration Tests ```python
class TestFactoryPlantIntegration: """Test integration between factory and plant models.""" def setup_method(self): """Setup integration test environment.""" from src.plant.configurations import ConfigurationFactory self.plant_configs = { 'simplified': ConfigurationFactory.create_default_config("simplified"), 'full': ConfigurationFactory.create_default_config("full") if hasattr(ConfigurationFactory, 'create_default_config') else None } self.test_scenarios = { 'equilibrium': np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0]), 'small_disturbance': np.array([0.1, 0.05, 0.03, 0.0, 0.0, 0.0]), 'large_angles': np.array([0.5, 0.8, 0.6, 0.2, 0.1, 0.15]) } @pytest.mark.parametrize("plant_type", ['simplified']) @pytest.mark.parametrize("controller_type,gains", [ ('classical_smc', [20.0, 15.0, 12.0, 8.0, 35.0, 5.0]), ('adaptive_smc', [25.0, 18.0, 15.0, 10.0, 4.0]), ]) def test_controller_plant_compatibility( self, plant_type: str, controller_type: str, gains: List[float] ): """Test controller-plant compatibility across configurations.""" plant_config = self.plant_configs[plant_type] if plant_config is None: pytest.skip(f"Plant config {plant_type} not available") # Create controller controller = create_controller(controller_type, plant_config, gains) # Test control computation for all scenarios for scenario_name, state in self.test_scenarios.items(): control_output = controller.compute_control(state, (), {}) assert control_output is not None assert hasattr(control_output, 'u') # Validate control output control_value = control_output.u assert isinstance(control_value, (int, float, np.ndarray)) assert np.isfinite(control_value) def test_closed_loop_simulation(self): """Test closed-loop simulation with factory-created controllers.""" from src.plant.models.simplified.dynamics import SimplifiedDIPDynamics plant_config = self.plant_configs['simplified'] dynamics = SimplifiedDIPDynamics(plant_config) controller = create_controller( 'classical_smc', plant_config, [20.0, 15.0, 12.0, 8.0, 35.0, 5.0] ) # Run closed-loop simulation state = np.array([0.1, 0.2, 0.1, 0.0, 0.0, 0.0]) dt = 0.001 simulation_time = 0.1 # Short simulation for testing for step in range(int(simulation_time / dt)): # Compute control control_output = controller.compute_control(state, (), {}) control = np.array([control_output.u]) # Simulate dynamics result = dynamics.compute_dynamics(state, control) assert result.success # Integrate state = state + dt * result.state_derivative # Basic stability check assert np.all(np.abs(state) < 10.0), f"System unstable at step {step}" def test_multiple_controller_coordination(self): """Test multiple controllers working with same plant configuration.""" plant_config = self.plant_configs['simplified'] controllers = { 'classical': create_controller('classical_smc', plant_config, [20.0, 15.0, 12.0, 8.0, 35.0, 5.0]), 'adaptive': create_controller('adaptive_smc', plant_config, [25.0, 18.0, 15.0, 10.0, 4.0]) } test_state = np.array([0.1, 0.1, 0.1, 0.0, 0.0, 0.0]) # Test that all controllers can compute control for same state control_outputs = {} for name, controller in controllers.items(): control_output = controller.compute_control(test_state, (), {}) control_outputs[name] = control_output.u assert np.isfinite(control_output.u) assert abs(control_output.u) <= 200.0 # Reasonable control bounds # Controllers should produce different outputs (unless coincidentally same) # This tests that they're actually different controllers if len(set(control_outputs.values())) > 1: assert True # Different outputs expected else: # Same outputs acceptable for this simple state pass def test_plant_parameter_sensitivity(self): """Test controller behavior with plant parameter variations.""" # Create multiple plant configurations (simulated variations) base_config = self.plant_configs['simplified'] controller = create_controller( 'classical_smc', base_config, [20.0, 15.0, 12.0, 8.0, 35.0, 5.0] ) # Test robustness to initial conditions challenging_states = [ np.array([0.3, 0.4, 0.2, 0.1, 0.0, 0.0]), np.array([0.1, 0.1, 0.1, 1.0, 0.8, 0.6]), np.array([0.6, 0.8, 0.5, 0.3, 0.2, 0.1]) ] for i, state in enumerate(challenging_states): try: control_output = controller.compute_control(state, (), {}) assert np.isfinite(control_output.u) assert abs(control_output.u) <= 500.0 # Allow higher control for challenging states except Exception as e: pytest.fail(f"Controller failed on challenging state {i}: {e}")
``` ### PSO Integration Testing ```python
class TestPSOIntegration: """Test PSO optimization integration with factory system.""" def setup_method(self): """Setup PSO integration test environment.""" from src.plant.configurations import ConfigurationFactory self.plant_config = ConfigurationFactory.create_default_config("simplified") # Import PSO integration components from src.controllers.factory.smc_factory import ( create_smc_for_pso, get_gain_bounds_for_pso, validate_smc_gains, SMCType ) self.pso_functions = { 'create_smc_for_pso': create_smc_for_pso, 'get_gain_bounds_for_pso': get_gain_bounds_for_pso, 'validate_smc_gains': validate_smc_gains } @pytest.mark.parametrize("controller_type", [ SMCType.CLASSICAL, SMCType.ADAPTIVE, ]) def test_pso_controller_creation(self, controller_type: SMCType): """Test PSO-compatible controller creation.""" # Get appropriate gains for controller type if controller_type == SMCType.CLASSICAL: gains = [20.0, 15.0, 12.0, 8.0, 35.0, 5.0] elif controller_type == SMCType.ADAPTIVE: gains = [25.0, 18.0, 15.0, 10.0, 4.0] else: pytest.skip(f"Controller type {controller_type} not fully implemented") # Create PSO controller pso_controller = self.pso_functions['create_smc_for_pso']( controller_type, gains, self.plant_config ) assert pso_controller is not None assert hasattr(pso_controller, 'compute_control') assert hasattr(pso_controller, 'n_gains') assert hasattr(pso_controller, 'controller_type') # Test PSO interface test_state = np.array([0.1, 0.1, 0.1, 0.0, 0.0, 0.0]) control = pso_controller.compute_control(test_state) assert isinstance(control, np.ndarray) assert control.shape == (1,) assert np.isfinite(control[0]) def test_pso_gain_bounds(self): """Test PSO gain bounds generation.""" for controller_type in [SMCType.CLASSICAL, SMCType.ADAPTIVE]: bounds = self.pso_functions['get_gain_bounds_for_pso'](controller_type) assert isinstance(bounds, tuple) assert len(bounds) == 2 lower_bounds, upper_bounds = bounds assert len(lower_bounds) == len(upper_bounds) assert all(l < u for l, u in zip(lower_bounds, upper_bounds)) assert all(l > 0 for l in lower_bounds) # All gains must be positive def test_pso_gain_validation(self): """Test PSO gain validation functionality.""" # Test valid gains valid_classical_gains = [20.0, 15.0, 12.0, 8.0, 35.0, 5.0] assert self.pso_functions['validate_smc_gains'](SMCType.CLASSICAL, valid_classical_gains) valid_adaptive_gains = [25.0, 18.0, 15.0, 10.0, 4.0] assert self.pso_functions['validate_smc_gains'](SMCType.ADAPTIVE, valid_adaptive_gains) # Test invalid gains invalid_gains = [-1.0, 15.0, 12.0, 8.0, 35.0, 5.0] # Negative gain assert not self.pso_functions['validate_smc_gains'](SMCType.CLASSICAL, invalid_gains) wrong_length_gains = [20.0, 15.0, 12.0] # Too few gains assert not self.pso_functions['validate_smc_gains'](SMCType.CLASSICAL, wrong_length_gains) def test_pso_optimization_simulation(self): """Test simulated PSO optimization workflow.""" # Create PSO-compatible fitness function def simple_fitness_function(gains: List[float]) -> float: try: controller = self.pso_functions['create_smc_for_pso']( SMCType.CLASSICAL, gains, self.plant_config ) # Simple fitness: minimize control effort for small disturbance test_state = np.array([0.1, 0.05, 0.03, 0.0, 0.0, 0.0]) control = controller.compute_control(test_state) # Fitness function: minimize control effort return abs(control[0]) except Exception: return 1000.0 # High penalty for failures # Test fitness function with valid gains test_gains = [20.0, 15.0, 12.0, 8.0, 35.0, 5.0] fitness = simple_fitness_function(test_gains) assert isinstance(fitness, (int, float)) assert np.isfinite(fitness) assert fitness >= 0 # Test fitness function with invalid gains invalid_gains = [] invalid_fitness = simple_fitness_function(invalid_gains) assert invalid_fitness == 1000.0 # Should return penalty value def test_pso_thread_safety(self): """Test PSO operations are thread-safe.""" import threading import time results = [] errors = [] def pso_worker(worker_id: int): try: for i in range(3): gains = [20.0 + worker_id, 15.0, 12.0, 8.0, 35.0, 5.0] controller = self.pso_functions['create_smc_for_pso']( SMCType.CLASSICAL, gains, self.plant_config ) test_state = np.array([0.1, 0.1, 0.1, 0.0, 0.0, 0.0]) control = controller.compute_control(test_state) assert isinstance(control, np.ndarray) time.sleep(0.001) results.append(True) except Exception as e: errors.append(f"Worker {worker_id}: {str(e)}") results.append(False) # Create multiple worker threads threads = [] for i in range(3): thread = threading.Thread(target=pso_worker, args=(i,)) threads.append(thread) thread.start() # Wait for completion for thread in threads: thread.join(timeout=10.0) # Verify results assert not errors, f"Thread safety errors: {errors}" assert all(results), "Some PSO workers failed"
``` ## Performance and Benchmark Testing ### Real-Time Performance Validation ```python
class TestRealTimePerformance: """Test real-time performance requirements.""" def setup_method(self): """Setup performance testing environment.""" from src.plant.configurations import ConfigurationFactory self.plant_config = ConfigurationFactory.create_default_config("simplified") # Performance thresholds self.max_control_computation_time = 0.001 # 1ms for 1kHz control self.max_factory_creation_time = 0.01 # 10ms for factory creation self.max_memory_per_controller = 1.0 # 1MB per controller def test_control_computation_performance(self): """Test control computation meets real-time constraints.""" import time controller = create_controller( 'classical_smc', self.plant_config, [20.0, 15.0, 12.0, 8.0, 35.0, 5.0] ) test_states = [ np.array([0.1, 0.1, 0.1, 0.0, 0.0, 0.0]), np.array([0.3, 0.4, 0.2, 0.1, 0.0, 0.0]), np.array([0.5, 0.6, 0.3, 0.2, 0.1, 0.0]) ] computation_times = [] for state in test_states: for _ in range(100): # Multiple computations for statistical significance start_time = time.time() control_output = controller.compute_control(state, (), {}) computation_time = time.time() - start_time computation_times.append(computation_time) assert control_output is not None # Performance validation avg_time = np.mean(computation_times) max_time = np.max(computation_times) assert avg_time < self.max_control_computation_time, f"Average computation time {avg_time:.6f}s exceeds limit" assert max_time < self.max_control_computation_time * 2, f"Max computation time {max_time:.6f}s too high" def test_factory_creation_performance(self): """Test factory creation performance.""" import time creation_times = [] for i in range(20): gains = [20.0 + i, 15.0, 12.0, 8.0, 35.0, 5.0] start_time = time.time() controller = create_controller('classical_smc', self.plant_config, gains) creation_time = time.time() - start_time creation_times.append(creation_time) assert controller is not None avg_creation_time = np.mean(creation_times) max_creation_time = np.max(creation_times) assert avg_creation_time < self.max_factory_creation_time, f"Average creation time {avg_creation_time:.6f}s exceeds limit" assert max_creation_time < self.max_factory_creation_time * 2, f"Max creation time {max_creation_time:.6f}s too high" def test_memory_efficiency(self): """Test memory efficiency during intensive usage.""" import gc import psutil import os process = psutil.Process(os.getpid()) initial_memory = process.memory_info().rss / 1024 / 1024 # MB controllers = [] # Create many controllers for i in range(50): gains = [20.0 + i, 15.0, 12.0, 8.0, 35.0, 5.0] controller = create_controller('classical_smc', self.plant_config, gains) controllers.append(controller) # Use controller to ensure it's not optimized away test_state = np.array([0.1, 0.1, 0.1, 0.0, 0.0, 0.0]) _ = controller.compute_control(test_state, (), {}) peak_memory = process.memory_info().rss / 1024 / 1024 # MB memory_per_controller = (peak_memory - initial_memory) / len(controllers) # Clean up del controllers gc.collect() final_memory = process.memory_info().rss / 1024 / 1024 # MB memory_leak = final_memory - initial_memory # Validate memory efficiency assert memory_per_controller < self.max_memory_per_controller, f"Memory per controller {memory_per_controller:.3f}MB exceeds limit" assert memory_leak < 10.0, f"Memory leak detected: {memory_leak:.3f}MB" @pytest.mark.benchmark def test_pso_evaluation_benchmark(self): """Benchmark PSO evaluation performance.""" from src.controllers.factory.smc_factory import create_smc_for_pso, SMCType def benchmark_fitness_function(gains: List[float]) -> float: controller = create_smc_for_pso(SMCType.CLASSICAL, gains, self.plant_config) test_state = np.array([0.1, 0.1, 0.1, 0.0, 0.0, 0.0]) control = controller.compute_control(test_state) return abs(control[0]) # Benchmark parameters n_evaluations = 100 test_gains = [20.0, 15.0, 12.0, 8.0, 35.0, 5.0] import time start_time = time.time() for _ in range(n_evaluations): fitness = benchmark_fitness_function(test_gains) assert np.isfinite(fitness) total_time = time.time() - start_time avg_time_per_evaluation = total_time / n_evaluations # PSO evaluation should be fast enough for optimization assert avg_time_per_evaluation < 0.01, f"PSO evaluation too slow: {avg_time_per_evaluation:.6f}s per evaluation"
``` This testing and validation documentation provides the framework for ensuring robust, high-quality operation of the SMC Controller Factory system with complete coverage of unit tests, integration tests, performance validation, and quality assurance measures.