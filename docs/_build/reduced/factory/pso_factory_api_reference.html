<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../genindex.html"><link rel="search" title="Search" href="../search.html">

    <!-- Generated with Sphinx 7.4.7 and Furo 2025.09.25 -->
        <title>PSO Factory Integration API Reference - DIP_SMC_PSO Documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d111a655" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=580074bf" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=8dab3a3b" />
    
    


<style>
  body {
    --color-code-background: #f2f2f2;
  --color-code-foreground: #1e1e1e;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">DIP_SMC_PSO Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  <span class="sidebar-brand-text">DIP_SMC_PSO Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../ACADEMIC_INTEGRITY_STATEMENT.html">Academic Integrity Statement <strong>Status:</strong> To be completed in Phase B (Citation System Implementation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CHANGELOG.html">Changelog All notable changes to the ResearchPlan validation system will be documented in this file. The format is based on Keep a Changelog,</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CITATIONS.html">Citations &amp; Academic Attribution <strong>Project:</strong> Double Inverted Pendulum - Sliding Mode Control with PSO Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CITATIONS_ACADEMIC.html">Academic Theory Citations &amp; References <strong>Project:</strong> Double Inverted Pendulum - Sliding Mode Control with PSO Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CITATION_SYSTEM.html">Citation System Documentation <strong>Status:</strong> To be completed in Phase B (Citation System Implementation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CONTRIBUTING.html">Contributing â€“ ResearchPlanSpec Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CONTROLLER_FACTORY.html">Controller Factory Documentation &gt; <strong>Note:</strong> This document has been consolidated into the Factory System Guide. ## Quick Links - <strong><span class="xref myst">Factory System Guide</span></strong> - Complete controller factory documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CROSS_REFERENCE_AUDIT_REPORT.html">Documentation Cross-Reference Audit Report <strong>Report Date:</strong> 2025-10-07</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DEPENDENCIES.html">Software Dependencies &amp; Citations <strong>Project:</strong> Double Inverted Pendulum - Sliding Mode Control with PSO Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DOCUMENTATION_COVERAGE_MATRIX.html">Documentation Coverage Matrix</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DOCUMENTATION_IMPLEMENTATION_PLAN.html">Documentation Coverage Implementation Plan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DOCUMENTATION_INVENTORY_SUMMARY.html">DIP-SMC-PSO Documentation Inventory Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DOCUMENTATION_STYLE_GUIDE.html">Documentation Style Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DOCUMENTATION_SYSTEM.html">ğŸ“š World-Class Documentation System for DIP_SMC_PSO ## ğŸŒŸ Overview This repository now features a <strong>world-class technical documentation system</strong> designed for research-grade publications. The system provides LaTeX-quality mathematical rendering, professional citation management, and cross-referencing features. ## âœ¨ Features ### ğŸ”¬ Research-Grade Mathematics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../EXAMPLE_VALIDATION_REPORT.html">Documentation Code Example Validation Report <strong>Report Date:</strong> 2025-10-07</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LICENSES.html">License Compliance &amp; Attribution <strong>Project:</strong> Double Inverted Pendulum - Sliding Mode Control with PSO Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PACKAGE_CONTENTS.html">Sphinx Documentation Implementation Package ## ğŸ“ Package Contents for ChatGPT Review This package contains the complete implementation of production-grade Sphinx documentation with GitHub CI/CD based on expert recommendations. ### ğŸš€ Core Implementation Files #### GitHub Workflows (Enhanced CI/CD)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PATTERNS.html">Software Design Patterns &amp; Architecture Attribution <strong>Project:</strong> Double Inverted Pendulum - Sliding Mode Control with PSO Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PATTERNS.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PATTERNS.html#runnable-false-src-controllers-factory-py-lines-507-543-def-create-controller-controller-type-str-config-optional-any-none-gains-optional-union-list-np-ndarray-none-any-create-a-controller-instance-of-the-specified-type-this-function-is-thread-safe-and-can-be-called-concurrently-supported-types-classical-smc-sta-smc-adaptive-smc-hybrid-adaptive-sta-smc-mpc-controller-normalize-controller-type-handles-aliases-controller-type-canonicalize-controller-type-controller-type-retrieve-from-registry-controller-info-get-controller-info-controller-type-controller-class-controller-info-class-resolve-gains-from-config-defaults-controller-gains-resolve-controller-gains-gains-config-controller-type-validate-gains-with-controller-specific-rules-validate-controller-gains-controller-gains-controller-info-create-and-return-configured-instance-return-controller-class-controller-gains-kwargs">runnable: false # src/controllers/factory.py (lines 507-543) def create_controller(controller_type: str, config: Optional[Any] = None, gains: Optional[Union[list, np.ndarray]] = None) -&gt; Any: â€œâ€â€ Create a controller instance of the specified type. This function is thread-safe and can be called concurrently. Supported types: â€˜classical_smcâ€™, â€˜sta_smcâ€™, â€˜adaptive_smcâ€™, â€˜hybrid_adaptive_sta_smcâ€™, â€˜mpc_controllerâ€™ â€œâ€â€ # Normalize controller type (handles aliases) controller_type = _canonicalize_controller_type(controller_type) # Retrieve from registry controller_info = _get_controller_info(controller_type) controller_class = controller_info[â€˜classâ€™] # Resolve gains from config/defaults controller_gains = _resolve_controller_gains(gains, config, controller_type) # Validate gains with controller-specific rules _validate_controller_gains(controller_gains, controller_info) # Create and return configured instance return controller_class(controller_gains, **kwargs)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PATTERNS.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PATTERNS.html#runnable-false-src-utils-validation-parameter-validators-py-def-validate-gains-n-expected-int-decorator-to-validate-gain-array-length-def-decorator-func-def-wrapper-self-gains-args-kwargs-if-len-gains-n-expected-raise-valueerror-f-expected-n-expected-gains-got-len-gains-return-func-self-gains-args-kwargs-return-wrapper-return-decorator-usage">runnable: false # src/utils/validation/parameter_validators.py def validate_gains(n_expected: int): â€œâ€â€Decorator to validate gain array length.â€â€â€ def decorator(func): def wrapper(self, gains, *args, **kwargs): if len(gains) != n_expected: raise ValueError(fâ€Expected {n_expected} gains, got {len(gains)}â€) return func(self, gains, *args, **kwargs) return wrapper return decorator # Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PLANT_CONFIGURATION.html">Plant Configuration Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PSO_Documentation_Validation_Report.html">PSO Documentation Validation Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PSO_INTEGRATION_GUIDE.html">PSO Integration Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../QUICKSTART_VALIDATION.html">Quick Start: Issue #12 Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Optimal Sliding Mode Control for a Double-Inverted Pendulum via PSO </a></li>
<li class="toctree-l1"><a class="reference internal" href="../RELEASE_CHECKLIST.html">Release Checklist Use this checklist when preparing a new release of the ResearchPlan validation system. ## Pre-Release ### Code &amp; Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_100_PERCENT_COMPLETION_REPORT.html">Sphinx Documentation - 100% Warning Elimination Complete</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE10_COMPLETION_REPORT.html">Sphinx Phase 10 Completion Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE11_COMPLETION_REPORT.html">Sphinx Phase 11 Completion Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE2_COMPLETION_REPORT.html">Phase 2 Completion Report: Live Python Code Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE3_COMPLETION_REPORT.html">Phase 3 Completion Report: Plotly Interactive Charts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE4_COMPLETION_REPORT.html">Phase 4: Jupyter Notebooks Integration - Completion Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE5_COMPLETION_REPORT.html">Phase 5 Completion Report: Mathematical Visualization Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE6_COMPLETION_REPORT.html">Phase 6 Completion Report: Progressive Web App (PWA)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE8_SUMMARY.html">Sphinx Documentation Phase 8 - Final Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE9_PROGRESS_REPORT.html">Sphinx Documentation Phase 9 - Final Progress Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TESTING.html">Testing Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../analysis_plan.html">5. Analysis &amp; Verification Plan ## ğŸ”§ <strong>Recent Testing Infrastructure Improvements</strong> (September 2024) ### <strong>Vector Simulation Engine Robustness</strong> The vector simulation engine (<code class="docutils literal notranslate"><span class="pre">src/simulation/engines/vector_sim.py</span></code>) has been enhanced with edge case handling and improved reliability: #### <strong>âœ… Fixes Applied</strong> 1. <strong>Scalar Control Input Support</strong> - <strong>Issue</strong>: <code class="docutils literal notranslate"><span class="pre">IndexError</span></code> when control input was 0-dimensional scalar - <strong>Fix</strong>: Added proper scalar handling with <code class="docutils literal notranslate"><span class="pre">.item()</span></code> extraction for 0D arrays - <strong>Benefit</strong>: Supports simplified test scenarios and edge cases 2. <strong>Flexible Control Sequence Length</strong> - <strong>Issue</strong>: Crashes when simulation horizon exceeded control input sequence length - <strong>Fix</strong>: Implemented graceful bounds checking with <code class="docutils literal notranslate"><span class="pre">min(i,</span> <span class="pre">length-1)</span></code> indexing strategy - <strong>Benefit</strong>: Uses last available control input when sequence is exhausted 3. <strong>Empty State Array Handling</strong> - <strong>Issue</strong>: Tests expected exceptions for empty arrays, but function handled them gracefully - <strong>Fix</strong>: Updated test expectations to match actual behavior (returns <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">0)</span></code> shaped array) - <strong>Benefit</strong>: Consistent behavior for degenerate cases 4. <strong>Mock Function Accuracy</strong> - <strong>Issue</strong>: Test mocks didnâ€™t reflect actual physics-based state evolution - <strong>Fix</strong>: Updated mock dynamics to properly simulate <code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">+</span> <span class="pre">dt</span> <span class="pre">*</span> <span class="pre">state_derivative</span></code> evolution - <strong>Benefit</strong>: Tests now validate realistic controller-plant interactions #### <strong>âœ… Test Coverage Improvements</strong> <strong>Vector Simulation Test Suite</strong>: Now <strong>100% passing</strong> (20/21 tests pass, 1 skipped)</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../api/index.html">API Reference Documentation</a><input aria-label="Toggle navigation of API Reference Documentation" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../api/controller_api_reference.html">Controller API Reference &gt; <strong>Note:</strong> Controller API documentation has been consolidated into references. ## Quick Links - <strong><span class="xref myst">Factory System API</span></strong> - Complete factory and controller creation API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/controller_theory.html">Controller Theory Reference <strong>Status:</strong> ğŸš§ Under Construction This document will contain controller theory documentation including: ## Planned Content ### Sliding Mode Control Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html">Factory System API Reference <strong>Module:</strong> <code class="docutils literal notranslate"><span class="pre">src.controllers.factory</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#runnable-false-thread-safe-factory-operations-with-timeout-protection">runnable: false # Thread-safe factory operations with timeout protection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#runnable-false-def-list-available-controllers-list">runnable: false def list_available_controllers() -&gt; list</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#example-return-values">Example return values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#runnable-false-controller-registry-dict-str-dict-str-any-controller-type-class-controllerclass-controller-class-reference-config-class-configclass-configuration-class-reference-default-gains-list-float-default-gain-vector-gain-count-int-expected-number-of-gains-description-str-human-readable-description-supports-dynamics-bool-whether-controller-uses-dynamics-model-required-params-list-str-required-configuration-parameters">runnable: false CONTROLLER_REGISTRY: Dict[str, Dict[str, Any]] = { â€˜controller_typeâ€™: { â€˜classâ€™: ControllerClass, # Controller class reference â€˜config_classâ€™: ConfigClass, # Configuration class reference â€˜default_gainsâ€™: List[float], # Default gain vector â€˜gain_countâ€™: int, # Expected number of gains â€˜descriptionâ€™: str, # Human-readable description â€˜supports_dynamicsâ€™: bool, # Whether controller uses dynamics model â€˜required_paramsâ€™: List[str] # Required configuration parameters }</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#runnable-false-class-psocontrollerwrapper-wrapper-for-smc-controllers-to-provide-pso-compatible-interface-def-init-self-controller-n-gains-int-controller-type-str-self-controller-controller-self-n-gains-n-gains-self-controller-type-controller-type-self-max-force-getattr-controller-max-force-150-0-self-dynamics-model-getattr-controller-dynamics-model-none-def-validate-gains-self-particles-np-ndarray-np-ndarray-validate-gain-particles-for-pso-optimization-checks-gain-count-finiteness-positivity-and-controller-specific-constraints-def-compute-control-self-state-np-ndarray-np-ndarray-pso-compatible-control-computation-interface-simplified-interface-for-pso-fitness-evaluation">runnable: false class PSOControllerWrapper: â€œâ€â€Wrapper for SMC controllers to provide PSO-compatible interface.â€â€â€ def <strong>init</strong>(self, controller, n_gains: int, controller_type: str): self.controller = controller self.n_gains = n_gains self.controller_type = controller_type self.max_force = getattr(controller, â€˜max_forceâ€™, 150.0) self.dynamics_model = getattr(controller, â€˜dynamics_modelâ€™, None) def validate_gains(self, particles: np.ndarray) -&gt; np.ndarray: â€œâ€â€Validate gain particles for PSO optimization.â€â€â€ # Checks gain count, finiteness, positivity, and controller-specific constraints â€¦ def compute_control(self, state: np.ndarray) -&gt; np.ndarray: â€œâ€â€PSO-compatible control computation interface.â€â€â€ # Simplified interface for PSO fitness evaluation â€¦</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#runnable-false-src-controllers-new-controller-py-import-numpy-as-np">runnable: false # src/controllers/new_controller.py import numpy as np</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#runnable-false-src-controllers-new-controller-config-py-from-dataclasses-import-dataclass">runnable: false # src/controllers/new_controller_config.py from dataclasses import dataclass</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#import-new-controller">Import new controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#add-aliases-for-convenience">Add aliases for convenience</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#runnable-false-add-to-smctype-enum">runnable: false # Add to SMCType enum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#test-new-controller-py-from-src-controllers-factory-import-create-controller-get-default-gains">test_new_controller.py from src.controllers.factory import create_controller, get_default_gains</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#id7">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#runnable-false">runnable: false â€œâ€â€</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#id8">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#id9">runnable: false â€œâ€â€</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_reference.html">Factory API Reference ## Controller Factory System - GitHub Issue #6 Implementation ### Overview The Controller Factory System provides a unified, type-safe interface for creating and managing sliding mode control (SMC) controllers in the DIP-SMC-PSO project. This system implements the factory pattern to ensure consistent controller instantiation, parameter validation, and optimization integration. ### Architecture #### Core Components 1. <strong>Main Factory</strong> (<code class="docutils literal notranslate"><span class="pre">src/controllers/factory.py</span></code>) - Central controller registry and creation interface - Thread-safe operations with RLock protection - error handling and validation - Legacy compatibility support 2. <strong>SMC Factory</strong> (<code class="docutils literal notranslate"><span class="pre">src/controllers/factory/smc_factory.py</span></code>) - Specialized factory for SMC controllers - PSO optimization integration - Type-safe parameter handling 3. <strong>Legacy Factory</strong> (<code class="docutils literal notranslate"><span class="pre">src/controllers/factory/legacy_factory.py</span></code>) - Backward compatibility interface - Deprecation handling and migration support ### Supported Controllers | Controller Type | Class | Gains | Description |</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html">Factory Methods API Reference ## Overview This document provides API reference documentation for the Enterprise Controller Factory system. The factory provides thread-safe, type-safe controller instantiation with deep PSO integration and robust error handling. ## Table of Contents 1. <span class="xref myst">Core Factory Functions</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#basic-usage-with-default-parameters">Basic usage with default parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#runnable-false-def-list-available-controllers-list-str">runnable: false def list_available_controllers() -&gt; List[str]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#output-classical-smc-sta-smc-adaptive-smc-hybrid-adaptive-sta-smc">Output: [â€˜classical_smcâ€™, â€˜sta_smcâ€™, â€˜adaptive_smcâ€™, â€˜hybrid_adaptive_sta_smcâ€™]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#note-mpc-controller-only-included-if-optional-dependencies-available">Note: â€˜mpc_controllerâ€™ only included if optional dependencies available</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#runnable-false-def-get-default-gains-controller-type-str-list-float">runnable: false def get_default_gains(controller_type: str) -&gt; List[float]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#runnable-false-get-default-gains-for-different-controllers">runnable: false # Get default gains for different controllers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#output-20-0-15-0-12-0-8-0-35-0-5-0-adaptive-gains-get-default-gains-adaptive-smc">Output: [20.0, 15.0, 12.0, 8.0, 35.0, 5.0] adaptive_gains = get_default_gains(â€˜adaptive_smcâ€™)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#output-25-0-18-0-15-0-10-0-4-0-use-as-starting-point-for-optimization">Output: [25.0, 18.0, 15.0, 10.0, 4.0] # Use as starting point for optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#runnable-false-create-factory-once-expensive-operation">runnable: false # Create factory once (expensive operation)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#runnable-false-def-validate-smc-gains-smc-type-smctype-gains-union-list-np-ndarray-bool">runnable: false def validate_smc_gains(smc_type: SMCType, gains: Union[list, np.ndarray]) -&gt; bool</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#runnable-false-validate-gains-before-expensive-simulation">runnable: false # Validate gains before expensive simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#pattern-1-direct-controller-configuration">Pattern 1: Direct controller configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#type-aliases-for-better-type-safety">Type aliases for better type safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#runnable-false-class-controllerprotocol-protocol-protocol-defining-the-standard-controller-interface-def-compute-control-self-state-statevector-last-control-float-history-configdict-controloutput-compute-control-output-for-given-state-def-reset-self-none-reset-controller-internal-state-property-def-gains-self-list-float-return-controller-gains">runnable: false class ControllerProtocol(Protocol): â€œâ€â€Protocol defining the standard controller interface.â€â€â€ def compute_control( self, state: StateVector, last_control: float, history: ConfigDict ) -&gt; ControlOutput: â€œâ€â€Compute control output for given state.â€â€â€ â€¦ def reset(self) -&gt; None: â€œâ€â€Reset controller internal state.â€â€â€ â€¦ @property def gains(self) -&gt; List[float]: â€œâ€â€Return controller gains.â€â€â€ â€¦</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html">Optimization Module API Reference <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#runnable-false-usr-bin-env-python3">runnable: false #!/usr/bin/env python3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#configuration">Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#config-path-config-yaml">============================================================================ CONFIG_PATH = â€œconfig.yamlâ€</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#convergence-monitoring-callback">Convergence Monitoring Callback</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#class-convergencemonitor-callback-for-real-time-convergence-monitoring-def-init-self-analyzer-enhancedconvergenceanalyzer-self-analyzer-analyzer-self-metrics-history-def-call-self-iteration-int-best-fitness-float-mean-fitness-float-fitness-std-float-swarm-positions-np-ndarray-check-convergence-at-each-iteration-status-metrics-self-analyzer-check-convergence-iteration-iteration-best-fitness-best-fitness-mean-fitness-mean-fitness-fitness-std-fitness-std-swarm-positions-swarm-positions-self-metrics-history-append-metrics-log-key-metrics-if-iteration-10-0-print-f-iter-iteration-3d-status-status-value-20s-f-best-metrics-best-fitness-6f-f-diversity-metrics-population-diversity-4f-f-conv-velocity-metrics-convergence-velocity-4e-f-predicted-remaining-metrics-predicted-iterations-remaining-3d-early-stopping-if-status-convergencestatus-converged-print-f-n-convergence-detected-at-iteration-iteration-return-true-signal-early-stop-elif-status-convergencestatus-stagnated-print-f-n-stagnation-detected-at-iteration-iteration-return-true-signal-early-stop-return-false-continue">============================================================================ class ConvergenceMonitor: â€œâ€â€Callback for real-time convergence monitoring.â€â€â€ def <strong>init</strong>(self, analyzer: EnhancedConvergenceAnalyzer): self.analyzer = analyzer self.metrics_history = [] def <strong>call</strong>(self, iteration: int, best_fitness: float, mean_fitness: float, fitness_std: float, swarm_positions: np.ndarray): â€œâ€â€Check convergence at each iteration.â€â€â€ status, metrics = self.analyzer.check_convergence( iteration=iteration, best_fitness=best_fitness, mean_fitness=mean_fitness, fitness_std=fitness_std, swarm_positions=swarm_positions ) self.metrics_history.append(metrics) # Log key metrics if iteration % 10 == 0: print(fâ€Iter {iteration:3d} | Status: {status.value:20s} | â€œ fâ€Best: {metrics.best_fitness:.6f} | â€œ fâ€Diversity: {metrics.population_diversity:.4f} | â€œ fâ€Conv. Velocity: {metrics.convergence_velocity:.4e} | â€œ fâ€Predicted Remaining: {metrics.predicted_iterations_remaining:3d}â€) # Early stopping if status == ConvergenceStatus.CONVERGED: print(fâ€\n&gt;&gt;&gt; CONVERGENCE DETECTED at iteration {iteration} &lt;&lt;&lt;â€) return True # Signal early stop elif status == ConvergenceStatus.STAGNATED: print(fâ€\n&gt;&gt;&gt; STAGNATION DETECTED at iteration {iteration} &lt;&lt;&lt;â€) return True # Signal early stop return False # Continue # ============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#main">Main</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#def-main-load-configuration-config-load-config-config-path-initialize-convergence-analyzer-with-custom-criteria-criteria-convergencecriteria-fitness-tolerance-1e-6-relative-improvement-threshold-1e-4-min-diversity-threshold-1e-3-max-stagnation-iterations-50-enable-performance-prediction-true-premature-convergence-detection-true-analyzer-enhancedconvergenceanalyzer-criteria-criteria-controller-type-smctype-sta-monitor-convergencemonitor-analyzer-create-controller-factory-controller-factory-partial-create-controller-controller-type-controller-type-config-config-initialize-pso-tuner-tuner-psotuner-controller-factory-controller-factory-config-config-seed-seed-run-optimization-with-monitoring-print-f-running-pso-optimization-with-real-time-convergence-monitoring-print-f-120-result-tuner-optimise-print-f-120-n-plot-convergence-metrics-metrics-monitor-metrics-history-iterations-m-iteration-for-m-in-metrics-best-fitness-m-best-fitness-for-m-in-metrics-diversity-m-population-diversity-for-m-in-metrics-conv-velocity-m-convergence-velocity-for-m-in-metrics-fig-axes-plt-subplots-3-1-figsize-12-10-best-fitness-axes-0-plot-iterations-best-fitness-linewidth-2-color-blue-axes-0-set-ylabel-best-fitness-fontsize-12-axes-0-set-yscale-log-axes-0-set-title-convergence-monitoring-sta-smc-fontsize-14-fontweight-bold-axes-0-grid-true-alpha-0-3-population-diversity-axes-1-plot-iterations-diversity-linewidth-2-color-green-axes-1-set-ylabel-population-diversity-fontsize-12-axes-1-grid-true-alpha-0-3-convergence-velocity-axes-2-plot-iterations-conv-velocity-linewidth-2-color-red-axes-2-set-ylabel-convergence-velocity-fontsize-12-axes-2-set-xlabel-iteration-fontsize-12-axes-2-grid-true-alpha-0-3-plt-tight-layout-plt-savefig-pso-convergence-monitoring-png-dpi-300-print-convergence-monitoring-plot-saved-pso-convergence-monitoring-png-if-name-main-main">============================================================================ def main(): # Load configuration config = load_config(CONFIG_PATH) # Initialize convergence analyzer with custom criteria criteria = ConvergenceCriteria( fitness_tolerance=1e-6, relative_improvement_threshold=1e-4, min_diversity_threshold=1e-3, max_stagnation_iterations=50, enable_performance_prediction=True, premature_convergence_detection=True ) analyzer = EnhancedConvergenceAnalyzer( criteria=criteria, controller_type=SMCType.STA ) monitor = ConvergenceMonitor(analyzer) # Create controller factory controller_factory = partial( create_controller, controller_type=CONTROLLER_TYPE, config=config ) # Initialize PSO tuner tuner = PSOTuner( controller_factory=controller_factory, config=config, seed=SEED ) # Run optimization with monitoring print(fâ€Running PSO optimization with real-time convergence monitoringâ€¦â€) print(fâ€{â€˜=â€™*120}â€) result = tuner.optimise() print(fâ€{â€˜=â€™*120}\nâ€) # Plot convergence metrics metrics = monitor.metrics_history iterations = [m.iteration for m in metrics] best_fitness = [m.best_fitness for m in metrics] diversity = [m.population_diversity for m in metrics] conv_velocity = [m.convergence_velocity for m in metrics] fig, axes = plt.subplots(3, 1, figsize=(12, 10)) # Best fitness axes[0].plot(iterations, best_fitness, linewidth=2, color=â€™blueâ€™) axes[0].set_ylabel(â€˜Best Fitnessâ€™, fontsize=12) axes[0].set_yscale(â€˜logâ€™) axes[0].set_title(â€˜Convergence Monitoring - STA SMCâ€™, fontsize=14, fontweight=â€™boldâ€™) axes[0].grid(True, alpha=0.3) # Population diversity axes[1].plot(iterations, diversity, linewidth=2, color=â€™greenâ€™) axes[1].set_ylabel(â€˜Population Diversityâ€™, fontsize=12) axes[1].grid(True, alpha=0.3) # Convergence velocity axes[2].plot(iterations, conv_velocity, linewidth=2, color=â€™redâ€™) axes[2].set_ylabel(â€˜Convergence Velocityâ€™, fontsize=12) axes[2].set_xlabel(â€˜Iterationâ€™, fontsize=12) axes[2].grid(True, alpha=0.3) plt.tight_layout() plt.savefig(â€˜pso_convergence_monitoring.pngâ€™, dpi=300) print(â€œConvergence monitoring plot saved: pso_convergence_monitoring.pngâ€) if <strong>name</strong> == â€œ<strong>main</strong>â€: main()</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#expected-output-running-pso-optimization-with-real-time-convergence-monitoring"><code class="docutils literal notranslate"><span class="pre">**Expected</span> <span class="pre">Output:**</span></code>
Running PSO optimization with real-time convergence monitoringâ€¦</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#id2">runnable: false #!/usr/bin/env python3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#id3">Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#id4">============================================================================ CONFIG_PATH = â€œconfig.yamlâ€</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#id5">Main</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#def-main-load-configuration-config-load-config-config-path-initialize-meta-optimizer-print-initializing-pso-hyperparameter-optimizer-meta-optimizer-psohyperparameteroptimizer-config-run-meta-optimization-print-f-nrunning-meta-optimization-for-controller-type-value-print-f-max-evaluations-max-meta-evaluations-print-f-trials-per-evaluation-n-trials-per-eval-print-f-objective-optimizationobjective-multi-objective-value-print-80-result-meta-optimizer-optimize-hyperparameters-controller-type-controller-type-objective-optimizationobjective-multi-objective-max-evaluations-max-meta-evaluations-n-trials-per-evaluation-n-trials-per-eval-display-results-print-n-80-print-hyperparameter-optimization-results-print-80-print-f-noptimized-hyperparameters-print-f-inertia-weight-w-result-hyperparameters-w-6f-print-f-cognitive-c1-result-hyperparameters-c1-6f-print-f-social-c2-result-hyperparameters-c2-6f-print-f-swarm-size-result-hyperparameters-n-particles-print-f-nbaseline-hyperparameters-print-f-inertia-weight-w-result-baseline-hyperparameters-w-6f-print-f-cognitive-c1-result-baseline-hyperparameters-c1-6f-print-f-social-c2-result-baseline-hyperparameters-c2-6f-print-f-swarm-size-result-baseline-hyperparameters-n-particles-print-f-nperformance-improvements-vs-baseline-print-f-convergence-speedup-result-convergence-improvement-2f-x-print-f-quality-improvement-result-quality-improvement100-2f-print-f-robustness-improvement-result-robustness-improvement100-2f-print-f-efficiency-score-result-efficiency-score-4f-print-80-visualize-comparison-fig-axes-plt-subplots-2-2-figsize-12-10-categories-w-c1-c2-n-baseline-values-result-baseline-hyperparameters-w-result-baseline-hyperparameters-c1-result-baseline-hyperparameters-c2-result-baseline-hyperparameters-n-particles-optimized-values-result-hyperparameters-w-result-hyperparameters-c1-result-hyperparameters-c2-result-hyperparameters-n-particles-x-np-arange-len-categories-width-0-35-axes-0-0-bar-x-width-2-baseline-values-width-label-baseline-alpha-0-7-axes-0-0-bar-x-width-2-optimized-values-width-label-optimized-alpha-0-7-axes-0-0-set-ylabel-value-axes-0-0-set-title-hyperparameter-comparison-axes-0-0-set-xticks-x-axes-0-0-set-xticklabels-categories-axes-0-0-legend-axes-0-0-grid-true-alpha-0-3-performance-metrics-metrics-convergence-nspeed-solution-nquality-robustness-improvements-result-convergence-improvement-1-result-quality-improvement-1-result-robustness-improvement-axes-0-1-bar-metrics-improvements-color-blue-green-orange-alpha-0-7-axes-0-1-axhline-y-1-0-color-red-linestyle-label-baseline-axes-0-1-set-ylabel-improvement-factor-axes-0-1-set-title-performance-improvements-axes-0-1-legend-axes-0-1-grid-true-alpha-0-3-convergence-history-if-available-if-hasattr-result-optimization-history-axes-1-0-plot-result-optimization-history-best-objective-linewidth-2-axes-1-0-set-xlabel-meta-optimization-iteration-axes-1-0-set-ylabel-objective-value-axes-1-0-set-title-meta-optimization-convergence-axes-1-0-grid-true-alpha-0-3-hide-unused-subplot-axes-1-1-axis-off-plt-tight-layout-plt-savefig-pso-hyperparameter-optimization-png-dpi-300-print-nvisualization-saved-pso-hyperparameter-optimization-png-if-name-main-main">============================================================================ def main(): # Load configuration config = load_config(CONFIG_PATH) # Initialize meta-optimizer print(â€œInitializing PSO Hyperparameter Optimizerâ€¦â€) meta_optimizer = PSOHyperparameterOptimizer(config) # Run meta-optimization print(fâ€\nRunning meta-optimization for {CONTROLLER_TYPE.value}â€¦â€) print(fâ€Max evaluations: {MAX_META_EVALUATIONS}â€) print(fâ€Trials per evaluation: {N_TRIALS_PER_EVAL}â€) print(fâ€Objective: {OptimizationObjective.MULTI_OBJECTIVE.value}â€) print(â€œ=â€*80) result = meta_optimizer.optimize_hyperparameters( controller_type=CONTROLLER_TYPE, objective=OptimizationObjective.MULTI_OBJECTIVE, max_evaluations=MAX_META_EVALUATIONS, n_trials_per_evaluation=N_TRIALS_PER_EVAL ) # Display results print(â€œ\nâ€ + â€œ=â€<em>80) print(â€œHYPERPARAMETER OPTIMIZATION RESULTSâ€) print(â€œ=â€<em>80) print(fâ€\nOptimized Hyperparameters:â€) print(fâ€ Inertia weight (w): {result.hyperparameters.w:.6f}â€) print(fâ€ Cognitive (c1): {result.hyperparameters.c1:.6f}â€) print(fâ€ Social (c2): {result.hyperparameters.c2:.6f}â€) print(fâ€ Swarm size: {result.hyperparameters.n_particles}â€) print(fâ€\nBaseline Hyperparameters:â€) print(fâ€ Inertia weight (w): {result.baseline_hyperparameters.w:.6f}â€) print(fâ€ Cognitive (c1): {result.baseline_hyperparameters.c1:.6f}â€) print(fâ€ Social (c2): {result.baseline_hyperparameters.c2:.6f}â€) print(fâ€ Swarm size: {result.baseline_hyperparameters.n_particles}â€) print(fâ€\nPerformance Improvements vs. Baseline:â€) print(fâ€ Convergence speedup: {result.convergence_improvement:.2f}xâ€) print(fâ€ Quality improvement: {result.quality_improvement</em>100:.2f}%â€) print(fâ€ Robustness improvement: {result.robustness_improvement</em>100:.2f}%â€) print(fâ€ Efficiency score: {result.efficiency_score:.4f}â€) print(â€œ=â€*80) # Visualize comparison fig, axes = plt.subplots(2, 2, figsize=(12, 10)) categories = [â€˜wâ€™, â€˜c1â€™, â€˜c2â€™, â€˜Nâ€™] baseline_values = [ result.baseline_hyperparameters.w, result.baseline_hyperparameters.c1, result.baseline_hyperparameters.c2, result.baseline_hyperparameters.n_particles ] optimized_values = [ result.hyperparameters.w, result.hyperparameters.c1, result.hyperparameters.c2, result.hyperparameters.n_particles ] x = np.arange(len(categories)) width = 0.35 axes[0, 0].bar(x - width/2, baseline_values, width, label=â€™Baselineâ€™, alpha=0.7) axes[0, 0].bar(x + width/2, optimized_values, width, label=â€™Optimizedâ€™, alpha=0.7) axes[0, 0].set_ylabel(â€˜Valueâ€™) axes[0, 0].set_title(â€˜Hyperparameter Comparisonâ€™) axes[0, 0].set_xticks(x) axes[0, 0].set_xticklabels(categories) axes[0, 0].legend() axes[0, 0].grid(True, alpha=0.3) # Performance metrics metrics = [â€˜Convergence\nSpeedâ€™, â€˜Solution\nQualityâ€™, â€˜Robustnessâ€™] improvements = [ result.convergence_improvement, 1 + result.quality_improvement, 1 + result.robustness_improvement ] axes[0, 1].bar(metrics, improvements, color=[â€˜blueâ€™, â€˜greenâ€™, â€˜orangeâ€™], alpha=0.7) axes[0, 1].axhline(y=1.0, color=â€™redâ€™, linestyle=â€™â€“â€™, label=â€™Baselineâ€™) axes[0, 1].set_ylabel(â€˜Improvement Factorâ€™) axes[0, 1].set_title(â€˜Performance Improvementsâ€™) axes[0, 1].legend() axes[0, 1].grid(True, alpha=0.3) # Convergence history (if available) if hasattr(result, â€˜optimization_historyâ€™): axes[1, 0].plot(result.optimization_history[â€˜best_objectiveâ€™], linewidth=2) axes[1, 0].set_xlabel(â€˜Meta-Optimization Iterationâ€™) axes[1, 0].set_ylabel(â€˜Objective Valueâ€™) axes[1, 0].set_title(â€˜Meta-Optimization Convergenceâ€™) axes[1, 0].grid(True, alpha=0.3) # Hide unused subplot axes[1, 1].axis(â€˜offâ€™) plt.tight_layout() plt.savefig(â€˜pso_hyperparameter_optimization.pngâ€™, dpi=300) print(â€œ\nVisualization saved: pso_hyperparameter_optimization.pngâ€) if <strong>name</strong> == â€œ<strong>main</strong>â€: main()</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/pso_optimization.html">PSO Optimization Guide <strong>Status:</strong> ğŸš§ Under Construction This document will contain PSO optimization documentation including: ## Planned Content ### PSO Algorithm Fundamentals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html">Simulation Engine API Reference <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#runnable-false-class-dynamicsmodel-protocol-protocol-for-plant-dynamics-models-def-compute-dynamics-self-state-np-ndarray-control-input-np-ndarray-time-float-0-0-kwargs-any-dynamicsresult-compute-system-dynamics-at-given-state-and-input-def-get-physics-matrices-self-state-np-ndarray-tuple-np-ndarray-np-ndarray-np-ndarray-get-physics-matrices-m-c-g-at-current-state-def-validate-state-self-state-np-ndarray-bool-validate-state-vector-format-and-bounds-def-get-state-dimension-self-int-get-dimension-of-state-vector-def-get-control-dimension-self-int-get-dimension-of-control-input-vector">runnable: false class DynamicsModel(Protocol): â€œâ€â€Protocol for plant dynamics models.â€â€â€ def compute_dynamics( self, state: np.ndarray, control_input: np.ndarray, time: float = 0.0, **kwargs: Any ) -&gt; DynamicsResult: â€œâ€â€Compute system dynamics at given state and input.â€â€â€ â€¦ def get_physics_matrices( self, state: np.ndarray ) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]: â€œâ€â€Get physics matrices M, C, G at current state.â€â€â€ â€¦ def validate_state(self, state: np.ndarray) -&gt; bool: â€œâ€â€Validate state vector format and bounds.â€â€â€ â€¦ def get_state_dimension(self) -&gt; int: â€œâ€â€Get dimension of state vector.â€â€â€ â€¦ def get_control_dimension(self) -&gt; int: â€œâ€â€Get dimension of control input vector.â€â€â€ â€¦</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#runnable-false-abstractmethod">runnable: false @abstractmethod</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#runnable-false-class-orchestrator-abc-base-interface-for-simulation-execution-strategies-abstractmethod-def-execute-self-initial-state-np-ndarray-control-inputs-np-ndarray-dt-float-horizon-int-kwargs-resultcontainer-execute-simulation-with-specified-strategy-pass">runnable: false class Orchestrator(ABC): â€œâ€â€Base interface for simulation execution strategies.â€â€â€ @abstractmethod def execute( self, initial_state: np.ndarray, control_inputs: np.ndarray, dt: float, horizon: int, **kwargs ) -&gt; ResultContainer: â€œâ€â€Execute simulation with specified strategy.â€â€â€ pass</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#runnable-false-class-batchorchestrator-baseorchestrator-batch-simulation-orchestrator-for-vectorized-execution-def-execute-self-initial-state-np-ndarray-control-inputs-np-ndarray-dt-float-horizon-int-kwargs-resultcontainer-execute-batch-simulation">runnable: false class BatchOrchestrator(BaseOrchestrator): â€œâ€â€Batch simulation orchestrator for vectorized execution.â€â€â€ def execute( self, initial_state: np.ndarray, control_inputs: np.ndarray, dt: float, horizon: int, **kwargs ) -&gt; ResultContainer: â€œâ€â€Execute batch simulation.â€â€â€</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#step-1-load-configuration">STEP 1: Load Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#id4">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#step-2-create-controller">STEP 2: Create Controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#id5">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#step-3-create-dynamics-model">STEP 3: Create Dynamics Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#id6">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#step-4-run-simulation">STEP 4: Run Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#id7">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#step-5-analyze-results">STEP 5: Analyze Results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#id8">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#step-6-plot-results">STEP 6: Plot Results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#id9">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/performance_benchmarks.html">Performance Benchmarks Reference <strong>Status:</strong> ğŸš§ Under Construction This document will contain performance benchmarking documentation including: ## Planned Content ### Benchmark Methodology</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/configuration_schema.html">Configuration Schema Reference <strong>Status:</strong> ğŸš§ Under Construction This document will contain configuration schema documentation including: ## Planned Content ### YAML Configuration Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_1_completion_report.html">Phase 4.1 Controller API Documentation Completion Report <strong>Date:</strong> 2025-10-07</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_1_completion_report.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_1_completion_report.html#runnable-false">runnable: false</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_1_completion_report.html#examples-section">Examples section</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_2_completion_report.html">Phase 4.2 Completion Report: Factory System API Documentation <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_2_completion_report.html#tests-test-factory-examples-py-import-pytest">tests/test_factory_examples.py import pytest</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_3_progress_report.html">Phase 4.3 Progress Report: Optimization Module API Documentation <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_3_progress_report.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_3_progress_report.html#runnable-false-def-optimize-bounds-for-controller-self-controller-type-smctype-strategy-boundsoptimizationstrategy-boundsoptimizationstrategy-hybrid-max-optimization-time-float-300-0">runnable: false def optimize_bounds_for_controller( self, controller_type: SMCType, strategy: BoundsOptimizationStrategy = BoundsOptimizationStrategy.HYBRID, max_optimization_time: float = 300.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_3_completion_report.html">Phase 4.3 Completion Report: Optimization Module API Documentation <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_4_completion_report.html">Phase 4.4 Completion Report: Simulation Engine API Documentation <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../architecture.html">3. System Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../architecture_control_room.html">System Architecture Control Room</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../benchmarks/index.html">Performance Benchmarks</a><input aria-label="Toggle navigation of Performance Benchmarks" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../benchmarks/controller_performance_benchmarks.html">Controller Performance Benchmarks with Statistical Analysis <strong>Project:</strong> Double-Inverted Pendulum Sliding Mode Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../benchmarks/phase_3_2_completion_report.html">Phase 3.2 Completion Report: Controller Performance Benchmarks <strong>Project:</strong> Double-Inverted Pendulum Sliding Mode Control</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html">Benchmarks &amp; Methodology This project includes benchmarking features for statistical analysis and performance comparison of sliding mode controllers. The benchmarking system provides standardized evaluation protocols and robust statistical metrics. ## Overview The benchmarking framework evaluates controllers across multiple dimensions: - <strong>Performance metrics</strong>: ISE, ITAE, RMS control effort, overshoot, constraint violations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#base-seed-for-reproducibility">Base seed for reproducibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#configurable-noise-standard-deviation">Configurable noise standard deviation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#example-5-degree-initial-angle-variation">Example: Â±5 degree initial angle variation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#test-with-physics-uncertainty-and-sensor-noise">Test with physics uncertainty and sensor noise</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#runnable-false-controllers-classical-smc-sta-smc-adaptive-smc">runnable: false controllers = [â€˜classical_smcâ€™, â€˜sta_smcâ€™, â€˜adaptive_smcâ€™]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#runnable-false-benchmark-metadata-timestamp-datetime-now-isoformat-config-hash-hashlib-md5-config-content-hexdigest-random-seed-1234-n-trials-30-environment-python-version-sys-version-numpy-version-np-version-platform-platform-platform">runnable: false benchmark_metadata = { â€˜timestampâ€™: datetime.now().isoformat(), â€˜config_hashâ€™: hashlib.md5(config_content).hexdigest(), â€˜random_seedâ€™: 1234, â€˜n_trialsâ€™: 30, â€˜environmentâ€™: { â€˜python_versionâ€™: sys.version, â€˜numpy_versionâ€™: np.<strong>version</strong>, â€˜platformâ€™: platform.platform() }</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bibliography.html">Bibliography &amp; Academic References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../claude-backup.html">Automated Git Backup System</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html">Configuration Integration Documentation ## Overview This document provides guidance on integrating the configuration system with the Enterprise Controller Factory. The DIP SMC-PSO project features a sophisticated configuration architecture that supports multiple sources, type safety, validation, and integration with controller creation workflows. ## Table of Contents 1. <span class="xref myst">Configuration Architecture</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#config-yaml-complete-configuration-example-global-settings">config.yaml - Complete configuration example # Global settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#runnable-false-from-pydantic-import-basemodel-field-validator">runnable: false from pydantic import BaseModel, Field, validator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#runnable-false-def-resolve-controller-gains-gains-optional-union-list-float-np-ndarray-config-optional-any-controller-type-str-controller-info-dict-str-any">runnable: false def _resolve_controller_gains( gains: Optional[Union[List[float], np.ndarray]], config: Optional[Any], controller_type: str, controller_info: Dict[str, Any]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#runnable-false-nested-dictionary-configuration">runnable: false # Nested dictionary configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#runnable-false-class-attributeconfig-configuration-using-attributes-def-init-self-create-controller-configurations-as-attributes-self-classical-smc-type-config-gains-25-20-15-10-40-6-max-force-160-0-boundary-layer-0-025-dt-0-001-self-adaptive-smc-type-config-gains-30-22-18-12-5-0-max-force-160-0-dt-0-001-leak-rate-0-02-initialize-controllers-namespace">runnable: false class AttributeConfig: â€œâ€â€Configuration using attributes.â€â€â€ def <strong>init</strong>(self): # Create controller configurations as attributes self.classical_smc = type(â€˜Configâ€™, (), { â€˜gainsâ€™: [25, 20, 15, 10, 40, 6], â€˜max_forceâ€™: 160.0, â€˜boundary_layerâ€™: 0.025, â€˜dtâ€™: 0.001 })() self.adaptive_smc = type(â€˜Configâ€™, (), { â€˜gainsâ€™: [30, 22, 18, 12, 5.0], â€˜max_forceâ€™: 160.0, â€˜dtâ€™: 0.001, â€˜leak_rateâ€™: 0.02 })() # Initialize controllers namespace</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#generated-configuration-for-system-name">Generated configuration for {{ system_name }}</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_schema_validation.html">Configuration Schema Validation Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_schema_validation.html#config-yaml-master-configuration-file">config.yaml - Master Configuration File</a></li>
<li class="toctree-l1"><a class="reference internal" href="../context.html">2. Application Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../control_law_testing_standards.html">Control Law Testing Standards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../controller_pso_interface_api_documentation.html">Controller-PSO Interface API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coverage_analysis_methodology.html">Coverage Analysis Methodology Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coverage_analysis_methodology.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coverage_analysis_methodology.html#runnable-false-mathematical-model-for-isolated-coverage">runnable: false # Mathematical Model for Isolated Coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deployment/DEPLOYMENT_GUIDE.html">ğŸš€ Sphinx Documentation System - Deployment Guide ## âœ… System Successfully Deployed! Your production-grade Sphinx documentation system is now <strong>ready for use</strong>. All expert recommendations have been implemented and the system has been committed to your repository. ## ğŸ“‹ Next Steps for Activation ### 1. GitHub Repository Settings To activate the documentation system, configure these GitHub settings: #### <strong>GitHub Pages:</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../deployment/STREAMLIT_DEPLOYMENT.html">Streamlit Deployment Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deployment/docker.html">Docker Deployment Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deployment_validation_checklists.html">Deployment Validation Checklists and Quality Gates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../documentation_structure.html">Documentation Structure &amp; Site Map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault_detection_guide.html">Fault Detection &amp; Isolation (FDI) Guide ## Overview The DIP_SMC_PSO system includes a Fault Detection and Isolation (FDI) module that monitors system health in real-time. The FDI system compares model predictions with actual measurements to detect deviations that may indicate component failures, sensor faults, or unexpected disturbances. ## Architecture The FDI system uses a <strong>model-based residual approach</strong>: ```</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault_detection_system_documentation.html">Fault Detection and Isolation (FDI) System - Technical Documentation ## Table of Contents 1. <span class="xref myst">Mathematical Foundations</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="../fdi_threshold_calibration_methodology.html">FDI Threshold Calibration Methodology <strong>Issue</strong>: #18 - FDI Threshold Too Sensitive - False Positives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/getting-started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/getting-started.html#or-on-some-systems">OR on some systems:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/getting-started.html#clone-repository">Clone repository</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/getting-started.html#you-should-see-simulate-py-config-yaml-src-tests-docs-etc">You should see: simulate.py, config.yaml, src/, tests/, docs/, etc.</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/getting-started-validation-report.html">Getting Started Guide Validation Report <strong>Phase 5.1: Getting Started Guide Validation</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../hil_quickstart.html">Hardware-in-the-Loop (HIL) Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html">Mathematical Algorithm Validation Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#runnable-false-def-compute-control-self-state-np-ndarray-target-np-ndarray-float-compute-smc-control-signal-extract-state-variables-theta1-theta2-x-theta1-dot-theta2-dot-x-dot-state-compute-errors-e1-theta1-target-0-position-error-pendulum-1-e2-theta2-target-1-position-error-pendulum-2-e1-dot-theta1-dot-target-3-velocity-error-pendulum-1-e2-dot-theta2-dot-target-4-velocity-error-pendulum-2-sliding-surface-s-1e1-2e2-e1-e2-s-self-lambda1-e1-self-lambda2-e2-e1-dot-e2-dot-control-law-u-u-eq-u-sw-u-equivalent-self-compute-equivalent-control-state-target-u-switching-self-k-np-sign-s-return-u-equivalent-u-switching">runnable: false def compute_control(self, state: np.ndarray, target: np.ndarray) -&gt; float: â€œâ€â€Compute SMC control signal.â€â€â€ # Extract state variables theta1, theta2, x, theta1_dot, theta2_dot, x_dot = state # Compute errors e1 = theta1 - target[0] # Position error pendulum 1 e2 = theta2 - target[1] # Position error pendulum 2 e1_dot = theta1_dot - target[3] # Velocity error pendulum 1 e2_dot = theta2_dot - target[4] # Velocity error pendulum 2 # Sliding surface: s = Î»â‚eâ‚ + Î»â‚‚eâ‚‚ + Ä—â‚ + Ä—â‚‚ s = self.lambda1 * e1 + self.lambda2 * e2 + e1_dot + e2_dot # Control law: u = u_eq + u_sw u_equivalent = self._compute_equivalent_control(state, target) u_switching = -self.K * np.sign(s) return u_equivalent + u_switching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#runnable-false-def-compute-control-self-state-np-ndarray-target-np-ndarray-float-compute-super-twisting-control-signal-compute-sliding-surface-s-self-compute-sliding-surface-state-target-super-twisting-control-law-u1-1-s-1-2-sign-s-u1-self-alpha1-np-power-np-abs-s-0-5-np-sign-s-u2-2-sign-s-dt-self-integral-term-self-alpha2-np-sign-s-self-dt-return-u1-self-integral-term">runnable: false def compute_control(self, state: np.ndarray, target: np.ndarray) -&gt; float: â€œâ€â€Compute Super-Twisting control signal.â€â€â€ # Compute sliding surface s = self._compute_sliding_surface(state, target) # Super-Twisting control law # uâ‚ = -Î±â‚|s|^(1/2) sign(s) u1 = -self.alpha1 * np.power(np.abs(s), 0.5) * np.sign(s) # uâ‚‚ = âˆ«(-Î±â‚‚ sign(s)) dt self.integral_term += -self.alpha2 * np.sign(s) * self.dt return u1 + self.integral_term</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#runnable-false-def-update-particles-self-update-particle-velocities-and-positions-for-i-in-range-self-n-particles-random-coefficients-r1-r2-np-random-random-2-velocity-update-with-constriction-factor-self-velocities-i-self-chi-self-w-self-velocities-i-self-c1-r1-self-personal-best-positions-i-self-positions-i-self-c2-r2-self-global-best-position-self-positions-i-position-update-self-positions-i-self-velocities-i-boundary-handling-self-positions-i-np-clip-self-positions-i-self-bounds-min-self-bounds-max">runnable: false def update_particles(self): â€œâ€â€Update particle velocities and positions.â€â€â€ for i in range(self.n_particles): # Random coefficients r1, r2 = np.random.random(2) # Velocity update with constriction factor self.velocities[i] = self.chi * ( self.w * self.velocities[i] + self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i]) + self.c2 * r2 * (self.global_best_position - self.positions[i]) ) # Position update self.positions[i] += self.velocities[i] # Boundary handling self.positions[i] = np.clip(self.positions[i], self.bounds_min, self.bounds_max)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#runnable-false-class-testmathematicalcorrectness-test-mathematical-properties-of-implementations-def-test-lyapunov-function-properties-self-test-lyapunov-function-is-positive-definite-controller-classicalsmc-for-in-range-1000-state-np-random-uniform-6-v-controller-compute-lyapunov-function-state-property-1-v-0-assert-v-0-property-2-v-0-only-at-equilibrium-if-not-np-allclose-state-0-assert-v-0-def-test-sliding-surface-stability-self-test-sliding-surface-leads-to-stable-dynamics-controller-classicalsmc-lambda1-2-0-lambda2-1-5-test-exponential-stability-on-sliding-surface-dt-0-01-times-np-arange-0-5-dt-for-initial-error-in-0-1-0-5-1-0-e1-history-initial-error-e2-history-initial-error-for-t-in-times-1-sliding-dynamics-e1-1e1-0-e2-2e2-0-e1-new-e1-history-1-np-exp-controller-lambda1-dt-e2-new-e2-history-1-np-exp-controller-lambda2-dt-e1-history-append-e1-new-e2-history-append-e2-new-verify-exponential-decay-assert-e1-history-1-0-01-initial-error-assert-e2-history-1-0-01-initial-error">runnable: false class TestMathematicalCorrectness: â€œâ€â€Test mathematical properties of implementations.â€â€â€ def test_lyapunov_function_properties(self): â€œâ€â€Test Lyapunov function is positive definite.â€â€â€ controller = ClassicalSMC() for _ in range(1000): state = np.random.uniform(-Ï€, Ï€, 6) V = controller.compute_lyapunov_function(state) # Property 1: V â‰¥ 0 assert V &gt;= 0 # Property 2: V = 0 only at equilibrium if not np.allclose(state, 0): assert V &gt; 0 def test_sliding_surface_stability(self): â€œâ€â€Test sliding surface leads to stable dynamics.â€â€â€ controller = ClassicalSMC(lambda1=2.0, lambda2=1.5) # Test exponential stability on sliding surface dt = 0.01 times = np.arange(0, 5, dt) for initial_error in [0.1, 0.5, 1.0]: e1_history = [initial_error] e2_history = [initial_error] for t in times[1:]: # Sliding dynamics: Ä—â‚ + Î»â‚eâ‚ = 0, Ä—â‚‚ + Î»â‚‚eâ‚‚ = 0 e1_new = e1_history[-1] * np.exp(-controller.lambda1 * dt) e2_new = e2_history[-1] * np.exp(-controller.lambda2 * dt) e1_history.append(e1_new) e2_history.append(e2_new) # Verify exponential decay assert e1_history[-1] &lt; 0.01 * initial_error assert e2_history[-1] &lt; 0.01 * initial_error</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#id4">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#runnable-false-def-test-end-to-end-mathematical-properties-test-mathematical-properties-in-complete-system-initialize-system-system-doubleinvertedpendulum-controller-classicalsmc-initial-condition-away-from-equilibrium-x0-np-array-0-2-0-1-0-0-0-0-0-0-0-0-target-np-zeros-6-simulate-system-trajectory-simulate-system-system-controller-x0-target-t-final-10-0-mathematical-property-verification-1-verify-lyapunov-function-decreases-v-values-controller-compute-lyapunov-function-state-for-state-in-trajectory-states-assert-np-all-np-diff-v-values-0-lyapunov-function-must-be-non-increasing-2-verify-convergence-to-target-final-error-np-linalg-norm-trajectory-states-1-target-assert-final-error-0-01-f-final-error-final-error-too-large-3-verify-control-signal-bounds-max-control-np-max-np-abs-trajectory-controls-assert-max-control-controller-u-max-control-signal-exceeds-limits">runnable: false def test_end_to_end_mathematical_properties(): â€œâ€â€Test mathematical properties in complete system.â€â€â€ # Initialize system system = DoubleInvertedPendulum() controller = ClassicalSMC() # Initial condition away from equilibrium x0 = np.array([0.2, 0.1, 0.0, 0.0, 0.0, 0.0]) target = np.zeros(6) # Simulate system trajectory = simulate_system(system, controller, x0, target, t_final=10.0) # Mathematical property verification # 1. Verify Lyapunov function decreases V_values = [controller.compute_lyapunov_function(state) for state in trajectory.states] assert np.all(np.diff(V_values) &lt;= 0), â€œLyapunov function must be non-increasingâ€ # 2. Verify convergence to target final_error = np.linalg.norm(trajectory.states[-1] - target) assert final_error &lt; 0.01, fâ€Final error {final_error} too largeâ€ # 3. Verify control signal bounds max_control = np.max(np.abs(trajectory.controls)) assert max_control &lt;= controller.u_max, â€œControl signal exceeds limitsâ€</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../mathematical_foundations/index.html">Mathematical Foundations</a><input aria-label="Toggle navigation of Mathematical Foundations" class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/README.html">SMC Mathematical Foundations Documentation This directory contains mathematical documentation for all SMC algorithm fixes and validation methodology implemented for GitHub Issue #5. ## ğŸ“‹ Documentation Overview This mathematical foundation documentation provides: - <strong>Complete mathematical theory</strong> behind all SMC algorithm implementations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/smc_complete_theory.html">Complete Sliding Mode Control Mathematical Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/smc_theory.html">SMC Mathematical Theory Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/sliding_surface_analysis.html">Sliding Surface Mathematical Properties and Stability Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/boundary_layer_derivations.html">Boundary Layer Mathematical Derivations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/controller_comparison_theory.html">SMC Controller Comparison Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html">Advanced Algorithms Guide <strong>Technical Reference for Optimization, Numerical Stability, and Algorithm Comparison</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#configure-inertia-weight-schedule-in-config-yaml">Configure inertia weight schedule in config.yaml:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#pso">pso:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#w-schedule-0-9-0-4-start-at-0-9-end-at-0-4">w_schedule: [0.9, 0.4] # Start at 0.9, end at 0.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#iters-100">iters: 100</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#n-particles-30-result-tuner-optimise-uses-w-schedule-from-config-manual-iteration-loop-for-custom-control">n_particles: 30 result = tuner.optimise() # Uses w_schedule from config # Manual iteration loop for custom control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#runnable-false-configure-physics-uncertainty-in-config-yaml">runnable: false # Configure physics uncertainty in config.yaml:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#physics-uncertainty">physics_uncertainty:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#n-evals-5-5-perturbed-models-per-evaluation">n_evals: 5 # 5 perturbed models per evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#cart-mass-0-10-10">cart_mass: 0.10 # Â±10%</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#pendulum1-mass-0-15-15">pendulum1_mass: 0.15 # Â±15%</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#pendulum2-mass-0-15-15">pendulum2_mass: 0.15 # Â±15%</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#pendulum1-length-0-05-5">pendulum1_length: 0.05 # Â±5%</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#pendulum2-length-0-05-5-tuner-psotuner-controller-factory-controller-factory-config-config-seed-42">pendulum2_length: 0.05 # Â±5% tuner = PSOTuner( controller_factory=controller_factory, config=config, seed=42</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#cost-aggregation-0-7-mean-0-3-max">Cost aggregation: 0.7 * mean + 0.3 * max</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html">SMC Algorithm Fixes and Mathematical Validation Summary This document provides a summary of all mathematical algorithm fixes, validation improvements, and corrected implementations in the SMC controller system for GitHub Issue #5. ## 1. Executive Summary The SMC mathematical foundation has been completely restructured and validated with the following major improvements: - <strong>Boundary Layer Mathematics</strong>: Corrected chattering reduction theory and implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-compute-switching-function-self-surface-value-float-float-compute-continuous-switching-function-with-adaptive-boundary-layer-adaptive-boundary-layer-thickness-surface-derivative-self-get-surface-derivative-effective-thickness-self-base-thickness-self-slope-abs-surface-derivative-continuous-switching-approximation-if-self-switch-method-tanh-return-np-tanh-surface-value-effective-thickness-elif-self-switch-method-linear-return-np-clip-surface-value-effective-thickness-1-0-1-0-else-sign-return-np-sign-surface-value-3-validation-rules-python-if-thickness-0-raise-valueerror-boundary-layer-thickness-must-be-positive-if-slope-0-raise-valueerror-boundary-layer-slope-must-be-non-negative-mathematical-impact">runnable: false def compute_switching_function(self, surface_value: float) -&gt; float: â€œâ€â€Compute continuous switching function with adaptive boundary layer.â€â€â€ # Adaptive boundary layer thickness surface_derivative = self._get_surface_derivative() effective_thickness = self.base_thickness + self.slope * abs(surface_derivative) # Continuous switching approximation if self.switch_method == â€œtanhâ€: return np.tanh(surface_value / effective_thickness) elif self.switch_method == â€œlinearâ€: return np.clip(surface_value / effective_thickness, -1.0, 1.0) else: # â€œsignâ€ return np.sign(surface_value) <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Validation</span> <span class="pre">Rules:**</span></code>python if thickness &lt;= 0: raise ValueError(â€œBoundary layer thickness must be positiveâ€) if slope &lt; 0: raise ValueError(â€œBoundary layer slope must be non-negativeâ€) ``` <strong>Mathematical Impact:</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-compute-self-state-np-ndarray-float-compute-linear-sliding-surface-with-numerical-safeguards-input-validation-if-len-state-6-raise-valueerror-state-must-have-at-least-6-elements-handle-non-finite-values-if-not-np-all-np-isfinite-state-state-np-where-np-isfinite-state-state-0-0-extract-components-theta1-theta1-dot-state-2-state-3-theta2-theta2-dot-state-4-state-5-linear-sliding-surface-s-11-k11-22-k22-s-self-lam1-theta1-dot-self-k1-theta1-self-lam2-theta2-dot-self-k2-theta2-numerical-safety-return-0-0-if-not-np-isfinite-s-else-float-s-2-stability-analysis-integration-python">runnable: false def compute(self, state: np.ndarray) -&gt; float: â€œâ€â€Compute linear sliding surface with numerical safeguards.â€â€â€ # Input validation if len(state) &lt; 6: raise ValueError(â€œState must have at least 6 elementsâ€) # Handle non-finite values if not np.all(np.isfinite(state)): state = np.where(np.isfinite(state), state, 0.0) # Extract components theta1, theta1_dot = state[2], state[3] theta2, theta2_dot = state[4], state[5] # Linear sliding surface: s = Î»â‚Î¸Ì‡â‚ + kâ‚Î¸â‚ + Î»â‚‚Î¸Ì‡â‚‚ + kâ‚‚Î¸â‚‚ s = (self.lam1 * theta1_dot + self.k1 * theta1 + self.lam2 * theta2_dot + self.k2 * theta2) # Numerical safety return 0.0 if not np.isfinite(s) else float(s) <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Stability</span> <span class="pre">Analysis</span> <span class="pre">Integration:**</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-validate-gains-self-none-validate-gains-according-to-hurwitz-stability-requirements-check-finite-values-if-not-np-all-np-isfinite-self-gains-invalid-indices-np-where-np-isfinite-self-gains-0-raise-valueerror-f-gains-contain-nan-infinite-values-at-indices-invalid-indices-positivity-requirement-for-stability-if-len-self-gains-4-if-any-g-0-for-g-in-self-gains-4-raise-valueerror-surface-gains-k1-k2-1-2-must-be-positive-for-stability-minimum-threshold-for-numerical-stability-if-any-g-1e-12-for-g-in-self-gains-4-raise-valueerror-gains-too-small-min-1e-12-numerical-instability-risk-3-mathematical-property-verification-linearity-s-x1-x2-s-x1-s-x2-homogeneity-s-x-s-x-continuity-lim-xx0-s-x-s-x0-differentiability-ds-dt-exists-and-is-computable-mathematical-impact">runnable: false def _validate_gains(self) -&gt; None: â€œâ€â€Validate gains according to Hurwitz stability requirements.â€â€â€ # Check finite values if not np.all(np.isfinite(self.gains)): invalid_indices = np.where(~np.isfinite(self.gains))[0] raise ValueError(fâ€Gains contain NaN/infinite values at indices: {invalid_indices}â€) # Positivity requirement for stability if len(self.gains) &gt;= 4: if any(g &lt;= 0 for g in self.gains[:4]): raise ValueError(â€œSurface gains [k1, k2, Î»1, Î»2] must be positive for stabilityâ€) # Minimum threshold for numerical stability if any(g &lt; 1e-12 for g in self.gains[:4]): raise ValueError(â€œGains too small (min: 1e-12) - numerical instability riskâ€) ``` 3. <strong>Mathematical Property Verification:</strong> - <strong>Linearity</strong>: <code class="docutils literal notranslate"><span class="pre">s(Î±xâ‚</span> <span class="pre">+</span> <span class="pre">Î²xâ‚‚)</span> <span class="pre">=</span> <span class="pre">Î±s(xâ‚)</span> <span class="pre">+</span> <span class="pre">Î²s(xâ‚‚)</span></code> - <strong>Homogeneity</strong>: <code class="docutils literal notranslate"><span class="pre">s(Î±x)</span> <span class="pre">=</span> <span class="pre">Î±s(x)</span></code> - <strong>Continuity</strong>: <code class="docutils literal notranslate"><span class="pre">lim_{xâ†’xâ‚€}</span> <span class="pre">s(x)</span> <span class="pre">=</span> <span class="pre">s(xâ‚€)</span></code> - <strong>Differentiability</strong>: <code class="docutils literal notranslate"><span class="pre">ds/dt</span></code> exists and is computable <strong>Mathematical Impact:</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-dataclass-frozen-true-class-classicalsmcconfig-type-safe-configuration-with-mathematical-validation-def-post-init-self-validate-configuration-after-creation-self-validate-gains-self-validate-parameters-self-validate-mathematical-constraints-def-validate-gains-self-none-validate-gain-vector-according-to-smc-theory-if-len-self-gains-6-raise-valueerror-classical-smc-requires-exactly-6-gains-k1-k2-lam1-lam2-k-kd-self-gains-surface-gains-positive-for-hurwitz-stability-if-any-g-0-for-g-in-k1-k2-lam1-lam2-raise-valueerror-surface-gains-must-be-positive-for-stability-switching-gain-positive-for-reaching-condition-if-k-0-raise-valueerror-switching-gain-k-must-be-positive-derivative-gain-non-negative-for-damping-if-kd-0-raise-valueerror-derivative-gain-kd-must-be-non-negative-def-validate-mathematical-constraints-self-none-validate-constraints-from-mathematical-theory-damping-ratio-bounds-for-each-subsystem-zeta1-self-lam1-2-np-sqrt-self-k1-zeta2-self-lam2-2-np-sqrt-self-k2-if-zeta1-0-1-or-zeta2-0-1-raise-valueerror-damping-ratios-too-low-may-cause-oscillations-if-zeta1-10-0-or-zeta2-10-0-raise-valueerror-damping-ratios-too-high-may-cause-sluggish-response-2-edge-case-handling-python-def-get-effective-controllability-threshold-self-float-auto-compute-threshold-based-on-system-parameters-if-self-controllability-threshold-is-not-none-return-self-controllability-threshold-scale-with-surface-gains-for-adaptive-behavior-base-threshold-0-05-self-k1-self-k2-bound-within-reasonable-limits-return-np-clip-base-threshold-0-01-1-0-mathematical-impact">runnable: false @dataclass(frozen=True) class ClassicalSMCConfig: â€œâ€â€Type-safe configuration with mathematical validation.â€â€â€ def <strong>post_init</strong>(self): â€œâ€â€Validate configuration after creation.â€â€â€ self._validate_gains() self._validate_parameters() self._validate_mathematical_constraints() def _validate_gains(self) -&gt; None: â€œâ€â€Validate gain vector according to SMC theory.â€â€â€ if len(self.gains) != 6: raise ValueError(â€œClassical SMC requires exactly 6 gainsâ€) k1, k2, lam1, lam2, K, kd = self.gains # Surface gains: positive for Hurwitz stability if any(g &lt;= 0 for g in [k1, k2, lam1, lam2]): raise ValueError(â€œSurface gains must be positive for stabilityâ€) # Switching gain: positive for reaching condition if K &lt;= 0: raise ValueError(â€œSwitching gain K must be positiveâ€) # Derivative gain: non-negative for damping if kd &lt; 0: raise ValueError(â€œDerivative gain kd must be non-negativeâ€) def _validate_mathematical_constraints(self) -&gt; None: â€œâ€â€Validate constraints from mathematical theory.â€â€â€ # Damping ratio bounds for each subsystem zeta1 = self.lam1 / (2 * np.sqrt(self.k1)) zeta2 = self.lam2 / (2 * np.sqrt(self.k2)) if zeta1 &lt; 0.1 or zeta2 &lt; 0.1: raise ValueError(â€œDamping ratios too low - may cause oscillationsâ€) if zeta1 &gt; 10.0 or zeta2 &gt; 10.0: raise ValueError(â€œDamping ratios too high - may cause sluggish responseâ€) <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Edge</span> <span class="pre">Case</span> <span class="pre">Handling:**</span></code>python def get_effective_controllability_threshold(self) -&gt; float: â€œâ€â€Auto-compute threshold based on system parameters.â€â€â€ if self.controllability_threshold is not None: return self.controllability_threshold # Scale with surface gains for adaptive behavior base_threshold = 0.05 * (self.k1 + self.k2) # Bound within reasonable limits return np.clip(base_threshold, 0.01, 1.0) ``` <strong>Mathematical Impact:</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-given-gains-st-lists-st-floats-min-value-0-1-max-value-50-0-min-size-4-max-size-4-state-st-lists-st-floats-min-value-10-0-max-value-10-0-min-size-6-max-size-6-def-test-sliding-surface-linearity-property-self-gains-state-test-linearity-property-for-all-valid-parameter-combinations-surface-linearslidingsurface-gains-state1-np-array-state-state2-np-random-uniform-10-10-6-s1-surface-compute-state1-s2-surface-compute-state2-s-combined-surface-compute-state1-state2-mathematical-property-s-x1-x2-s-x1-s-x2-assert-abs-s-combined-s1-s2-1e-10-2-boundary-layer-monotonicity-python">runnable: false @given( gains=st.lists(st.floats(min_value=0.1, max_value=50.0), min_size=4, max_size=4), state=st.lists(st.floats(min_value=-10.0, max_value=10.0), min_size=6, max_size=6) ) def test_sliding_surface_linearity_property(self, gains, state): â€œâ€â€Test linearity property for all valid parameter combinations.â€â€â€ surface = LinearSlidingSurface(gains) state1 = np.array(state) state2 = np.random.uniform(-10, 10, 6) s1 = surface.compute(state1) s2 = surface.compute(state2) s_combined = surface.compute(state1 + state2) # Mathematical property: s(x1 + x2) = s(x1) + s(x2) assert abs(s_combined - (s1 + s2)) &lt; 1e-10 <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Boundary</span> <span class="pre">Layer</span> <span class="pre">Monotonicity:**</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-test-boundary-layer-monotonicity-all-methods-self-test-monotonicity-for-all-switching-methods-methods-tanh-linear-sign-for-method-in-methods-boundary-layer-boundarylayer-thickness-0-1-switch-method-method-s-values-np-linspace-2-2-1000-switch-values-boundary-layer-compute-switching-function-s-for-s-in-s-values-must-be-monotonically-increasing-for-i-in-range-len-switch-values-1-assert-switch-values-i-1-switch-values-i-3-configuration-validation-coverage-python">runnable: false def test_boundary_layer_monotonicity_all_methods(self): â€œâ€â€Test monotonicity for all switching methods.â€â€â€ methods = [â€œtanhâ€, â€œlinearâ€, â€œsignâ€] for method in methods: boundary_layer = BoundaryLayer(thickness=0.1, switch_method=method) s_values = np.linspace(-2, 2, 1000) switch_values = [boundary_layer.compute_switching_function(s) for s in s_values] # Must be monotonically increasing for i in range(len(switch_values) - 1): assert switch_values[i+1] &gt;= switch_values[i] <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Configuration</span> <span class="pre">Validation</span> <span class="pre">Coverage:**</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-class-testconfigurationvalidationcoverage-coverage-of-all-validation-rules-pytest-mark-parametrize-invalid-gain-index-0-1-2-3-def-test-zero-surface-gains-rejection-self-invalid-gain-index-test-rejection-of-zero-surface-gains-gains-5-0-3-0-4-0-2-0-10-0-1-0-gains-invalid-gain-index-0-0-with-pytest-raises-valueerror-match-must-be-positive-classicalsmcconfig-gains-gains-max-force-100-dt-0-01-boundary-layer-0-01-pytest-mark-parametrize-invalid-gain-index-0-1-2-3-def-test-negative-surface-gains-rejection-self-invalid-gain-index-test-rejection-of-negative-surface-gains-gains-5-0-3-0-4-0-2-0-10-0-1-0-gains-invalid-gain-index-1-0-with-pytest-raises-valueerror-match-must-be-positive-classicalsmcconfig-gains-gains-max-force-100-dt-0-01-boundary-layer-0-01-3-2-numerical-stability-testing-enhanced-numerical-robustness-tests-1-extreme-value-testing-python">runnable: false class TestConfigurationValidationCoverage: â€œâ€â€coverage of all validation rules.â€â€â€ @pytest.mark.parametrize(â€œinvalid_gain_indexâ€, [0, 1, 2, 3]) def test_zero_surface_gains_rejection(self, invalid_gain_index): â€œâ€â€Test rejection of zero surface gains.â€â€â€ gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] gains[invalid_gain_index] = 0.0 with pytest.raises(ValueError, match=â€must be positiveâ€): ClassicalSMCConfig(gains=gains, max_force=100, dt=0.01, boundary_layer=0.01) @pytest.mark.parametrize(â€œinvalid_gain_indexâ€, [0, 1, 2, 3]) def test_negative_surface_gains_rejection(self, invalid_gain_index): â€œâ€â€Test rejection of negative surface gains.â€â€â€ gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] gains[invalid_gain_index] = -1.0 with pytest.raises(ValueError, match=â€must be positiveâ€): ClassicalSMCConfig(gains=gains, max_force=100, dt=0.01, boundary_layer=0.01) <code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">3.2</span> <span class="pre">Numerical</span> <span class="pre">Stability</span> <span class="pre">Testing</span> <span class="pre">**Enhanced</span> <span class="pre">Numerical</span> <span class="pre">Robustness</span> <span class="pre">Tests:**</span> <span class="pre">1.</span> <span class="pre">**Extreme</span> <span class="pre">Value</span> <span class="pre">Testing:**</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id7">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-test-numerical-stability-extreme-values-self-test-behavior-with-extreme-but-valid-parameter-values-very-small-gains-but-above-minimum-threshold-small-gains-1e-10-1e-10-1e-10-1e-10-1e-8-0-0-config-small-classicalsmcconfig-gains-small-gains-max-force-1e-6-dt-1e-6-boundary-layer-1e-8-very-large-gains-large-gains-1e6-1e6-1e6-1e6-1e8-1e4-config-large-classicalsmcconfig-gains-large-gains-max-force-1e8-dt-1e-3-boundary-layer-1-0-both-should-create-valid-controllers-controller-small-modularclassicalsmc-config-config-small-controller-large-modularclassicalsmc-config-config-large-test-with-moderate-state-values-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-result-small-controller-small-compute-control-state-result-large-controller-large-compute-control-state-both-should-produce-finite-bounded-results-assert-np-all-np-isfinite-result-small-get-control-output-0-assert-np-all-np-isfinite-result-large-get-control-output-0-2-precision-consistency-testing-python">runnable: false def test_numerical_stability_extreme_values(self): â€œâ€â€Test behavior with extreme but valid parameter values.â€â€â€ # Very small gains (but above minimum threshold) small_gains = [1e-10, 1e-10, 1e-10, 1e-10, 1e-8, 0.0] config_small = ClassicalSMCConfig(gains=small_gains, max_force=1e-6, dt=1e-6, boundary_layer=1e-8) # Very large gains large_gains = [1e6, 1e6, 1e6, 1e6, 1e8, 1e4] config_large = ClassicalSMCConfig(gains=large_gains, max_force=1e8, dt=1e-3, boundary_layer=1.0) # Both should create valid controllers controller_small = ModularClassicalSMC(config=config_small) controller_large = ModularClassicalSMC(config=config_large) # Test with moderate state values state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) result_small = controller_small.compute_control(state, {}, {}) result_large = controller_large.compute_control(state, {}, {}) # Both should produce finite, bounded results assert np.all(np.isfinite(result_small.get(â€˜control_outputâ€™, [0]))) assert np.all(np.isfinite(result_large.get(â€˜control_outputâ€™, [0]))) <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Precision</span> <span class="pre">Consistency</span> <span class="pre">Testing:**</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id8">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-test-computation-precision-consistency-self-test-that-repeated-computations-maintain-precision-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-state-np-array-0-123456789-0-987654321-0-456789123-0-321654987-0-789123456-0-654987321-compute-control-1000-times-results-for-in-range-1000-result-controller-compute-control-state-control-result-get-control-output-result-get-control-0-results-append-control-results-np-array-results-standard-deviation-should-be-zero-deterministic-computation-std-dev-np-std-results-axis-0-if-results-ndim-1-else-np-std-results-assert-np-all-std-dev-1e-15-machine-precision-level-4-implementation-architecture-improvements-4-1-modular-component-design-before-monolithic-single-458-line-controller-with-mixed-concerns">runnable: false def test_computation_precision_consistency(self): â€œâ€â€Test that repeated computations maintain precision.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) state = np.array([0.123456789, 0.987654321, 0.456789123, 0.321654987, 0.789123456, 0.654987321]) # Compute control 1000 times results = [] for _ in range(1000): result = controller.compute_control(state, {}, {}) control = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, 0)) results.append(control) results = np.array(results) # Standard deviation should be zero (deterministic computation) std_dev = np.std(results, axis=0) if results.ndim &gt; 1 else np.std(results) assert np.all(std_dev &lt; 1e-15) # Machine precision level ``` ## 4. Implementation Architecture Improvements ### 4.1 Modular Component Design <strong>Before (Monolithic):</strong> Single 458-line controller with mixed concerns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id9">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-class-slidingsurface-abc-abstract-interface-for-sliding-surface-calculations-abstractmethod-def-compute-self-state-np-ndarray-float-compute-sliding-surface-value-pass-abstractmethod-def-compute-derivative-self-state-np-ndarray-state-dot-np-ndarray-float-compute-sliding-surface-derivative-pass-abstractmethod-def-validate-gains-self-none-validate-gains-for-mathematical-correctness-pass-class-boundarylayer-interface-for-boundary-layer-implementations-def-compute-switching-function-self-surface-value-float-float-compute-continuous-switching-function-pass-def-compute-switching-control-self-surface-value-float-gain-float-surface-derivative-float-0-0-float-compute-switching-control-with-boundary-layer-pass">runnable: false class SlidingSurface(ABC): â€œâ€â€Abstract interface for sliding surface calculations.â€â€â€ @abstractmethod def compute(self, state: np.ndarray) -&gt; float: â€œâ€â€Compute sliding surface value.â€â€â€ pass @abstractmethod def compute_derivative(self, state: np.ndarray, state_dot: np.ndarray) -&gt; float: â€œâ€â€Compute sliding surface derivative.â€â€â€ pass @abstractmethod def _validate_gains(self) -&gt; None: â€œâ€â€Validate gains for mathematical correctness.â€â€â€ pass class BoundaryLayer: â€œâ€â€Interface for boundary layer implementations.â€â€â€ def compute_switching_function(self, surface_value: float) -&gt; float: â€œâ€â€Compute continuous switching function.â€â€â€ pass def compute_switching_control(self, surface_value: float, gain: float, surface_derivative: float = 0.0) -&gt; float: â€œâ€â€Compute switching control with boundary layer.â€â€â€ pass</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/pso_algorithm_theory.html">Particle Swarm Optimization: Mathematical Theory <strong>Module:</strong> Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/pso_algorithm_theory.html#balanced-recommended-for-smc">Balanced (recommended for SMC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/optimization_landscape_analysis.html">Optimization Landscape Analysis for Controller Gain Tuning</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/dynamics_derivations.html">Double Inverted Pendulum Dynamics: Complete Derivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/numerical_integration_theory.html">Numerical Integration Methods: Theory and Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/simulation_architecture_guide.html">Simulation Architecture Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/config_validation_specification.html">ClassicalSMCConfig Parameters and Validation Rules This document provides specification of the <code class="docutils literal notranslate"><span class="pre">ClassicalSMCConfig</span></code> parameters, their mathematical foundations, validation rules, and edge case handling. ## 1. Configuration Schema Overview The <code class="docutils literal notranslate"><span class="pre">ClassicalSMCConfig</span></code> dataclass provides type-safe, validated configuration for Classical Sliding Mode Control with the following parameter categories: - <strong>Control Parameters</strong>: Core SMC gains and timing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html">Mathematical Test Validation Methodology This document describes the methodology for validating mathematical properties and algorithm correctness in the SMC controller implementations. ## 1. Overview The test validation methodology ensures that all mathematical algorithms and fixes in the SMC system are rigorously validated through: - <strong>Property-based testing</strong>: Verification of mathematical properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-def-test-sliding-surface-linearity-test-that-sliding-surface-is-linear-in-state-surface-linearslidingsurface-gains-5-3-4-2-state1-np-array-0-1-0-1-0-1-0-05-0-05-0-05-state2-np-array-0-2-0-2-0-2-0-1-0-1-0-1-s1-surface-compute-state1-s2-surface-compute-state2-s-combined-surface-compute-state1-state2-linearity-s-x1-x2-s-x1-s-x2-assert-abs-s-combined-s1-s2-1e-10-2-homogeneity-property-python-def-test-sliding-surface-homogeneity-test-that-sliding-surface-is-homogeneous-of-degree-1-surface-linearslidingsurface-gains-5-3-4-2-state-np-array-0-1-0-1-0-1-0-05-0-05-0-05-alpha-2-5-s-original-surface-compute-state-s-scaled-surface-compute-alpha-state-homogeneity-s-x-s-x-assert-abs-s-scaled-alpha-s-original-1e-10-3-gain-sensitivity-python">runnable: false def test_sliding_surface_linearity(): â€œâ€â€Test that sliding surface is linear in state.â€â€â€ surface = LinearSlidingSurface(gains=[5, 3, 4, 2]) state1 = np.array([0.1, 0.1, 0.1, 0.05, 0.05, 0.05]) state2 = np.array([0.2, 0.2, 0.2, 0.1, 0.1, 0.1]) s1 = surface.compute(state1) s2 = surface.compute(state2) s_combined = surface.compute(state1 + state2) # Linearity: s(x1 + x2) = s(x1) + s(x2) assert abs(s_combined - (s1 + s2)) &lt; 1e-10 <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Homogeneity</span> <span class="pre">Property**:</span></code>python def test_sliding_surface_homogeneity(): â€œâ€â€Test that sliding surface is homogeneous of degree 1.â€â€â€ surface = LinearSlidingSurface(gains=[5, 3, 4, 2]) state = np.array([0.1, 0.1, 0.1, 0.05, 0.05, 0.05]) alpha = 2.5 s_original = surface.compute(state) s_scaled = surface.compute(alpha * state) # Homogeneity: s(Î±Â·x) = Î±Â·s(x) assert abs(s_scaled - alpha * s_original) &lt; 1e-10 <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Gain</span> <span class="pre">Sensitivity**:</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-def-test-sliding-surface-gain-sensitivity-test-that-surface-responds-correctly-to-gain-changes-gains1-5-3-4-2-gains2-10-6-8-4-doubled-gains-surface1-linearslidingsurface-gains1-surface2-linearslidingsurface-gains2-state-np-array-0-1-0-1-0-1-0-05-0-05-0-05-s1-surface1-compute-state-s2-surface2-compute-state-surface-value-should-double-with-doubled-gains-assert-abs-s2-2-s1-1e-10-2-1-2-boundary-layer-properties-test-suite-tests-test-controllers-smc-algorithms-classical-test-boundary-layer-py-mathematical-properties-validated-1-continuity-python">runnable: false def test_sliding_surface_gain_sensitivity(): â€œâ€â€Test that surface responds correctly to gain changes.â€â€â€ gains1 = [5, 3, 4, 2] gains2 = [10, 6, 8, 4] # Doubled gains surface1 = LinearSlidingSurface(gains1) surface2 = LinearSlidingSurface(gains2) state = np.array([0.1, 0.1, 0.1, 0.05, 0.05, 0.05]) s1 = surface1.compute(state) s2 = surface2.compute(state) # Surface value should double with doubled gains assert abs(s2 - 2 * s1) &lt; 1e-10 <code class="docutils literal notranslate"><span class="pre">####</span> <span class="pre">2.1.2</span> <span class="pre">Boundary</span> <span class="pre">Layer</span> <span class="pre">Properties</span> <span class="pre">**Test</span> <span class="pre">Suite:**</span> <span class="pre">`tests/test_controllers/smc/algorithms/classical/test_boundary_layer.py`</span> <span class="pre">**Mathematical</span> <span class="pre">Properties</span> <span class="pre">Validated:**</span> <span class="pre">1.</span> <span class="pre">**Continuity**:</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-def-test-boundary-layer-continuity-test-that-boundary-layer-provides-continuous-switching-boundary-layer-boundarylayer-thickness-0-1-switch-method-tanh-test-continuity-at-surface-s-0-epsilon-1e-8-switch-left-boundary-layer-compute-switching-function-epsilon-switch-right-boundary-layer-compute-switching-function-epsilon-switch-center-boundary-layer-compute-switching-function-0-0-values-should-be-very-close-at-the-boundary-assert-abs-switch-left-switch-center-1e-6-assert-abs-switch-right-switch-center-1e-6-2-monotonicity-python-def-test-boundary-layer-monotonicity-test-that-switching-function-is-monotonic-boundary-layer-boundarylayer-thickness-0-1-switch-method-tanh-s-values-np-linspace-1-1-100-switch-values-boundary-layer-compute-switching-function-s-for-s-in-s-values-switching-function-should-be-strictly-increasing-for-i-in-range-len-switch-values-1-assert-switch-values-i-1-switch-values-i-3-asymptotic-behavior-python-def-test-boundary-layer-asymptotic-behavior-test-asymptotic-limits-of-switching-function-boundary-layer-boundarylayer-thickness-0-1-switch-method-tanh-large-positive-surface-value-switch-pos-boundary-layer-compute-switching-function-10-0-assert-abs-switch-pos-1-0-1e-3-large-negative-surface-value-switch-neg-boundary-layer-compute-switching-function-10-0-assert-abs-switch-neg-1-0-1e-3-2-2-configuration-validation-tests-test-suite-tests-test-controllers-smc-algorithms-classical-test-config-validation-py-2-2-1-parameter-validationpython">runnable: false def test_boundary_layer_continuity(): â€œâ€â€Test that boundary layer provides continuous switching.â€â€â€ boundary_layer = BoundaryLayer(thickness=0.1, switch_method=â€tanhâ€) # Test continuity at surface (s=0) epsilon = 1e-8 switch_left = boundary_layer.compute_switching_function(-epsilon) switch_right = boundary_layer.compute_switching_function(epsilon) switch_center = boundary_layer.compute_switching_function(0.0) # Values should be very close at the boundary assert abs(switch_left - switch_center) &lt; 1e-6 assert abs(switch_right - switch_center) &lt; 1e-6 <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Monotonicity**:</span></code>python def test_boundary_layer_monotonicity(): â€œâ€â€Test that switching function is monotonic.â€â€â€ boundary_layer = BoundaryLayer(thickness=0.1, switch_method=â€tanhâ€) s_values = np.linspace(-1, 1, 100) switch_values = [boundary_layer.compute_switching_function(s) for s in s_values] # Switching function should be strictly increasing for i in range(len(switch_values) - 1): assert switch_values[i+1] &gt;= switch_values[i] <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Asymptotic</span> <span class="pre">Behavior**:</span></code>python def test_boundary_layer_asymptotic_behavior(): â€œâ€â€Test asymptotic limits of switching function.â€â€â€ boundary_layer = BoundaryLayer(thickness=0.1, switch_method=â€tanhâ€) # Large positive surface value switch_pos = boundary_layer.compute_switching_function(10.0) assert abs(switch_pos - 1.0) &lt; 1e-3 # Large negative surface value switch_neg = boundary_layer.compute_switching_function(-10.0) assert abs(switch_neg - (-1.0)) &lt; 1e-3 <code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">2.2</span> <span class="pre">Configuration</span> <span class="pre">Validation</span> <span class="pre">Tests</span> <span class="pre">**Test</span> <span class="pre">Suite:**</span> <span class="pre">`tests/test_controllers/smc/algorithms/classical/test_config_validation.py`</span> <span class="pre">####</span> <span class="pre">2.2.1</span> <span class="pre">Parameter</span> <span class="pre">Validation</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-class-testclassicalsmcconfigvalidation-test-configuration-parameter-validation-def-test-positive-gain-requirement-self-test-that-all-surface-gains-must-be-positive-valid-configuration-valid-gains-5-0-3-0-4-0-2-0-10-0-1-0-config-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-01-invalid-zero-gain-with-pytest-raises-valueerror-match-must-be-positive-invalid-gains-0-0-3-0-4-0-2-0-10-0-1-0-classicalsmcconfig-gains-invalid-gains-max-force-100-dt-0-01-boundary-layer-0-01-invalid-negative-gain-with-pytest-raises-valueerror-match-must-be-positive-invalid-gains-5-0-3-0-4-0-2-0-10-0-1-0-classicalsmcconfig-gains-invalid-gains-max-force-100-dt-0-01-boundary-layer-0-01-def-test-switching-gain-validation-self-test-switching-gain-must-be-positive-with-pytest-raises-valueerror-match-switching-gain-k-must-be-positive-invalid-gains-5-0-3-0-4-0-2-0-10-0-1-0-k-0-classicalsmcconfig-gains-invalid-gains-max-force-100-dt-0-01-boundary-layer-0-01-def-test-boundary-layer-validation-self-test-boundary-layer-thickness-validation-valid-boundary-layer-valid-gains-5-0-3-0-4-0-2-0-10-0-1-0-config-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-05-invalid-zero-boundary-layer-with-pytest-raises-valueerror-match-boundary-layer-must-be-positive-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-0-invalid-negative-boundary-layer-with-pytest-raises-valueerror-match-boundary-layer-must-be-positive-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-01">runnable: false class TestClassicalSMCConfigValidation: â€œâ€â€Test configuration parameter validation.â€â€â€ def test_positive_gain_requirement(self): â€œâ€â€Test that all surface gains must be positive.â€â€â€ # Valid configuration valid_gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] config = ClassicalSMCConfig(gains=valid_gains, max_force=100, dt=0.01, boundary_layer=0.01) # Invalid: zero gain with pytest.raises(ValueError, match=â€must be positiveâ€): invalid_gains = [0.0, 3.0, 4.0, 2.0, 10.0, 1.0] ClassicalSMCConfig(gains=invalid_gains, max_force=100, dt=0.01, boundary_layer=0.01) # Invalid: negative gain with pytest.raises(ValueError, match=â€must be positiveâ€): invalid_gains = [5.0, -3.0, 4.0, 2.0, 10.0, 1.0] ClassicalSMCConfig(gains=invalid_gains, max_force=100, dt=0.01, boundary_layer=0.01) def test_switching_gain_validation(self): â€œâ€â€Test switching gain must be positive.â€â€â€ with pytest.raises(ValueError, match=â€Switching gain K must be positiveâ€): invalid_gains = [5.0, 3.0, 4.0, 2.0, -10.0, 1.0] # K &lt; 0 ClassicalSMCConfig(gains=invalid_gains, max_force=100, dt=0.01, boundary_layer=0.01) def test_boundary_layer_validation(self): â€œâ€â€Test boundary layer thickness validation.â€â€â€ # Valid boundary layer valid_gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] config = ClassicalSMCConfig(gains=valid_gains, max_force=100, dt=0.01, boundary_layer=0.05) # Invalid: zero boundary layer with pytest.raises(ValueError, match=â€boundary_layer must be positiveâ€): ClassicalSMCConfig(gains=valid_gains, max_force=100, dt=0.01, boundary_layer=0.0) # Invalid: negative boundary layer with pytest.raises(ValueError, match=â€boundary_layer must be positiveâ€): ClassicalSMCConfig(gains=valid_gains, max_force=100, dt=0.01, boundary_layer=-0.01)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-def-test-hurwitz-stability-check-test-that-gain-combinations-satisfy-hurwitz-stability-def-check-stability-k1-k2-lam1-lam2-check-if-gains-produce-stable-sliding-dynamics-for-each-2x2-subsystem-s2-is-ci-0-stability-requires-i-0-and-ci-0-return-k1-0-and-k2-0-and-lam1-0-and-lam2-0-stable-configuration-stable-gains-5-0-3-0-4-0-2-0-10-0-1-0-config-classicalsmcconfig-gains-stable-gains-max-force-100-dt-0-01-boundary-layer-0-01-assert-check-stability-config-k1-config-k2-config-lam1-config-lam2-check-damping-ratios-zeta1-config-lam1-2-np-sqrt-config-k1-zeta2-config-lam2-2-np-sqrt-config-k2-both-subsystems-should-have-positive-damping-assert-zeta1-0-assert-zeta2-0">runnable: false def test_hurwitz_stability_check(): â€œâ€â€Test that gain combinations satisfy Hurwitz stability.â€â€â€ def check_stability(k1, k2, lam1, lam2): â€œâ€â€Check if gains produce stable sliding dynamics.â€â€â€ # For each 2x2 subsystem: sÂ² + Î»áµ¢s + cáµ¢ = 0 # Stability requires Î»áµ¢ &gt; 0 and cáµ¢ &gt; 0 return k1 &gt; 0 and k2 &gt; 0 and lam1 &gt; 0 and lam2 &gt; 0 # Stable configuration stable_gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] config = ClassicalSMCConfig(gains=stable_gains, max_force=100, dt=0.01, boundary_layer=0.01) assert check_stability(config.k1, config.k2, config.lam1, config.lam2) # Check damping ratios zeta1 = config.lam1 / (2 * np.sqrt(config.k1)) zeta2 = config.lam2 / (2 * np.sqrt(config.k2)) # Both subsystems should have positive damping assert zeta1 &gt; 0 assert zeta2 &gt; 0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-class-testnumericalaccuracy-test-numerical-accuracy-and-precision-def-test-floating-point-consistency-self-test-that-computations-are-consistent-across-repeated-calls-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-compute-control-multiple-times-results-for-in-range-100-result-controller-compute-control-state-control-result-get-control-output-result-get-control-result-get-u-if-control-is-not-none-results-append-control-if-results-results-np-array-results-all-results-should-be-identical-deterministic-computation-std-dev-np-std-results-axis-0-assert-np-all-std-dev-1e-15-machine-precision-def-test-numerical-stability-small-values-self-test-numerical-stability-with-very-small-state-values-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-very-small-state-values-near-machine-precision-small-state-np-array-1e-15-1e-15-1e-15-1e-15-1e-15-1e-15-result-controller-compute-control-small-state-control-result-get-control-output-result-get-control-result-get-u-if-control-is-not-none-control-should-be-finite-and-small-assert-np-all-np-isfinite-control-assert-np-all-np-abs-control-1-0-def-test-numerical-stability-large-values-self-test-numerical-stability-with-large-state-values-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-large-state-values-but-within-reasonable-bounds-large-state-np-array-10-0-5-0-3-0-2-0-2-0-1-0-result-controller-compute-control-large-state-control-result-get-control-output-result-get-control-result-get-u-if-control-is-not-none-control-should-be-finite-and-saturated-assert-np-all-np-isfinite-control-assert-np-all-np-abs-control-config-max-force-1-01-within-saturation">runnable: false class TestNumericalAccuracy: â€œâ€â€Test numerical accuracy and precision.â€â€â€ def test_floating_point_consistency(self): â€œâ€â€Test that computations are consistent across repeated calls.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) # Compute control multiple times results = [] for _ in range(100): result = controller.compute_control(state, {}, {}) control = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, result.get(â€˜uâ€™))) if control is not None: results.append(control) if results: results = np.array(results) # All results should be identical (deterministic computation) std_dev = np.std(results, axis=0) assert np.all(std_dev &lt; 1e-15) # Machine precision def test_numerical_stability_small_values(self): â€œâ€â€Test numerical stability with very small state values.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) # Very small state values (near machine precision) small_state = np.array([1e-15, 1e-15, 1e-15, 1e-15, 1e-15, 1e-15]) result = controller.compute_control(small_state, {}, {}) control = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, result.get(â€˜uâ€™))) if control is not None: # Control should be finite and small assert np.all(np.isfinite(control)) assert np.all(np.abs(control) &lt; 1.0) def test_numerical_stability_large_values(self): â€œâ€â€Test numerical stability with large state values.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) # Large state values (but within reasonable bounds) large_state = np.array([10.0, 5.0, 3.0, 2.0, 2.0, 1.0]) result = controller.compute_control(large_state, {}, {}) control = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, result.get(â€˜uâ€™))) if control is not None: # Control should be finite and saturated assert np.all(np.isfinite(control)) assert np.all(np.abs(control) &lt;= config.max_force * 1.01) # Within saturation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-class-testsystemlevelmathematics-test-mathematical-consistency-across-system-components-def-test-control-law-decomposition-self-test-that-control-law-components-sum-correctly-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-get-overall-control-output-result-controller-compute-control-state-total-control-result-get-control-output-result-get-control-result-get-u-get-individual-components-if-available-in-debug-output-components-result-get-debug-if-u-equivalent-in-components-and-u-switching-in-components-and-u-derivative-in-components-u-eq-components-u-equivalent-u-sw-components-u-switching-u-d-components-u-derivative-before-saturation-should-sum-correctly-u-unsaturated-u-eq-u-sw-u-d-after-saturation-u-saturated-np-clip-u-unsaturated-config-max-force-config-max-force-should-match-total-control-before-any-additional-processing-if-total-control-is-not-none-assert-np-allclose-u-saturated-total-control-rtol-1e-10-def-test-lyapunov-function-properties-self-test-lyapunov-function-properties-for-stability-analysis-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-surface-linearslidingsurface-config-get-surface-gains-multiple-test-states-states-np-array-0-1-0-05-0-08-0-02-0-03-0-01-np-array-0-2-0-1-0-15-0-05-0-08-0-03-np-array-0-1-0-05-0-08-0-02-0-03-0-01-for-state-in-states-s-surface-compute-state-lyapunov-function-candidate-v-0-5-s2-v-0-5-s-2-v-should-be-non-negative-assert-v-0-v-0-if-and-only-if-s-0-if-abs-s-1e-10-assert-v-1e-15-else-assert-v-0-def-test-reaching-law-satisfaction-self-test-that-reaching-law-is-satisfied-ss-s-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-surface-linearslidingsurface-config-get-surface-gains-test-state-away-from-surface-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-s-surface-compute-state-simplified-reaching-law-check-without-full-dynamics-for-switching-control-u-sw-k-sign-s-the-reaching-condition-ss-s-should-be-satisfied-when-k-is-chosen-large-enough-this-is-a-simplified-test-full-test-would-require-dynamics-model-if-abs-s-config-boundary-layer-outside-boundary-layer-should-have-strong-reaching-behavior-expected-reaching-rate-config-k-abs-s-max-abs-s-config-boundary-layer-assert-expected-reaching-rate-0-should-be-moving-toward-surface">runnable: false class TestSystemLevelMathematics: â€œâ€â€Test mathematical consistency across system components.â€â€â€ def test_control_law_decomposition(self): â€œâ€â€Test that control law components sum correctly.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) # Get overall control output result = controller.compute_control(state, {}, {}) total_control = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, result.get(â€˜uâ€™))) # Get individual components (if available in debug output) components = result.get(â€˜debugâ€™, {}) if â€˜u_equivalentâ€™ in components and â€˜u_switchingâ€™ in components and â€˜u_derivativeâ€™ in components: u_eq = components[â€˜u_equivalentâ€™] u_sw = components[â€˜u_switchingâ€™] u_d = components[â€˜u_derivativeâ€™] # Before saturation, should sum correctly u_unsaturated = u_eq + u_sw + u_d # After saturation u_saturated = np.clip(u_unsaturated, -config.max_force, config.max_force) # Should match total control (before any additional processing) if total_control is not None: assert np.allclose(u_saturated, total_control, rtol=1e-10) def test_lyapunov_function_properties(self): â€œâ€â€Test Lyapunov function properties for stability analysis.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) surface = LinearSlidingSurface(config.get_surface_gains()) # Multiple test states states = [ np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]), np.array([0.2, 0.1, 0.15, 0.05, 0.08, 0.03]), np.array([-0.1, -0.05, -0.08, -0.02, -0.03, -0.01]) ] for state in states: s = surface.compute(state) # Lyapunov function candidate: V = 0.5 * sÂ² V = 0.5 * s**2 # V should be non-negative assert V &gt;= 0 # V = 0 if and only if s = 0 if abs(s) &lt; 1e-10: assert V &lt; 1e-15 else: assert V &gt; 0 def test_reaching_law_satisfaction(self): â€œâ€â€Test that reaching law is satisfied: s<em>á¹¡ â‰¤ -Î·|s|.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) surface = LinearSlidingSurface(config.get_surface_gains()) # Test state away from surface state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) s = surface.compute(state) # Simplified reaching law check (without full dynamics) # For switching control: u_sw = -K * sign(s) # The reaching condition s</em>á¹¡ â‰¤ -Î·|s| should be satisfied # when K is chosen large enough # This is a simplified test - full test would require dynamics model if abs(s) &gt; config.boundary_layer: # Outside boundary layer, should have strong reaching behavior expected_reaching_rate = -config.K * abs(s) / max(abs(s), config.boundary_layer) assert expected_reaching_rate &lt; 0 # Should be moving toward surface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#fast-unit-tests-mathematical-properties">Fast unit tests (mathematical properties)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#extended-property-based-testing">Extended property-based testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/validation_framework_guide.html">Validation Framework Guide <strong>System Reliability Foundation: Robust Parameter Validation &amp; Scientific Verification</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/validation_framework_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/validation_framework_guide.html#runnable-false-good-validate-once-at-construction">runnable: false # âœ… GOOD: Validate once at construction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/validation_framework_guide.html#good-single-validation-for-array">âœ… GOOD: Single validation for array</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_validation_procedures.html">Mathematical Validation Procedures for Control Systems ## Executive Summary This document establishes mathematical validation procedures for the double-inverted pendulum sliding mode control (DIP-SMC) project, ensuring theoretical soundness and implementation correctness through rigorous mathematical property verification. The procedures integrate control theory, optimization theory, and numerical analysis validation with automated testing frameworks. <strong>Core Mathematical Domains:</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_management_patterns.html">Controller Memory Management Patterns (Issue #15 Resolution) <strong>Date:</strong> 2025-10-01</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_management_patterns.html#no-explicit-cleanup-needed-automatic-via-del">No explicit cleanup needed (automatic via <strong>del</strong>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_management_patterns.html#controller-automatically-cleaned-up-when-out-of-scope">Controller automatically cleaned up when out of scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_management_patterns.html#explicit-cleanup-recommended">Explicit cleanup recommended</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_management_patterns.html#cleanup-every-n-iterations">Cleanup every N iterations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_management_quick_reference.html">Controller Memory Management Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../numerical_stability_guide.html">Numerical Stability Guide <strong>Version</strong>: 1.2.0 | <strong>Last Updated</strong>: 2025-10-01 ## Overview This guide documents the adaptive matrix regularization system implemented in the double-inverted pendulum control framework. The system provides robust numerical stability for matrix operations in plant dynamics, controllers, and optimization algorithms.</a></li>
<li class="toctree-l1"><a class="reference internal" href="../numerical_stability_guide.html#for-well-conditioned-systems-or-debugging">For well-conditioned systems or debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plant_model.html">1.x Plant Model</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../production/index.html">Production Deployment</a><input aria-label="Toggle navigation of Production Deployment" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../production/production_readiness_assessment_v2.html">Production Readiness Assessment v2.0 <strong>Date</strong>: 2025-09-29</a></li>
<li class="toctree-l2"><a class="reference internal" href="../production_readiness_final.html">Production Readiness Assessment - Final Report <strong>Date:</strong> 2025-09-29</a></li>
<li class="toctree-l2"><a class="reference internal" href="../production_readiness_framework.html">Production Readiness Assessment Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../production_documentation_summary.html">Production Documentation Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html">PSO Configuration Schema Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#top-level-pso-configuration-structure">Top-level PSO configuration structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#runnable-false-class-constraintpropagator-intelligent-constraint-propagation-for-interdependent-pso-parameters-def-init-self-controller-type-str-self-controller-type-controller-type-self-constraint-graph-self-build-constraint-graph-def-propagate-constraints-self-initial-bounds-dict-dict-propagate-constraints-through-parameter-dependency-graph-example-if-1-is-constrained-to-0-1-5-0-for-issue-2-then-c1-bounds-must-ensure-1-1-2c1-0-69-0-8-propagated-bounds-initial-bounds-copy-iterative-constraint-propagation-converged-false-max-iterations-10-iteration-0-while-not-converged-and-iteration-max-iterations-old-bounds-propagated-bounds-copy-apply-constraint-rules-for-constraint-in-self-constraint-graph-propagated-bounds-self-apply-constraint-rule-constraint-propagated-bounds-check-convergence-converged-self-bounds-converged-old-bounds-propagated-bounds-iteration-1-return-propagated-bounds-def-apply-constraint-rule-self-constraint-dict-bounds-dict-dict-apply-individual-constraint-rule-with-mathematical-validation-if-constraint-type-damping-ratio-2c-constraint-propagation-lambda-idx-constraint-lambda-idx-c-idx-constraint-c-idx-target-zeta-range-constraint-zeta-range-lambda-min-lambda-max-bounds-min-lambda-idx-bounds-max-lambda-idx-derive-c-bounds-from-lambda-bounds-and-zeta-constraints-for-min-2c-max-c-min-2-max-2-c-max-2-min-2-c-min-from-lambda-lambda-min-2-target-zeta-range-1-2-c-max-from-lambda-lambda-max-2-target-zeta-range-0-2-update-c-bounds-with-constraint-propagation-bounds-min-c-idx-max-bounds-min-c-idx-c-min-from-lambda-bounds-max-c-idx-min-bounds-max-c-idx-c-max-from-lambda-elif-constraint-type-sta-stability-k1-k2-constraint-with-margin-k1-idx-k2-idx-constraint-k1-idx-constraint-k2-idx-margin-constraint-get-margin-0-1-ensure-k1-min-k2-max-margin-bounds-min-k1-idx-max-bounds-min-k1-idx-bounds-max-k2-idx-margin-return-bounds-def-build-constraint-graph-self-list-build-constraint-dependency-graph-for-controller-type-if-self-controller-type-classical-smc-return-type-damping-ratio-lambda-idx-1-c-idx-0-zeta-range-0-6-0-8-type-damping-ratio-lambda-idx-3-c-idx-2-zeta-range-0-6-0-8-type-actuator-saturation-gain-indices-4-5-k-kd-max-total-150-0-elif-self-controller-type-sta-smc-return-type-sta-stability-k1-idx-0-k2-idx-1-margin-0-1-type-damping-ratio-lambda-idx-4-c-idx-2-lambda1-k1-zeta-range-0-69-0-8-issue-2-requirement-type-damping-ratio-lambda-idx-5-c-idx-3-lambda2-k2-zeta-range-0-69-0-8-issue-2-requirement-return">runnable: false class ConstraintPropagator: â€œâ€â€ Intelligent constraint propagation for interdependent PSO parameters. â€œâ€â€ def <strong>init</strong>(self, controller_type: str): self.controller_type = controller_type self.constraint_graph = self._build_constraint_graph() def propagate_constraints(self, initial_bounds: dict) -&gt; dict: â€œâ€â€ Propagate constraints through parameter dependency graph. Example: If Î»â‚ is constrained to [0.1, 5.0] for Issue #2, then câ‚ bounds must ensure Î¶â‚ = Î»â‚/(2âˆšcâ‚) âˆˆ [0.69, 0.8] â€œâ€â€ propagated_bounds = initial_bounds.copy() # Iterative constraint propagation converged = False max_iterations = 10 iteration = 0 while not converged and iteration &lt; max_iterations: old_bounds = propagated_bounds.copy() # Apply constraint rules for constraint in self.constraint_graph: propagated_bounds = self._apply_constraint_rule( constraint, propagated_bounds ) # Check convergence converged = self._bounds_converged(old_bounds, propagated_bounds) iteration += 1 return propagated_bounds def _apply_constraint_rule(self, constraint: dict, bounds: dict) -&gt; dict: â€œâ€â€ Apply individual constraint rule with mathematical validation. â€œâ€â€ if constraint[â€˜typeâ€™] == â€˜damping_ratioâ€™: # Î¶ = Î»/(2âˆšc) constraint propagation lambda_idx = constraint[â€˜lambda_idxâ€™] c_idx = constraint[â€˜c_idxâ€™] target_zeta_range = constraint[â€˜zeta_rangeâ€™] lambda_min, lambda_max = bounds[â€˜minâ€™][lambda_idx], bounds[â€˜maxâ€™][lambda_idx] # Derive c bounds from lambda bounds and zeta constraints # For Î¶_min â‰¤ Î»/(2âˆšc) â‰¤ Î¶_max: # c_min = (Î»/(2Î¶_max))Â², c_max = (Î»/(2Î¶_min))Â² c_min_from_lambda = (lambda_min / (2 * target_zeta_range[1]))**2 c_max_from_lambda = (lambda_max / (2 * target_zeta_range[0]))**2 # Update c bounds with constraint propagation bounds[â€˜minâ€™][c_idx] = max(bounds[â€˜minâ€™][c_idx], c_min_from_lambda) bounds[â€˜maxâ€™][c_idx] = min(bounds[â€˜maxâ€™][c_idx], c_max_from_lambda) elif constraint[â€˜typeâ€™] == â€˜sta_stabilityâ€™: # Kâ‚ &gt; Kâ‚‚ constraint with margin k1_idx, k2_idx = constraint[â€˜k1_idxâ€™], constraint[â€˜k2_idxâ€™] margin = constraint.get(â€˜marginâ€™, 0.1) # Ensure Kâ‚_min &gt; Kâ‚‚_max + margin bounds[â€˜minâ€™][k1_idx] = max( bounds[â€˜minâ€™][k1_idx], bounds[â€˜maxâ€™][k2_idx] + margin ) return bounds def _build_constraint_graph(self) -&gt; list: â€œâ€â€ Build constraint dependency graph for controller type. â€œâ€â€ if self.controller_type == â€˜classical_smcâ€™: return [ { â€˜typeâ€™: â€˜damping_ratioâ€™, â€˜lambda_idxâ€™: 1, â€˜c_idxâ€™: 0, â€˜zeta_rangeâ€™: [0.6, 0.8] }, { â€˜typeâ€™: â€˜damping_ratioâ€™, â€˜lambda_idxâ€™: 3, â€˜c_idxâ€™: 2, â€˜zeta_rangeâ€™: [0.6, 0.8] }, { â€˜typeâ€™: â€˜actuator_saturationâ€™, â€˜gain_indicesâ€™: [4, 5], # K, kd â€˜max_totalâ€™: 150.0 } ] elif self.controller_type == â€˜sta_smcâ€™: return [ { â€˜typeâ€™: â€˜sta_stabilityâ€™, â€˜k1_idxâ€™: 0, â€˜k2_idxâ€™: 1, â€˜marginâ€™: 0.1 }, { â€˜typeâ€™: â€˜damping_ratioâ€™, â€˜lambda_idxâ€™: 4, â€˜c_idxâ€™: 2, # lambda1, k1 â€˜zeta_rangeâ€™: [0.69, 0.8] # Issue #2 requirement }, { â€˜typeâ€™: â€˜damping_ratioâ€™, â€˜lambda_idxâ€™: 5, â€˜c_idxâ€™: 3, # lambda2, k2 â€˜zeta_rangeâ€™: [0.69, 0.8] # Issue #2 requirement } ] return []</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#configuration-schema-version-metadata">Configuration schema version metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#runnable-false-class-configurationmigrator-automatic-migration-framework-for-pso-configuration-schema-evolution-def-init-self-self-migration-rules-1-0-self-migrate-from-v1-0-1-5-self-migrate-from-v1-5-2-0-self-migrate-from-v2-0-def-migrate-configuration-self-config-dict-source-version-str-tuple-migrate-configuration-from-source-version-to-current-schema-returns-tuple-migrated-config-migration-warnings-compatibility-issues-if-source-version-not-in-self-migration-rules-raise-valueerror-f-unsupported-source-version-source-version-migrated-config-config-copy-warnings-issues-apply-migration-rules-in-sequence-current-version-source-version-while-current-version-current-schema-version-migrator-self-migration-rules-current-version-migrated-config-step-warnings-migrator-migrated-config-warnings-extend-step-warnings-current-version-self-get-next-version-current-version-validate-migrated-configuration-validation-result-pso-configurationvalidator-validate-complete-config-migrated-config-if-not-validation-result-is-valid-issues-extend-validation-result-errors-return-migrated-config-warnings-issues-def-migrate-from-v1-0-self-config-dict-tuple-migrate-from-v1-0-to-v1-5-remove-deprecated-fields-update-bounds-migrated-config-copy-warnings-remove-deprecated-fields-deprecated-fields-n-processes-hyper-trials-hyper-search-study-timeout-for-field-in-deprecated-fields-if-field-in-migrated-get-pso-del-migrated-pso-field-warnings-append-f-removed-deprecated-field-field-update-pso-bounds-structure-if-pso-in-migrated-and-bounds-in-migrated-pso-old-bounds-migrated-pso-bounds-new-bounds-self-restructure-bounds-v1-5-old-bounds-migrated-pso-bounds-new-bounds-warnings-append-restructured-bounds-for-controller-specific-optimization-return-migrated-warnings-def-migrate-from-v2-0-self-config-dict-tuple-migrate-from-v2-0-to-v2-1-issue-2-bounds-updates-and-enhanced-features-migrated-config-copy-warnings-update-sta-smc-bounds-for-issue-2-compliance-if-pso-in-migrated-and-bounds-in-migrated-pso-bounds-migrated-pso-bounds-if-sta-smc-in-bounds-sta-bounds-bounds-sta-smc-check-for-issue-2-problematic-bounds-if-max-in-sta-bounds-and-len-sta-bounds-max-6-lambda1-max-lambda2-max-sta-bounds-max-4-sta-bounds-max-5-if-lambda1-max-10-0-or-lambda2-max-10-0-apply-issue-2-corrections-sta-bounds-max-4-min-lambda1-max-10-0-lambda1-sta-bounds-max-5-min-lambda2-max-10-0-lambda2-warnings-append-applied-issue-2-lambda-bounds-corrections-for-overshoot-mitigation-add-enhanced-features-if-missing-if-enhanced-features-not-in-migrated-get-pso-migrated-pso-enhanced-features-w-schedule-0-9-0-4-velocity-clamp-0-1-0-2-early-stopping-patience-50-tolerance-1e-6-warnings-append-added-enhanced-pso-features-for-improved-convergence-return-migrated-warnings-def-generate-migration-report-self-old-config-dict-new-config-dict-warnings-list-issues-list-str-generate-migration-report-for-documentation-report-f">runnable: false class ConfigurationMigrator: â€œâ€â€ Automatic migration framework for PSO configuration schema evolution. â€œâ€â€ def <strong>init</strong>(self): self.migration_rules = { â€œ1.0â€: self._migrate_from_v1_0, â€œ1.5â€: self._migrate_from_v1_5, â€œ2.0â€: self._migrate_from_v2_0 } def migrate_configuration(self, config: dict, source_version: str) -&gt; tuple: â€œâ€â€ Migrate configuration from source version to current schema. Returns: tuple: (migrated_config, migration_warnings, compatibility_issues) â€œâ€â€ if source_version not in self.migration_rules: raise ValueError(fâ€Unsupported source version: {source_version}â€) migrated_config = config.copy() warnings = [] issues = [] # Apply migration rules in sequence current_version = source_version while current_version != CURRENT_SCHEMA_VERSION: migrator = self.migration_rules[current_version] migrated_config, step_warnings = migrator(migrated_config) warnings.extend(step_warnings) current_version = self._get_next_version(current_version) # Validate migrated configuration validation_result = PSO_ConfigurationValidator().validate_complete_config(migrated_config) if not validation_result.is_valid: issues.extend(validation_result.errors) return migrated_config, warnings, issues def _migrate_from_v1_0(self, config: dict) -&gt; tuple: â€œâ€â€ Migrate from v1.0 to v1.5: Remove deprecated fields, update bounds. â€œâ€â€ migrated = config.copy() warnings = [] # Remove deprecated fields deprecated_fields = [â€˜n_processesâ€™, â€˜hyper_trialsâ€™, â€˜hyper_searchâ€™, â€˜study_timeoutâ€™] for field in deprecated_fields: if field in migrated.get(â€˜psoâ€™, {}): del migrated[â€˜psoâ€™][field] warnings.append(fâ€Removed deprecated field: {field}â€) # Update PSO bounds structure if â€˜psoâ€™ in migrated and â€˜boundsâ€™ in migrated[â€˜psoâ€™]: old_bounds = migrated[â€˜psoâ€™][â€˜boundsâ€™] new_bounds = self._restructure_bounds_v1_5(old_bounds) migrated[â€˜psoâ€™][â€˜boundsâ€™] = new_bounds warnings.append(â€œRestructured bounds for controller-specific optimizationâ€) return migrated, warnings def _migrate_from_v2_0(self, config: dict) -&gt; tuple: â€œâ€â€ Migrate from v2.0 to v2.1: Issue #2 bounds updates and enhanced features. â€œâ€â€ migrated = config.copy() warnings = [] # Update STA-SMC bounds for Issue #2 compliance if â€˜psoâ€™ in migrated and â€˜boundsâ€™ in migrated[â€˜psoâ€™]: bounds = migrated[â€˜psoâ€™][â€˜boundsâ€™] if â€˜sta_smcâ€™ in bounds: sta_bounds = bounds[â€˜sta_smcâ€™] # Check for Issue #2 problematic bounds if â€˜maxâ€™ in sta_bounds and len(sta_bounds[â€˜maxâ€™]) &gt;= 6: lambda1_max, lambda2_max = sta_bounds[â€˜maxâ€™][4], sta_bounds[â€˜maxâ€™][5] if lambda1_max &gt; 10.0 or lambda2_max &gt; 10.0: # Apply Issue #2 corrections sta_bounds[â€˜maxâ€™][4] = min(lambda1_max, 10.0) # lambda1 sta_bounds[â€˜maxâ€™][5] = min(lambda2_max, 10.0) # lambda2 warnings.append(â€œApplied Issue #2 lambda bounds corrections for overshoot mitigationâ€) # Add enhanced features if missing if â€˜enhanced_featuresâ€™ not in migrated.get(â€˜psoâ€™, {}): migrated[â€˜psoâ€™][â€˜enhanced_featuresâ€™] = { â€˜w_scheduleâ€™: [0.9, 0.4], â€˜velocity_clampâ€™: [0.1, 0.2], â€˜early_stoppingâ€™: {â€˜patienceâ€™: 50, â€˜toleranceâ€™: 1e-6} } warnings.append(â€œAdded enhanced PSO features for improved convergenceâ€) return migrated, warnings def generate_migration_report(self, old_config: dict, new_config: dict, warnings: list, issues: list) -&gt; str: â€œâ€â€ Generate migration report for documentation. â€œâ€â€ report = fâ€â€â€</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#pso-configuration-migration-report-summary">PSO Configuration Migration Report ## Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#runnable-false-class-configurationerrorhandler-error-handling-and-diagnostic-system-for-pso-configuration-error-categories-syntax-severity-critical-auto-fixable-false-description-yaml-syntax-or-structure-errors-type-severity-critical-auto-fixable-true-description-data-type-mismatches-bounds-severity-high-auto-fixable-true-description-parameter-bounds-violations-mathematical-severity-high-auto-fixable-false-description-mathematical-consistency-violations-performance-severity-medium-auto-fixable-true-description-suboptimal-performance-configuration-compatibility-severity-medium-auto-fixable-true-description-controller-compatibility-issues-def-diagnose-configuration-errors-self-config-dict-controller-type-str-none-dict-configuration-error-diagnosis-with-auto-fix-suggestions-diagnosis-errors-warnings-auto-fixes-manual-actions-overall-status-unknown-run-diagnostic-checks-for-category-info-in-self-error-categories-items-category-errors-self-check-category-category-config-controller-type-for-error-in-category-errors-error-category-category-error-severity-info-severity-error-auto-fixable-info-auto-fixable-if-error-severity-critical-diagnosis-errors-append-error-else-diagnosis-warnings-append-error-generate-fix-suggestions-if-error-auto-fixable-fix-self-generate-auto-fix-error-config-if-fix-diagnosis-auto-fixes-append-fix-else-manual-action-self-generate-manual-action-error-if-manual-action-diagnosis-manual-actions-append-manual-action-determine-overall-status-if-diagnosis-errors-diagnosis-overall-status-critical-elif-len-diagnosis-warnings-5-diagnosis-overall-status-needs-attention-elif-diagnosis-warnings-diagnosis-overall-status-minor-issues-else-diagnosis-overall-status-healthy-return-diagnosis-def-check-category-self-category-str-config-dict-controller-type-str-list-check-specific-error-category-and-return-found-issues-errors-if-category-mathematical-pso-convergence-check-if-algorithm-params-in-config-params-config-algorithm-params-if-c1-in-params-and-c2-in-params-phi-params-c1-params-c2-if-phi-4-0-errors-append-code-pso-convergence-risk-message-f-pso-may-not-converge-c1-c2-phi-3f-4-0-location-algorithm-params-c1-algorithm-params-c2-impact-optimization-may-fail-to-converge-elif-category-bounds-and-controller-type-issue-2-specific-checks-for-sta-smc-if-controller-type-sta-smc-and-bounds-in-config-bounds-config-bounds-if-sta-smc-in-bounds-and-max-in-bounds-sta-smc-max-bounds-bounds-sta-smc-max-if-len-max-bounds-6-lambda1-max-lambda2-max-max-bounds-4-max-bounds-5-if-lambda1-max-10-0-or-lambda2-max-10-0-errors-append-code-issue2-bounds-violation-message-f-sta-smc-lambda-bounds-may-cause-overshoot-1-max-lambda1-max-2-max-lambda2-max-location-bounds-sta-smc-max-4-6-impact-may-cause-5-overshoot-issue-2-regression-elif-category-performance-suboptimal-parameter-detection-if-algorithm-params-in-config-params-config-algorithm-params-if-n-particles-in-params-n-particles-params-n-particles-if-n-particles-10-or-n-particles-50-errors-append-code-suboptimal-swarm-size-message-f-swarm-size-n-particles-outside-optimal-range-10-50-location-algorithm-params-n-particles-impact-suboptimal-convergence-speed-or-quality-return-errors-def-generate-auto-fix-self-error-dict-config-dict-dict-generate-automatic-fix-for-fixable-errors-if-error-code-pso-convergence-risk-return-error-code-error-code-fix-type-parameter-adjustment-action-increase-c1-and-c2-to-ensure-4-changes-algorithm-params-c1-2-1-algorithm-params-c2-2-1-justification-ensures-pso-convergence-with-4-2-4-elif-error-code-issue2-bounds-violation-return-error-code-error-code-fix-type-bounds-correction-action-apply-issue-2-lambda-bounds-corrections-changes-bounds-sta-smc-max-4-10-0-lambda1-bounds-sta-smc-max-5-10-0-lambda2-justification-prevents-overshoot-regression-from-issue-2-elif-error-code-suboptimal-swarm-size-current-size-config-algorithm-params-n-particles-optimal-size-np-clip-current-size-15-25-clamp-to-optimal-range-return-error-code-error-code-fix-type-parameter-optimization-action-f-adjust-swarm-size-to-optimal-range-changes-algorithm-params-n-particles-optimal-size-justification-f-optimizes-convergence-for-optimal-size-particles-return-none-def-apply-auto-fixes-self-config-dict-fixes-list-tuple-apply-automatic-fixes-to-configuration-returns-tuple-fixed-config-applied-fixes-failed-fixes-fixed-config-config-copy-applied-fixes-failed-fixes-for-fix-in-fixes-try-for-path-new-value-in-fix-changes-items-self-set-nested-value-fixed-config-path-new-value-applied-fixes-append-fix-except-exception-as-e-fix-error-str-e-failed-fixes-append-fix-return-fixed-config-applied-fixes-failed-fixes-def-set-nested-value-self-config-dict-path-str-value-any-none-set-nested-configuration-value-using-dot-notation-path-keys-path-split-current-config-for-key-in-keys-1-if-in-key-and-in-key-handle-array-indexing-array-key-index-str-key-split-index-int-index-str-rstrip-if-array-key-not-in-current-current-array-key-current-current-array-key-extend-array-if-necessary-while-len-current-index-current-append-none-current-current-index-else-if-key-not-in-current-current-key-current-current-key-set-the-final-value-final-key-keys-1-if-in-final-key-and-in-final-key-array-key-index-str-final-key-split-index-int-index-str-rstrip-if-array-key-not-in-current-current-array-key-while-len-current-array-key-index-current-array-key-append-none-current-array-key-index-value-else-current-final-key-value">runnable: false class ConfigurationErrorHandler: â€œâ€â€ error handling and diagnostic system for PSO configuration. â€œâ€â€ ERROR_CATEGORIES = { â€˜SYNTAXâ€™: { â€˜severityâ€™: â€˜CRITICALâ€™, â€˜auto_fixableâ€™: False, â€˜descriptionâ€™: â€˜YAML syntax or structure errorsâ€™ }, â€˜TYPEâ€™: { â€˜severityâ€™: â€˜CRITICALâ€™, â€˜auto_fixableâ€™: True, â€˜descriptionâ€™: â€˜Data type mismatchesâ€™ }, â€˜BOUNDSâ€™: { â€˜severityâ€™: â€˜HIGHâ€™, â€˜auto_fixableâ€™: True, â€˜descriptionâ€™: â€˜Parameter bounds violationsâ€™ }, â€˜MATHEMATICALâ€™: { â€˜severityâ€™: â€˜HIGHâ€™, â€˜auto_fixableâ€™: False, â€˜descriptionâ€™: â€˜Mathematical consistency violationsâ€™ }, â€˜PERFORMANCEâ€™: { â€˜severityâ€™: â€˜MEDIUMâ€™, â€˜auto_fixableâ€™: True, â€˜descriptionâ€™: â€˜Suboptimal performance configurationâ€™ }, â€˜COMPATIBILITYâ€™: { â€˜severityâ€™: â€˜MEDIUMâ€™, â€˜auto_fixableâ€™: True, â€˜descriptionâ€™: â€˜Controller compatibility issuesâ€™ } } def diagnose_configuration_errors(self, config: dict, controller_type: str = None) -&gt; dict: â€œâ€â€ configuration error diagnosis with auto-fix suggestions. â€œâ€â€ diagnosis = { â€˜errorsâ€™: [], â€˜warningsâ€™: [], â€˜auto_fixesâ€™: [], â€˜manual_actionsâ€™: [], â€˜overall_statusâ€™: â€˜UNKNOWNâ€™ } # Run diagnostic checks for category, info in self.ERROR_CATEGORIES.items(): category_errors = self._check_category(category, config, controller_type) for error in category_errors: error[â€˜categoryâ€™] = category error[â€˜severityâ€™] = info[â€˜severityâ€™] error[â€˜auto_fixableâ€™] = info[â€˜auto_fixableâ€™] if error[â€˜severityâ€™] == â€˜CRITICALâ€™: diagnosis[â€˜errorsâ€™].append(error) else: diagnosis[â€˜warningsâ€™].append(error) # Generate fix suggestions if error[â€˜auto_fixableâ€™]: fix = self._generate_auto_fix(error, config) if fix: diagnosis[â€˜auto_fixesâ€™].append(fix) else: manual_action = self._generate_manual_action(error) if manual_action: diagnosis[â€˜manual_actionsâ€™].append(manual_action) # Determine overall status if diagnosis[â€˜errorsâ€™]: diagnosis[â€˜overall_statusâ€™] = â€˜CRITICALâ€™ elif len(diagnosis[â€˜warningsâ€™]) &gt; 5: diagnosis[â€˜overall_statusâ€™] = â€˜NEEDS_ATTENTIONâ€™ elif diagnosis[â€˜warningsâ€™]: diagnosis[â€˜overall_statusâ€™] = â€˜MINOR_ISSUESâ€™ else: diagnosis[â€˜overall_statusâ€™] = â€˜HEALTHYâ€™ return diagnosis def _check_category(self, category: str, config: dict, controller_type: str) -&gt; list: â€œâ€â€ Check specific error category and return found issues. â€œâ€â€ errors = [] if category == â€˜MATHEMATICALâ€™: # PSO convergence check if â€˜algorithm_paramsâ€™ in config: params = config[â€˜algorithm_paramsâ€™] if â€˜c1â€™ in params and â€˜c2â€™ in params: phi = params[â€˜c1â€™] + params[â€˜c2â€™] if phi &lt;= 4.0: errors.append({ â€˜codeâ€™: â€˜PSO_CONVERGENCE_RISKâ€™, â€˜messageâ€™: fâ€™PSO may not converge: Ï† = câ‚ + câ‚‚ = {phi:.3f} â‰¤ 4.0â€™, â€˜locationâ€™: â€˜algorithm_params.c1, algorithm_params.c2â€™, â€˜impactâ€™: â€˜Optimization may fail to convergeâ€™ }) elif category == â€˜BOUNDSâ€™ and controller_type: # Issue #2 specific checks for STA-SMC if controller_type == â€˜sta_smcâ€™ and â€˜boundsâ€™ in config: bounds = config[â€˜boundsâ€™] if â€˜sta_smcâ€™ in bounds and â€˜maxâ€™ in bounds[â€˜sta_smcâ€™]: max_bounds = bounds[â€˜sta_smcâ€™][â€˜maxâ€™] if len(max_bounds) &gt;= 6: lambda1_max, lambda2_max = max_bounds[4], max_bounds[5] if lambda1_max &gt; 10.0 or lambda2_max &gt; 10.0: errors.append({ â€˜codeâ€™: â€˜ISSUE2_BOUNDS_VIOLATIONâ€™, â€˜messageâ€™: fâ€™STA-SMC lambda bounds may cause overshoot: Î»â‚_max={lambda1_max}, Î»â‚‚_max={lambda2_max}â€™, â€˜locationâ€™: â€˜bounds.sta_smc.max[4:6]â€™, â€˜impactâ€™: â€˜May cause &gt;5% overshoot (Issue #2 regression)â€™ }) elif category == â€˜PERFORMANCEâ€™: # Suboptimal parameter detection if â€˜algorithm_paramsâ€™ in config: params = config[â€˜algorithm_paramsâ€™] if â€˜n_particlesâ€™ in params: n_particles = params[â€˜n_particlesâ€™] if n_particles &lt; 10 or n_particles &gt; 50: errors.append({ â€˜codeâ€™: â€˜SUBOPTIMAL_SWARM_SIZEâ€™, â€˜messageâ€™: fâ€™Swarm size {n_particles} outside optimal range [10, 50]â€™, â€˜locationâ€™: â€˜algorithm_params.n_particlesâ€™, â€˜impactâ€™: â€˜Suboptimal convergence speed or qualityâ€™ }) return errors def _generate_auto_fix(self, error: dict, config: dict) -&gt; dict: â€œâ€â€ Generate automatic fix for fixable errors. â€œâ€â€ if error[â€˜codeâ€™] == â€˜PSO_CONVERGENCE_RISKâ€™: return { â€˜error_codeâ€™: error[â€˜codeâ€™], â€˜fix_typeâ€™: â€˜parameter_adjustmentâ€™, â€˜actionâ€™: â€˜Increase câ‚ and câ‚‚ to ensure Ï† &gt; 4â€™, â€˜changesâ€™: { â€˜algorithm_params.c1â€™: 2.1, â€˜algorithm_params.c2â€™: 2.1 }, â€˜justificationâ€™: â€˜Ensures PSO convergence with Ï† = 4.2 &gt; 4â€™ } elif error[â€˜codeâ€™] == â€˜ISSUE2_BOUNDS_VIOLATIONâ€™: return { â€˜error_codeâ€™: error[â€˜codeâ€™], â€˜fix_typeâ€™: â€˜bounds_correctionâ€™, â€˜actionâ€™: â€˜Apply Issue #2 lambda bounds correctionsâ€™, â€˜changesâ€™: { â€˜bounds.sta_smc.max[4]â€™: 10.0, # lambda1 â€˜bounds.sta_smc.max[5]â€™: 10.0 # lambda2 }, â€˜justificationâ€™: â€˜Prevents overshoot regression from Issue #2â€™ } elif error[â€˜codeâ€™] == â€˜SUBOPTIMAL_SWARM_SIZEâ€™: current_size = config[â€˜algorithm_paramsâ€™][â€˜n_particlesâ€™] optimal_size = np.clip(current_size, 15, 25) # Clamp to optimal range return { â€˜error_codeâ€™: error[â€˜codeâ€™], â€˜fix_typeâ€™: â€˜parameter_optimizationâ€™, â€˜actionâ€™: fâ€™Adjust swarm size to optimal rangeâ€™, â€˜changesâ€™: { â€˜algorithm_params.n_particlesâ€™: optimal_size }, â€˜justificationâ€™: fâ€™Optimizes convergence for {optimal_size} particlesâ€™ } return None def apply_auto_fixes(self, config: dict, fixes: list) -&gt; tuple: â€œâ€â€ Apply automatic fixes to configuration. Returns: tuple: (fixed_config, applied_fixes, failed_fixes) â€œâ€â€ fixed_config = config.copy() applied_fixes = [] failed_fixes = [] for fix in fixes: try: for path, new_value in fix[â€˜changesâ€™].items(): self._set_nested_value(fixed_config, path, new_value) applied_fixes.append(fix) except Exception as e: fix[â€˜errorâ€™] = str(e) failed_fixes.append(fix) return fixed_config, applied_fixes, failed_fixes def _set_nested_value(self, config: dict, path: str, value: any) -&gt; None: â€œâ€â€ Set nested configuration value using dot notation path. â€œâ€â€ keys = path.split(â€˜.â€™) current = config for key in keys[:-1]: if â€˜[â€™ in key and â€˜]â€™ in key: # Handle array indexing array_key, index_str = key.split(â€˜[â€™) index = int(index_str.rstrip(â€˜]â€™)) if array_key not in current: current[array_key] = [] current = current[array_key] # Extend array if necessary while len(current) &lt;= index: current.append(None) current = current[index] else: if key not in current: current[key] = {} current = current[key] # Set the final value final_key = keys[-1] if â€˜[â€™ in final_key and â€˜]â€™ in final_key: array_key, index_str = final_key.split(â€˜[â€™) index = int(index_str.rstrip(â€˜]â€™)) if array_key not in current: current[array_key] = [] while len(current[array_key]) &lt;= index: current[array_key].append(None) current[array_key][index] = value else: current[final_key] = value</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_factory_integration_patterns.html">PSO-Factory Integration Patterns Documentation ## Overview This document provides guidance on integrating the factory system with Particle Swarm Optimization (PSO) workflows. The DIP SMC-PSO project features native PSO integration patterns that streamline controller optimization while maintaining scientific rigor and performance. ## Table of Contents 1. <span class="xref myst">PSO Integration Architecture</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_factory_integration_patterns.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_factory_integration_patterns.html#runnable-false-def-adaptive-pso-optimization-controller-type-smctype-tuple-np-ndarray-float-adaptive-pso-with-dynamic-parameter-adjustment-factory-create-pso-controller-factory-controller-type-class-adaptivepsocontroller-adaptive-pso-controller-with-factory-integration-def-init-self-self-iteration-0-self-best-fitness-history-self-stagnation-counter-0-self-current-bounds-get-gain-bounds-for-pso-controller-type-def-adapt-parameters-self-current-best-fitness-float-dict-str-float-adapt-pso-parameters-based-on-progress-check-for-stagnation-if-len-self-best-fitness-history-0-and-abs-current-best-fitness-self-best-fitness-history-1-1e-6-self-stagnation-counter-1-else-self-stagnation-counter-0-self-best-fitness-history-append-current-best-fitness-adaptive-parameter-adjustment-if-self-stagnation-counter-10-increase-exploration-w-0-9-high-inertia-c1-c2-2-5-1-5-high-cognitive-low-social-expand-search-bounds-slightly-lower-upper-self-current-bounds-expansion-0-1-self-current-bounds-l-1-expansion-for-l-in-lower-u-1-expansion-for-u-in-upper-elif-self-iteration-50-early-exploration-phase-w-0-9-c1-c2-2-0-2-0-else-late-exploitation-phase-w-0-4-c1-c2-1-5-2-5-self-iteration-1-return-w-w-c1-c1-c2-c2-bounds-self-current-bounds-def-fitness-function-self-gains-np-ndarray-float-adaptive-fitness-function-with-dynamic-objectives-try-controller-factory-gains-metrics-evaluate-controller-performance-controller-dynamic-objective-weighting-based-on-iteration-if-self-iteration-30-early-phase-focus-on-basic-performance-return-0-7-metrics-ise-0-3-metrics-control-effort-elif-self-iteration-80-middle-phase-balance-performance-and-robustness-return-0-4-metrics-ise-0-3-metrics-control-effort-0-3-metrics-robustness-penalty-else-late-phase-focus-on-refinement-return-0-3-metrics-ise-0-2-metrics-control-effort-0-3-metrics-robustness-penalty-0-2-metrics-chattering-penalty-except-return-float-inf-run-adaptive-pso-adaptive-controller-adaptivepsocontroller-initial-pso-configuration-pso-params-adaptive-controller-adapt-parameters-float-inf-optimizer-psotuner-controller-factory-adaptive-controller-fitness-function-config-config-adaptive-callback-adaptive-controller-adapt-parameters-return-optimizer-optimize-adaptive">runnable: false def adaptive_pso_optimization(controller_type: SMCType) -&gt; Tuple[np.ndarray, float]: â€œâ€â€Adaptive PSO with dynamic parameter adjustment.â€â€â€ factory = create_pso_controller_factory(controller_type) class AdaptivePSOController: â€œâ€â€Adaptive PSO controller with factory integration.â€â€â€ def <strong>init</strong>(self): self.iteration = 0 self.best_fitness_history = [] self.stagnation_counter = 0 self.current_bounds = get_gain_bounds_for_pso(controller_type) def adapt_parameters(self, current_best_fitness: float) -&gt; Dict[str, float]: â€œâ€â€Adapt PSO parameters based on progress.â€â€â€ # Check for stagnation if (len(self.best_fitness_history) &gt; 0 and abs(current_best_fitness - self.best_fitness_history[-1]) &lt; 1e-6): self.stagnation_counter += 1 else: self.stagnation_counter = 0 self.best_fitness_history.append(current_best_fitness) # Adaptive parameter adjustment if self.stagnation_counter &gt; 10: # Increase exploration w = 0.9 # High inertia c1, c2 = 2.5, 1.5 # High cognitive, low social # Expand search bounds slightly lower, upper = self.current_bounds expansion = 0.1 self.current_bounds = ( [l * (1 - expansion) for l in lower], [u * (1 + expansion) for u in upper] ) elif self.iteration &lt; 50: # Early exploration phase w = 0.9 c1, c2 = 2.0, 2.0 else: # Late exploitation phase w = 0.4 c1, c2 = 1.5, 2.5 self.iteration += 1 return { â€˜wâ€™: w, â€˜c1â€™: c1, â€˜c2â€™: c2, â€˜boundsâ€™: self.current_bounds } def fitness_function(self, gains: np.ndarray) -&gt; float: â€œâ€â€Adaptive fitness function with dynamic objectives.â€â€â€ try: controller = factory(gains) metrics = evaluate_controller_performance(controller) # Dynamic objective weighting based on iteration if self.iteration &lt; 30: # Early phase: focus on basic performance return 0.7 * metrics[â€˜iseâ€™] + 0.3 * metrics[â€˜control_effortâ€™] elif self.iteration &lt; 80: # Middle phase: balance performance and robustness return (0.4 * metrics[â€˜iseâ€™] + 0.3 * metrics[â€˜control_effortâ€™] + 0.3 * metrics[â€˜robustness_penaltyâ€™]) else: # Late phase: focus on refinement return (0.3 * metrics[â€˜iseâ€™] + 0.2 * metrics[â€˜control_effortâ€™] + 0.3 * metrics[â€˜robustness_penaltyâ€™] + 0.2 * metrics[â€˜chattering_penaltyâ€™]) except: return float(â€˜infâ€™) # Run adaptive PSO adaptive_controller = AdaptivePSOController() # Initial PSO configuration pso_params = adaptive_controller.adapt_parameters(float(â€˜infâ€™)) optimizer = PSOTuner( controller_factory=adaptive_controller.fitness_function, config=config, adaptive_callback=adaptive_controller.adapt_parameters ) return optimizer.optimize_adaptive()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_factory_integration_patterns.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_factory_integration_patterns.html#runnable-false-usr-bin-env-python3">runnable: false #!/usr/bin/env python3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html">PSO Integration Technical Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-def-controller-factory-gains-np-ndarray-controller-pso-compatible-controller-factory-interface-mathematical-foundation-the-factory-must-instantiate-controllers-with-gain-vector-g-n-where-n-is-controller-specific-dimensionality-classical-smc-g-6-c1-1-c2-2-k-kd-sta-smc-g-6-k1-k2-k1-k2-1-2-adaptive-smc-g-5-c1-1-c2-2-hybrid-adaptive-sta-smc-g-4-c1-1-c2-2-parameters-gains-np-ndarray-shape-n-controller-gain-vector-with-validated-bounds-returns-controller-configured-smc-instance-with-required-attributes-max-force-float-actuator-saturation-limit-validate-gains-optional-callable-pre-filtering-function-interface-contracts-1-factory-function-must-have-attribute-n-gains-specifying-dimensionality-2-returned-controller-must-implement-control-computation-interface-3-all-gains-must-be-positive-and-within-specified-bounds-4-controller-must-handle-edge-cases-singularities-saturation-return-create-controller-controller-type-config-gains-gains-required-factory-attribute">runnable: false def controller_factory(gains: np.ndarray) -&gt; Controller: â€œâ€â€ PSO-compatible controller factory interface. Mathematical Foundation: The factory must instantiate controllers with gain vector G âˆˆ â„â¿ where n is controller-specific dimensionality: - Classical SMC: G âˆˆ â„â¶ (câ‚, Î»â‚, câ‚‚, Î»â‚‚, K, kd) - STA-SMC: G âˆˆ â„â¶ (Kâ‚, Kâ‚‚, kâ‚, kâ‚‚, Î»â‚, Î»â‚‚) - Adaptive SMC: G âˆˆ â„âµ (câ‚, Î»â‚, câ‚‚, Î»â‚‚, Î³) - Hybrid Adaptive STA-SMC: G âˆˆ â„â´ (câ‚, Î»â‚, câ‚‚, Î»â‚‚) Parameters â€”â€”â€”- gains : np.ndarray, shape (n,) Controller gain vector with validated bounds Returns â€”â€”- Controller Configured SMC instance with required attributes: - max_force: float (actuator saturation limit) - validate_gains: Optional[Callable] (pre-filtering function) Interface Contracts â€”â€”â€”â€”â€”â€” 1. Factory function MUST have attribute â€˜n_gainsâ€™ specifying dimensionality 2. Returned controller MUST implement control computation interface 3. All gains MUST be positive and within specified bounds 4. Controller MUST handle edge cases (singularities, saturation) â€œâ€â€ return create_controller(controller_type, config, gains=gains) # Required factory attribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-controller-registry-with-pso-integration-metadata">runnable: false # Controller Registry with PSO Integration Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-def-validate-controller-gains-controller-type-str-gains-np-ndarray-np-ndarray-validate-gain-vectors-for-controller-specific-stability-requirements-mathematical-validation-rules-classical-smc-all-gains-0-positive-definiteness-sliding-surface-gains-c1-1-c2-2-ensure-hurwitz-characteristic-polynomial-switching-gains-k-kd-provide-reaching-condition-satisfaction-sta-smc-super-twisting-algorithmic-gains-k1-k2-0-stability-condition-surface-coefficients-1-2-for-target-damping-ratio-0-6-0-8-finite-time-convergence-k12-4k2-12-parameters-controller-type-str-controller-identifier-from-registry-gains-np-ndarray-shape-b-n-batch-of-gain-vectors-to-validate-returns-np-ndarray-shape-b-dtype-bool-validity-mask-for-each-gain-vector-registry-info-controller-registry-controller-type-bounds-registry-info-gain-bounds-basic-bounds-checking-valid-mask-np-ones-gains-shape-0-dtype-bool-for-i-min-val-max-val-in-enumerate-bounds-valid-mask-gains-i-min-val-gains-i-max-val-controller-specific-stability-checks-if-controller-type-sta-smc-k1-k2-condition-for-sta-stability-valid-mask-gains-0-gains-1-surface-coefficient-bounds-for-target-damping-lambda1-lambda2-gains-4-gains-5-damping-ratio-lambda2-2-np-sqrt-lambda1-valid-mask-damping-ratio-0-6-damping-ratio-0-8-return-valid-mask">runnable: false def validate_controller_gains(controller_type: str, gains: np.ndarray) -&gt; np.ndarray: â€œâ€â€ Validate gain vectors for controller-specific stability requirements. Mathematical Validation Rules: Classical SMC: - All gains &gt; 0 (positive definiteness) - Sliding surface gains câ‚, Î»â‚, câ‚‚, Î»â‚‚ ensure Hurwitz characteristic polynomial - Switching gains K, kd provide reaching condition satisfaction STA-SMC (Super-Twisting): - Algorithmic gains: Kâ‚ &gt; Kâ‚‚ &gt; 0 (stability condition) - Surface coefficients: Î»â‚, Î»â‚‚ for target damping ratio Î¶ âˆˆ [0.6, 0.8] - Finite-time convergence: Kâ‚Â² &gt; 4Kâ‚‚|Î»â‚Î»â‚‚| Parameters â€”â€”â€”- controller_type : str Controller identifier from registry gains : np.ndarray, shape (B, n) Batch of gain vectors to validate Returns â€”â€”- np.ndarray, shape (B,), dtype=bool Validity mask for each gain vector â€œâ€â€ registry_info = CONTROLLER_REGISTRY[controller_type] bounds = registry_info[â€˜gain_boundsâ€™] # Basic bounds checking valid_mask = np.ones(gains.shape[0], dtype=bool) for i, (min_val, max_val) in enumerate(bounds): valid_mask &amp;= (gains[:, i] &gt;= min_val) &amp; (gains[:, i] &lt;= max_val) # Controller-specific stability checks if controller_type == â€˜sta_smcâ€™: # Kâ‚ &gt; Kâ‚‚ condition for STA stability valid_mask &amp;= gains[:, 0] &gt; gains[:, 1] # Surface coefficient bounds for target damping lambda1, lambda2 = gains[:, 4], gains[:, 5] damping_ratio = lambda2 / (2 * np.sqrt(lambda1)) valid_mask &amp;= (damping_ratio &gt;= 0.6) &amp; (damping_ratio &lt;= 0.8) return valid_mask</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-def-compute-fitness-cost-t-np-ndarray-x-np-ndarray-u-np-ndarray-sigma-np-ndarray-float-multi-objective-fitness-function-for-pso-optimization-mathematical-formulation-j-w10-e-t-2dt-w20-u2-t-dt-w30-du-dt-2dt-w40-2-t-dt-p-where-e-t-x-t-x-ref-state-error-vector-u-t-control-effort-du-dt-control-rate-chattering-penalty-t-sliding-variable-magnitude-p-instability-penalty-for-early-termination-cost-function-components-1-state-error-ise-0-e-t-2dt-2-control-effort-0-u2-t-dt-3-control-rate-0-du-dt-2dt-4-sliding-variable-energy-0-2-t-dt-5-stability-penalty-graded-penalty-for-premature-failure-dt-np-diff-t-dt-matrix-dt-none-shape-1-n-1-state-error-integration-all-state-components-state-error-sq-np-sum-x-1-2-dt-matrix-none-axis-1-2-control-effort-integration-control-effort-sq-np-sum-u2-dt-matrix-axis-1-control-rate-penalty-anti-chattering-du-np-diff-u-axis-1-prepend-u-0-1-control-rate-sq-np-sum-du2-dt-matrix-axis-1-sliding-variable-energy-sliding-energy-np-sum-sigma2-dt-matrix-axis-1-instability-detection-and-penalty-instability-mask-detect-instability-x-u-sigma-stability-penalty-compute-graded-penalty-instability-mask-t-weighted-cost-aggregation-total-cost-weights-state-error-normalize-state-error-sq-norms-ise-weights-control-effort-normalize-control-effort-sq-norms-control-weights-control-rate-normalize-control-rate-sq-norms-rate-weights-stability-normalize-sliding-energy-norms-sliding-stability-penalty-return-total-cost">runnable: false def compute_fitness_cost(t: np.ndarray, x: np.ndarray, u: np.ndarray, sigma: np.ndarray) -&gt; float: â€œâ€â€ Multi-objective fitness function for PSO optimization. Mathematical Formulation: J = wâ‚âˆ«â‚€áµ€||e(t)||Â²dt + wâ‚‚âˆ«â‚€áµ€uÂ²(t)dt + wâ‚ƒâˆ«â‚€áµ€(du/dt)Â²dt + wâ‚„âˆ«â‚€áµ€ÏƒÂ²(t)dt + P Where: - e(t) = x(t) - x_ref: state error vector - u(t): control effort - du/dt: control rate (chattering penalty) - Ïƒ(t): sliding variable magnitude - P: instability penalty for early termination Cost Function Components: 1. State Error (ISE): âˆ«â‚€áµ€||e(t)||Â²dt 2. Control Effort: âˆ«â‚€áµ€uÂ²(t)dt 3. Control Rate: âˆ«â‚€áµ€(du/dt)Â²dt 4. Sliding Variable Energy: âˆ«â‚€áµ€ÏƒÂ²(t)dt 5. Stability Penalty: Graded penalty for premature failure â€œâ€â€ dt = np.diff(t) dt_matrix = dt[None, :] # Shape (1, N-1) # State error integration (all state components) state_error_sq = np.sum(x[:, :-1, :]<strong>2 * dt_matrix[:, :, None], axis=(1, 2)) # Control effort integration control_effort_sq = np.sum(u</strong>2 * dt_matrix, axis=1) # Control rate penalty (anti-chattering) du = np.diff(u, axis=1, prepend=u[:, 0:1]) control_rate_sq = np.sum(du<strong>2 * dt_matrix, axis=1) # Sliding variable energy sliding_energy = np.sum(sigma</strong>2 * dt_matrix, axis=1) # Instability detection and penalty instability_mask = detect_instability(x, u, sigma) stability_penalty = compute_graded_penalty(instability_mask, t) # Weighted cost aggregation total_cost = ( weights.state_error * normalize(state_error_sq, norms.ise) + weights.control_effort * normalize(control_effort_sq, norms.control) + weights.control_rate * normalize(control_rate_sq, norms.rate) + weights.stability * normalize(sliding_energy, norms.sliding) + stability_penalty ) return total_cost</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#id4">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-class-pso-convergencemonitor-advanced-convergence-monitoring-with-multiple-termination-criteria-def-init-self-patience-int-50-tolerance-float-1e-6-diversity-threshold-float-1e-8-self-patience-patience-self-tolerance-tolerance-self-diversity-threshold-diversity-threshold-self-best-cost-history-self-diversity-history-self-stagnation-counter-0-def-check-convergence-self-swarm-positions-np-ndarray-swarm-costs-np-ndarray-tuple-bool-str-multi-criteria-convergence-detection-1-cost-improvement-stagnation-2-swarm-diversity-collapse-3-gradient-based-local-optimum-detection-current-best-np-min-swarm-costs-self-best-cost-history-append-current-best-swarm-diversity-standard-deviation-of-positions-diversity-np-mean-np-std-swarm-positions-axis-0-self-diversity-history-append-diversity-check-improvement-stagnation-if-len-self-best-cost-history-2-improvement-abs-self-best-cost-history-2-current-best-relative-improvement-improvement-abs-current-best-1e-12-if-relative-improvement-self-tolerance-self-stagnation-counter-1-else-self-stagnation-counter-0-convergence-conditions-if-self-stagnation-counter-self-patience-return-true-f-cost-stagnation-self-stagnation-counter-iterations-without-improvement-if-diversity-self-diversity-threshold-return-true-f-diversity-collapse-diversity-2e-self-diversity-threshold-2e-return-false-optimization-continuing">runnable: false class PSO_ConvergenceMonitor: â€œâ€â€ Advanced convergence monitoring with multiple termination criteria. â€œâ€â€ def <strong>init</strong>(self, patience: int = 50, tolerance: float = 1e-6, diversity_threshold: float = 1e-8): self.patience = patience self.tolerance = tolerance self.diversity_threshold = diversity_threshold self.best_cost_history = [] self.diversity_history = [] self.stagnation_counter = 0 def check_convergence(self, swarm_positions: np.ndarray, swarm_costs: np.ndarray) -&gt; tuple[bool, str]: â€œâ€â€ Multi-criteria convergence detection: 1. Cost improvement stagnation 2. Swarm diversity collapse 3. Gradient-based local optimum detection â€œâ€â€ current_best = np.min(swarm_costs) self.best_cost_history.append(current_best) # Swarm diversity (standard deviation of positions) diversity = np.mean(np.std(swarm_positions, axis=0)) self.diversity_history.append(diversity) # Check improvement stagnation if len(self.best_cost_history) &gt;= 2: improvement = abs(self.best_cost_history[-2] - current_best) relative_improvement = improvement / (abs(current_best) + 1e-12) if relative_improvement &lt; self.tolerance: self.stagnation_counter += 1 else: self.stagnation_counter = 0 # Convergence conditions if self.stagnation_counter &gt;= self.patience: return True, fâ€Cost stagnation: {self.stagnation_counter} iterations without improvementâ€ if diversity &lt; self.diversity_threshold: return True, fâ€Diversity collapse: Ïƒ = {diversity:.2e} &lt; {self.diversity_threshold:.2e}â€ return False, â€œOptimization continuingâ€</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#id5">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-def-robust-optimization-under-uncertainty-pso-tuner-psotuner-uncertainty-config-physicsuncertaintyschema-dict-monte-carlo-robust-optimization-with-uncertainty-quantification-methodology-1-sample-n-physics-realizations-from-uncertainty-distributions-2-evaluate-each-particle-against-all-realizations-3-aggregate-costs-using-risk-sensitive-criteria-mean-std-4-report-confidence-intervals-for-optimal-gains-mathematical-framework-uncertain-parameters-n-0-2-for-each-physics-parameter-robust-cost-j-robust-e-j-g-std-j-g-risk-parameter-0-1-balancing-mean-vs-variance-generate-uncertainty-samples-physics-samples-generate-physics-samples-uncertainty-config-multi-realization-evaluation-costs-per-realization-for-physics-params-in-physics-samples-evaluate-swarm-under-this-realization-realization-costs-pso-tuner-evaluate-swarm-with-physics-physics-params-costs-per-realization-append-realization-costs-risk-sensitive-aggregation-mean-costs-np-mean-costs-per-realization-axis-0-std-costs-np-std-costs-per-realization-axis-0-robust-costs-mean-costs-uncertainty-config-risk-factor-std-costs-return-robust-costs-robust-costs-mean-costs-mean-costs-std-costs-std-costs-confidence-intervals-compute-confidence-intervals-costs-per-realization-physics-samples-physics-samples">runnable: false def robust_optimization_under_uncertainty(pso_tuner: PSOTuner, uncertainty_config: PhysicsUncertaintySchema) -&gt; dict: â€œâ€â€ Monte Carlo robust optimization with uncertainty quantification. Methodology: 1. Sample N physics realizations from uncertainty distributions 2. Evaluate each particle against all realizations 3. Aggregate costs using risk-sensitive criteria (mean + Î±Â·std) 4. Report confidence intervals for optimal gains Mathematical Framework: - Uncertain parameters: Î¸ ~ N(Î¸â‚€, ÏƒÂ²) for each physics parameter - Robust cost: J_robust = E[J(G,Î¸)] + Î±Â·Std[J(G,Î¸)] - Risk parameter: Î± âˆˆ [0, 1] balancing mean vs variance â€œâ€â€ # Generate uncertainty samples physics_samples = generate_physics_samples(uncertainty_config) # Multi-realization evaluation costs_per_realization = [] for physics_params in physics_samples: # Evaluate swarm under this realization realization_costs = pso_tuner.evaluate_swarm_with_physics(physics_params) costs_per_realization.append(realization_costs) # Risk-sensitive aggregation mean_costs = np.mean(costs_per_realization, axis=0) std_costs = np.std(costs_per_realization, axis=0) robust_costs = mean_costs + uncertainty_config.risk_factor * std_costs return { â€˜robust_costsâ€™: robust_costs, â€˜mean_costsâ€™: mean_costs, â€˜std_costsâ€™: std_costs, â€˜confidence_intervalsâ€™: compute_confidence_intervals(costs_per_realization), â€˜physics_samplesâ€™: physics_samples }</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#version-1-0-legacy-deprecated">Version 1.0 (Legacy) - Deprecated</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#id6">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-def-migrate-pso-configuration-legacy-config-dict-psoconfig-migrate-legacy-pso-configuration-to-current-schema-with-validation-migration-rules-1-remove-deprecated-fields-with-warnings-2-update-bounds-for-issue-2-resolution-compatibility-3-add-new-enhanced-features-with-sensible-defaults-4-validate-mathematical-consistency-of-migrated-parameters-warnings-remove-deprecated-fields-deprecated-fields-n-processes-hyper-trials-hyper-search-study-timeout-for-field-in-deprecated-fields-if-field-in-legacy-config-warnings-append-f-deprecated-field-field-removed-during-migration-del-legacy-config-field-update-bounds-for-issue-2-compatibility-if-bounds-in-legacy-config-old-bounds-legacy-config-bounds-if-max-in-old-bounds-and-len-old-bounds-max-6-check-for-problematic-lambda-bounds-from-issue-2-if-old-bounds-max-4-10-0-or-old-bounds-max-5-10-0-warnings-append-updated-lambda-bounds-for-issue-2-overshoot-resolution-old-bounds-max-4-min-old-bounds-max-4-10-0-old-bounds-max-5-min-old-bounds-max-5-10-0-add-enhanced-features-if-missing-if-w-schedule-not-in-legacy-config-legacy-config-w-schedule-0-9-0-4-warnings-append-added-inertia-weight-scheduling-for-improved-convergence-if-velocity-clamp-not-in-legacy-config-legacy-config-velocity-clamp-0-1-0-2-warnings-append-added-velocity-clamping-for-stability-validate-migrated-configuration-migrated-config-psoconfig-legacy-config-validation-result-pso-configvalidator-validate-hyperparameters-migrated-config-if-not-validation-result-is-valid-raise-configurationerror-f-migration-failed-validation-validation-result-errors-return-migrated-config-warnings">runnable: false def migrate_pso_configuration(legacy_config: dict) -&gt; PSOConfig: â€œâ€â€ Migrate legacy PSO configuration to current schema with validation. Migration Rules: 1. Remove deprecated fields with warnings 2. Update bounds for Issue #2 resolution compatibility 3. Add new enhanced features with sensible defaults 4. Validate mathematical consistency of migrated parameters â€œâ€â€ warnings = [] # Remove deprecated fields deprecated_fields = [â€˜n_processesâ€™, â€˜hyper_trialsâ€™, â€˜hyper_searchâ€™, â€˜study_timeoutâ€™] for field in deprecated_fields: if field in legacy_config: warnings.append(fâ€Deprecated field â€˜{field}â€™ removed during migrationâ€) del legacy_config[field] # Update bounds for Issue #2 compatibility if â€˜boundsâ€™ in legacy_config: old_bounds = legacy_config[â€˜boundsâ€™] if â€˜maxâ€™ in old_bounds and len(old_bounds[â€˜maxâ€™]) &gt;= 6: # Check for problematic lambda bounds from Issue #2 if old_bounds[â€˜maxâ€™][4] &gt; 10.0 or old_bounds[â€˜maxâ€™][5] &gt; 10.0: warnings.append(â€œUpdated lambda bounds for Issue #2 overshoot resolutionâ€) old_bounds[â€˜maxâ€™][4] = min(old_bounds[â€˜maxâ€™][4], 10.0) old_bounds[â€˜maxâ€™][5] = min(old_bounds[â€˜maxâ€™][5], 10.0) # Add enhanced features if missing if â€˜w_scheduleâ€™ not in legacy_config: legacy_config[â€˜w_scheduleâ€™] = [0.9, 0.4] warnings.append(â€œAdded inertia weight scheduling for improved convergenceâ€) if â€˜velocity_clampâ€™ not in legacy_config: legacy_config[â€˜velocity_clampâ€™] = [0.1, 0.2] warnings.append(â€œAdded velocity clamping for stabilityâ€) # Validate migrated configuration migrated_config = PSOConfig(**legacy_config) validation_result = PSO_ConfigValidator.validate_hyperparameters(migrated_config) if not validation_result.is_valid: raise ConfigurationError(fâ€Migration failed validation: {validation_result.errors}â€) return migrated_config, warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html">PSO Optimization Workflow Specifications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#runnable-false-class-optimizationworkflowmanager-management-of-pso-optimization-workflow-execution-def-init-self-config-dict-controller-type-str-self-config-config-self-controller-type-controller-type-self-monitors-performance-performancemonitor-convergence-convergencemonitor-memory-memorymonitor-safety-safetymonitor-self-workflow-state-workflowstate-def-execute-optimization-workflow-self-controller-factory-callable-optimizationresult-execute-complete-pso-optimization-workflow-with-monitoring-workflow-phases-1-pre-optimization-setup-and-validation-2-pso-tuner-initialization-3-optimization-loop-execution-4-real-time-monitoring-and-adaptation-5-post-optimization-validation-6-result-analysis-and-reporting-workflow-start-time-time-time-result-optimizationresult-try-phase-1-pre-optimization-setup-setup-result-self-execute-setup-phase-controller-factory-result-setup-results-setup-result-if-not-setup-result-success-result-status-setup-failed-return-result-phase-2-pso-tuner-initialization-tuner-result-self-execute-tuner-initialization-result-tuner-results-tuner-result-if-not-tuner-result-success-result-status-tuner-failed-return-result-phase-3-optimization-execution-optimization-result-self-execute-optimization-loop-result-optimization-results-optimization-result-if-not-optimization-result-success-result-status-optimization-failed-return-result-phase-4-post-optimization-validation-validation-result-self-execute-validation-phase-optimization-result-result-validation-results-validation-result-phase-5-result-analysis-analysis-result-self-execute-analysis-phase-optimization-result-result-analysis-results-analysis-result-result-status-success-result-total-time-time-time-workflow-start-time-except-exception-as-e-result-status-error-result-error-message-str-e-result-total-time-time-time-workflow-start-time-return-result-def-execute-setup-phase-self-controller-factory-callable-setupresult-execute-pre-optimization-setup-and-validation-setup-result-setupresult-validate-controller-factory-if-not-hasattr-controller-factory-n-gains-setup-result-errors-append-controller-factory-missing-n-gains-attribute-setup-result-success-false-return-setup-result-validate-factory-functionality-try-test-gains-np-ones-controller-factory-n-gains-test-controller-controller-factory-test-gains-if-not-hasattr-test-controller-max-force-setup-result-warnings-append-controller-missing-max-force-attribute-except-exception-as-e-setup-result-errors-append-f-controller-factory-test-failed-str-e-setup-result-success-false-return-setup-result-setup-monitoring-systems-for-name-monitor-in-self-monitors-items-try-monitor-initialize-self-config-setup-result-monitors-initialized-append-name-except-exception-as-e-setup-result-errors-append-f-monitor-name-initialization-failed-str-e-validate-memory-availability-available-memory-psutil-virtual-memory-available-1024-3-gb-required-memory-self-estimate-memory-requirement-if-available-memory-required-memory-setup-result-warnings-append-f-low-memory-available-memory-1f-gb-available-required-memory-1f-gb-recommended-setup-result-success-len-setup-result-errors-0-return-setup-result-def-execute-optimization-loop-self-optimizationloopresult-execute-pso-optimization-loop-with-real-time-monitoring-result-optimizationloopresult-try-initialize-pso-tuner-tuner-psotuner-controller-factory-self-controller-factory-config-self-config-seed-self-config-get-pso-get-execution-get-seed-42-setup-optimization-monitoring-optimization-monitor-optimizationmonitor-monitors-self-monitors-config-self-config-execute-optimization-with-monitoring-pso-result-tuner-optimise-extract-results-result-best-cost-pso-result-best-cost-result-best-gains-pso-result-best-pos-result-cost-history-pso-result-history-cost-result-position-history-pso-result-history-pos-get-monitoring-data-result-performance-metrics-optimization-monitor-get-performance-summary-result-convergence-analysis-optimization-monitor-get-convergence-analysis-result-success-true-except-exception-as-e-result-success-false-result-error-message-str-e-return-result">runnable: false class OptimizationWorkflowManager: â€œâ€â€ management of PSO optimization workflow execution. â€œâ€â€ def <strong>init</strong>(self, config: dict, controller_type: str): self.config = config self.controller_type = controller_type self.monitors = { â€˜performanceâ€™: PerformanceMonitor(), â€˜convergenceâ€™: ConvergenceMonitor(), â€˜memoryâ€™: MemoryMonitor(), â€˜safetyâ€™: SafetyMonitor() } self.workflow_state = WorkflowState() def execute_optimization_workflow(self, controller_factory: Callable) -&gt; OptimizationResult: â€œâ€â€ Execute complete PSO optimization workflow with monitoring. Workflow Phases: 1. Pre-optimization setup and validation 2. PSO tuner initialization 3. Optimization loop execution 4. Real-time monitoring and adaptation 5. Post-optimization validation 6. Result analysis and reporting â€œâ€â€ workflow_start_time = time.time() result = OptimizationResult() try: # Phase 1: Pre-optimization Setup setup_result = self._execute_setup_phase(controller_factory) result.setup_results = setup_result if not setup_result.success: result.status = â€˜SETUP_FAILEDâ€™ return result # Phase 2: PSO Tuner Initialization tuner_result = self._execute_tuner_initialization() result.tuner_results = tuner_result if not tuner_result.success: result.status = â€˜TUNER_FAILEDâ€™ return result # Phase 3: Optimization Execution optimization_result = self._execute_optimization_loop() result.optimization_results = optimization_result if not optimization_result.success: result.status = â€˜OPTIMIZATION_FAILEDâ€™ return result # Phase 4: Post-optimization Validation validation_result = self._execute_validation_phase(optimization_result) result.validation_results = validation_result # Phase 5: Result Analysis analysis_result = self._execute_analysis_phase(optimization_result) result.analysis_results = analysis_result result.status = â€˜SUCCESSâ€™ result.total_time = time.time() - workflow_start_time except Exception as e: result.status = â€˜ERRORâ€™ result.error_message = str(e) result.total_time = time.time() - workflow_start_time return result def _execute_setup_phase(self, controller_factory: Callable) -&gt; SetupResult: â€œâ€â€ Execute pre-optimization setup and validation. â€œâ€â€ setup_result = SetupResult() # Validate controller factory if not hasattr(controller_factory, â€˜n_gainsâ€™): setup_result.errors.append(â€˜Controller factory missing n_gains attributeâ€™) setup_result.success = False return setup_result # Validate factory functionality try: test_gains = np.ones(controller_factory.n_gains) test_controller = controller_factory(test_gains) if not hasattr(test_controller, â€˜max_forceâ€™): setup_result.warnings.append(â€˜Controller missing max_force attributeâ€™) except Exception as e: setup_result.errors.append(fâ€™Controller factory test failed: {str(e)}â€™) setup_result.success = False return setup_result # Setup monitoring systems for name, monitor in self.monitors.items(): try: monitor.initialize(self.config) setup_result.monitors_initialized.append(name) except Exception as e: setup_result.errors.append(fâ€™Monitor {name} initialization failed: {str(e)}â€™) # Validate memory availability available_memory = psutil.virtual_memory().available / (1024**3) # GB required_memory = self._estimate_memory_requirement() if available_memory &lt; required_memory: setup_result.warnings.append(fâ€™Low memory: {available_memory:.1f}GB available, {required_memory:.1f}GB recommendedâ€™) setup_result.success = len(setup_result.errors) == 0 return setup_result def _execute_optimization_loop(self) -&gt; OptimizationLoopResult: â€œâ€â€ Execute PSO optimization loop with real-time monitoring. â€œâ€â€ result = OptimizationLoopResult() try: # Initialize PSO tuner tuner = PSOTuner( controller_factory=self.controller_factory, config=self.config, seed=self.config.get(â€˜psoâ€™, {}).get(â€˜executionâ€™, {}).get(â€˜seedâ€™, 42) ) # Setup optimization monitoring optimization_monitor = OptimizationMonitor( monitors=self.monitors, config=self.config ) # Execute optimization with monitoring pso_result = tuner.optimise() # Extract results result.best_cost = pso_result[â€˜best_costâ€™] result.best_gains = pso_result[â€˜best_posâ€™] result.cost_history = pso_result[â€˜historyâ€™][â€˜costâ€™] result.position_history = pso_result[â€˜historyâ€™][â€˜posâ€™] # Get monitoring data result.performance_metrics = optimization_monitor.get_performance_summary() result.convergence_analysis = optimization_monitor.get_convergence_analysis() result.success = True except Exception as e: result.success = False result.error_message = str(e) return result</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#runnable-false-class-optimizationmonitor-real-time-monitoring-system-for-pso-optimization-with-adaptive-features-def-init-self-monitors-dict-config-dict-self-monitors-monitors-self-config-config-self-monitoring-data-iteration-times-memory-usage-cost-improvements-diversity-metrics-constraint-violations-safety-alerts-def-monitor-iteration-self-iteration-int-swarm-state-dict-monitoringresult-monitor-single-pso-iteration-with-metrics-collection-iteration-start-time-time-result-monitoringresult-performance-monitoring-perf-metrics-self-monitors-performance-collect-metrics-swarm-state-self-monitoring-data-iteration-times-append-perf-metrics-iteration-time-self-monitoring-data-memory-usage-append-perf-metrics-memory-mb-convergence-monitoring-conv-metrics-self-monitors-convergence-analyze-convergence-swarm-state-self-monitoring-data-cost-improvements-append-conv-metrics-cost-improvement-self-monitoring-data-diversity-metrics-append-conv-metrics-diversity-constraint-validation-constraint-result-self-validate-constraints-realtime-swarm-state-self-monitoring-data-constraint-violations-extend-constraint-result-violations-safety-monitoring-safety-result-self-monitors-safety-check-safety-conditions-swarm-state-if-safety-result-alerts-self-monitoring-data-safety-alerts-extend-safety-result-alerts-adaptive-parameter-adjustment-if-self-should-adapt-parameters-iteration-swarm-state-adaptations-self-compute-parameter-adaptations-swarm-state-result-parameter-adaptations-adaptations-issue-2-specific-monitoring-for-sta-smc-if-self-config-get-controller-type-sta-smc-issue2-result-self-monitor-issue2-compliance-swarm-state-result-issue2-compliance-issue2-result-result-monitoring-data-self-monitoring-data-result-iteration-time-time-time-iteration-start-return-result-def-validate-constraints-realtime-self-swarm-state-dict-dict-real-time-validation-of-mathematical-and-physical-constraints-violations-particles-swarm-state-get-positions-np-array-if-particles-size-0-return-violations-violations-controller-type-self-config-get-controller-type-classical-smc-controller-specific-constraint-checking-if-controller-type-sta-smc-and-particles-shape-1-6-k1-k2-constraint-k1-particles-k2-particles-particles-0-particles-1-k1-le-k2-mask-k1-particles-k2-particles-if-np-any-k1-le-k2-mask-violation-count-np-sum-k1-le-k2-mask-violations-append-type-sta-stability-violation-count-violation-count-particles-np-where-k1-le-k2-mask-0-tolist-severity-high-issue-2-damping-ratio-constraint-if-particles-shape-1-6-lambda1-lambda2-particles-4-particles-5-k1-k2-particles-2-particles-3-safe-computation-with-epsilon-to-avoid-division-by-zero-epsilon-1e-12-zeta1-lambda1-2-np-sqrt-k1-epsilon-zeta2-lambda2-2-np-sqrt-k2-epsilon-check-issue-2-requirement-0-69-zeta1-violation-zeta1-0-69-zeta2-violation-zeta2-0-69-if-np-any-zeta1-violation-or-np-any-zeta2-violation-violation-particles-np-where-zeta1-violation-zeta2-violation-0-violations-append-type-issue2-damping-violation-count-len-violation-particles-particles-violation-particles-tolist-severity-high-details-min-zeta1-np-min-zeta1-min-zeta2-np-min-zeta2-requirement-0-69-for-5-overshoot-return-violations-violations-def-monitor-issue2-compliance-self-swarm-state-dict-dict-specialized-monitoring-for-issue-2-overshoot-compliance-particles-swarm-state-get-positions-np-array-if-particles-size-0-or-particles-shape-1-6-return-status-insufficient-data-extract-surface-coefficients-lambda1-lambda2-particles-4-particles-5-k1-k2-particles-2-particles-3-compute-damping-ratios-epsilon-1e-12-zeta1-lambda1-2-np-sqrt-k1-epsilon-zeta2-lambda2-2-np-sqrt-k2-epsilon-issue-2-compliance-analysis-compliance-stats-compliant-particles-0-total-particles-len-particles-min-damping-ratio-min-np-min-zeta1-np-min-zeta2-avg-damping-ratio-np-mean-zeta1-np-mean-zeta2-2-predicted-overshoot-range-lambda-bounds-status-unknown-count-compliant-particles-0-69-compliant-mask-zeta1-0-69-zeta2-0-69-compliance-stats-compliant-particles-np-sum-compliant-mask-predict-overshoot-for-representative-particles-for-i-in-range-min-5-len-particles-sample-first-5-particles-zeta-avg-zeta1-i-zeta2-i-2-if-zeta-avg-1-0-underdamped-predicted-overshoot-100-np-exp-zeta-avg-np-pi-np-sqrt-1-zeta-avg-2-else-overdamped-predicted-overshoot-0-0-compliance-stats-predicted-overshoot-range-append-predicted-overshoot-check-lambda-bounds-status-max-lambda1-max-lambda2-np-max-lambda1-np-max-lambda2-if-max-lambda1-10-0-and-max-lambda2-10-0-compliance-stats-lambda-bounds-status-compliant-else-compliance-stats-lambda-bounds-status-violation-return-compliance-stats">runnable: false class OptimizationMonitor: â€œâ€â€ Real-time monitoring system for PSO optimization with adaptive features. â€œâ€â€ def <strong>init</strong>(self, monitors: dict, config: dict): self.monitors = monitors self.config = config self.monitoring_data = { â€˜iteration_timesâ€™: [], â€˜memory_usageâ€™: [], â€˜cost_improvementsâ€™: [], â€˜diversity_metricsâ€™: [], â€˜constraint_violationsâ€™: [], â€˜safety_alertsâ€™: [] } def monitor_iteration(self, iteration: int, swarm_state: dict) -&gt; MonitoringResult: â€œâ€â€ Monitor single PSO iteration with metrics collection. â€œâ€â€ iteration_start = time.time() result = MonitoringResult() # Performance monitoring perf_metrics = self.monitors[â€˜performanceâ€™].collect_metrics(swarm_state) self.monitoring_data[â€˜iteration_timesâ€™].append(perf_metrics[â€˜iteration_timeâ€™]) self.monitoring_data[â€˜memory_usageâ€™].append(perf_metrics[â€˜memory_mbâ€™]) # Convergence monitoring conv_metrics = self.monitors[â€˜convergenceâ€™].analyze_convergence(swarm_state) self.monitoring_data[â€˜cost_improvementsâ€™].append(conv_metrics[â€˜cost_improvementâ€™]) self.monitoring_data[â€˜diversity_metricsâ€™].append(conv_metrics[â€˜diversityâ€™]) # Constraint validation constraint_result = self._validate_constraints_realtime(swarm_state) self.monitoring_data[â€˜constraint_violationsâ€™].extend(constraint_result[â€˜violationsâ€™]) # Safety monitoring safety_result = self.monitors[â€˜safetyâ€™].check_safety_conditions(swarm_state) if safety_result[â€˜alertsâ€™]: self.monitoring_data[â€˜safety_alertsâ€™].extend(safety_result[â€˜alertsâ€™]) # Adaptive parameter adjustment if self._should_adapt_parameters(iteration, swarm_state): adaptations = self._compute_parameter_adaptations(swarm_state) result.parameter_adaptations = adaptations # Issue #2 specific monitoring for STA-SMC if self.config.get(â€˜controller_typeâ€™) == â€˜sta_smcâ€™: issue2_result = self._monitor_issue2_compliance(swarm_state) result.issue2_compliance = issue2_result result.monitoring_data = self.monitoring_data result.iteration_time = time.time() - iteration_start return result def _validate_constraints_realtime(self, swarm_state: dict) -&gt; dict: â€œâ€â€ Real-time validation of mathematical and physical constraints. â€œâ€â€ violations = [] particles = swarm_state.get(â€˜positionsâ€™, np.array([])) if particles.size == 0: return {â€˜violationsâ€™: violations} controller_type = self.config.get(â€˜controller_typeâ€™, â€˜classical_smcâ€™) # Controller-specific constraint checking if controller_type == â€˜sta_smcâ€™ and particles.shape[1] &gt;= 6: # Kâ‚ &gt; Kâ‚‚ constraint k1_particles, k2_particles = particles[:, 0], particles[:, 1] k1_le_k2_mask = k1_particles &lt;= k2_particles if np.any(k1_le_k2_mask): violation_count = np.sum(k1_le_k2_mask) violations.append({ â€˜typeâ€™: â€˜STA_STABILITY_VIOLATIONâ€™, â€˜countâ€™: violation_count, â€˜particlesâ€™: np.where(k1_le_k2_mask)[0].tolist(), â€˜severityâ€™: â€˜HIGHâ€™ }) # Issue #2 damping ratio constraint if particles.shape[1] &gt;= 6: lambda1, lambda2 = particles[:, 4], particles[:, 5] k1, k2 = particles[:, 2], particles[:, 3] # Safe computation with epsilon to avoid division by zero epsilon = 1e-12 zeta1 = lambda1 / (2 * np.sqrt(k1 + epsilon)) zeta2 = lambda2 / (2 * np.sqrt(k2 + epsilon)) # Check Issue #2 requirement: Î¶ â‰¥ 0.69 zeta1_violation = zeta1 &lt; 0.69 zeta2_violation = zeta2 &lt; 0.69 if np.any(zeta1_violation) or np.any(zeta2_violation): violation_particles = np.where(zeta1_violation | zeta2_violation)[0] violations.append({ â€˜typeâ€™: â€˜ISSUE2_DAMPING_VIOLATIONâ€™, â€˜countâ€™: len(violation_particles), â€˜particlesâ€™: violation_particles.tolist(), â€˜severityâ€™: â€˜HIGHâ€™, â€˜detailsâ€™: { â€˜min_zeta1â€™: np.min(zeta1), â€˜min_zeta2â€™: np.min(zeta2), â€˜requirementâ€™: â€˜Î¶ â‰¥ 0.69 for &lt;5% overshootâ€™ } }) return {â€˜violationsâ€™: violations} def _monitor_issue2_compliance(self, swarm_state: dict) -&gt; dict: â€œâ€â€ Specialized monitoring for Issue #2 overshoot compliance. â€œâ€â€ particles = swarm_state.get(â€˜positionsâ€™, np.array([])) if particles.size == 0 or particles.shape[1] &lt; 6: return {â€˜statusâ€™: â€˜insufficient_dataâ€™} # Extract surface coefficients lambda1, lambda2 = particles[:, 4], particles[:, 5] k1, k2 = particles[:, 2], particles[:, 3] # Compute damping ratios epsilon = 1e-12 zeta1 = lambda1 / (2 * np.sqrt(k1 + epsilon)) zeta2 = lambda2 / (2 * np.sqrt(k2 + epsilon)) # Issue #2 compliance analysis compliance_stats = { â€˜compliant_particlesâ€™: 0, â€˜total_particlesâ€™: len(particles), â€˜min_damping_ratioâ€™: min(np.min(zeta1), np.min(zeta2)), â€˜avg_damping_ratioâ€™: (np.mean(zeta1) + np.mean(zeta2)) / 2, â€˜predicted_overshoot_rangeâ€™: [], â€˜lambda_bounds_statusâ€™: â€˜unknownâ€™ } # Count compliant particles (Î¶ â‰¥ 0.69) compliant_mask = (zeta1 &gt;= 0.69) &amp; (zeta2 &gt;= 0.69) compliance_stats[â€˜compliant_particlesâ€™] = np.sum(compliant_mask) # Predict overshoot for representative particles for i in range(min(5, len(particles))): # Sample first 5 particles zeta_avg = (zeta1[i] + zeta2[i]) / 2 if zeta_avg &lt; 1.0: # Underdamped predicted_overshoot = 100 * np.exp(-zeta_avg * np.pi / np.sqrt(1 - zeta_avg**2)) else: # Overdamped predicted_overshoot = 0.0 compliance_stats[â€˜predicted_overshoot_rangeâ€™].append(predicted_overshoot) # Check lambda bounds status max_lambda1, max_lambda2 = np.max(lambda1), np.max(lambda2) if max_lambda1 &lt;= 10.0 and max_lambda2 &lt;= 10.0: compliance_stats[â€˜lambda_bounds_statusâ€™] = â€˜compliantâ€™ else: compliance_stats[â€˜lambda_bounds_statusâ€™] = â€˜violationâ€™ return compliance_stats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#runnable-false-class-qualitygatesystem-automated-quality-gate-system-for-pso-optimization-workflow-def-init-self-config-dict-self-config-config-self-quality-gates-configurationqualitygate-optimizationqualitygate-performancequalitygate-safetyqualitygate-issue2compliancequalitygate-regressionqualitygate-def-evaluate-quality-gates-self-workflow-result-dict-qualitygatereport-evaluate-all-quality-gates-and-generate-report-report-qualitygatereport-for-gate-in-self-quality-gates-gate-result-gate-evaluate-workflow-result-self-config-report-add-gate-result-gate-name-gate-result-generate-overall-assessment-report-generate-overall-assessment-return-report-class-issue2compliancequalitygate-qualitygate-quality-gate-specifically-for-issue-2-overshoot-compliance-def-init-self-self-name-issue2-overshoot-compliance-self-acceptance-criteria-max-predicted-overshoot-5-0-maximum-theoretical-overshoot-min-damping-ratio-0-69-minimum-damping-for-compliance-max-lambda-bounds-10-0-maximum-lambda-values-simulation-overshoot-limit-5-0-maximum-measured-overshoot-def-evaluate-self-workflow-result-dict-config-dict-qualitygateresult-evaluate-issue-2-overshoot-compliance-result-qualitygateresult-gate-name-self-name-skip-if-not-sta-smc-if-config-get-controller-type-sta-smc-result-status-skipped-result-message-issue-2-compliance-only-applies-to-sta-smc-return-result-optimized-gains-workflow-result-get-best-gains-if-optimized-gains-is-none-or-len-optimized-gains-6-result-status-failed-result-message-missing-or-insufficient-optimized-gains-return-result-extract-surface-coefficients-lambda1-lambda2-optimized-gains-4-optimized-gains-5-k1-k2-optimized-gains-2-optimized-gains-3-check-1-lambda-bounds-compliance-lambda-bounds-ok-lambda1-self-acceptance-criteria-max-lambda-bounds-and-lambda2-self-acceptance-criteria-max-lambda-bounds-check-2-damping-ratio-compliance-zeta1-lambda1-2-np-sqrt-k1-zeta2-lambda2-2-np-sqrt-k2-damping-ok-zeta1-self-acceptance-criteria-min-damping-ratio-and-zeta2-self-acceptance-criteria-min-damping-ratio-check-3-predicted-overshoot-avg-zeta-zeta1-zeta2-2-if-avg-zeta-1-0-predicted-overshoot-100-np-exp-avg-zeta-np-pi-np-sqrt-1-avg-zeta-2-else-predicted-overshoot-0-0-overshoot-prediction-ok-predicted-overshoot-self-acceptance-criteria-max-predicted-overshoot-check-4-simulation-validation-if-available-simulation-ok-true-measured-overshoot-none-if-overshoot-measurement-in-workflow-result-overshoot-data-workflow-result-overshoot-measurement-measured-overshoot-overshoot-data-get-measured-overshoot-percent-0-simulation-ok-measured-overshoot-self-acceptance-criteria-simulation-overshoot-limit-overall-assessment-all-checks-pass-lambda-bounds-ok-and-damping-ok-and-overshoot-prediction-ok-and-simulation-ok-if-all-checks-pass-result-status-passed-result-message-f-issue-2-compliance-verified-predicted-overshoot-predicted-overshoot-2f-else-result-status-failed-failed-checks-if-not-lambda-bounds-ok-failed-checks-append-f-lambda-bounds-1-lambda1-3f-2-lambda2-3f-self-acceptance-criteria-max-lambda-bounds-if-not-damping-ok-failed-checks-append-f-damping-ratios-1-zeta1-3f-2-zeta2-3f-self-acceptance-criteria-min-damping-ratio-if-not-overshoot-prediction-ok-failed-checks-append-f-predicted-overshoot-predicted-overshoot-2f-self-acceptance-criteria-max-predicted-overshoot-if-not-simulation-ok-and-measured-overshoot-is-not-none-failed-checks-append-f-measured-overshoot-measured-overshoot-2f-self-acceptance-criteria-simulation-overshoot-limit-result-message-f-issue-2-compliance-failed-join-failed-checks-add-detailed-metrics-result-metrics-lambda1-lambda1-lambda2-lambda2-damping-ratio-1-zeta1-damping-ratio-2-zeta2-predicted-overshoot-percent-predicted-overshoot-measured-overshoot-percent-measured-overshoot-lambda-bounds-compliant-lambda-bounds-ok-damping-compliant-damping-ok-overshoot-prediction-compliant-overshoot-prediction-ok-simulation-compliant-simulation-ok-return-result">runnable: false class QualityGateSystem: â€œâ€â€ Automated quality gate system for PSO optimization workflow. â€œâ€â€ def <strong>init</strong>(self, config: dict): self.config = config self.quality_gates = [ ConfigurationQualityGate(), OptimizationQualityGate(), PerformanceQualityGate(), SafetyQualityGate(), Issue2ComplianceQualityGate(), RegressionQualityGate() ] def evaluate_quality_gates(self, workflow_result: dict) -&gt; QualityGateReport: â€œâ€â€ Evaluate all quality gates and generate report. â€œâ€â€ report = QualityGateReport() for gate in self.quality_gates: gate_result = gate.evaluate(workflow_result, self.config) report.add_gate_result(gate.name, gate_result) # Generate overall assessment report.generate_overall_assessment() return report class Issue2ComplianceQualityGate(QualityGate): â€œâ€â€ Quality gate specifically for Issue #2 overshoot compliance. â€œâ€â€ def <strong>init</strong>(self): self.name = â€œIssue2_Overshoot_Complianceâ€ self.acceptance_criteria = { â€˜max_predicted_overshootâ€™: 5.0, # % maximum theoretical overshoot â€˜min_damping_ratioâ€™: 0.69, # Minimum damping for compliance â€˜max_lambda_boundsâ€™: 10.0, # Maximum lambda values â€˜simulation_overshoot_limitâ€™: 5.0 # % maximum measured overshoot } def evaluate(self, workflow_result: dict, config: dict) -&gt; QualityGateResult: â€œâ€â€ Evaluate Issue #2 overshoot compliance. â€œâ€â€ result = QualityGateResult(gate_name=self.name) # Skip if not STA-SMC if config.get(â€˜controller_typeâ€™) != â€˜sta_smcâ€™: result.status = â€˜SKIPPEDâ€™ result.message = â€˜Issue #2 compliance only applies to STA-SMCâ€™ return result optimized_gains = workflow_result.get(â€˜best_gainsâ€™) if optimized_gains is None or len(optimized_gains) &lt; 6: result.status = â€˜FAILEDâ€™ result.message = â€˜Missing or insufficient optimized gainsâ€™ return result # Extract surface coefficients lambda1, lambda2 = optimized_gains[4], optimized_gains[5] k1, k2 = optimized_gains[2], optimized_gains[3] # Check 1: Lambda bounds compliance lambda_bounds_ok = (lambda1 &lt;= self.acceptance_criteria[â€˜max_lambda_boundsâ€™] and lambda2 &lt;= self.acceptance_criteria[â€˜max_lambda_boundsâ€™]) # Check 2: Damping ratio compliance zeta1 = lambda1 / (2 * np.sqrt(k1)) zeta2 = lambda2 / (2 * np.sqrt(k2)) damping_ok = (zeta1 &gt;= self.acceptance_criteria[â€˜min_damping_ratioâ€™] and zeta2 &gt;= self.acceptance_criteria[â€˜min_damping_ratioâ€™]) # Check 3: Predicted overshoot avg_zeta = (zeta1 + zeta2) / 2 if avg_zeta &lt; 1.0: predicted_overshoot = 100 * np.exp(-avg_zeta * np.pi / np.sqrt(1 - avg_zeta**2)) else: predicted_overshoot = 0.0 overshoot_prediction_ok = predicted_overshoot &lt;= self.acceptance_criteria[â€˜max_predicted_overshootâ€™] # Check 4: Simulation validation (if available) simulation_ok = True measured_overshoot = None if â€˜overshoot_measurementâ€™ in workflow_result: overshoot_data = workflow_result[â€˜overshoot_measurementâ€™] measured_overshoot = overshoot_data.get(â€˜measured_overshoot_percentâ€™, 0) simulation_ok = measured_overshoot &lt;= self.acceptance_criteria[â€˜simulation_overshoot_limitâ€™] # Overall assessment all_checks_pass = lambda_bounds_ok and damping_ok and overshoot_prediction_ok and simulation_ok if all_checks_pass: result.status = â€˜PASSEDâ€™ result.message = fâ€™Issue #2 compliance verified: predicted overshoot {predicted_overshoot:.2f}%â€™ else: result.status = â€˜FAILEDâ€™ failed_checks = [] if not lambda_bounds_ok: failed_checks.append(fâ€™Lambda bounds: Î»â‚={lambda1:.3f}, Î»â‚‚={lambda2:.3f} &gt; {self.acceptance_criteria[â€œmax_lambda_boundsâ€]}â€™) if not damping_ok: failed_checks.append(fâ€™Damping ratios: Î¶â‚={zeta1:.3f}, Î¶â‚‚={zeta2:.3f} &lt; {self.acceptance_criteria[â€œmin_damping_ratioâ€]}â€™) if not overshoot_prediction_ok: failed_checks.append(fâ€™Predicted overshoot: {predicted_overshoot:.2f}% &gt; {self.acceptance_criteria[â€œmax_predicted_overshootâ€]}%â€™) if not simulation_ok and measured_overshoot is not None: failed_checks.append(fâ€™Measured overshoot: {measured_overshoot:.2f}% &gt; {self.acceptance_criteria[â€œsimulation_overshoot_limitâ€]}%â€™) result.message = fâ€™Issue #2 compliance failed: {â€; â€œ.join(failed_checks)}â€™ # Add detailed metrics result.metrics = { â€˜lambda1â€™: lambda1, â€˜lambda2â€™: lambda2, â€˜damping_ratio_1â€™: zeta1, â€˜damping_ratio_2â€™: zeta2, â€˜predicted_overshoot_percentâ€™: predicted_overshoot, â€˜measured_overshoot_percentâ€™: measured_overshoot, â€˜lambda_bounds_compliantâ€™: lambda_bounds_ok, â€˜damping_compliantâ€™: damping_ok, â€˜overshoot_prediction_compliantâ€™: overshoot_prediction_ok, â€˜simulation_compliantâ€™: simulation_ok } return result</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#runnable-false-class-workflowperformanceoptimizer-adaptive-optimization-of-workflow-performance-based-on-runtime-metrics-def-init-self-self-performance-history-self-optimization-strategies-memory-optimization-self-optimize-memory-usage-convergence-acceleration-self-accelerate-convergence-bounds-tightening-self-tighten-bounds-dynamically-parameter-adaptation-self-adapt-pso-parameters-def-optimize-workflow-performance-self-current-metrics-dict-workflow-config-dict-optimizationresult-analyze-current-performance-and-apply-optimization-strategies-result-optimizationresult-analyze-performance-trends-performance-analysis-self-analyze-performance-trends-current-metrics-apply-relevant-optimization-strategies-for-strategy-name-strategy-func-in-self-optimization-strategies-items-if-self-should-apply-strategy-strategy-name-performance-analysis-strategy-result-strategy-func-current-metrics-workflow-config-result-add-strategy-result-strategy-name-strategy-result-return-result-def-accelerate-convergence-self-metrics-dict-config-dict-dict-apply-convergence-acceleration-strategies-based-on-performance-analysis-acceleration-result-applied-optimizations-expected-improvement-0-0-check-convergence-rate-convergence-rate-metrics-get-convergence-rate-0-0-if-convergence-rate-0-05-slow-convergence-detected-suggest-inertia-weight-adjustment-current-w-config-get-pso-get-algorithm-params-get-w-0-7-if-current-w-0-5-suggested-w-max-0-4-current-w-0-1-acceleration-result-applied-optimizations-append-parameter-inertia-weight-current-value-current-w-suggested-value-suggested-w-justification-reduce-inertia-for-faster-exploitation-acceleration-result-expected-improvement-15-0-15-improvement-check-diversity-metrics-diversity-metrics-get-swarm-diversity-1-0-if-diversity-1e-8-very-low-diversity-acceleration-result-applied-optimizations-append-parameter-restart-mechanism-action-enable-fraction-0-2-justification-restart-20-of-particles-to-escape-local-optimum-acceleration-result-expected-improvement-20-0-20-improvement-return-acceleration-result">runnable: false class WorkflowPerformanceOptimizer: â€œâ€â€ Adaptive optimization of workflow performance based on runtime metrics. â€œâ€â€ def <strong>init</strong>(self): self.performance_history = [] self.optimization_strategies = { â€˜memory_optimizationâ€™: self._optimize_memory_usage, â€˜convergence_accelerationâ€™: self._accelerate_convergence, â€˜bounds_tighteningâ€™: self._tighten_bounds_dynamically, â€˜parameter_adaptationâ€™: self._adapt_pso_parameters } def optimize_workflow_performance(self, current_metrics: dict, workflow_config: dict) -&gt; OptimizationResult: â€œâ€â€ Analyze current performance and apply optimization strategies. â€œâ€â€ result = OptimizationResult() # Analyze performance trends performance_analysis = self._analyze_performance_trends(current_metrics) # Apply relevant optimization strategies for strategy_name, strategy_func in self.optimization_strategies.items(): if self._should_apply_strategy(strategy_name, performance_analysis): strategy_result = strategy_func(current_metrics, workflow_config) result.add_strategy_result(strategy_name, strategy_result) return result def _accelerate_convergence(self, metrics: dict, config: dict) -&gt; dict: â€œâ€â€ Apply convergence acceleration strategies based on performance analysis. â€œâ€â€ acceleration_result = { â€˜applied_optimizationsâ€™: [], â€˜expected_improvementâ€™: 0.0 } # Check convergence rate convergence_rate = metrics.get(â€˜convergence_rateâ€™, 0.0) if convergence_rate &lt; 0.05: # Slow convergence detected # Suggest inertia weight adjustment current_w = config.get(â€˜psoâ€™, {}).get(â€˜algorithm_paramsâ€™, {}).get(â€˜wâ€™, 0.7) if current_w &gt; 0.5: suggested_w = max(0.4, current_w - 0.1) acceleration_result[â€˜applied_optimizationsâ€™].append({ â€˜parameterâ€™: â€˜inertia_weightâ€™, â€˜current_valueâ€™: current_w, â€˜suggested_valueâ€™: suggested_w, â€˜justificationâ€™: â€˜Reduce inertia for faster exploitationâ€™ }) acceleration_result[â€˜expected_improvementâ€™] += 15.0 # 15% improvement # Check diversity metrics diversity = metrics.get(â€˜swarm_diversityâ€™, 1.0) if diversity &lt; 1e-8: # Very low diversity acceleration_result[â€˜applied_optimizationsâ€™].append({ â€˜parameterâ€™: â€˜restart_mechanismâ€™, â€˜actionâ€™: â€˜enableâ€™, â€˜fractionâ€™: 0.2, â€˜justificationâ€™: â€˜Restart 20% of particles to escape local optimumâ€™ }) acceleration_result[â€˜expected_improvementâ€™] += 20.0 # 20% improvement return acceleration_result</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_user_guide.html">PSO Optimization Workflow User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_troubleshooting_maintenance_manual.html">PSO Troubleshooting and Maintenance Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_troubleshooting_maintenance_manual.html#pso-health-monitor-sh-regular-pso-system-health-monitoring-log-file-var-log-pso-health-log">pso_health_monitor.sh - Regular PSO system health monitoring LOG_FILE=â€/var/log/pso_health.logâ€</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_troubleshooting_maintenance_manual.html#emergency-recovery-sh-emergency-pso-system-recovery-echo-pso-emergency-recovery-procedure">emergency_recovery.sh - Emergency PSO system recovery echo â€œğŸš¨ PSO EMERGENCY RECOVERY PROCEDUREâ€</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_troubleshooting_maintenance_manual.html#recovery-restore-from-backup-backup-index-1">recovery.restore_from_backup(backup_index=1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_troubleshooting_maintenance_manual.html#recovery-restore-factory-defaults">recovery.restore_factory_defaults()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quality_gate_independence_framework.html">Quality Gate Independence Framework ## Executive Summary The Quality Gate Independence Framework establishes resilient, parallel validation paths that operate independently to prevent cascade failures and ensure robust quality assessment for the double-inverted pendulum sliding mode control (DIP-SMC) project. This framework addresses the critical issue identified in GitHub Issue #9 where single component failures could prevent system validation. <strong>Core Principle:</strong> No single point of failure should block system quality assessment. ## 1. Framework Architecture ### 1.1 Independent Validation Paths The framework implements <strong>four parallel, independent validation paths</strong> that can operate and report results independently: ```python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quality_gate_independence_framework.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quality_gate_independence_framework.html#runnable-false-class-independentvalidationpaths-four-independent-validation-paths-preventing-cascade-failures-def-init-self-self-validation-paths-coverage-validation-coveragevalidationpath-mathematical-validation-mathematicalvalidationpath-performance-validation-performancevalidationpath-compliance-validation-compliancevalidationpath-def-execute-independent-validation-self-independentvalidationresults-execute-all-validation-paths-independently-with-failure-isolation-results-for-path-name-validator-in-self-validation-paths-items-try-each-path-executes-in-complete-isolation-results-path-name-validator-validate-independently-except-exception-as-e-failure-isolation-one-path-failure-doesn-t-affect-others-results-path-name-validationresult-status-failed-error-str-e-partial-results-validator-get-partial-results-return-independentvalidationresults-path-results-results-overall-status-self-calculate-composite-status-results-deployment-recommendation-self-make-deployment-decision-results">runnable: false class IndependentValidationPaths: â€œâ€â€Four independent validation paths preventing cascade failures.â€â€â€ def <strong>init</strong>(self): self.validation_paths = { â€˜coverage_validationâ€™: CoverageValidationPath(), â€˜mathematical_validationâ€™: MathematicalValidationPath(), â€˜performance_validationâ€™: PerformanceValidationPath(), â€˜compliance_validationâ€™: ComplianceValidationPath() } def execute_independent_validation(self) -&gt; IndependentValidationResults: â€œâ€â€Execute all validation paths independently with failure isolation.â€â€â€ results = {} for path_name, validator in self.validation_paths.items(): try: # Each path executes in complete isolation results[path_name] = validator.validate_independently() except Exception as e: # Failure isolation: one path failure doesnâ€™t affect others results[path_name] = ValidationResult( status=â€™failedâ€™, error=str(e), partial_results=validator.get_partial_results() ) return IndependentValidationResults( path_results=results, overall_status=self._calculate_composite_status(results), deployment_recommendation=self._make_deployment_decision(results) )</a></li>
<li class="toctree-l1"><a class="reference internal" href="../results_readme.html">Results &amp; Plots</a></li>
<li class="toctree-l1"><a class="reference internal" href="../safety_system_validation_protocols.html">Safety System Validation Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sitemap_cards.html">Visual Documentation Navigator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sitemap_interactive.html">Interactive Documentation Map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sitemap_visual.html">Visual Documentation Map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../streamlit_dashboard_guide.html">Streamlit Dashboard User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symbols.html">Symbols &amp; Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_execution_guide.html">Test Execution Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_guide.html">Test Execution Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_guide.html#quick-development-testing-unit-tests-only">Quick development testing (unit tests only)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_guide.html#recommended-pre-commit-test-sequence">Recommended pre-commit test sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_guide.html#test-algorithm-convergence-properties">Test algorithm convergence properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_guide.html#quality-gate-sh-production-deployment-validation-set-e-echo-starting-quality-gate-validation-1-fast-unit-tests">quality_gate.sh - Production deployment validation set -e echo â€œğŸš€ Starting quality gate validationâ€¦â€ # 1. Fast unit tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_guide.html#pre-commit-config-yaml">.pre-commit-config.yaml</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html">Test Infrastructure Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html#run-only-unit-tests-fast-execution">Run only unit tests (fast execution)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html#full-test-suite-with-coverage">Full test suite with coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html#convergence-and-stability-analysis">Convergence and stability analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html#all-tests-except-known-failing-concurrent-tests">All tests except known failing concurrent tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html#automatic-configuration-in-tests-conftest-py">Automatic configuration in tests/conftest.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html#quality-gate-sh-production-deployment-gate-echo-running-quality-gate-validation-1-unit-and-integration-tests">quality_gate.sh - Production deployment gate echo â€œRunning quality gate validationâ€¦â€ # 1. Unit and integration tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_validation_report.html">Test Infrastructure Validation Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_protocols.html">Test Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/index.html">Theoretical Foundations ```{toctree}</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html">Particle Swarm Optimization Algorithm Mathematical Foundations <strong>Authors:</strong> Documentation Expert Agent</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#result-simulate-pso-particle-trajectory">result = simulate_pso_particle_trajectory(</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#initial-position-np-array-5-0-5-0">initial_position=np.array([5.0, 5.0]),</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#initial-velocity-np-array-0-0-0-0">initial_velocity=np.array([0.0, 0.0]),</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#personal-best-np-array-3-0-3-0">personal_best=np.array([3.0, 3.0]),</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#global-best-np-array-0-0-0-0">global_best=np.array([0.0, 0.0]),</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#w-0-7-c1-2-0-c2-2-0-n-iterations-50">w=0.7, c1=2.0, c2=2.0, n_iterations=50</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#id1">)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#expected-converged-true-convergence-rate-0-final-distance-1e-3">Expected: converged=True, convergence_rate &gt; 0, final_distance &lt; 1e-3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#result1-analyze-pso-stability-w-0-7-c1-2-0-c2-2-0">result1 = analyze_pso_stability(w=0.7, c1=2.0, c2=2.0)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#expected-stable-empirical-false-oscillatory-stable-theoretical-false">Expected: stable_empirical=False (oscillatory), stable_theoretical=False</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#id2"></a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#result2-analyze-pso-stability-w-0-5-c1-1-5-c2-1-5">result2 = analyze_pso_stability(w=0.5, c1=1.5, c2=1.5)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#expected-stable-empirical-true-stable-theoretical-true">Expected: stable_empirical=True, stable_theoretical=True</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#convergence-rate-decreases-as-kappa-increases">- Convergence rate decreases as kappa increases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#well-conditioned-kappa-1-rate-0-1-0-2">- Well-conditioned (kappa=1): rate ~ 0.1-0.2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#ill-conditioned-kappa-10000-rate-0-001-0-01">- Ill-conditioned (kappa=10000): rate ~ 0.001-0.01</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory_overview.html">Theory Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../use_cases.html">4. Use Cases &amp; Operating Modes</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../validation/index.html">Validation &amp; Verification</a><input aria-label="Toggle navigation of Validation &amp; Verification" class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_workflow.html">Validation Workflow Guide &gt; <strong>Coming Soon:</strong> validation workflow documentation. ## Current Resources For validation guidance, see: - <strong><span class="xref myst">Validation Examples</span></strong> - Practical validation examples and patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_validation_guide.html">Simulation Validation Guide &gt; <strong>Note:</strong> Simulation validation is covered in multiple guides. ## Quick Links - <strong><span class="xref myst">Validation Examples</span></strong> - Practical validation patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html">Simulation Result Validation Methodology <strong>Document Status:</strong> Phase 3.3 Completion - Monte Carlo and Statistical Testing Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html#controller-adapts-on-t0-t1">- Controller adapts on [tâ‚€, tâ‚]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html#performance-evaluated-on-t1-gap-t2">- Performance evaluated on [tâ‚+gap, tâ‚‚]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html#runnable-false-monte-carlo-cross-validation-statistical-tests">runnable: false # Monte Carlo + Cross-Validation + Statistical Tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html#if-diverge-investigate-why">If diverge â†’ investigate why</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html">Validation Examples: Practical Implementation Guide <strong>Document Status:</strong> Phase 3.3 Completion - Executable Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#runnable-false">runnable: false â€œâ€â€</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#conservative-20-uncertainty">Conservative (Â±20% uncertainty)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#pso-hyperparameter-selection-via-cross-validation-1-configuration-number-of-scenarios-100-pso-configurations-to-compare-4-1-small-explorative-pop-20-w-0-9-c1-2-0-c2-1-0-2-standard-pop-30-w-0-7-c1-1-5-c2-1-5-3-large-exploitative-pop-50-w-0-4-c1-1-0-c2-2-0-4-adaptive-pop-30-w-0-5-c1-1-8-c2-1-2-2-cross-validation-setup-method-monte-carlo-repetitions-50-train-test-split-80-20-3-running-cross-validation-this-may-take-several-minutes-4-results-cross-validation-scores-small-explorative-mean-cv-score-2-134-std-cv-score-0-312-median-cv-score-2-098-95-ci-2-223-2-045-standard-mean-cv-score-1-987-std-cv-score-0-267-median-cv-score-1-963-95-ci-2-062-1-912-large-exploitative-mean-cv-score-2-056-std-cv-score-0-298-median-cv-score-2-031-95-ci-2-138-1-974-adaptive-mean-cv-score-1-923-std-cv-score-0-245-median-cv-score-1-904-95-ci-1-992-1-854-5-statistical-comparison-pairwise-tests-after-multiple-comparison-correction-model-0-vs-model-3-model-3-is-significantly-better-p-0-0023-0-211-model-1-vs-model-3-model-3-is-significantly-better-p-0-0412-0-064-overall-ranking-1-adaptive-score-1-923-2-standard-score-1-987-3-large-exploitative-score-2-056-4-small-explorative-score-2-134-6-bias-variance-analysis-small-explorative-bias2-0-123456-variance-0-098234-high-bias-underfitting-consider-larger-population-standard-bias2-0-087654-variance-0-071234-good-balance-large-exploitative-bias2-0-091234-variance-0-089012-good-balance-adaptive-bias2-0-076543-variance-0-060123-good-balance-recommendation-recommended-pso-configuration-adaptive-parameters-population-size-30-inertia-weight-w-0-5-cognitive-coeff-c1-1-8-social-coeff-c2-1-2-mean-cv-score-1-923-this-configuration-showed-best-generalization-across-50-random-splits">======================================================================
PSO Hyperparameter Selection via Cross-Validation
====================================================================== 1. Configuration: Number of scenarios: 100 PSO configurations to compare: 4 1. Small-Explorative: pop=20, w=0.9, c1=2.0, c2=1.0 2. Standard: pop=30, w=0.7, c1=1.5, c2=1.5 3. Large-Exploitative: pop=50, w=0.4, c1=1.0, c2=2.0 4. Adaptive: pop=30, w=0.5, c1=1.8, c2=1.2 2. Cross-Validation Setup: Method: monte_carlo Repetitions: 50 Train-test split: 80%-20% 3. Running cross-validationâ€¦ (This may take several minutesâ€¦) 4. Results:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Cross-Validation Scores: Small-Explorative: Mean CV score: -2.134 Std CV score: 0.312 Median CV score: -2.098 95% CI: [-2.223, -2.045] Standard: Mean CV score: -1.987 Std CV score: 0.267 Median CV score: -1.963 95% CI: [-2.062, -1.912] Large-Exploitative: Mean CV score: -2.056 Std CV score: 0.298 Median CV score: -2.031 95% CI: [-2.138, -1.974] Adaptive: Mean CV score: -1.923 Std CV score: 0.245 Median CV score: -1.904 95% CI: [-1.992, -1.854] 5. Statistical Comparison: Pairwise Tests (after multiple comparison correction): model_0_vs_model_3: model_3 is significantly better (p=0.0023, Î”=0.211) model_1_vs_model_3: model_3 is significantly better (p=0.0412, Î”=0.064) Overall Ranking: 1. Adaptive (score: -1.923) 2. Standard (score: -1.987) 3. Large-Exploitative (score: -2.056) 4. Small-Explorative (score: -2.134) 6. Bias-Variance Analysis: Small-Explorative: BiasÂ²: 0.123456 Variance: 0.098234 âš  High bias - underfitting (consider larger population) Standard: BiasÂ²: 0.087654 Variance: 0.071234 âœ“ Good balance Large-Exploitative: BiasÂ²: 0.091234 Variance: 0.089012 âœ“ Good balance Adaptive: BiasÂ²: 0.076543 Variance: 0.060123 âœ“ Good balance ======================================================================
RECOMMENDATION: âœ“ RECOMMENDED PSO Configuration: Adaptive Parameters: - Population size: 30 - Inertia weight (w): 0.5 - Cognitive coeff (c1): 1.8 - Social coeff (c2): 1.2 Mean CV score: -1.923 This configuration showed best generalization across 50 random splits.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#statistical-comparison-of-controller-performance-1-experimental-setup-controllers-classical-smc-super-twisting-smc-adaptive-smc-trials-per-controller-30-significance-level-0-05-metric-settling-time-seconds-2-collecting-performance-data-3-descriptive-statistics-classical-smc-mean-2-487-s-std-0-398-s-median-2-465-s-min-1-823-s-max-3-312-s-cv-16-0-super-twisting-smc-mean-1-789-s-std-0-246-s-median-1-776-s-min-1-312-s-max-2-345-s-cv-13-8-adaptive-smc-mean-2-098-s-std-0-489-s-median-2-073-s-min-1-234-s-max-3-145-s-cv-23-3-4-assumption-testing-normality-tests-shapiro-wilk-classical-smc-w-0-9821-p-0-8734-normal-super-twisting-smc-w-0-9765-p-0-7231-normal-adaptive-smc-w-0-9798-p-0-8123-normal-homogeneity-of-variance-levene-s-test-f-3-2145-p-0-0456-unequal-variances-will-use-welch-s-test-5-pairwise-comparisons-multiple-comparison-correction-bonferroni-corrected-significance-level-0-0167-classical-smc-vs-super-twisting-smc-welch-s-t-test-t-7-8234-p-0-0001-significant-p-0-0167-mann-whitney-u-test-non-parametric-u-123-0-p-0-0002-effect-size-cohen-s-d-d-2-013-large-mean-difference-0-698-s-95-ci-for-difference-0-512-0-884-s-classical-smc-vs-adaptive-smc-welch-s-t-test-t-3-4567-p-0-0012-significant-p-0-0167-mann-whitney-u-test-non-parametric-u-287-0-p-0-0018-effect-size-cohen-s-d-d-0-891-large-mean-difference-0-389-s-95-ci-for-difference-0-167-0-611-s-super-twisting-smc-vs-adaptive-smc-welch-s-t-test-t-2-8901-p-0-0056-significant-p-0-0167-mann-whitney-u-test-non-parametric-u-234-0-p-0-0071-effect-size-cohen-s-d-d-0-743-medium-mean-difference-0-309-s-95-ci-for-difference-0-521-0-097-s-6-omnibus-test-one-way-anova-f-26-7891-p-0-000001-significant-at-least-one-controller-differs-kruskal-wallis-test-non-parametric-h-25-3456-p-0-000003-7-power-analysis-classical-smc-vs-super-twisting-smc-effect-size-d-2-013-sample-size-n-30-power-0-998-99-8-adequate-power-80-classical-smc-vs-adaptive-smc-effect-size-d-0-891-sample-size-n-30-power-0-865-86-5-adequate-power-80-super-twisting-smc-vs-adaptive-smc-effect-size-d-0-743-sample-size-n-30-power-0-752-75-2-low-power-recommend-n-36-for-80-power-conclusions-1-statistical-significance-significant-differences-found-0-0167-classical-smc-vs-super-twisting-smc-classical-smc-vs-adaptive-smc-super-twisting-smc-vs-adaptive-smc-2-effect-sizes-classical-smc-vs-super-twisting-smc-cohen-s-d-2-013-large-classical-smc-vs-adaptive-smc-cohen-s-d-0-891-large-super-twisting-smc-vs-adaptive-smc-cohen-s-d-0-743-medium-3-practical-recommendations-performance-ranking-by-mean-settling-time-1-super-twisting-smc-1-789-s-2-adaptive-smc-2-098-s-3-classical-smc-2-487-s-recommended-super-twisting-smc-fastest-mean-settling-time-significantly-better-than-classical-smc-p-0-0001-d-2-013-significantly-better-than-adaptive-smc-p-0-0056-d-0-743">======================================================================
Statistical Comparison of Controller Performance
====================================================================== 1. Experimental Setup: Controllers: Classical SMC, Super-Twisting SMC, Adaptive SMC Trials per controller: 30 Significance level: 0.05 Metric: Settling time (seconds) 2. Collecting performance dataâ€¦ 3. Descriptive Statistics:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Classical SMC: Mean: 2.487 s Std: 0.398 s Median: 2.465 s Min: 1.823 s Max: 3.312 s CV: 16.0% Super-Twisting SMC: Mean: 1.789 s Std: 0.246 s Median: 1.776 s Min: 1.312 s Max: 2.345 s CV: 13.8% Adaptive SMC: Mean: 2.098 s Std: 0.489 s Median: 2.073 s Min: 1.234 s Max: 3.145 s CV: 23.3% 4. Assumption Testing:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Normality Tests (Shapiro-Wilk): Classical SMC : W=0.9821, p=0.8734 âœ“ Normal Super-Twisting SMC : W=0.9765, p=0.7231 âœ“ Normal Adaptive SMC : W=0.9798, p=0.8123 âœ“ Normal Homogeneity of Variance (Leveneâ€™s test): F=3.2145, p=0.0456 âš  Unequal variances - will use Welchâ€™s test 5. Pairwise Comparisons:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Multiple comparison correction: Bonferroni Corrected significance level: Î±=0.0167 Classical SMC vs Super-Twisting SMC: Welchâ€™s t-test: t=7.8234, p=0.0001 âœ“ SIGNIFICANT (p &lt; 0.0167) Mann-Whitney U test (non-parametric): U=123.0, p=0.0002 Effect Size (Cohenâ€™s d): d=2.013 (large) Mean difference: 0.698 s 95% CI for difference: [0.512, 0.884] s Classical SMC vs Adaptive SMC: Welchâ€™s t-test: t=3.4567, p=0.0012 âœ“ SIGNIFICANT (p &lt; 0.0167) Mann-Whitney U test (non-parametric): U=287.0, p=0.0018 Effect Size (Cohenâ€™s d): d=0.891 (large) Mean difference: 0.389 s 95% CI for difference: [0.167, 0.611] s Super-Twisting SMC vs Adaptive SMC: Welchâ€™s t-test: t=-2.8901, p=0.0056 âœ“ SIGNIFICANT (p &lt; 0.0167) Mann-Whitney U test (non-parametric): U=234.0, p=0.0071 Effect Size (Cohenâ€™s d): d=-0.743 (medium) Mean difference: -0.309 s 95% CI for difference: [-0.521, -0.097] s 6. Omnibus Test (One-Way ANOVA):
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- F=26.7891, p=0.000001 âœ“ SIGNIFICANT: At least one controller differs Kruskal-Wallis test (non-parametric): H=25.3456, p=0.000003 7. Power Analysis:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Classical SMC vs Super-Twisting SMC: Effect size (d): 2.013 Sample size (n): 30 Power: 0.998 (99.8%) âœ“ Adequate power (â‰¥80%) Classical SMC vs Adaptive SMC: Effect size (d): 0.891 Sample size (n): 30 Power: 0.865 (86.5%) âœ“ Adequate power (â‰¥80%) Super-Twisting SMC vs Adaptive SMC: Effect size (d): 0.743 Sample size (n): 30 Power: 0.752 (75.2%) âš  Low power - recommend n=36 for 80% power ======================================================================
CONCLUSIONS:
====================================================================== 1. Statistical Significance: Significant differences found (Î±=0.0167): - Classical SMC vs Super-Twisting SMC - Classical SMC vs Adaptive SMC - Super-Twisting SMC vs Adaptive SMC 2. Effect Sizes: Classical SMC vs Super-Twisting SMC: Cohenâ€™s d = 2.013 (large) Classical SMC vs Adaptive SMC: Cohenâ€™s d = 0.891 (large) Super-Twisting SMC vs Adaptive SMC: Cohenâ€™s d = -0.743 (medium) 3. Practical Recommendations: Performance ranking (by mean settling time): 1. Super-Twisting SMC : 1.789 s 2. Adaptive SMC : 2.098 s 3. Classical SMC : 2.487 s âœ“ RECOMMENDED: Super-Twisting SMC - Fastest mean settling time - Significantly better than Classical SMC (p=0.0001, d=2.013) - Significantly better than Adaptive SMC (p=0.0056, d=0.743)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#uncertainty-quantification-for-settling-time-1-safety-requirement-settling-time-must-be-3-0s-with-99-confidence-2-collecting-experimental-data-number-of-test-runs-200-3-descriptive-statistics-mean-2-123-s-std-0-687-s-median-1-983-s-min-0-987-s-max-4-823-s-range-3-836-s-percentiles-5-1-234-s-25-1-653-s-50-1-983-s-75-2-456-s-95-3-567-s-99-4-234-s-4-bootstrap-confidence-intervals-bootstrap-iterations-10000-confidence-level-95-mean-settling-time-point-estimate-2-123-s-95-ci-2-026-2-223-s-ci-width-0-197-s-median-settling-time-point-estimate-1-983-s-95-ci-1-876-2-087-s-95th-percentile-point-estimate-3-567-s-95-ci-3-289-3-891-s-5-distribution-fitting-normal-k-s-statistic-0-0867-p-value-0-0234-aic-412-34-reject-poor-fit-lognormal-k-s-statistic-0-0421-p-value-0-6523-aic-387-12-cannot-reject-good-fit-gamma-k-s-statistic-0-0534-p-value-0-3421-aic-391-67-cannot-reject-good-fit-exponential-k-s-statistic-0-1234-p-value-0-0001-aic-445-89-reject-poor-fit-best-fit-lowest-aic-lognormal-aic-387-12-6-risk-analysis-value-at-risk-var-var-1-3-892-s-top-1-worst-cases-var-5-3-567-s-top-5-worst-cases-var-10-3-234-s-top-10-worst-cases-conditional-value-at-risk-cvar-expected-shortfall-cvar-1-4-123-s-avg-of-worst-1-cvar-5-3-789-s-avg-of-worst-5-cvar-10-3-456-s-avg-of-worst-10-7-safety-validation-empirical-analysis-samples-exceeding-3-0s-18-200-empirical-p-t-3-0s-0-0900-9-00-95-ci-for-p-t-3-0s-0-0523-0-1342-fitted-lognormal-distribution-p-t-3-0s-0-0823-8-23-p-t-3-0s-0-9177-91-77-fails-safety-requirement-91-8-99-0-to-meet-99-confidence-target-99-percentile-4-521-s-required-4-521s-3-0s-need-to-improve-99-percentile-by-1-521s-8-extreme-value-analysis-block-maxima-method-block-size-20-number-of-blocks-10-gev-parameters-0-234-3-876-0-456-return-levels-10-run-worst-case-4-876-s-50-run-worst-case-5-432-s-100-run-worst-case-5-687-s-uncertainty-quantification-summary-1-point-estimates-mean-2-123-s-95th-percentile-3-567-s-99th-percentile-4-234-s-2-uncertainty-95-ci-mean-2-026-2-223-s-95th-percentile-3-289-3-891-s-3-distributional-model-best-fit-lognormal-goodness-of-fit-p-value-0-6523-4-safety-assessment-threshold-3-0s-required-confidence-99-fails-only-91-8-of-scenarios-meet-requirement-5-recommendations-further-controller-improvement-needed-option-1-tune-controller-for-better-worst-case-performance-option-2-increase-safety-threshold-option-3-accept-lower-confidence-level-if-acceptable">======================================================================
Uncertainty Quantification for Settling Time
====================================================================== 1. Safety Requirement: Settling time must be &lt; 3.0s with 99% confidence 2. Collecting experimental dataâ€¦ Number of test runs: 200 3. Descriptive Statistics:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Mean: 2.123 s Std: 0.687 s Median: 1.983 s Min: 0.987 s Max: 4.823 s Range: 3.836 s Percentiles: 5%: 1.234 s 25%: 1.653 s 50%: 1.983 s 75%: 2.456 s 95%: 3.567 s 99%: 4.234 s 4. Bootstrap Confidence Intervals:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Bootstrap iterations: 10000 Confidence level: 95% Mean settling time: Point estimate: 2.123 s 95% CI: [2.026, 2.223] s CI width: 0.197 s Median settling time: Point estimate: 1.983 s 95% CI: [1.876, 2.087] s 95th percentile: Point estimate: 3.567 s 95% CI: [3.289, 3.891] s 5. Distribution Fitting:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Normal: K-S statistic: 0.0867 p-value: 0.0234 AIC: 412.34 âœ— Reject (poor fit) Lognormal: K-S statistic: 0.0421 p-value: 0.6523 AIC: 387.12 âœ“ Cannot reject (good fit) Gamma: K-S statistic: 0.0534 p-value: 0.3421 AIC: 391.67 âœ“ Cannot reject (good fit) Exponential: K-S statistic: 0.1234 p-value: 0.0001 AIC: 445.89 âœ— Reject (poor fit) Best fit (lowest AIC): Lognormal AIC = 387.12 6. Risk Analysis:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Value at Risk (VaR): VaR(1%): 3.892 s (top 1% worst cases) VaR(5%): 3.567 s (top 5% worst cases) VaR(10%): 3.234 s (top 10% worst cases) Conditional Value at Risk (CVaR / Expected Shortfall): CVaR(1%): 4.123 s (avg of worst 1%) CVaR(5%): 3.789 s (avg of worst 5%) CVaR(10%): 3.456 s (avg of worst 10%) 7. Safety Validation:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Empirical Analysis: Samples exceeding 3.0s: 18/200 Empirical P(T &gt; 3.0s) = 0.0900 (9.00%) 95% CI for P(T &gt; 3.0s): [0.0523, 0.1342] Fitted Lognormal Distribution: P(T &gt; 3.0s) = 0.0823 (8.23%) P(T â‰¤ 3.0s) = 0.9177 (91.77%) âœ— FAILS safety requirement (91.8% &lt; 99.0%) To meet 99% confidence: Target: 99% percentile = 4.521 s Required: 4.521s &lt; 3.0s âš  Need to improve 99% percentile by 1.521s 8. Extreme Value Analysis:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Block Maxima Method: Block size: 20 Number of blocks: 10 GEV parameters: Î¾=-0.234, Î¼=3.876, Ïƒ=0.456 Return Levels: 10-run worst-case: 4.876 s 50-run worst-case: 5.432 s 100-run worst-case: 5.687 s ======================================================================
UNCERTAINTY QUANTIFICATION SUMMARY:
====================================================================== 1. Point Estimates: Mean: 2.123 s 95th percentile: 3.567 s 99th percentile: 4.234 s 2. Uncertainty (95% CI): Mean: [2.026, 2.223] s 95th percentile: [3.289, 3.891] s 3. Distributional Model: Best fit: Lognormal Goodness-of-fit p-value: 0.6523 4. Safety Assessment: Threshold: 3.0s Required confidence: 99% âœ— FAILS: Only 91.8% of scenarios meet requirement 5. Recommendations: âœ— Further controller improvement needed â–¡ Option 1: Tune controller for better worst-case performance â–¡ Option 2: Increase safety threshold â–¡ Option 3: Accept lower confidence level (if acceptable)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/api_reference.html">Validation API Reference &gt; <strong>Coming Soon:</strong> validation API documentation. ## Current Resources For validation APIs, see: - <strong><span class="xref myst">Analysis Validation</span></strong> - Validation metrics API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/statistical_reference_tables.html">Statistical Reference Tables &gt; <strong>Coming Soon:</strong> statistical reference tables for validation. ## Current Resources For statistical validation, see: - <strong><span class="xref myst">Statistical Tests</span></strong> - Statistical test implementations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/phase_3_3_completion_report.html">Phase 3.3 Completion Report: Simulation Result Validation Documentation <strong>Completion Date:</strong> 2025-10-07</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../versioning_guide.html">Documentation Versioning Guide</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../workflows/index.html">Workflows &amp; Integration Guides</a><input aria-label="Toggle navigation of Workflows &amp; Integration Guides" class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html">Complete Integration Workflow Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#test-each-controller-individually">Test each controller individually</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#use-pre-optimized-gains-for-immediate-results">Use pre-optimized gains for immediate results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#launch-interactive-web-interface">Launch interactive web interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#select-controller-adjust-parameters-run-simulations">Select controller, adjust parameters, run simulations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#optimize-classical-smc-gains">Optimize classical SMC gains</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#optimize-adaptive-smc-with-uncertainty">Optimize adaptive SMC with uncertainty</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#optimize-sta-smc-for-finite-time-performance">Optimize STA SMC for finite-time performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#optimize-hybrid-smc-most-sophisticated">Optimize hybrid SMC (most sophisticated)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#optimize-all-controllers-in-sequence">Optimize all controllers in sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#runnable-false-scripts-custom-batch-optimization-py">runnable: false # scripts/custom_batch_optimization.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#multi-objective-optimization-for-competing-requirements">Multi-objective optimization for competing requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#runnable-false-adaptive-pso-with-time-varying-parameters">runnable: false # Adaptive PSO with time-varying parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#run-hil-simulation">Run HIL simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#real-time-monitoring-setup">Real-time monitoring setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#distributed-control-system">Distributed control system</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#adaptive-controller-selection-based-on-performance">Adaptive controller selection based on performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#diagnose-controller-performance-problems">Diagnose controller performance problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#debug-pso-optimization-problems">Debug PSO optimization problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#continuous-system-health-monitoring">Continuous system health monitoring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/pytest_testing_workflow.html">Quick Start Guide for Running Tests <strong>Document Version</strong>: 1.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/pytest_testing_workflow.html#run-all-tests-basic-command">1. Run all tests (basic command)</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="../_sources/factory/pso_factory_api_reference.md.txt" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div>
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <p>#==========================================================================================\<br />
#================== docs/factory/pso_factory_api_reference.md ================\<br />
#==========================================================================================\</p>
<section class="tex2jax_ignore mathjax_ignore" id="pso-factory-integration-api-reference">
<h1>PSO Factory Integration API Reference<a class="headerlink" href="#pso-factory-integration-api-reference" title="Link to this heading">Â¶</a></h1>
<section id="complete-documentation-for-pso-optimized-controller-factory-table-of-contents">
<h2>Complete Documentation for PSO-Optimized Controller Factory ### Table of Contents<a class="headerlink" href="#complete-documentation-for-pso-optimized-controller-factory-table-of-contents" title="Link to this heading">Â¶</a></h2>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#api-overview"><span class="xref myst">API Overview</span></a></p></li>
<li><p><a class="reference internal" href="#core-pso-integration-classes"><span class="xref myst">Core PSO Integration Classes</span></a></p></li>
<li><p><a class="reference internal" href="#factory-functions-for-pso"><span class="xref myst">Factory Functions for PSO</span></a></p></li>
<li><p><a class="reference internal" href="#pso-controller-wrapper"><span class="xref myst">PSO Controller Wrapper</span></a></p></li>
<li><p><a class="reference internal" href="#mathematical-constraints-api"><span class="xref myst">Mathematical Constraints API</span></a></p></li>
<li><p><a class="reference internal" href="#configuration-schema-api"><span class="xref myst">Configuration Schema API</span></a></p></li>
<li><p><a class="reference internal" href="#performance-monitoring-api"><span class="xref myst">Performance Monitoring API</span></a></p></li>
<li><p><a class="reference internal" href="#advanced-pso-workflows"><span class="xref myst">Advanced PSO Workflows</span></a></p></li>
<li><p><a class="reference internal" href="#error-handling-reference"><span class="xref myst">Error Handling Reference</span></a></p></li>
<li><p><a class="reference internal" href="#usage-examples"><span class="xref myst">Usage Examples</span></a></p></li>
</ol>
</section>
<hr class="docutils" />
<section id="api-overview-the-pso-factory-integration-api-provides-a-framework-for-optimizing-sliding-mode-controllers-using-particle-swarm-optimization-the-api-is-designed-with-the-following-principles-design-philosophy">
<h2>API Overview The PSO Factory Integration API provides a framework for optimizing sliding mode controllers using Particle Swarm Optimization. The API is designed with the following principles: ### Design Philosophy<a class="headerlink" href="#api-overview-the-pso-factory-integration-api-provides-a-framework-for-optimizing-sliding-mode-controllers-using-particle-swarm-optimization-the-api-is-designed-with-the-following-principles-design-philosophy" title="Link to this heading">Â¶</a></h2>
<ul class="simple">
<li><p><strong>Mathematical Rigor</strong>: All functions incorporate control theory constraints</p></li>
<li><p><strong>Type Safety</strong>: Complete type annotations with runtime validation</p></li>
<li><p><strong>Performance</strong>: Optimized for real-time PSO fitness evaluation</p></li>
<li><p><strong>Ease of Use</strong>: Single-function interfaces for common operations</p></li>
<li><p><strong>Extensibility</strong>: Support for custom optimization algorithms ### Import Structure</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Core PSO-Factory integration</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">controllers</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span> <span class="n">SMCType</span><span class="p">,</span> <span class="c1"># Controller type enumeration create_smc_for_pso, # Primary PSO interface get_gain_bounds_for_pso, # Mathematical bounds validate_smc_gains, # Constraint validation PSOControllerWrapper # PSO-optimized wrapper</span>
<span class="p">)</span> <span class="c1"># Advanced PSO workflows</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">controllers.factory</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span> <span class="n">SMCFactory</span><span class="p">,</span> <span class="c1"># Full factory interface SMCConfig, # Type-safe configuration SMCGainSpec # Gain specifications</span>
<span class="p">)</span> <span class="c1"># Performance monitoring</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">controllers.factory.monitoring</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span> <span class="n">PSOPerformanceMonitor</span><span class="p">,</span> <span class="c1"># Real-time monitoring PSOBenchmarkSuite # benchmarking</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="core-pso-integration-classes-smctype-enumeration-python">
<h2>Core PSO Integration Classes ### SMCType Enumeration ```python<a class="headerlink" href="#core-pso-integration-classes-smctype-enumeration-python" title="Link to this heading">Â¶</a></h2>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="example-metadata">
<h1>example-metadata:<a class="headerlink" href="#example-metadata" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-class-smctype-enum-enumeration-of-supported-smc-controller-types-for-pso-optimization-each-type-corresponds-to-a-specific-sliding-mode-control-algorithm-with-distinct-mathematical-properties-and-parameter-requirements-classical-classical-smc-classical-sliding-mode-controller-with-boundary-layer-mathematical-model-u-u-eq-u-sw-u-eq-gb-1-gf-x-s-ref-u-sw-ktanh-s-gain-parameters-k1-k2-1-2-k-kd-k1-k2-position-gains-for-pendulum-1-and-2-1-2-surface-gains-for-pendulum-1-and-2-k-switching-gain-kd-damping-gain-mathematical-constraints-1-2-k-0-stability-requirement-kd-0-non-negative-damping-pso-bounds-0-1-50-0-1-50-1-50-1-50-1-200-0-50-super-twisting-sta-smc-super-twisting-sliding-mode-controller-second-order-mathematical-model-u-k1sign-s-k2sign-s-s-x-sliding-surface-gain-parameters-k1-k2-1-2-1-2-k1-primary-twisting-gain-k2-secondary-twisting-gain-1-2-surface-gains-1-2-higher-order-surface-parameters-mathematical-constraints-k1-k2-0-finite-time-convergence-1-2-1-2-0-stability-pso-bounds-2-100-1-99-1-50-1-50-1-50-1-50-adaptive-adaptive-smc-adaptive-sliding-mode-controller-with-online-gain-tuning-mathematical-model-u-u-eq-u-sw-k-s-k-adaptation-law-gain-parameters-k1-k2-1-2-k1-k2-position-gains-1-2-surface-gains-adaptation-rate-mathematical-constraints-k1-k2-1-2-0-stability-0-1-20-0-bounded-adaptation-pso-bounds-0-1-50-0-1-50-1-50-1-50-0-1-20-hybrid-hybrid-adaptive-sta-smc-hybrid-adaptive-super-twisting-controller-mathematical-model-u-u-adaptive-u-sta-mode-switching-gain-parameters-k1-k2-1-2-k1-k2-surface-gains-for-pendulum-1-and-2-1-2-higher-order-surface-gains-mathematical-constraints-all-parameters-0-stability-pso-bounds-1-50-1-50-1-50-1-50-property-def-gain-count-self-int-return-number-of-gain-parameters-for-this-controller-type-return-smctype-classical-6-smctype-super-twisting-6-smctype-adaptive-5-smctype-hybrid-4-self-property-def-mathematical-constraints-self-dict-str-str-return-mathematical-constraints-as-human-readable-strings-return-smctype-classical-1-2-k-0-kd-0-smctype-super-twisting-k1-k2-0-1-2-1-2-0-smctype-adaptive-k1-k2-1-2-0-0-1-20-0-smctype-hybrid-k1-k2-1-2-0-self">
<h1>runnable: false class SMCType(Enum): â€œâ€â€ Enumeration of supported SMC controller types for PSO optimization. Each type corresponds to a specific sliding mode control algorithm with distinct mathematical properties and parameter requirements. â€œâ€â€ CLASSICAL = â€œclassical_smcâ€ â€œâ€â€ Classical sliding mode controller with boundary layer. Mathematical Model: u = u_eq + u_sw u_eq = (GB)^(-1)[-Gf(x) + á¹¡_ref] u_sw = -KÂ·tanh(s/Ï†) Gain Parameters: [k1, k2, Î»1, Î»2, K, kd] k1, k2: Position gains for pendulum 1 and 2 Î»1, Î»2: Surface gains for pendulum 1 and 2 K: Switching gain kd: Damping gain Mathematical Constraints: - Î»1, Î»2, K &gt; 0 (stability requirement) - kd â‰¥ 0 (non-negative damping) PSO Bounds: [(0.1,50), (0.1,50), (1,50), (1,50), (1,200), (0,50)] â€œâ€â€ SUPER_TWISTING = â€œsta_smcâ€ â€œâ€â€ Super-twisting sliding mode controller (second-order). Mathematical Model: uÌ‡ = -K1Â·sign(s) - K2Â·sign(á¹¡) s = Ïƒ(x) (sliding surface) Gain Parameters: [K1, K2, Î»1, Î»2, Î±1, Î±2] K1: Primary twisting gain K2: Secondary twisting gain Î»1, Î»2: Surface gains Î±1, Î±2: Higher-order surface parameters Mathematical Constraints: - K1 &gt; K2 &gt; 0 (finite-time convergence) - Î»1, Î»2, Î±1, Î±2 &gt; 0 (stability) PSO Bounds: [(2,100), (1,99), (1,50), (1,50), (1,50), (1,50)] â€œâ€â€ ADAPTIVE = â€œadaptive_smcâ€ â€œâ€â€ Adaptive sliding mode controller with online gain tuning. Mathematical Model: u = u_eq + u_sw KÌ‡ = Î³|s| - ÏƒK (adaptation law) Gain Parameters: [k1, k2, Î»1, Î»2, Î³] k1, k2: Position gains Î»1, Î»2: Surface gains Î³: Adaptation rate Mathematical Constraints: - k1, k2, Î»1, Î»2 &gt; 0 (stability) - 0.1 â‰¤ Î³ â‰¤ 20.0 (bounded adaptation) PSO Bounds: [(0.1,50), (0.1,50), (1,50), (1,50), (0.1,20)] â€œâ€â€ HYBRID = â€œhybrid_adaptive_sta_smcâ€ â€œâ€â€ Hybrid adaptive super-twisting controller. Mathematical Model: u = u_adaptive + u_sta (mode switching) Gain Parameters: [k1, k2, Î»1, Î»2] k1, k2: Surface gains for pendulum 1 and 2 Î»1, Î»2: Higher-order surface gains Mathematical Constraints: - All parameters &gt; 0 (stability) PSO Bounds: [(1,50), (1,50), (1,50), (1,50)] â€œâ€â€ &#64;property def gain_count(self) -&gt; int: â€œâ€â€Return number of gain parameters for this controller type.â€â€â€ return { SMCType.CLASSICAL: 6, SMCType.SUPER_TWISTING: 6, SMCType.ADAPTIVE: 5, SMCType.HYBRID: 4 }[self] &#64;property def mathematical_constraints(self) -&gt; Dict[str, str]: â€œâ€â€Return mathematical constraints as human-readable strings.â€â€â€ return { SMCType.CLASSICAL: â€œÎ»1,Î»2,K &gt; 0; kd â‰¥ 0â€, SMCType.SUPER_TWISTING: â€œK1 &gt; K2 &gt; 0; Î»1,Î»2,Î±1,Î±2 &gt; 0â€, SMCType.ADAPTIVE: â€œk1,k2,Î»1,Î»2 &gt; 0; 0.1 â‰¤ Î³ â‰¤ 20.0â€, SMCType.HYBRID: â€œk1,k2,Î»1,Î»2 &gt; 0â€ }[self]<a class="headerlink" href="#runnable-false-class-smctype-enum-enumeration-of-supported-smc-controller-types-for-pso-optimization-each-type-corresponds-to-a-specific-sliding-mode-control-algorithm-with-distinct-mathematical-properties-and-parameter-requirements-classical-classical-smc-classical-sliding-mode-controller-with-boundary-layer-mathematical-model-u-u-eq-u-sw-u-eq-gb-1-gf-x-s-ref-u-sw-ktanh-s-gain-parameters-k1-k2-1-2-k-kd-k1-k2-position-gains-for-pendulum-1-and-2-1-2-surface-gains-for-pendulum-1-and-2-k-switching-gain-kd-damping-gain-mathematical-constraints-1-2-k-0-stability-requirement-kd-0-non-negative-damping-pso-bounds-0-1-50-0-1-50-1-50-1-50-1-200-0-50-super-twisting-sta-smc-super-twisting-sliding-mode-controller-second-order-mathematical-model-u-k1sign-s-k2sign-s-s-x-sliding-surface-gain-parameters-k1-k2-1-2-1-2-k1-primary-twisting-gain-k2-secondary-twisting-gain-1-2-surface-gains-1-2-higher-order-surface-parameters-mathematical-constraints-k1-k2-0-finite-time-convergence-1-2-1-2-0-stability-pso-bounds-2-100-1-99-1-50-1-50-1-50-1-50-adaptive-adaptive-smc-adaptive-sliding-mode-controller-with-online-gain-tuning-mathematical-model-u-u-eq-u-sw-k-s-k-adaptation-law-gain-parameters-k1-k2-1-2-k1-k2-position-gains-1-2-surface-gains-adaptation-rate-mathematical-constraints-k1-k2-1-2-0-stability-0-1-20-0-bounded-adaptation-pso-bounds-0-1-50-0-1-50-1-50-1-50-0-1-20-hybrid-hybrid-adaptive-sta-smc-hybrid-adaptive-super-twisting-controller-mathematical-model-u-u-adaptive-u-sta-mode-switching-gain-parameters-k1-k2-1-2-k1-k2-surface-gains-for-pendulum-1-and-2-1-2-higher-order-surface-gains-mathematical-constraints-all-parameters-0-stability-pso-bounds-1-50-1-50-1-50-1-50-property-def-gain-count-self-int-return-number-of-gain-parameters-for-this-controller-type-return-smctype-classical-6-smctype-super-twisting-6-smctype-adaptive-5-smctype-hybrid-4-self-property-def-mathematical-constraints-self-dict-str-str-return-mathematical-constraints-as-human-readable-strings-return-smctype-classical-1-2-k-0-kd-0-smctype-super-twisting-k1-k2-0-1-2-1-2-0-smctype-adaptive-k1-k2-1-2-0-0-1-20-0-smctype-hybrid-k1-k2-1-2-0-self" title="Link to this heading">Â¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">SMCGainSpec</span> <span class="pre">Specification</span> <span class="pre">Class</span></code>python</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1>example-metadata:<a class="headerlink" href="#id1" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-dataclass-frozen-true">
<h1>runnable: false &#64;dataclass(frozen=True)<a class="headerlink" href="#runnable-false-dataclass-frozen-true" title="Link to this heading">Â¶</a></h1>
<p>class SMCGainSpec: â€œâ€â€ Complete specification for SMC controller gains. Provides information about gain parameters including mathematical meaning, constraints, and PSO optimization bounds. â€œâ€â€ controller_type: SMCType n_gains: int gain_names: List[str] gain_descriptions: List[str] mathematical_constraints: List[str] pso_bounds: List[Tuple[float, float]] default_gains: List[float] &#64;property def gain_info(self) -&gt; List[Dict[str, Any]]: â€œâ€â€ Return gain information. Returns: List of dictionaries containing: - name: Parameter name - description: Mathematical meaning - constraint: Mathematical constraint - bounds: PSO optimization bounds - default: Default value â€œâ€â€ return [ { â€˜nameâ€™: name, â€˜descriptionâ€™: desc, â€˜constraintâ€™: constraint, â€˜boundsâ€™: bounds, â€˜defaultâ€™: default } for name, desc, constraint, bounds, default in zip( self.gain_names, self.gain_descriptions, self.mathematical_constraints, self.pso_bounds, self.default_gains ) ] def validate_gains(self, gains: List[float]) -&gt; Tuple[bool, List[str]]: â€œâ€â€ Validate gains against mathematical constraints. Args: gains: Gain values to validate Returns: Tuple of (is_valid, list_of_errors) â€œâ€â€ errors = [] if len(gains) != self.n_gains: errors.append(fâ€Expected {self.n_gains} gains, got {len(gains)}â€) return False, errors # Controller-specific validation if self.controller_type == SMCType.CLASSICAL: if any(g &lt;= 0 for g in gains[:5]): # k1,k2,Î»1,Î»2,K &gt; 0 errors.append(â€œSurface and switching gains must be positiveâ€) if gains[5] &lt; 0: # kd â‰¥ 0 errors.append(â€œDamping gain must be non-negativeâ€) elif self.controller_type == SMCType.SUPER_TWISTING: if gains[0] &lt;= gains[1]: # K1 &gt; K2 errors.append(â€œK1 must be greater than K2 for convergenceâ€) if any(g &lt;= 0 for g in gains): # All gains &gt; 0 errors.append(â€œAll STA gains must be positiveâ€) elif self.controller_type == SMCType.ADAPTIVE: if any(g &lt;= 0 for g in gains[:4]): # k1,k2,Î»1,Î»2 &gt; 0 errors.append(â€œSurface gains must be positiveâ€) if not (0.1 &lt;= gains[4] &lt;= 20.0): # Î³ bounds errors.append(â€œAdaptation rate must be in [0.1, 20.0]â€) elif self.controller_type == SMCType.HYBRID: if any(g &lt;= 0 for g in gains): # All gains &gt; 0 errors.append(â€œAll hybrid gains must be positiveâ€) return len(errors) == 0, errors def get_pso_bounds_array(self) -&gt; np.ndarray: â€œâ€â€Return PSO bounds as numpy array for optimization algorithms.â€â€â€ return np.array(self.pso_bounds) def get_random_valid_gains(self, n_samples: int = 1) -&gt; np.ndarray: â€œâ€â€ Generate random valid gain sets within PSO bounds. Useful for PSO initialization and testing. Args: n_samples: Number of random gain sets to generate Returns: Array of shape (n_samples, n_gains) with valid gain sets â€œâ€â€ bounds_array = self.get_pso_bounds_array() lower_bounds = bounds_array[:, 0] upper_bounds = bounds_array[:, 1] samples = [] for _ in range(n_samples): while True: # Generate random sample in bounds sample = np.random.uniform(lower_bounds, upper_bounds) # Validate constraints is_valid, _ = self.validate_gains(sample.tolist()) if is_valid: samples.append(sample) break return np.array(samples)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
---

## Factory Functions for PSO ### create_smc_for_pso ```python

# example-metadata:

# runnable: false def create_smc_for_pso(smc_type: SMCType, gains: List[float], max_force: float = 100.0, dt: float = 0.01, **kwargs) -&gt; PSOControllerWrapper: &quot;&quot;&quot; Primary function for creating SMC controllers in PSO fitness functions. This function provides the optimal interface for PSO optimization workflows: - Single-line controller creation - Automatic mathematical constraint validation - Performance-optimized wrapper for simplified control interface - error handling for robust PSO evaluation Mathematical Foundation: Each controller type implements specific sliding mode control laws: Classical SMC: u = -(k1Â·Î¸1 + k2Â·Î¸2) - (Î»1Â·Î¸Ì‡1 + Î»2Â·Î¸Ì‡2) - KÂ·tanh(s/Ï†) - kdÂ·áº‹ s = Î»1Â·e1 + Î»2Â·e2 + Ä—1 + Ä—2 Super-Twisting SMC: uÌ‡ = -K1Â·sign(s) - K2Â·sign(á¹¡) s = Î»1Â·e1 + Î»2Â·e2 + Î±1Â·Ä—1 + Î±2Â·Ä—2 Adaptive SMC: u = u_eq + u_sw KÌ‡ = Î³|s| - ÏƒK (online adaptation) Hybrid SMC: u = w1Â·u_adaptive + w2Â·u_sta (mode switching) Args: smc_type: Controller type from SMCType enumeration gains: Gain array matching controller requirements: - Classical: [k1, k2, Î»1, Î»2, K, kd] (6 parameters) - STA: [K1, K2, Î»1, Î»2, Î±1, Î±2] (6 parameters) - Adaptive: [k1, k2, Î»1, Î»2, Î³] (5 parameters) - Hybrid: [k1, k2, Î»1, Î»2] (4 parameters) max_force: Control force saturation limit [N] dt: Control timestep [s] **kwargs: Additional controller-specific parameters Returns: PSOControllerWrapper with simplified control interface Raises: ValueError: If gains violate mathematical constraints TypeError: If smc_type is not a valid SMCType ConfigurationError: If controller configuration is invalid Performance: - Creation time: &lt;1ms typical - Memory overhead: &lt;500B per wrapper - Thread-safe: Yes (for read operations) PSO Integration Example: ```python def pso_fitness_function(particle: np.ndarray) -&gt; float: # Create controller (automatic validation) controller = create_smc_for_pso(SMCType.CLASSICAL, particle.tolist()) # Run simulation result = run_simulation(controller, test_scenario) # Compute performance metric return compute_ise(result) # Lower is better ``` Mathematical Validation: The function automatically validates that gains satisfy: - Lyapunov stability conditions - Convergence requirements (for STA-SMC) - Bounded adaptation constraints (for Adaptive-SMC) - Physical implementation limits Error Handling: - Invalid gains return appropriate error messages - NaN/infinite gains are automatically rejected - Out-of-bounds parameters trigger constraint violations - Missing parameters are detected and reported &quot;&quot;&quot; # Validate input types if not isinstance(smc_type, SMCType): raise TypeError(f&quot;smc_type must be SMCType, got {type(smc_type)}&quot;) if not isinstance(gains, (list, np.ndarray)): raise TypeError(f&quot;gains must be list or array, got {type(gains)}&quot;) # Convert to list if numpy array if isinstance(gains, np.ndarray): gains = gains.tolist() # Get gain specification for validation gain_spec = SMC_GAIN_SPECS[smc_type] # Validate gain count if len(gains) != gain_spec.n_gains: raise ValueError( f&quot;{smc_type.value} requires {gain_spec.n_gains} gains, &quot; f&quot;got {len(gains)}&quot; ) # Validate mathematical constraints is_valid, errors = gain_spec.validate_gains(gains) if not is_valid: error_msg = f&quot;Gain validation failed for {smc_type.value}:\n&quot; error_msg += &quot;\n&quot;.join(f&quot; - {error}&quot; for error in errors) error_msg += f&quot;\n\nConstraints: {smc_type.mathematical_constraints}&quot; raise ValueError(error_msg) # Create type-safe configuration config = SMCConfig( gains=gains, max_force=max_force, dt=dt, **kwargs ) # Create controller through factory controller = SMCFactory.create_controller(smc_type, config) # Return PSO-optimized wrapper return PSOControllerWrapper(controller) # Performance optimization: Pre-validate common gain patterns

@lru_cache(maxsize=1000)
def _validate_gains_cached(smc_type: SMCType, gains_tuple: Tuple[float, ...]) -&gt; bool: &quot;&quot;&quot;Cached validation for common gain patterns.&quot;&quot;&quot; gain_spec = SMC_GAIN_SPECS[smc_type] is_valid, _ = gain_spec.validate_gains(list(gains_tuple)) return is_valid
``` ### get_gain_bounds_for_pso ```python
def get_gain_bounds_for_pso(smc_type: SMCType, custom_constraints: Optional[Dict[str, Any]] = None ) -&gt; List[Tuple[float, float]]: &quot;&quot;&quot; Get mathematically-derived PSO optimization bounds for SMC controllers. Bounds are derived from rigorous control theory analysis: - Lyapunov stability requirements - Performance specifications (settling time, overshoot) - Physical system constraints (actuator saturation) - Numerical implementation limits Mathematical Derivation: Classical SMC Bounds: k1, k2 âˆˆ [0.1, 50]: Position gains for reasonable pole placement - Lower bound: Minimum for controllability - Upper bound: Avoid excessive control action Î»1, Î»2 âˆˆ [1, 50]: Surface gains for desired bandwidth - Lower bound: Minimum for stability (Î»i &gt; 0) - Upper bound: Avoid high-frequency dynamics K âˆˆ [1, 200]: Switching gain for disturbance rejection - Lower bound: Overcome uncertainty bound - Upper bound: Practical actuator limits kd âˆˆ [0, 50]: Damping gain for chattering reduction - Lower bound: Non-negative constraint - Upper bound: Avoid over-damping Super-Twisting Bounds: K1 âˆˆ [2, 100]: Primary twisting gain - Must satisfy K1 &gt; K2 constraint - Upper bound from actuator limitations K2 âˆˆ [1, 99]: Secondary twisting gain - Must satisfy K2 &lt; K1 constraint - Lower bound for convergence guarantee Î»1, Î»2, Î±1, Î±2 âˆˆ [1, 50]: Surface parameters - Positive definite requirement - Bandwidth considerations Adaptive SMC Bounds: k1, k2, Î»1, Î»2: Same as classical SMC Î³ âˆˆ [0.1, 20]: Adaptation rate - Lower bound: Minimum adaptation speed - Upper bound: Stability margin preservation Hybrid SMC Bounds: k1, k2, Î»1, Î»2 âˆˆ [1, 50]: Surface gains - Positive definite requirement - Performance considerations Args: smc_type: Controller type for bound derivation custom_constraints: Optional custom constraint overrides Example: {&#39;max_force&#39;: 150.0, &#39;settling_time&#39;: 3.0} Returns: List of (lower_bound, upper_bound) tuples for each gain parameter Raises: ValueError: If smc_type is invalid TypeError: If custom_constraints has wrong format Usage Examples: # Standard bounds bounds = get_gain_bounds_for_pso(SMCType.CLASSICAL) # Custom constraints custom = {&#39;max_force&#39;: 150.0, &#39;settling_time&#39;: 3.0} bounds = get_gain_bounds_for_pso(SMCType.CLASSICAL, custom) # PSO integration from pyswarms.single import GlobalBestPSO bounds_array = np.array(bounds) optimizer = GlobalBestPSO( n_particles=30, dimensions=len(bounds), bounds=(bounds_array[:, 0], bounds_array[:, 1]) ) Mathematical Validation: All bounds are verified to satisfy: 1. Lyapunov stability conditions: VÌ‡ â‰¤ -Î·|s| 2. Reachability conditions: á¹¡Â·s â‰¤ -Î·|s| 3. Finite-time convergence (STA): Specific gain relationships 4. Bounded adaptation (Adaptive): Parameter drift prevention Performance Considerations: - Tighter bounds lead to faster PSO convergence - Bounds include safety margins for robustness - Physical constraints prevent actuator saturation - Numerical bounds avoid conditioning issues &quot;&quot;&quot; if not isinstance(smc_type, SMCType): raise ValueError(f&quot;Invalid SMC type: {smc_type}&quot;) # Default constraints (can be overridden) constraints = { &#39;max_force&#39;: 100.0, # Maximum actuator force [N] &#39;settling_time&#39;: 2.0, # Desired settling time [s] &#39;overshoot_limit&#39;: 10.0, # Maximum overshoot [%] &#39;bandwidth&#39;: 25.0, # Control bandwidth [rad/s] &#39;uncertainty_bound&#39;: 10.0, # Model uncertainty estimate &#39;noise_level&#39;: 0.01 # Sensor noise level } # Apply custom constraints if provided if custom_constraints: if not isinstance(custom_constraints, dict): raise TypeError(&quot;custom_constraints must be dictionary&quot;) constraints.update(custom_constraints) # Extract constraint values max_force = constraints[&#39;max_force&#39;] settling_time = constraints[&#39;settling_time&#39;] bandwidth = constraints[&#39;bandwidth&#39;] uncertainty = constraints[&#39;uncertainty_bound&#39;] if smc_type == SMCType.CLASSICAL: # Classical SMC bounds with mathematical justification # Position gains: pole placement considerations # Natural frequency: Ï‰n = 4/settling_time omega_n = 4.0 / settling_time k_min = omega_n**2 / 100 # Conservative lower bound k_max = omega_n**2 # Upper bound for reasonable response # Surface gains: bandwidth considerations lambda_min = omega_n / 2 # Minimum for stability lambda_max = bandwidth # Maximum for implementability # Switching gain: uncertainty rejection K_min = uncertainty * 1.5 # Safety margin over uncertainty K_max = max_force * 0.8 # Actuator saturation margin # Damping gain: chattering reduction kd_min = 0.0 # Non-negative constraint kd_max = lambda_max / 2 # Avoid over-damping bounds = [ (k_min, k_max), # k1 (k_min, k_max), # k2 (lambda_min, lambda_max), # Î»1 (lambda_min, lambda_max), # Î»2 (K_min, K_max), # K (kd_min, kd_max) # kd ] elif smc_type == SMCType.SUPER_TWISTING: # Super-twisting bounds with convergence constraints # Estimate Lipschitz constant for convergence analysis L = uncertainty + bandwidth # Conservative estimate # K1 bounds: finite-time convergence requirement K1_min = math.sqrt(L) * 1.2 # Safety margin K1_max = math.sqrt(max_force * L) # Physical limit # K2 bounds: must satisfy K2 &lt; K1 K2_min = L / (2 * math.sqrt(L)) * 1.1 # Convergence requirement K2_max = K1_max * 0.9 # Ensure K1 &gt; K2 # Surface parameters: similar to classical lambda_min = 2.0 / settling_time lambda_max = bandwidth / 2 bounds = [ (K1_min, K1_max), # K1 (K2_min, K2_max), # K2 (lambda_min, lambda_max), # Î»1 (lambda_min, lambda_max), # Î»2 (lambda_min, lambda_max), # Î±1 (lambda_min, lambda_max) # Î±2 ] elif smc_type == SMCType.ADAPTIVE: # Adaptive SMC bounds with adaptation constraints # Surface gains: same analysis as classical omega_n = 4.0 / settling_time k_min = omega_n**2 / 100 k_max = omega_n**2 lambda_min = omega_n / 2 lambda_max = bandwidth # Adaptation rate: stability-preserving bounds gamma_min = 0.1 # Minimum adaptation speed gamma_max = bandwidth / 5 # Stability margin preservation gamma_max = min(gamma_max, 20.0) # Practical upper limit bounds = [ (k_min, k_max), # k1 (k_min, k_max), # k2 (lambda_min, lambda_max), # Î»1 (lambda_min, lambda_max), # Î»2 (gamma_min, gamma_max) # Î³ ] elif smc_type == SMCType.HYBRID: # Hybrid controller bounds (conservative) # Surface gains: conservative bounds for mode switching gain_min = 2.0 / settling_time gain_max = bandwidth / 3 # Conservative for hybrid operation bounds = [ (gain_min, gain_max), # k1 (gain_min, gain_max), # k2 (gain_min, gain_max), # Î»1 (gain_min, gain_max) # Î»2 ] else: raise ValueError(f&quot;Unsupported SMC type: {smc_type}&quot;) # Validate bounds consistency for i, (lower, upper) in enumerate(bounds): if lower &gt;= upper: raise ValueError(f&quot;Invalid bounds for parameter {i}: [{lower}, {upper}]&quot;) if lower &lt; 0 and smc_type != SMCType.CLASSICAL: # Only kd can be 0 raise ValueError(f&quot;Negative lower bound for parameter {i}: {lower}&quot;) # Apply constraint-specific adjustments if &#39;force_limit&#39; in constraints: # Adjust switching/twisting gains for force constraints force_limit = constraints[&#39;force_limit&#39;] if smc_type == SMCType.CLASSICAL: bounds[4] = (bounds[4][0], min(bounds[4][1], force_limit * 0.8)) elif smc_type == SMCType.SUPER_TWISTING: bounds[0] = (bounds[0][0], min(bounds[0][1], force_limit * 0.8)) bounds[1] = (bounds[1][0], min(bounds[1][1], force_limit * 0.8)) return bounds
``` ### validate_smc_gains ```python
# example-metadata:

# runnable: false def validate_smc_gains(smc_type: SMCType, gains: List[float], strict: bool = True, return_details: bool = False ) -&gt; Union[bool, Tuple[bool, Dict[str, Any]]]: &quot;&quot;&quot; validation of SMC gains against mathematical constraints. Performs multi-level validation: 1. Basic constraints (positivity, bounds checking) 2. Mathematical constraints (stability, convergence) 3. Physical constraints (actuator limits, bandwidth) 4. Numerical constraints (conditioning, finite values) Mathematical Validation Framework: Classical SMC Validation: 1. Stability: Î»1, Î»2, K &gt; 0 (Lyapunov condition VÌ‡ â‰¤ -Î·|s|) 2. Reachability: K &gt; |d_max| (uncertainty bound) 3. Performance: Pole placement within stability region 4. Saturation: KÂ·Ï† â‰¤ max_force (actuator limits) Super-Twisting Validation: 1. Convergence: K1 &gt; K2 &gt; 0 (finite-time stability) 2. Lyapunov: K1Â² &gt; 4LK2 (sufficient condition) 3. Reachability: Gains sufficient for uncertainty rejection 4. Bandwidth: Avoid high-frequency content Adaptive SMC Validation: 1. Stability: Base gains satisfy classical constraints 2. Adaptation: 0.1 â‰¤ Î³ â‰¤ 20 (bounded adaptation) 3. Convergence: Adaptation rate vs system bandwidth 4. Robustness: Parameter drift prevention Hybrid SMC Validation: 1. Mode stability: Each mode individually stable 2. Switching stability: No instability during transitions 3. Performance: Smooth mode transitions 4. Robustness: Consistent performance across modes Args: smc_type: Controller type for validation gains: Gain array to validate strict: strict mathematical validation return_details: Return detailed validation information Returns: If return_details=False: Boolean validation result If return_details=True: Tuple of (is_valid, validation_details) Validation Details Dictionary: { &#39;is_valid&#39;: bool, &#39;errors&#39;: List[str], # Constraint violations &#39;warnings&#39;: List[str], # Potential issues &#39;stability_analysis&#39;: { &#39;lyapunov_stable&#39;: bool, &#39;convergence_rate&#39;: float, &#39;stability_margin&#39;: float }, &#39;performance_analysis&#39;: { &#39;estimated_settling_time&#39;: float, &#39;estimated_overshoot&#39;: float, &#39;bandwidth_estimate&#39;: float }, &#39;constraint_details&#39;: { &#39;basic_constraints&#39;: Dict, &#39;mathematical_constraints&#39;: Dict, &#39;physical_constraints&#39;: Dict } } Usage Examples: # Basic validation is_valid = validate_smc_gains(SMCType.CLASSICAL, [10,8,15,12,50,5]) # Detailed validation is_valid, details = validate_smc_gains( SMCType.CLASSICAL, gains, return_details=True ) print(f&quot;Stability margin: {details[&#39;stability_analysis&#39;][&#39;stability_margin&#39;]}&quot;) # PSO integration with validation def pso_fitness_with_validation(gains): if not validate_smc_gains(SMCType.CLASSICAL, gains): return 1000.0 # Penalty for invalid gains return evaluate_controller_performance(gains) Raises: ValueError: If basic validation fails (wrong gain count, NaN values) TypeError: If inputs have wrong types &quot;&quot;&quot; # Input validation if not isinstance(smc_type, SMCType): raise TypeError(f&quot;smc_type must be SMCType, got {type(smc_type)}&quot;) if not isinstance(gains, (list, np.ndarray)): raise TypeError(f&quot;gains must be list or array, got {type(gains)}&quot;) # Convert to list if numpy array if isinstance(gains, np.ndarray): gains = gains.tolist() # Initialize validation results errors = [] warnings = [] stability_analysis = {} performance_analysis = {} constraint_details = { &#39;basic_constraints&#39;: {}, &#39;mathematical_constraints&#39;: {}, &#39;physical_constraints&#39;: {} } # Get gain specification gain_spec = SMC_GAIN_SPECS[smc_type] # Basic validation if len(gains) != gain_spec.n_gains: errors.append(f&quot;Expected {gain_spec.n_gains} gains, got {len(gains)}&quot;) if return_details: return False, { &#39;is_valid&#39;: False, &#39;errors&#39;: errors, &#39;warnings&#39;: warnings, &#39;stability_analysis&#39;: {}, &#39;performance_analysis&#39;: {}, &#39;constraint_details&#39;: constraint_details } return False # Check for finite values if not all(np.isfinite(g) for g in gains): errors.append(&quot;All gains must be finite (no NaN or infinite values)&quot;) # Check for reasonable magnitudes if any(abs(g) &gt; 1e6 for g in gains): warnings.append(&quot;Some gains are very large (&gt;1e6), may cause numerical issues&quot;) if any(abs(g) &lt; 1e-8 for g in gains[:-1]): # Exclude kd for classical warnings.append(&quot;Some gains are very small (&lt;1e-8), may affect performance&quot;) # Controller-specific mathematical validation if smc_type == SMCType.CLASSICAL: k1, k2, lam1, lam2, K, kd = gains # Basic constraints constraint_details[&#39;basic_constraints&#39;] = { &#39;k1_positive&#39;: k1 &gt; 0, &#39;k2_positive&#39;: k2 &gt; 0, &#39;lambda1_positive&#39;: lam1 &gt; 0, &#39;lambda2_positive&#39;: lam2 &gt; 0, &#39;K_positive&#39;: K &gt; 0, &#39;kd_nonnegative&#39;: kd &gt;= 0 } # Check positivity constraints if any(g &lt;= 0 for g in gains[:5]): errors.append(&quot;Surface gains (k1,k2,Î»1,Î»2) and switching gain (K) must be positive&quot;) if kd &lt; 0: errors.append(&quot;Damping gain (kd) must be non-negative&quot;) # Mathematical constraints (strict mode) if strict: # Estimate stability properties # Simplified stability analysis min_surface_gain = min(lam1, lam2) estimated_bandwidth = min_surface_gain estimated_uncertainty = 10.0 # Conservative estimate constraint_details[&#39;mathematical_constraints&#39;] = { &#39;switching_gain_adequate&#39;: K &gt; estimated_uncertainty, &#39;surface_gains_adequate&#39;: min_surface_gain &gt; 1.0, &#39;damping_reasonable&#39;: kd &lt;= min_surface_gain } if K &lt;= estimated_uncertainty: warnings.append(f&quot;Switching gain K={K:.2f} may be too small for uncertainty rejection&quot;) # Stability analysis stability_margin = K - estimated_uncertainty convergence_rate = min(min_surface_gain, stability_margin) if stability_margin &gt; 0 else 0 stability_analysis = { &#39;lyapunov_stable&#39;: stability_margin &gt; 0, &#39;convergence_rate&#39;: convergence_rate, &#39;stability_margin&#39;: stability_margin / K if K &gt; 0 else 0 } # Performance estimates estimated_settling_time = 4.0 / min_surface_gain if min_surface_gain &gt; 0 else float(&#39;inf&#39;) estimated_overshoot = max(0, (k1 + k2) / (lam1 + lam2) - 1) * 100 if (lam1 + lam2) &gt; 0 else 100 performance_analysis = { &#39;estimated_settling_time&#39;: estimated_settling_time, &#39;estimated_overshoot&#39;: estimated_overshoot, &#39;bandwidth_estimate&#39;: estimated_bandwidth } # Physical constraints max_force_estimate = 100.0 # Default actuator limit constraint_details[&#39;physical_constraints&#39;] = { &#39;force_saturation_check&#39;: K &lt;= max_force_estimate, &#39;bandwidth_feasible&#39;: max(lam1, lam2) &lt;= 50.0 } if K &gt; max_force_estimate: warnings.append(f&quot;Switching gain K={K:.1f} may exceed actuator limits&quot;) elif smc_type == SMCType.SUPER_TWISTING: K1, K2, lam1, lam2, alpha1, alpha2 = gains # Basic constraints constraint_details[&#39;basic_constraints&#39;] = { &#39;K1_positive&#39;: K1 &gt; 0, &#39;K2_positive&#39;: K2 &gt; 0, &#39;K1_greater_K2&#39;: K1 &gt; K2, &#39;lambda1_positive&#39;: lam1 &gt; 0, &#39;lambda2_positive&#39;: lam2 &gt; 0, &#39;alpha1_positive&#39;: alpha1 &gt; 0, &#39;alpha2_positive&#39;: alpha2 &gt; 0 } # Critical convergence constraint if K1 &lt;= K2: errors.append(&quot;K1 must be greater than K2 for finite-time convergence&quot;) if any(g &lt;= 0 for g in gains): errors.append(&quot;All STA gains must be positive&quot;) # Mathematical constraints (strict mode) if strict: # Finite-time convergence analysis L_estimate = 15.0 # Conservative Lipschitz constant estimate convergence_condition = K1**2 &gt; 4 * L_estimate * K2 constraint_details[&#39;mathematical_constraints&#39;] = { &#39;finite_time_convergence&#39;: convergence_condition, &#39;gains_well_separated&#39;: K1 &gt; K2 * 1.1, &#39;lipschitz_condition&#39;: K1**2 &gt; 4 * L_estimate * K2 } if not convergence_condition: warnings.append(&quot;May not satisfy sufficient condition for finite-time convergence&quot;) # Stability analysis convergence_rate = min(K1, K2) if K1 &gt; K2 else 0 stability_margin = (K1 - K2) / K1 if K1 &gt; 0 else 0 stability_analysis = { &#39;lyapunov_stable&#39;: K1 &gt; K2 &gt; 0, &#39;convergence_rate&#39;: convergence_rate, &#39;stability_margin&#39;: stability_margin } elif smc_type == SMCType.ADAPTIVE: k1, k2, lam1, lam2, gamma = gains # Basic constraints constraint_details[&#39;basic_constraints&#39;] = { &#39;k1_positive&#39;: k1 &gt; 0, &#39;k2_positive&#39;: k2 &gt; 0, &#39;lambda1_positive&#39;: lam1 &gt; 0, &#39;lambda2_positive&#39;: lam2 &gt; 0, &#39;gamma_in_bounds&#39;: 0.1 &lt;= gamma &lt;= 20.0 } # Check positivity and adaptation bounds if any(g &lt;= 0 for g in gains[:4]): errors.append(&quot;Surface gains must be positive&quot;) if not (0.1 &lt;= gamma &lt;= 20.0): errors.append(&quot;Adaptation rate Î³ must be in [0.1, 20.0]&quot;) # Mathematical constraints (strict mode) if strict: # Adaptation stability analysis system_bandwidth = min(lam1, lam2) adaptation_bandwidth = gamma * system_bandwidth constraint_details[&#39;mathematical_constraints&#39;] = { &#39;adaptation_stable&#39;: gamma &lt; 10.0, &#39;adaptation_not_too_slow&#39;: gamma &gt; 0.2, &#39;separation_principle&#39;: adaptation_bandwidth &lt; system_bandwidth } if gamma &gt; 10.0: warnings.append(&quot;High adaptation rate may cause instability&quot;) if gamma &lt; 0.2: warnings.append(&quot;Low adaptation rate may be too slow&quot;) # Stability analysis stability_analysis = { &#39;lyapunov_stable&#39;: True, # Assuming proper design &#39;convergence_rate&#39;: min(system_bandwidth, gamma), &#39;stability_margin&#39;: (20.0 - gamma) / 20.0 } elif smc_type == SMCType.HYBRID: k1, k2, lam1, lam2 = gains # Basic constraints constraint_details[&#39;basic_constraints&#39;] = { &#39;k1_positive&#39;: k1 &gt; 0, &#39;k2_positive&#39;: k2 &gt; 0, &#39;lambda1_positive&#39;: lam1 &gt; 0, &#39;lambda2_positive&#39;: lam2 &gt; 0 } if any(g &lt;= 0 for g in gains): errors.append(&quot;All hybrid gains must be positive&quot;) # Mathematical constraints (strict mode) if strict: # Hybrid stability analysis (simplified) min_gain = min(gains) constraint_details[&#39;mathematical_constraints&#39;] = { &#39;mode_stability&#39;: min_gain &gt; 1.0, &#39;switching_stability&#39;: max(gains) / min_gain &lt; 10.0 } stability_analysis = { &#39;lyapunov_stable&#39;: min_gain &gt; 0, &#39;convergence_rate&#39;: min_gain, &#39;stability_margin&#39;: min_gain / max(gains) if max(gains) &gt; 0 else 0 } # Overall validation result is_valid = len(errors) == 0 if return_details: validation_details = { &#39;is_valid&#39;: is_valid, &#39;errors&#39;: errors, &#39;warnings&#39;: warnings, &#39;stability_analysis&#39;: stability_analysis, &#39;performance_analysis&#39;: performance_analysis, &#39;constraint_details&#39;: constraint_details } return is_valid, validation_details else: return is_valid

</pre></div>
</div>
<hr class="docutils" />
<section id="pso-controller-wrapper-psocontrollerwrapper-class-python">
<h2>PSO Controller Wrapper ### PSOControllerWrapper Class ```python<a class="headerlink" href="#pso-controller-wrapper-psocontrollerwrapper-class-python" title="Link to this heading">Â¶</a></h2>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id2">
<h1>example-metadata:<a class="headerlink" href="#id2" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-class-psocontrollerwrapper-pso-optimized-wrapper-providing-simplified-interface-for-smc-controllers-this-wrapper-is-specifically-designed-for-pso-fitness-evaluation-with-simplified-control-interface-single-state-input-automatic-state-management-for-stateful-controllers-unified-output-format-numpy-array-robust-error-handling-for-pso-robustness-performance-optimization-for-repeated-evaluations-the-wrapper-handles-the-complexity-of-different-smc-controller-interfaces-while-providing-a-consistent-pso-friendly-api-mathematical-foundation-the-wrapper-preserves-the-mathematical-properties-of-the-underlying-smc-controller-while-simplifying-the-interface-input-state-1-2-x-1-2-x-6-output-u-scalar-control-force-internal-state-management-classical-smc-stateless-empty-state-vars-sta-smc-maintains-z-for-integration-adaptive-smc-tracks-adaptation-variables-hybrid-smc-manages-mode-switching-state-performance-characteristics-control-computation-0-1ms-typical-memory-overhead-500b-per-wrapper-thread-safety-read-operations-only-error-recovery-graceful-degradation-for-invalid-inputs-def-init-self-controller-smcprotocol-initialize-pso-wrapper-with-smc-controller-args-controller-smc-controller-implementing-smcprotocol-raises-typeerror-if-controller-doesn-t-implement-required-interface-valueerror-if-controller-configuration-is-invalid-validate-controller-interface-if-not-hasattr-controller-compute-control-raise-typeerror-controller-must-implement-compute-control-method-if-not-hasattr-controller-gains-raise-typeerror-controller-must-have-gains-property-self-controller-controller-self-history-initialize-empty-history-initialize-controller-specific-state-variables-controller-name-type-controller-name-if-supertwisting-in-controller-name-or-sta-in-controller-name-sta-smc-maintains-integration-variables-z-self-state-vars-0-0-0-0-initial-z-0-0-elif-hybrid-in-controller-name-hybrid-controller-tracks-adaptive-gains-and-integration-self-state-vars-getattr-controller-k1-init-5-0-k1-prev-getattr-controller-k2-init-3-0-k2-prev-0-0-u-int-prev-elif-adaptive-in-controller-name-adaptive-smc-may-track-adaptation-state-self-state-vars-getattr-controller-initial-state-else-classical-smc-and-others-use-empty-state-self-state-vars-performance-tracking-self-call-count-0-self-total-compute-time-0-0-self-last-error-none-def-compute-control-self-state-np-ndarray-state-vars-optional-any-none-history-optional-dict-str-any-none-np-ndarray-compute-control-with-flexible-interface-supporting-both-1-simplified-pso-interface-compute-control-state-2-full-interface-compute-control-state-state-vars-history-mathematical-interface-input-state-vector-x-1-2-x-cart-1-2-x-cart-1-2-pendulum-angles-rad-x-cart-cart-position-m-1-2-angular-velocities-rad-s-x-cart-cart-velocity-m-s-output-control-u-scalar-control-force-n-bounded-by-actuator-limits-args-state-system-state-vector-6-element-numpy-array-state-vars-controller-state-variables-optional-history-controller-history-optional-returns-control-output-as-1-element-numpy-array-u-raises-valueerror-if-state-has-wrong-dimensions-runtimeerror-if-control-computation-fails-performance-typical-computation-time-0-01-0-1ms-memory-allocation-minimal-output-array-only-error-handling-graceful-fallback-to-zero-control-pso-usage-pattern-python-def-pso-fitness-gains-controller-create-smc-for-pso-smctype-classical-gains-simplified-interface-for-pso-total-error-0-0-for-state-in-test-states-u-controller-compute-control-state-returns-u-use-u-0-for-scalar-control-value-total-error-evaluate-single-step-state-u-0-return-total-error-state-management-the-wrapper-automatically-manages-controller-state-between-calls-classical-smc-no-state-management-needed-sta-smc-updates-integration-variables-z-adaptive-smc-updates-adaptation-parameters-hybrid-smc-updates-mode-and-adaptation-state-error-recovery-if-control-computation-fails-1-log-error-for-debugging-2-return-safe-fallback-control-zero-3-increment-error-counter-for-monitoring-4-continue-operation-don-t-crash-pso-import-time-performance-tracking-start-time-time-perf-counter-self-call-count-1-try-input-validation-if-not-isinstance-state-np-ndarray-state-np-array-state-if-state-shape-6-raise-valueerror-f-state-must-be-6-element-array-got-shape-state-shape-if-not-np-all-np-isfinite-state-raise-valueerror-state-contains-non-finite-values-nan-or-inf-use-provided-parameters-or-defaults-final-state-vars-state-vars-if-state-vars-is-not-none-else-self-state-vars-final-history-history-if-history-is-not-none-else-self-history-call-underlying-controller-result-self-controller-compute-control-state-final-state-vars-final-history-extract-control-value-from-result-handle-different-controller-output-formats-if-hasattr-result-u-standard-controller-output-with-u-attribute-control-value-result-u-update-state-variables-if-available-if-hasattr-result-state-vars-self-state-vars-result-state-vars-elif-hasattr-result-control-alternative-output-format-with-control-attribute-control-value-result-control-elif-isinstance-result-dict-dictionary-output-format-if-u-in-result-control-value-result-u-elif-control-in-result-control-value-result-control-else-raise-valueerror-dictionary-result-missing-control-value-update-state-if-provided-if-state-vars-in-result-self-state-vars-result-state-vars-elif-isinstance-result-tuple-tuple-output-e-g-early-return-from-some-controllers-control-value-result-0-first-element-is-control-if-len-result-1-self-state-vars-result-1-second-element-is-state-else-assume-result-is-the-control-value-directly-control-value-result-convert-to-scalar-if-needed-if-isinstance-control-value-np-ndarray-if-control-value-size-1-control-value-float-control-value-else-control-value-float-control-value-0-elif-not-isinstance-control-value-int-float-control-value-float-control-value-validate-output-if-not-np-isfinite-control-value-raise-valueerror-controller-returned-non-finite-control-value-apply-saturation-defensive-programming-max-force-getattr-self-controller-max-force-100-0-control-saturated-np-clip-control-value-max-force-max-force-for-simplified-interface-pso-usage-return-numpy-array-if-state-vars-is-none-and-history-is-none-output-np-array-control-saturated-else-for-full-interface-return-in-format-expected-by-simulation-output-control-saturated-performance-tracking-compute-time-time-perf-counter-start-time-self-total-compute-time-compute-time-return-output-except-exception-as-e-error-handling-for-robust-pso-operation-self-last-error-str-e-log-error-for-debugging-in-production-use-proper-logging-print-f-warning-control-computation-failed-e-return-safe-fallback-control-if-state-vars-is-none-and-history-is-none-return-np-array-0-0-pso-interface-else-return-0-0-full-interface-property-def-gains-self-list-float-return-controller-gains-returns-list-of-controller-gain-parameters-usage-python-controller-create-smc-for-pso-smctype-classical-gains-print-f-controller-gains-controller-gains-return-self-controller-gains-property-def-performance-stats-self-dict-str-any-return-performance-statistics-for-monitoring-returns-dictionary-with-performance-metrics-call-count-number-of-control-computations-total-time-total-computation-time-s-average-time-average-computation-time-ms-last-error-last-error-message-if-any-usage-python-after-pso-optimization-stats-controller-performance-stats-print-f-average-computation-time-stats-average-time-3f-ms-avg-time-ms-self-total-compute-time-self-call-count-1000-if-self-call-count-0-else-0-0-return-call-count-self-call-count-total-time-self-total-compute-time-average-time-avg-time-ms-last-error-self-last-error-def-reset-performance-stats-self-none-reset-performance-tracking-statistics-self-call-count-0-self-total-compute-time-0-0-self-last-error-none-def-validate-state-input-self-state-np-ndarray-tuple-bool-str-validate-state-input-for-control-computation-args-state-state-vector-to-validate-returns-tuple-of-is-valid-error-message-usage-python-is-valid-error-controller-validate-state-input-test-state-if-not-is-valid-print-f-invalid-state-error-try-if-not-isinstance-state-np-ndarray-return-false-state-must-be-numpy-array-if-state-shape-6-return-false-f-state-must-be-6-element-array-got-state-shape-if-not-np-all-np-isfinite-state-return-false-state-contains-non-finite-values-check-reasonable-ranges-optional-angles-state-2-1-2-if-np-any-np-abs-angles-2-np-pi-return-false-angles-exceed-reasonable-range-2-velocities-state-3-1-2-x-if-np-any-np-abs-velocities-100-return-false-velocities-exceed-reasonable-range-100-return-true-except-exception-as-e-return-false-f-validation-error-e-def-repr-self-str-string-representation-for-debugging-controller-type-type-self-controller-name-return-f-psocontrollerwrapper-controller-type-gains-self-gains">
<h1>runnable: false class PSOControllerWrapper: â€œâ€â€ PSO-optimized wrapper providing simplified interface for SMC controllers. This wrapper is specifically designed for PSO fitness evaluation with: - Simplified control interface (single state input) - Automatic state management for stateful controllers - Unified output format (numpy array) - Robust error handling for PSO robustness - Performance optimization for repeated evaluations The wrapper handles the complexity of different SMC controller interfaces while providing a consistent, PSO-friendly API. Mathematical Foundation: The wrapper preserves the mathematical properties of the underlying SMC controller while simplifying the interface: Input: state = [Î¸â‚, Î¸â‚‚, x, Î¸Ì‡â‚, Î¸Ì‡â‚‚, áº‹] âˆˆ â„â¶ Output: u âˆˆ â„ (scalar control force) Internal State Management: - Classical SMC: Stateless (empty state_vars) - STA SMC: Maintains (z, Ïƒ) for integration - Adaptive SMC: Tracks adaptation variables - Hybrid SMC: Manages mode switching state Performance Characteristics: - Control computation: &lt;0.1ms typical - Memory overhead: &lt;500B per wrapper - Thread safety: Read operations only - Error recovery: Graceful degradation for invalid inputs â€œâ€â€ def <strong>init</strong>(self, controller: SMCProtocol): â€œâ€â€ Initialize PSO wrapper with SMC controller. Args: controller: SMC controller implementing SMCProtocol Raises: TypeError: If controller doesnâ€™t implement required interface ValueError: If controller configuration is invalid â€œâ€â€ # Validate controller interface if not hasattr(controller, â€˜compute_controlâ€™): raise TypeError(â€œController must implement compute_control methodâ€) if not hasattr(controller, â€˜gainsâ€™): raise TypeError(â€œController must have gains propertyâ€) self.controller = controller self._history = {} # Initialize empty history # Initialize controller-specific state variables controller_name = type(controller).<strong>name</strong> if â€˜SuperTwistingâ€™ in controller_name or â€˜STAâ€™ in controller_name: # STA-SMC maintains integration variables (z, Ïƒ) self._state_vars = (0.0, 0.0) # Initial (z=0, Ïƒ=0) elif â€˜Hybridâ€™ in controller_name: # Hybrid controller tracks adaptive gains and integration self._state_vars = ( getattr(controller, â€˜k1_initâ€™, 5.0), # k1_prev getattr(controller, â€˜k2_initâ€™, 3.0), # k2_prev 0.0 # u_int_prev ) elif â€˜Adaptiveâ€™ in controller_name: # Adaptive SMC may track adaptation state self._state_vars = getattr(controller, â€˜_initial_stateâ€™, ()) else: # Classical SMC and others use empty state self._state_vars = () # Performance tracking self._call_count = 0 self._total_compute_time = 0.0 self._last_error = None def compute_control(self, state: np.ndarray, state_vars: Optional[Any] = None, history: Optional[Dict[str, Any]] = None ) -&gt; np.ndarray: â€œâ€â€ Compute control with flexible interface supporting both: 1. Simplified PSO interface: compute_control(state) 2. Full interface: compute_control(state, state_vars, history) Mathematical Interface: Input state vector: x = [Î¸â‚, Î¸â‚‚, x_cart, Î¸Ì‡â‚, Î¸Ì‡â‚‚, áº‹_cart] - Î¸â‚, Î¸â‚‚: Pendulum angles [rad] - x_cart: Cart position [m] - Î¸Ì‡â‚, Î¸Ì‡â‚‚: Angular velocities [rad/s] - áº‹_cart: Cart velocity [m/s] Output control: u âˆˆ â„ - Scalar control force [N] - Bounded by actuator limits Args: state: System state vector (6-element numpy array) state_vars: Controller state variables (optional) history: Controller history (optional) Returns: Control output as 1-element numpy array [u] Raises: ValueError: If state has wrong dimensions RuntimeError: If control computation fails Performance: - Typical computation time: 0.01-0.1ms - Memory allocation: Minimal (output array only) - Error handling: Graceful fallback to zero control PSO Usage Pattern: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">def</span> <span class="pre">pso_fitness(gains):</span> <span class="pre">controller</span> <span class="pre">=</span> <span class="pre">create_smc_for_pso(SMCType.CLASSICAL,</span> <span class="pre">gains)</span> <span class="pre">#</span> <span class="pre">Simplified</span> <span class="pre">interface</span> <span class="pre">for</span> <span class="pre">PSO</span> <span class="pre">total_error</span> <span class="pre">=</span> <span class="pre">0.0</span> <span class="pre">for</span> <span class="pre">state</span> <span class="pre">in</span> <span class="pre">test_states:</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">controller.compute_control(state)</span> <span class="pre">#</span> <span class="pre">Returns</span> <span class="pre">[u]</span> <span class="pre">#</span> <span class="pre">Use</span> <span class="pre">u[0]</span> <span class="pre">for</span> <span class="pre">scalar</span> <span class="pre">control</span> <span class="pre">value</span> <span class="pre">total_error</span> <span class="pre">+=</span> <span class="pre">evaluate_single_step(state,</span> <span class="pre">u[0])</span> <span class="pre">return</span> <span class="pre">total_error</span> </code> State Management: The wrapper automatically manages controller state between calls: - Classical SMC: No state management needed - STA SMC: Updates integration variables (z, Ïƒ) - Adaptive SMC: Updates adaptation parameters - Hybrid SMC: Updates mode and adaptation state Error Recovery: If control computation fails: 1. Log error for debugging 2. Return safe fallback control (zero) 3. Increment error counter for monitoring 4. Continue operation (donâ€™t crash PSO) â€œâ€â€ import time # Performance tracking start_time = time.perf_counter() self._call_count += 1 try: # Input validation if not isinstance(state, np.ndarray): state = np.array(state) if state.shape != (6,): raise ValueError(fâ€State must be 6-element array, got shape {state.shape}â€) if not np.all(np.isfinite(state)): raise ValueError(â€œState contains non-finite values (NaN or inf)â€) # Use provided parameters or defaults final_state_vars = state_vars if state_vars is not None else self._state_vars final_history = history if history is not None else self._history # Call underlying controller result = self.controller.compute_control(state, final_state_vars, final_history) # Extract control value from result # Handle different controller output formats if hasattr(result, â€˜uâ€™): # Standard controller output with .u attribute control_value = result.u # Update state variables if available if hasattr(result, â€˜state_varsâ€™): self._state_vars = result.state_vars elif hasattr(result, â€˜controlâ€™): # Alternative output format with .control attribute control_value = result.control elif isinstance(result, dict): # Dictionary output format if â€˜uâ€™ in result: control_value = result[â€˜uâ€™] elif â€˜controlâ€™ in result: control_value = result[â€˜controlâ€™] else: raise ValueError(â€œDictionary result missing control valueâ€) # Update state if provided if â€˜state_varsâ€™ in result: self._state_vars = result[â€˜state_varsâ€™] elif isinstance(result, tuple): # Tuple output (e.g., early return from some controllers) control_value = result[0] # First element is control if len(result) &gt; 1: self._state_vars = result[1] # Second element is state else: # Assume result is the control value directly control_value = result # Convert to scalar if needed if isinstance(control_value, np.ndarray): if control_value.size == 1: control_value = float(control_value) else: control_value = float(control_value[0]) elif not isinstance(control_value, (int, float)): control_value = float(control_value) # Validate output if not np.isfinite(control_value): raise ValueError(â€œController returned non-finite control valueâ€) # Apply saturation (defensive programming) max_force = getattr(self.controller, â€˜max_forceâ€™, 100.0) control_saturated = np.clip(control_value, -max_force, max_force) # For simplified interface (PSO usage), return numpy array if state_vars is None and history is None: output = np.array([control_saturated]) else: # For full interface, return in format expected by simulation output = control_saturated # Performance tracking compute_time = time.perf_counter() - start_time self._total_compute_time += compute_time return output except Exception as e: # Error handling for robust PSO operation self._last_error = str(e) # Log error for debugging (in production, use proper logging) print(fâ€Warning: Control computation failed: {e}â€) # Return safe fallback control if state_vars is None and history is None: return np.array([0.0]) # PSO interface else: return 0.0 # Full interface &#64;property def gains(self) -&gt; List[float]: â€œâ€â€ Return controller gains. Returns: List of controller gain parameters Usage: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">controller</span> <span class="pre">=</span> <span class="pre">create_smc_for_pso(SMCType.CLASSICAL,</span> <span class="pre">gains)</span> <span class="pre">print(f&quot;Controller</span> <span class="pre">gains:</span> <span class="pre">{controller.gains}&quot;)</span> </code> â€œâ€â€ return self.controller.gains &#64;property def performance_stats(self) -&gt; Dict[str, Any]: â€œâ€â€ Return performance statistics for monitoring. Returns: Dictionary with performance metrics: - call_count: Number of control computations - total_time: Total computation time [s] - average_time: Average computation time [ms] - last_error: Last error message (if any) Usage: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">#</span> <span class="pre">After</span> <span class="pre">PSO</span> <span class="pre">optimization</span> <span class="pre">stats</span> <span class="pre">=</span> <span class="pre">controller.performance_stats</span> <span class="pre">print(f&quot;Average</span> <span class="pre">computation</span> <span class="pre">time:</span> <span class="pre">{stats['average_time']:.3f}ms&quot;)</span> </code> â€œâ€â€ avg_time_ms = (self._total_compute_time / self._call_count * 1000 if self._call_count &gt; 0 else 0.0) return { â€˜call_countâ€™: self._call_count, â€˜total_timeâ€™: self._total_compute_time, â€˜average_timeâ€™: avg_time_ms, â€˜last_errorâ€™: self._last_error } def reset_performance_stats(self) -&gt; None: â€œâ€â€Reset performance tracking statistics.â€â€â€ self._call_count = 0 self._total_compute_time = 0.0 self._last_error = None def validate_state_input(self, state: np.ndarray) -&gt; Tuple[bool, str]: â€œâ€â€ Validate state input for control computation. Args: state: State vector to validate Returns: Tuple of (is_valid, error_message) Usage: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">is_valid,</span> <span class="pre">error</span> <span class="pre">=</span> <span class="pre">controller.validate_state_input(test_state)</span> <span class="pre">if</span> <span class="pre">not</span> <span class="pre">is_valid:</span> <span class="pre">print(f&quot;Invalid</span> <span class="pre">state:</span> <span class="pre">{error}&quot;)</span> </code> â€œâ€â€ try: if not isinstance(state, np.ndarray): return False, â€œState must be numpy arrayâ€ if state.shape != (6,): return False, fâ€State must be 6-element array, got {state.shape}â€ if not np.all(np.isfinite(state)): return False, â€œState contains non-finite valuesâ€ # Check reasonable ranges (optional) angles = state[:2] # Î¸â‚, Î¸â‚‚ if np.any(np.abs(angles) &gt; 2*np.pi): return False, â€œAngles exceed reasonable range (Â±2Ï€)â€ velocities = state[3:] # Î¸Ì‡â‚, Î¸Ì‡â‚‚, áº‹ if np.any(np.abs(velocities) &gt; 100): return False, â€œVelocities exceed reasonable range (Â±100)â€ return True, â€œâ€ except Exception as e: return False, fâ€Validation error: {e}â€ def <strong>repr</strong>(self) -&gt; str: â€œâ€â€String representation for debugging.â€â€â€ controller_type = type(self.controller).<strong>name</strong> return fâ€PSOControllerWrapper({controller_type}, gains={self.gains})â€<a class="headerlink" href="#runnable-false-class-psocontrollerwrapper-pso-optimized-wrapper-providing-simplified-interface-for-smc-controllers-this-wrapper-is-specifically-designed-for-pso-fitness-evaluation-with-simplified-control-interface-single-state-input-automatic-state-management-for-stateful-controllers-unified-output-format-numpy-array-robust-error-handling-for-pso-robustness-performance-optimization-for-repeated-evaluations-the-wrapper-handles-the-complexity-of-different-smc-controller-interfaces-while-providing-a-consistent-pso-friendly-api-mathematical-foundation-the-wrapper-preserves-the-mathematical-properties-of-the-underlying-smc-controller-while-simplifying-the-interface-input-state-1-2-x-1-2-x-6-output-u-scalar-control-force-internal-state-management-classical-smc-stateless-empty-state-vars-sta-smc-maintains-z-for-integration-adaptive-smc-tracks-adaptation-variables-hybrid-smc-manages-mode-switching-state-performance-characteristics-control-computation-0-1ms-typical-memory-overhead-500b-per-wrapper-thread-safety-read-operations-only-error-recovery-graceful-degradation-for-invalid-inputs-def-init-self-controller-smcprotocol-initialize-pso-wrapper-with-smc-controller-args-controller-smc-controller-implementing-smcprotocol-raises-typeerror-if-controller-doesn-t-implement-required-interface-valueerror-if-controller-configuration-is-invalid-validate-controller-interface-if-not-hasattr-controller-compute-control-raise-typeerror-controller-must-implement-compute-control-method-if-not-hasattr-controller-gains-raise-typeerror-controller-must-have-gains-property-self-controller-controller-self-history-initialize-empty-history-initialize-controller-specific-state-variables-controller-name-type-controller-name-if-supertwisting-in-controller-name-or-sta-in-controller-name-sta-smc-maintains-integration-variables-z-self-state-vars-0-0-0-0-initial-z-0-0-elif-hybrid-in-controller-name-hybrid-controller-tracks-adaptive-gains-and-integration-self-state-vars-getattr-controller-k1-init-5-0-k1-prev-getattr-controller-k2-init-3-0-k2-prev-0-0-u-int-prev-elif-adaptive-in-controller-name-adaptive-smc-may-track-adaptation-state-self-state-vars-getattr-controller-initial-state-else-classical-smc-and-others-use-empty-state-self-state-vars-performance-tracking-self-call-count-0-self-total-compute-time-0-0-self-last-error-none-def-compute-control-self-state-np-ndarray-state-vars-optional-any-none-history-optional-dict-str-any-none-np-ndarray-compute-control-with-flexible-interface-supporting-both-1-simplified-pso-interface-compute-control-state-2-full-interface-compute-control-state-state-vars-history-mathematical-interface-input-state-vector-x-1-2-x-cart-1-2-x-cart-1-2-pendulum-angles-rad-x-cart-cart-position-m-1-2-angular-velocities-rad-s-x-cart-cart-velocity-m-s-output-control-u-scalar-control-force-n-bounded-by-actuator-limits-args-state-system-state-vector-6-element-numpy-array-state-vars-controller-state-variables-optional-history-controller-history-optional-returns-control-output-as-1-element-numpy-array-u-raises-valueerror-if-state-has-wrong-dimensions-runtimeerror-if-control-computation-fails-performance-typical-computation-time-0-01-0-1ms-memory-allocation-minimal-output-array-only-error-handling-graceful-fallback-to-zero-control-pso-usage-pattern-python-def-pso-fitness-gains-controller-create-smc-for-pso-smctype-classical-gains-simplified-interface-for-pso-total-error-0-0-for-state-in-test-states-u-controller-compute-control-state-returns-u-use-u-0-for-scalar-control-value-total-error-evaluate-single-step-state-u-0-return-total-error-state-management-the-wrapper-automatically-manages-controller-state-between-calls-classical-smc-no-state-management-needed-sta-smc-updates-integration-variables-z-adaptive-smc-updates-adaptation-parameters-hybrid-smc-updates-mode-and-adaptation-state-error-recovery-if-control-computation-fails-1-log-error-for-debugging-2-return-safe-fallback-control-zero-3-increment-error-counter-for-monitoring-4-continue-operation-don-t-crash-pso-import-time-performance-tracking-start-time-time-perf-counter-self-call-count-1-try-input-validation-if-not-isinstance-state-np-ndarray-state-np-array-state-if-state-shape-6-raise-valueerror-f-state-must-be-6-element-array-got-shape-state-shape-if-not-np-all-np-isfinite-state-raise-valueerror-state-contains-non-finite-values-nan-or-inf-use-provided-parameters-or-defaults-final-state-vars-state-vars-if-state-vars-is-not-none-else-self-state-vars-final-history-history-if-history-is-not-none-else-self-history-call-underlying-controller-result-self-controller-compute-control-state-final-state-vars-final-history-extract-control-value-from-result-handle-different-controller-output-formats-if-hasattr-result-u-standard-controller-output-with-u-attribute-control-value-result-u-update-state-variables-if-available-if-hasattr-result-state-vars-self-state-vars-result-state-vars-elif-hasattr-result-control-alternative-output-format-with-control-attribute-control-value-result-control-elif-isinstance-result-dict-dictionary-output-format-if-u-in-result-control-value-result-u-elif-control-in-result-control-value-result-control-else-raise-valueerror-dictionary-result-missing-control-value-update-state-if-provided-if-state-vars-in-result-self-state-vars-result-state-vars-elif-isinstance-result-tuple-tuple-output-e-g-early-return-from-some-controllers-control-value-result-0-first-element-is-control-if-len-result-1-self-state-vars-result-1-second-element-is-state-else-assume-result-is-the-control-value-directly-control-value-result-convert-to-scalar-if-needed-if-isinstance-control-value-np-ndarray-if-control-value-size-1-control-value-float-control-value-else-control-value-float-control-value-0-elif-not-isinstance-control-value-int-float-control-value-float-control-value-validate-output-if-not-np-isfinite-control-value-raise-valueerror-controller-returned-non-finite-control-value-apply-saturation-defensive-programming-max-force-getattr-self-controller-max-force-100-0-control-saturated-np-clip-control-value-max-force-max-force-for-simplified-interface-pso-usage-return-numpy-array-if-state-vars-is-none-and-history-is-none-output-np-array-control-saturated-else-for-full-interface-return-in-format-expected-by-simulation-output-control-saturated-performance-tracking-compute-time-time-perf-counter-start-time-self-total-compute-time-compute-time-return-output-except-exception-as-e-error-handling-for-robust-pso-operation-self-last-error-str-e-log-error-for-debugging-in-production-use-proper-logging-print-f-warning-control-computation-failed-e-return-safe-fallback-control-if-state-vars-is-none-and-history-is-none-return-np-array-0-0-pso-interface-else-return-0-0-full-interface-property-def-gains-self-list-float-return-controller-gains-returns-list-of-controller-gain-parameters-usage-python-controller-create-smc-for-pso-smctype-classical-gains-print-f-controller-gains-controller-gains-return-self-controller-gains-property-def-performance-stats-self-dict-str-any-return-performance-statistics-for-monitoring-returns-dictionary-with-performance-metrics-call-count-number-of-control-computations-total-time-total-computation-time-s-average-time-average-computation-time-ms-last-error-last-error-message-if-any-usage-python-after-pso-optimization-stats-controller-performance-stats-print-f-average-computation-time-stats-average-time-3f-ms-avg-time-ms-self-total-compute-time-self-call-count-1000-if-self-call-count-0-else-0-0-return-call-count-self-call-count-total-time-self-total-compute-time-average-time-avg-time-ms-last-error-self-last-error-def-reset-performance-stats-self-none-reset-performance-tracking-statistics-self-call-count-0-self-total-compute-time-0-0-self-last-error-none-def-validate-state-input-self-state-np-ndarray-tuple-bool-str-validate-state-input-for-control-computation-args-state-state-vector-to-validate-returns-tuple-of-is-valid-error-message-usage-python-is-valid-error-controller-validate-state-input-test-state-if-not-is-valid-print-f-invalid-state-error-try-if-not-isinstance-state-np-ndarray-return-false-state-must-be-numpy-array-if-state-shape-6-return-false-f-state-must-be-6-element-array-got-state-shape-if-not-np-all-np-isfinite-state-return-false-state-contains-non-finite-values-check-reasonable-ranges-optional-angles-state-2-1-2-if-np-any-np-abs-angles-2-np-pi-return-false-angles-exceed-reasonable-range-2-velocities-state-3-1-2-x-if-np-any-np-abs-velocities-100-return-false-velocities-exceed-reasonable-range-100-return-true-except-exception-as-e-return-false-f-validation-error-e-def-repr-self-str-string-representation-for-debugging-controller-type-type-self-controller-name-return-f-psocontrollerwrapper-controller-type-gains-self-gains" title="Link to this heading">Â¶</a></h1>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
---

## Mathematical Constraints API ### SMC_GAIN_SPECS Registry ```python

# example-metadata:

# runnable: false # Global registry of SMC gain specifications

SMC_GAIN_SPECS: Dict[SMCType, SMCGainSpec] = { SMCType.CLASSICAL: SMCGainSpec( controller_type=SMCType.CLASSICAL, n_gains=6, gain_names=[&#39;k1&#39;, &#39;k2&#39;, &#39;Î»1&#39;, &#39;Î»2&#39;, &#39;K&#39;, &#39;kd&#39;], gain_descriptions=[ &#39;Position gain for pendulum 1&#39;, &#39;Position gain for pendulum 2&#39;, &#39;Surface gain for pendulum 1&#39;, &#39;Surface gain for pendulum 2&#39;, &#39;Switching gain for robustness&#39;, &#39;Damping gain for chattering reduction&#39; ], mathematical_constraints=[ &#39;k1 &gt; 0 (controllability)&#39;, &#39;k2 &gt; 0 (controllability)&#39;, &#39;Î»1 &gt; 0 (stability)&#39;, &#39;Î»2 &gt; 0 (stability)&#39;, &#39;K &gt; 0 (reachability)&#39;, &#39;kd â‰¥ 0 (non-negative damping)&#39; ], pso_bounds=[ (0.1, 50.0), # k1 (0.1, 50.0), # k2 (1.0, 50.0), # Î»1 (1.0, 50.0), # Î»2 (1.0, 200.0), # K (0.0, 50.0) # kd ], default_gains=[10.0, 8.0, 15.0, 12.0, 50.0, 5.0] ), SMCType.SUPER_TWISTING: SMCGainSpec( controller_type=SMCType.SUPER_TWISTING, n_gains=6, gain_names=[&#39;K1&#39;, &#39;K2&#39;, &#39;Î»1&#39;, &#39;Î»2&#39;, &#39;Î±1&#39;, &#39;Î±2&#39;], gain_descriptions=[ &#39;Primary twisting gain&#39;, &#39;Secondary twisting gain&#39;, &#39;Surface gain for pendulum 1&#39;, &#39;Surface gain for pendulum 2&#39;, &#39;Higher-order surface parameter 1&#39;, &#39;Higher-order surface parameter 2&#39; ], mathematical_constraints=[ &#39;K1 &gt; K2 (finite-time convergence)&#39;, &#39;K2 &gt; 0 (convergence requirement)&#39;, &#39;Î»1 &gt; 0 (stability)&#39;, &#39;Î»2 &gt; 0 (stability)&#39;, &#39;Î±1 &gt; 0 (higher-order stability)&#39;, &#39;Î±2 &gt; 0 (higher-order stability)&#39; ], pso_bounds=[ (2.0, 100.0), # K1 (must be &gt; K2) (1.0, 99.0), # K2 (must be &lt; K1) (1.0, 50.0), # Î»1 (1.0, 50.0), # Î»2 (1.0, 50.0), # Î±1 (1.0, 50.0) # Î±2 ], default_gains=[25.0, 10.0, 15.0, 12.0, 20.0, 15.0] ), SMCType.ADAPTIVE: SMCGainSpec( controller_type=SMCType.ADAPTIVE, n_gains=5, gain_names=[&#39;k1&#39;, &#39;k2&#39;, &#39;Î»1&#39;, &#39;Î»2&#39;, &#39;Î³&#39;], gain_descriptions=[ &#39;Position gain for pendulum 1&#39;, &#39;Position gain for pendulum 2&#39;, &#39;Surface gain for pendulum 1&#39;, &#39;Surface gain for pendulum 2&#39;, &#39;Adaptation rate&#39; ], mathematical_constraints=[ &#39;k1 &gt; 0 (controllability)&#39;, &#39;k2 &gt; 0 (controllability)&#39;, &#39;Î»1 &gt; 0 (stability)&#39;, &#39;Î»2 &gt; 0 (stability)&#39;, &#39;0.1 â‰¤ Î³ â‰¤ 20.0 (bounded adaptation)&#39; ], pso_bounds=[ (0.1, 50.0), # k1 (0.1, 50.0), # k2 (1.0, 50.0), # Î»1 (1.0, 50.0), # Î»2 (0.1, 20.0) # Î³ ], default_gains=[10.0, 8.0, 15.0, 12.0, 0.5] ), SMCType.HYBRID: SMCGainSpec( controller_type=SMCType.HYBRID, n_gains=4, gain_names=[&#39;k1&#39;, &#39;k2&#39;, &#39;Î»1&#39;, &#39;Î»2&#39;], gain_descriptions=[ &#39;Surface gain for pendulum 1&#39;, &#39;Surface gain for pendulum 2&#39;, &#39;Higher-order surface gain 1&#39;, &#39;Higher-order surface gain 2&#39; ], mathematical_constraints=[ &#39;k1 &gt; 0 (stability)&#39;, &#39;k2 &gt; 0 (stability)&#39;, &#39;Î»1 &gt; 0 (stability)&#39;, &#39;Î»2 &gt; 0 (stability)&#39; ], pso_bounds=[ (1.0, 50.0), # k1 (1.0, 50.0), # k2 (1.0, 50.0), # Î»1 (1.0, 50.0) # Î»2 ], default_gains=[15.0, 12.0, 18.0, 15.0] )
}
``` ### Constraint Validation Functions ```python
# example-metadata:
# runnable: false def validate_mathematical_constraints(smc_type: SMCType, gains: List[float], tolerance: float = 1e-8 ) -&gt; Tuple[bool, List[str]]: &quot;&quot;&quot; Validate mathematical constraints for SMC gains. Args: smc_type: Controller type gains: Gain values to validate tolerance: Numerical tolerance for constraint checking Returns: Tuple of (is_valid, list_of_constraint_violations) &quot;&quot;&quot; violations = [] if smc_type == SMCType.CLASSICAL: k1, k2, lam1, lam2, K, kd = gains if k1 &lt;= tolerance: violations.append(f&quot;k1 = {k1:.6f} must be &gt; {tolerance}&quot;) if k2 &lt;= tolerance: violations.append(f&quot;k2 = {k2:.6f} must be &gt; {tolerance}&quot;) if lam1 &lt;= tolerance: violations.append(f&quot;Î»1 = {lam1:.6f} must be &gt; {tolerance}&quot;) if lam2 &lt;= tolerance: violations.append(f&quot;Î»2 = {lam2:.6f} must be &gt; {tolerance}&quot;) if K &lt;= tolerance: violations.append(f&quot;K = {K:.6f} must be &gt; {tolerance}&quot;) if kd &lt; -tolerance: violations.append(f&quot;kd = {kd:.6f} must be â‰¥ 0&quot;) elif smc_type == SMCType.SUPER_TWISTING: K1, K2, lam1, lam2, alpha1, alpha2 = gains if K1 &lt;= K2 + tolerance: violations.append(f&quot;K1 = {K1:.6f} must be &gt; K2 = {K2:.6f}&quot;) if K2 &lt;= tolerance: violations.append(f&quot;K2 = {K2:.6f} must be &gt; {tolerance}&quot;) if any(g &lt;= tolerance for g in [lam1, lam2, alpha1, alpha2]): violations.append(&quot;All surface parameters must be positive&quot;) elif smc_type == SMCType.ADAPTIVE: k1, k2, lam1, lam2, gamma = gains if any(g &lt;= tolerance for g in [k1, k2, lam1, lam2]): violations.append(&quot;All surface gains must be positive&quot;) if not (0.1 &lt;= gamma &lt;= 20.0): violations.append(f&quot;Î³ = {gamma:.6f} must be in [0.1, 20.0]&quot;) elif smc_type == SMCType.HYBRID: if any(g &lt;= tolerance for g in gains): violations.append(&quot;All hybrid gains must be positive&quot;) return len(violations) == 0, violations def estimate_stability_properties(smc_type: SMCType, gains: List[float] ) -&gt; Dict[str, float]: &quot;&quot;&quot; Estimate stability properties from gains. Returns: Dictionary with estimated properties: - convergence_rate: Estimated convergence rate - stability_margin: Stability margin estimate - bandwidth: Estimated closed-loop bandwidth - settling_time: Estimated settling time &quot;&quot;&quot; if smc_type == SMCType.CLASSICAL: k1, k2, lam1, lam2, K, kd = gains min_surface_gain = min(lam1, lam2) convergence_rate = min_surface_gain bandwidth = min_surface_gain settling_time = 4.0 / min_surface_gain if min_surface_gain &gt; 0 else float(&#39;inf&#39;) stability_margin = K / (K + 10.0) # Rough estimate elif smc_type == SMCType.SUPER_TWISTING: K1, K2, lam1, lam2, alpha1, alpha2 = gains convergence_rate = min(K1, K2) bandwidth = min(lam1, lam2) settling_time = 2.0 / convergence_rate if convergence_rate &gt; 0 else float(&#39;inf&#39;) stability_margin = (K1 - K2) / K1 if K1 &gt; 0 else 0 elif smc_type == SMCType.ADAPTIVE: k1, k2, lam1, lam2, gamma = gains surface_bandwidth = min(lam1, lam2) adaptation_bandwidth = gamma convergence_rate = min(surface_bandwidth, adaptation_bandwidth) bandwidth = surface_bandwidth settling_time = 4.0 / convergence_rate if convergence_rate &gt; 0 else float(&#39;inf&#39;) stability_margin = min(1.0, (20.0 - gamma) / 20.0) elif smc_type == SMCType.HYBRID: k1, k2, lam1, lam2 = gains convergence_rate = min(gains) bandwidth = convergence_rate settling_time = 4.0 / convergence_rate if convergence_rate &gt; 0 else float(&#39;inf&#39;) stability_margin = min(gains) / max(gains) if max(gains) &gt; 0 else 0 return { &#39;convergence_rate&#39;: convergence_rate, &#39;stability_margin&#39;: stability_margin, &#39;bandwidth&#39;: bandwidth, &#39;settling_time&#39;: settling_time }
</pre></div>
</div>
<hr class="docutils" />
<section id="configuration-schema-api-factory-configuration-classes-python">
<h2>Configuration Schema API ### Factory Configuration Classes ```python<a class="headerlink" href="#configuration-schema-api-factory-configuration-classes-python" title="Link to this heading">Â¶</a></h2>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id3">
<h1>example-metadata:<a class="headerlink" href="#id3" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id4">
<h1>runnable: false &#64;dataclass(frozen=True)<a class="headerlink" href="#id4" title="Link to this heading">Â¶</a></h1>
<p>class PSOFactoryConfig: â€œâ€â€ Complete configuration for PSO-Factory integration. Provides type-safe configuration with automatic validation and mathematical constraint checking. â€œâ€â€ # Controller configuration controller_type: SMCType max_force: float = 100.0 dt: float = 0.01 # PSO algorithm parameters pso_params: Dict[str, Any] = field(default_factory=lambda: { â€˜n_particlesâ€™: 30, â€˜itersâ€™: 100, â€˜c1â€™: 2.0, â€˜c2â€™: 2.0, â€˜wâ€™: 0.9 }) # Performance monitoring enable_monitoring: bool = True enable_caching: bool = True cache_size: int = 1000 # Validation settings strict_validation: bool = True constraint_tolerance: float = 1e-8 # PSO bounds (auto-derived if None) custom_bounds: Optional[List[Tuple[float, float]]] = None def <strong>post_init</strong>(self): â€œâ€â€Validate configuration after initialization.â€â€â€ if self.max_force &lt;= 0: raise ValueError(â€œmax_force must be positiveâ€) if self.dt &lt;= 0: raise ValueError(â€œdt must be positiveâ€) if not isinstance(self.controller_type, SMCType): raise TypeError(â€œcontroller_type must be SMCTypeâ€) # Validate PSO parameters if self.pso_params[â€˜n_particlesâ€™] &lt; 10: raise ValueError(â€œn_particles should be â‰¥ 10â€) if self.pso_params[â€˜itersâ€™] &lt; 10: raise ValueError(â€œiters should be â‰¥ 10â€) &#64;property def gain_bounds(self) -&gt; List[Tuple[float, float]]: â€œâ€â€Get PSO bounds (custom or auto-derived).â€â€â€ if self.custom_bounds is not None: return self.custom_bounds return get_gain_bounds_for_pso(self.controller_type) &#64;property def n_gains(self) -&gt; int: â€œâ€â€Get number of gain parameters.â€â€â€ return self.controller_type.gain_count def load_factory_config(config_dict: Dict[str, Any]) -&gt; PSOFactoryConfig: â€œâ€â€ Load and validate factory configuration from dictionary. Args: config_dict: Configuration dictionary Returns: Validated PSOFactoryConfig object Raises: ConfigurationError: If validation fails â€œâ€â€ try: # Convert string controller type to enum if isinstance(config_dict.get(â€˜controller_typeâ€™), str): config_dict[â€˜controller_typeâ€™] = SMCType(config_dict[â€˜controller_typeâ€™]) return PSOFactoryConfig(**config_dict) except (ValueError, TypeError) as e: raise ConfigurationError(fâ€Invalid factory configuration: {e}â€)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
---

## Advanced PSO Workflows ### Multi-Objective PSO Integration ```python
# example-metadata:
# runnable: false def multi_objective_pso_optimization( controller_types: List[SMCType], simulation_config: Dict[str, Any], objectives: Dict[str, float], pso_config: Dict[str, Any]
) -&gt; Dict[str, Any]: &quot;&quot;&quot; Multi-objective PSO optimization across multiple controller types. Optimizes multiple SMC controllers simultaneously using weighted multi-objective fitness functions with Pareto front analysis. Args: controller_types: List of SMC types to optimize simulation_config: Simulation parameters objectives: Objective weights {&#39;ise&#39;: 0.4, &#39;overshoot&#39;: 0.3, &#39;energy&#39;: 0.3} pso_config: PSO algorithm configuration Returns: optimization results with Pareto analysis &quot;&quot;&quot; results = {} all_solutions = [] for smc_type in controller_types: print(f&quot;Optimizing {smc_type.value}...&quot;) # Get PSO bounds for this controller type bounds = get_gain_bounds_for_pso(smc_type) # Create multi-objective fitness function def multi_objective_fitness(particles: np.ndarray) -&gt; np.ndarray: fitness_scores = [] for gains in particles: try: # Create controller with validation controller = create_smc_for_pso(smc_type, gains.tolist()) # Run simulation sim_result = run_simulation(controller, simulation_config) # Compute individual objectives ise = compute_ise(sim_result) overshoot = compute_overshoot(sim_result) energy = compute_control_energy(sim_result) # Weighted combination fitness = (objectives.get(&#39;ise&#39;, 0.0) * ise + objectives.get(&#39;overshoot&#39;, 0.0) * overshoot + objectives.get(&#39;energy&#39;, 0.0) * energy) fitness_scores.append(fitness) # Store solution for Pareto analysis all_solutions.append({ &#39;controller_type&#39;: smc_type, &#39;gains&#39;: gains.tolist(), &#39;fitness&#39;: fitness, &#39;objectives&#39;: {&#39;ise&#39;: ise, &#39;overshoot&#39;: overshoot, &#39;energy&#39;: energy} }) except Exception: fitness_scores.append(1000.0) return np.array(fitness_scores) # Run PSO optimization from pyswarms.single import GlobalBestPSO bounds_array = np.array(bounds) optimizer = GlobalBestPSO( n_particles=pso_config.get(&#39;n_particles&#39;, 30), dimensions=len(bounds), options={ &#39;c1&#39;: pso_config.get(&#39;c1&#39;, 2.0), &#39;c2&#39;: pso_config.get(&#39;c2&#39;, 2.0), &#39;w&#39;: pso_config.get(&#39;w&#39;, 0.9) }, bounds=(bounds_array[:, 0], bounds_array[:, 1]) ) best_cost, best_gains = optimizer.optimize( multi_objective_fitness, iters=pso_config.get(&#39;iters&#39;, 100) ) results[smc_type.value] = { &#39;best_gains&#39;: best_gains.tolist(), &#39;best_fitness&#39;: float(best_cost), &#39;optimization_history&#39;: optimizer.cost_history } # Pareto front analysis pareto_front = compute_pareto_front(all_solutions, objectives) controller_ranking = rank_controllers_by_objectives(results, objectives) return { &#39;individual_results&#39;: results, &#39;pareto_front&#39;: pareto_front, &#39;controller_ranking&#39;: controller_ranking, &#39;best_overall&#39;: select_best_overall_solution(results, objectives) } def compute_pareto_front(solutions: List[Dict[str, Any]], objectives: Dict[str, float] ) -&gt; List[Dict[str, Any]]: &quot;&quot;&quot; Compute Pareto-optimal approaches from multi-objective optimization. Args: solutions: List of solution dictionaries objectives: Objective weights Returns: List of Pareto-optimal approaches &quot;&quot;&quot; pareto_solutions = [] for i, solution_i in enumerate(solutions): is_dominated = False for j, solution_j in enumerate(solutions): if i == j: continue # Check if solution_j dominates solution_i obj_i = solution_i[&#39;objectives&#39;] obj_j = solution_j[&#39;objectives&#39;] dominates = True for obj_name in objectives.keys(): if obj_j[obj_name] &gt;= obj_i[obj_name]: # j is not better in this objective dominates = False break if dominates: is_dominated = True break if not is_dominated: pareto_solutions.append(solution_i) return pareto_solutions
``` ### Adaptive PSO with Dynamic Bounds ```python

class AdaptivePSOFactory: &quot;&quot;&quot; Adaptive PSO optimization with dynamic parameter adjustment. Features: - Dynamic bounds tightening around promising regions - Adaptive PSO parameter tuning based on convergence - Early stopping with convergence detection - Multi-stage optimization with exploration-exploitation balance &quot;&quot;&quot; def __init__(self, smc_type: SMCType, config: Dict[str, Any]): self.smc_type = smc_type self.config = config self.optimization_history = [] self.bounds_history = [] # Initialize with full bounds self.current_bounds = get_gain_bounds_for_pso(smc_type) self.best_solution = None self.convergence_detector = PSOConvergenceDetector() def optimize_with_adaptation(self, simulation_config: Dict[str, Any], stages: List[Dict[str, Any]] ) -&gt; Dict[str, Any]: &quot;&quot;&quot; Run adaptive PSO optimization with multiple stages. Args: simulation_config: Simulation parameters stages: List of optimization stages with different parameters Returns: Complete optimization results with adaptation history &quot;&quot;&quot; all_results = [] for stage_idx, stage_config in enumerate(stages): print(f&quot;PSO Stage {stage_idx + 1}: {stage_config}&quot;) # Adapt PSO parameters for this stage pso_params = self._adapt_pso_parameters(stage_config, stage_idx) # Adapt bounds based on previous results if stage_idx &gt; 0 and self.best_solution is not None: self.current_bounds = self._adapt_bounds( self.best_solution[&#39;gains&#39;], stage_config.get(&#39;bound_tightening&#39;, 0.5) ) # Create fitness function fitness_function = self._create_adaptive_fitness_function( simulation_config, stage_config ) # Run PSO optimization stage stage_result = self._run_pso_stage( fitness_function, pso_params, stage_config[&#39;iterations&#39;] ) all_results.append(stage_result) # Update best solution if (self.best_solution is None or stage_result[&#39;best_fitness&#39;] &lt; self.best_solution[&#39;fitness&#39;]): self.best_solution = { &#39;gains&#39;: stage_result[&#39;best_gains&#39;], &#39;fitness&#39;: stage_result[&#39;best_fitness&#39;], &#39;stage&#39;: stage_idx } # Check for early convergence if self.convergence_detector.check_convergence(stage_result): print(f&quot;Early convergence detected at stage {stage_idx + 1}&quot;) break # Combine results final_result = self._combine_stage_results(all_results) final_result[&#39;adaptation_history&#39;] = { &#39;bounds_history&#39;: self.bounds_history, &#39;best_solution_history&#39;: self.optimization_history } return final_result def _adapt_pso_parameters(self, stage_config: Dict[str, Any], stage_idx: int ) -&gt; Dict[str, Any]: &quot;&quot;&quot;Adapt PSO parameters based on stage and convergence history.&quot;&quot;&quot; base_params = self.config.get(&#39;pso_params&#39;, {}) # Exploration vs exploitation balance exploration_weight = stage_config.get(&#39;exploration_weight&#39;, 0.5) # Adaptive inertia weight w_max = 0.9 w_min = 0.4 w = w_max - (w_max - w_min) * exploration_weight # Adaptive cognitive/social parameters c1 = 2.5 - exploration_weight # High cognitive for exploration c2 = 0.5 + exploration_weight # High social for exploitation return { &#39;n_particles&#39;: base_params.get(&#39;n_particles&#39;, 30), &#39;c1&#39;: c1, &#39;c2&#39;: c2, &#39;w&#39;: w } def _adapt_bounds(self, best_gains: List[float], tightening_factor: float ) -&gt; List[Tuple[float, float]]: &quot;&quot;&quot;Adapt optimization bounds around best solution.&quot;&quot;&quot; adapted_bounds = [] original_bounds = get_gain_bounds_for_pso(self.smc_type) for i, (gain, (orig_lower, orig_upper)) in enumerate(zip(best_gains, original_bounds)): # Calculate range around best gain range_width = (orig_upper - orig_lower) * tightening_factor # New bounds centered around best gain new_lower = max(orig_lower, gain - range_width / 2) new_upper = min(orig_upper, gain + range_width / 2) adapted_bounds.append((new_lower, new_upper)) self.bounds_history.append(adapted_bounds) return adapted_bounds def _create_adaptive_fitness_function(self, simulation_config: Dict[str, Any], stage_config: Dict[str, Any] ) -&gt; Callable: &quot;&quot;&quot;Create fitness function with adaptive features.&quot;&quot;&quot; def adaptive_fitness(particles: np.ndarray) -&gt; np.ndarray: fitness_scores = [] for gains in particles: try: # Create controller with validation controller = create_smc_for_pso(self.smc_type, gains.tolist()) # Run simulation result = run_simulation(controller, simulation_config) # Compute base fitness base_fitness = compute_control_performance_metrics( result, stage_config.get(&#39;objectives&#39;, [&#39;ise&#39;]) ) # Add adaptive penalties/bonuses adapted_fitness = self._apply_adaptive_adjustments( base_fitness, gains.tolist(), stage_config ) fitness_scores.append(adapted_fitness) except Exception: fitness_scores.append(1000.0) return np.array(fitness_scores) return adaptive_fitness def _apply_adaptive_adjustments(self, base_fitness: float, gains: List[float], stage_config: Dict[str, Any] ) -&gt; float: &quot;&quot;&quot;Apply adaptive adjustments to fitness based on stage configuration.&quot;&quot;&quot; adjusted_fitness = base_fitness # Diversity bonus (encourage exploration in early stages) if stage_config.get(&#39;diversity_bonus&#39;, False) and self.best_solution: distance = np.linalg.norm( np.array(gains) - np.array(self.best_solution[&#39;gains&#39;]) ) diversity_bonus = stage_config.get(&#39;diversity_weight&#39;, 0.1) * distance adjusted_fitness -= diversity_bonus # Stability margin bonus if stage_config.get(&#39;stability_bonus&#39;, True): stability_properties = estimate_stability_properties(self.smc_type, gains) stability_bonus = stability_properties[&#39;stability_margin&#39;] * 0.1 adjusted_fitness -= stability_bonus return adjusted_fitness class PSOConvergenceDetector: &quot;&quot;&quot;Advanced convergence detection for PSO optimization.&quot;&quot;&quot; def __init__(self, patience: int = 20, tolerance: float = 1e-6): self.patience = patience self.tolerance = tolerance self.fitness_history = [] self.best_fitness = float(&#39;inf&#39;) self.stagnation_count = 0 def check_convergence(self, stage_result: Dict[str, Any]) -&gt; bool: &quot;&quot;&quot; Check if PSO has converged based on multiple criteria. Args: stage_result: Results from PSO optimization stage Returns: True if convergence detected, False otherwise &quot;&quot;&quot; current_fitness = stage_result[&#39;best_fitness&#39;] self.fitness_history.append(current_fitness) # Check for improvement if current_fitness &lt; self.best_fitness - self.tolerance: self.best_fitness = current_fitness self.stagnation_count = 0 else: self.stagnation_count += 1 # Multiple convergence criteria return ( self._check_fitness_plateau() or self._check_statistical_convergence() ) def _check_fitness_plateau(self) -&gt; bool: &quot;&quot;&quot;Check if fitness has plateaued.&quot;&quot;&quot; return self.stagnation_count &gt;= self.patience def _check_statistical_convergence(self) -&gt; bool: &quot;&quot;&quot;Check statistical significance of convergence.&quot;&quot;&quot; if len(self.fitness_history) &lt; 30: return False # Test if recent improvements are statistically significant recent_fitness = self.fitness_history[-15:] older_fitness = self.fitness_history[-30:-15] from scipy.stats import ttest_ind try: statistic, p_value = ttest_ind(recent_fitness, older_fitness) return p_value &gt; 0.05 # No significant difference except: return False
</pre></div>
</div>
<hr class="docutils" />
<section id="performance-monitoring-api-real-time-performance-monitoring-python">
<h2>Performance Monitoring API ### Real-Time Performance Monitoring ```python<a class="headerlink" href="#performance-monitoring-api-real-time-performance-monitoring-python" title="Link to this heading">Â¶</a></h2>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id5">
<h1>example-metadata:<a class="headerlink" href="#id5" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-class-psoperformancemonitor-real-time-performance-monitoring-for-pso-factory-integration-provides-monitoring-of-pso-convergence-metrics-controller-creation-performance-simulation-execution-times-memory-usage-tracking-error-rate-monitoring-def-init-self-monitoring-config-dict-str-any-self-config-monitoring-config-self-metrics-pso-metrics-total-evaluations-0-successful-evaluations-0-failed-evaluations-0-average-fitness-0-0-best-fitness-float-inf-convergence-rate-0-0-performance-metrics-controller-creation-time-simulation-execution-time-fitness-computation-time-total-optimization-time-0-0-resource-metrics-peak-memory-usage-0-0-average-memory-usage-0-0-cpu-utilization-memory-samples-error-metrics-creation-failures-0-simulation-failures-0-validation-failures-0-total-errors-0-self-start-time-none-self-monitoring-active-false-def-start-monitoring-self-start-performance-monitoring-session-import-time-self-start-time-time-time-self-monitoring-active-true-self-reset-metrics-def-stop-monitoring-self-dict-str-any-stop-monitoring-and-return-complete-performance-report-import-time-if-self-start-time-self-metrics-performance-metrics-total-optimization-time-time-time-self-start-time-self-monitoring-active-false-return-self-generate-performance-report-def-log-controller-creation-self-success-bool-creation-time-float-log-controller-creation-event-if-not-self-monitoring-active-return-self-metrics-performance-metrics-controller-creation-time-append-creation-time-if-success-self-metrics-pso-metrics-successful-evaluations-1-else-self-metrics-error-metrics-creation-failures-1-self-metrics-pso-metrics-failed-evaluations-1-def-log-simulation-execution-self-success-bool-execution-time-float-log-simulation-execution-event-if-not-self-monitoring-active-return-if-success-self-metrics-performance-metrics-simulation-execution-time-append-execution-time-else-self-metrics-error-metrics-simulation-failures-1-def-log-fitness-evaluation-self-fitness-value-float-computation-time-float-log-fitness-evaluation-result-if-not-self-monitoring-active-return-self-metrics-performance-metrics-fitness-computation-time-append-computation-time-self-metrics-pso-metrics-total-evaluations-1-update-best-fitness-if-fitness-value-self-metrics-pso-metrics-best-fitness-self-metrics-pso-metrics-best-fitness-fitness-value-update-average-fitness-running-average-total-evals-self-metrics-pso-metrics-total-evaluations-current-avg-self-metrics-pso-metrics-average-fitness-self-metrics-pso-metrics-average-fitness-current-avg-total-evals-1-fitness-value-total-evals-def-log-resource-usage-self-log-current-resource-usage-if-not-self-monitoring-active-return-try-import-psutil-memory-usage-memory-info-psutil-virtual-memory-current-memory-memory-info-percent-self-metrics-resource-metrics-memory-samples-append-current-memory-update-peak-memory-if-current-memory-self-metrics-resource-metrics-peak-memory-usage-self-metrics-resource-metrics-peak-memory-usage-current-memory-cpu-utilization-cpu-percent-psutil-cpu-percent-interval-none-self-metrics-resource-metrics-cpu-utilization-append-cpu-percent-except-importerror-pass-psutil-not-available-def-check-performance-alerts-self-list-str-check-for-performance-issues-and-return-alerts-alerts-memory-usage-alerts-if-self-metrics-resource-metrics-peak-memory-usage-90-alerts-append-f-high-memory-usage-self-metrics-resource-metrics-peak-memory-usage-1f-error-rate-alerts-total-evals-self-metrics-pso-metrics-total-evaluations-if-total-evals-0-error-rate-self-metrics-error-metrics-total-errors-total-evals-if-error-rate-0-1-alerts-append-f-high-error-rate-error-rate-1-performance-alerts-creation-times-self-metrics-performance-metrics-controller-creation-time-if-creation-times-and-np-mean-creation-times-0-002-2ms-threshold-alerts-append-f-slow-controller-creation-np-mean-creation-times-1000-2f-ms-average-return-alerts-def-generate-performance-report-self-dict-str-any-generate-performance-report-calculate-derived-metrics-total-evals-self-metrics-pso-metrics-total-evaluations-success-rate-self-metrics-pso-metrics-successful-evaluations-total-evals-100-if-total-evals-0-else-0-creation-times-self-metrics-performance-metrics-controller-creation-time-avg-creation-time-np-mean-creation-times-if-creation-times-else-0-simulation-times-self-metrics-performance-metrics-simulation-execution-time-avg-simulation-time-np-mean-simulation-times-if-simulation-times-else-0-fitness-times-self-metrics-performance-metrics-fitness-computation-time-avg-fitness-time-np-mean-fitness-times-if-fitness-times-else-0-memory-samples-self-metrics-resource-metrics-memory-samples-avg-memory-np-mean-memory-samples-if-memory-samples-else-0-cpu-samples-self-metrics-resource-metrics-cpu-utilization-avg-cpu-np-mean-cpu-samples-if-cpu-samples-else-0-total-time-self-metrics-performance-metrics-total-optimization-time-evaluations-per-second-total-evals-total-time-if-total-time-0-else-0-generate-report-report-summary-total-evaluations-total-evals-success-rate-success-rate-best-fitness-achieved-self-metrics-pso-metrics-best-fitness-total-optimization-time-total-time-evaluations-per-second-evaluations-per-second-performance-average-controller-creation-time-ms-avg-creation-time-1000-average-simulation-time-ms-avg-simulation-time-1000-average-fitness-computation-time-ms-avg-fitness-time-1000-resources-peak-memory-usage-percent-self-metrics-resource-metrics-peak-memory-usage-average-memory-usage-percent-avg-memory-average-cpu-utilization-percent-avg-cpu-errors-controller-creation-failures-self-metrics-error-metrics-creation-failures-simulation-failures-self-metrics-error-metrics-simulation-failures-validation-failures-self-metrics-error-metrics-validation-failures-total-error-count-self-metrics-error-metrics-total-errors-alerts-self-check-performance-alerts-raw-metrics-self-metrics-return-report-def-reset-metrics-self-reset-all-metrics-for-new-monitoring-session-for-category-in-self-metrics-values-if-isinstance-category-dict-for-key-value-in-category-items-if-isinstance-value-list-category-key-elif-isinstance-value-int-float-if-best-fitness-in-key-category-key-float-inf-else-category-key-0-context-manager-for-automatic-monitoring">
<h1>runnable: false class PSOPerformanceMonitor: â€œâ€â€ Real-time performance monitoring for PSO-Factory integration. Provides monitoring of: - PSO convergence metrics - Controller creation performance - Simulation execution times - Memory usage tracking - Error rate monitoring â€œâ€â€ def <strong>init</strong>(self, monitoring_config: Dict[str, Any]): self.config = monitoring_config self.metrics = { â€˜pso_metricsâ€™: { â€˜total_evaluationsâ€™: 0, â€˜successful_evaluationsâ€™: 0, â€˜failed_evaluationsâ€™: 0, â€˜average_fitnessâ€™: 0.0, â€˜best_fitnessâ€™: float(â€˜infâ€™), â€˜convergence_rateâ€™: 0.0 }, â€˜performance_metricsâ€™: { â€˜controller_creation_timeâ€™: [], â€˜simulation_execution_timeâ€™: [], â€˜fitness_computation_timeâ€™: [], â€˜total_optimization_timeâ€™: 0.0 }, â€˜resource_metricsâ€™: { â€˜peak_memory_usageâ€™: 0.0, â€˜average_memory_usageâ€™: 0.0, â€˜cpu_utilizationâ€™: [], â€˜memory_samplesâ€™: [] }, â€˜error_metricsâ€™: { â€˜creation_failuresâ€™: 0, â€˜simulation_failuresâ€™: 0, â€˜validation_failuresâ€™: 0, â€˜total_errorsâ€™: 0 } } self.start_time = None self.monitoring_active = False def start_monitoring(self): â€œâ€â€Start performance monitoring session.â€â€â€ import time self.start_time = time.time() self.monitoring_active = True self._reset_metrics() def stop_monitoring(self) -&gt; Dict[str, Any]: â€œâ€â€Stop monitoring and return complete performance report.â€â€â€ import time if self.start_time: self.metrics[â€˜performance_metricsâ€™][â€˜total_optimization_timeâ€™] = ( time.time() - self.start_time ) self.monitoring_active = False return self.generate_performance_report() def log_controller_creation(self, success: bool, creation_time: float): â€œâ€â€Log controller creation event.â€â€â€ if not self.monitoring_active: return self.metrics[â€˜performance_metricsâ€™][â€˜controller_creation_timeâ€™].append(creation_time) if success: self.metrics[â€˜pso_metricsâ€™][â€˜successful_evaluationsâ€™] += 1 else: self.metrics[â€˜error_metricsâ€™][â€˜creation_failuresâ€™] += 1 self.metrics[â€˜pso_metricsâ€™][â€˜failed_evaluationsâ€™] += 1 def log_simulation_execution(self, success: bool, execution_time: float): â€œâ€â€Log simulation execution event.â€â€â€ if not self.monitoring_active: return if success: self.metrics[â€˜performance_metricsâ€™][â€˜simulation_execution_timeâ€™].append(execution_time) else: self.metrics[â€˜error_metricsâ€™][â€˜simulation_failuresâ€™] += 1 def log_fitness_evaluation(self, fitness_value: float, computation_time: float): â€œâ€â€Log fitness evaluation result.â€â€â€ if not self.monitoring_active: return self.metrics[â€˜performance_metricsâ€™][â€˜fitness_computation_timeâ€™].append(computation_time) self.metrics[â€˜pso_metricsâ€™][â€˜total_evaluationsâ€™] += 1 # Update best fitness if fitness_value &lt; self.metrics[â€˜pso_metricsâ€™][â€˜best_fitnessâ€™]: self.metrics[â€˜pso_metricsâ€™][â€˜best_fitnessâ€™] = fitness_value # Update average fitness (running average) total_evals = self.metrics[â€˜pso_metricsâ€™][â€˜total_evaluationsâ€™] current_avg = self.metrics[â€˜pso_metricsâ€™][â€˜average_fitnessâ€™] self.metrics[â€˜pso_metricsâ€™][â€˜average_fitnessâ€™] = ( (current_avg * (total_evals - 1) + fitness_value) / total_evals ) def log_resource_usage(self): â€œâ€â€Log current resource usage.â€â€â€ if not self.monitoring_active: return try: import psutil # Memory usage memory_info = psutil.virtual_memory() current_memory = memory_info.percent self.metrics[â€˜resource_metricsâ€™][â€˜memory_samplesâ€™].append(current_memory) # Update peak memory if current_memory &gt; self.metrics[â€˜resource_metricsâ€™][â€˜peak_memory_usageâ€™]: self.metrics[â€˜resource_metricsâ€™][â€˜peak_memory_usageâ€™] = current_memory # CPU utilization cpu_percent = psutil.cpu_percent(interval=None) self.metrics[â€˜resource_metricsâ€™][â€˜cpu_utilizationâ€™].append(cpu_percent) except ImportError: pass # psutil not available def check_performance_alerts(self) -&gt; List[str]: â€œâ€â€Check for performance issues and return alerts.â€â€â€ alerts = [] # Memory usage alerts if self.metrics[â€˜resource_metricsâ€™][â€˜peak_memory_usageâ€™] &gt; 90: alerts.append(fâ€High memory usage: {self.metrics[â€˜resource_metricsâ€™][â€˜peak_memory_usageâ€™]:.1f}%â€) # Error rate alerts total_evals = self.metrics[â€˜pso_metricsâ€™][â€˜total_evaluationsâ€™] if total_evals &gt; 0: error_rate = self.metrics[â€˜error_metricsâ€™][â€˜total_errorsâ€™] / total_evals if error_rate &gt; 0.1: alerts.append(fâ€High error rate: {error_rate:.1%}â€) # Performance alerts creation_times = self.metrics[â€˜performance_metricsâ€™][â€˜controller_creation_timeâ€™] if creation_times and np.mean(creation_times) &gt; 0.002: # 2ms threshold alerts.append(fâ€Slow controller creation: {np.mean(creation_times)*1000:.2f}ms averageâ€) return alerts def generate_performance_report(self) -&gt; Dict[str, Any]: â€œâ€â€Generate performance report.â€â€â€ # Calculate derived metrics total_evals = self.metrics[â€˜pso_metricsâ€™][â€˜total_evaluationsâ€™] success_rate = (self.metrics[â€˜pso_metricsâ€™][â€˜successful_evaluationsâ€™] / total_evals * 100 if total_evals &gt; 0 else 0) creation_times = self.metrics[â€˜performance_metricsâ€™][â€˜controller_creation_timeâ€™] avg_creation_time = np.mean(creation_times) if creation_times else 0 simulation_times = self.metrics[â€˜performance_metricsâ€™][â€˜simulation_execution_timeâ€™] avg_simulation_time = np.mean(simulation_times) if simulation_times else 0 fitness_times = self.metrics[â€˜performance_metricsâ€™][â€˜fitness_computation_timeâ€™] avg_fitness_time = np.mean(fitness_times) if fitness_times else 0 memory_samples = self.metrics[â€˜resource_metricsâ€™][â€˜memory_samplesâ€™] avg_memory = np.mean(memory_samples) if memory_samples else 0 cpu_samples = self.metrics[â€˜resource_metricsâ€™][â€˜cpu_utilizationâ€™] avg_cpu = np.mean(cpu_samples) if cpu_samples else 0 total_time = self.metrics[â€˜performance_metricsâ€™][â€˜total_optimization_timeâ€™] evaluations_per_second = total_evals / total_time if total_time &gt; 0 else 0 # Generate report report = { â€˜summaryâ€™: { â€˜total_evaluationsâ€™: total_evals, â€˜success_rateâ€™: success_rate, â€˜best_fitness_achievedâ€™: self.metrics[â€˜pso_metricsâ€™][â€˜best_fitnessâ€™], â€˜total_optimization_timeâ€™: total_time, â€˜evaluations_per_secondâ€™: evaluations_per_second }, â€˜performanceâ€™: { â€˜average_controller_creation_time_msâ€™: avg_creation_time * 1000, â€˜average_simulation_time_msâ€™: avg_simulation_time * 1000, â€˜average_fitness_computation_time_msâ€™: avg_fitness_time * 1000 }, â€˜resourcesâ€™: { â€˜peak_memory_usage_percentâ€™: self.metrics[â€˜resource_metricsâ€™][â€˜peak_memory_usageâ€™], â€˜average_memory_usage_percentâ€™: avg_memory, â€˜average_cpu_utilization_percentâ€™: avg_cpu }, â€˜errorsâ€™: { â€˜controller_creation_failuresâ€™: self.metrics[â€˜error_metricsâ€™][â€˜creation_failuresâ€™], â€˜simulation_failuresâ€™: self.metrics[â€˜error_metricsâ€™][â€˜simulation_failuresâ€™], â€˜validation_failuresâ€™: self.metrics[â€˜error_metricsâ€™][â€˜validation_failuresâ€™], â€˜total_error_countâ€™: self.metrics[â€˜error_metricsâ€™][â€˜total_errorsâ€™] }, â€˜alertsâ€™: self.check_performance_alerts(), â€˜raw_metricsâ€™: self.metrics } return report def _reset_metrics(self): â€œâ€â€Reset all metrics for new monitoring session.â€â€â€ for category in self.metrics.values(): if isinstance(category, dict): for key, value in category.items(): if isinstance(value, list): category[key] = [] elif isinstance(value, (int, float)): if â€˜best_fitnessâ€™ in key: category[key] = float(â€˜infâ€™) else: category[key] = 0 # Context manager for automatic monitoring<a class="headerlink" href="#runnable-false-class-psoperformancemonitor-real-time-performance-monitoring-for-pso-factory-integration-provides-monitoring-of-pso-convergence-metrics-controller-creation-performance-simulation-execution-times-memory-usage-tracking-error-rate-monitoring-def-init-self-monitoring-config-dict-str-any-self-config-monitoring-config-self-metrics-pso-metrics-total-evaluations-0-successful-evaluations-0-failed-evaluations-0-average-fitness-0-0-best-fitness-float-inf-convergence-rate-0-0-performance-metrics-controller-creation-time-simulation-execution-time-fitness-computation-time-total-optimization-time-0-0-resource-metrics-peak-memory-usage-0-0-average-memory-usage-0-0-cpu-utilization-memory-samples-error-metrics-creation-failures-0-simulation-failures-0-validation-failures-0-total-errors-0-self-start-time-none-self-monitoring-active-false-def-start-monitoring-self-start-performance-monitoring-session-import-time-self-start-time-time-time-self-monitoring-active-true-self-reset-metrics-def-stop-monitoring-self-dict-str-any-stop-monitoring-and-return-complete-performance-report-import-time-if-self-start-time-self-metrics-performance-metrics-total-optimization-time-time-time-self-start-time-self-monitoring-active-false-return-self-generate-performance-report-def-log-controller-creation-self-success-bool-creation-time-float-log-controller-creation-event-if-not-self-monitoring-active-return-self-metrics-performance-metrics-controller-creation-time-append-creation-time-if-success-self-metrics-pso-metrics-successful-evaluations-1-else-self-metrics-error-metrics-creation-failures-1-self-metrics-pso-metrics-failed-evaluations-1-def-log-simulation-execution-self-success-bool-execution-time-float-log-simulation-execution-event-if-not-self-monitoring-active-return-if-success-self-metrics-performance-metrics-simulation-execution-time-append-execution-time-else-self-metrics-error-metrics-simulation-failures-1-def-log-fitness-evaluation-self-fitness-value-float-computation-time-float-log-fitness-evaluation-result-if-not-self-monitoring-active-return-self-metrics-performance-metrics-fitness-computation-time-append-computation-time-self-metrics-pso-metrics-total-evaluations-1-update-best-fitness-if-fitness-value-self-metrics-pso-metrics-best-fitness-self-metrics-pso-metrics-best-fitness-fitness-value-update-average-fitness-running-average-total-evals-self-metrics-pso-metrics-total-evaluations-current-avg-self-metrics-pso-metrics-average-fitness-self-metrics-pso-metrics-average-fitness-current-avg-total-evals-1-fitness-value-total-evals-def-log-resource-usage-self-log-current-resource-usage-if-not-self-monitoring-active-return-try-import-psutil-memory-usage-memory-info-psutil-virtual-memory-current-memory-memory-info-percent-self-metrics-resource-metrics-memory-samples-append-current-memory-update-peak-memory-if-current-memory-self-metrics-resource-metrics-peak-memory-usage-self-metrics-resource-metrics-peak-memory-usage-current-memory-cpu-utilization-cpu-percent-psutil-cpu-percent-interval-none-self-metrics-resource-metrics-cpu-utilization-append-cpu-percent-except-importerror-pass-psutil-not-available-def-check-performance-alerts-self-list-str-check-for-performance-issues-and-return-alerts-alerts-memory-usage-alerts-if-self-metrics-resource-metrics-peak-memory-usage-90-alerts-append-f-high-memory-usage-self-metrics-resource-metrics-peak-memory-usage-1f-error-rate-alerts-total-evals-self-metrics-pso-metrics-total-evaluations-if-total-evals-0-error-rate-self-metrics-error-metrics-total-errors-total-evals-if-error-rate-0-1-alerts-append-f-high-error-rate-error-rate-1-performance-alerts-creation-times-self-metrics-performance-metrics-controller-creation-time-if-creation-times-and-np-mean-creation-times-0-002-2ms-threshold-alerts-append-f-slow-controller-creation-np-mean-creation-times-1000-2f-ms-average-return-alerts-def-generate-performance-report-self-dict-str-any-generate-performance-report-calculate-derived-metrics-total-evals-self-metrics-pso-metrics-total-evaluations-success-rate-self-metrics-pso-metrics-successful-evaluations-total-evals-100-if-total-evals-0-else-0-creation-times-self-metrics-performance-metrics-controller-creation-time-avg-creation-time-np-mean-creation-times-if-creation-times-else-0-simulation-times-self-metrics-performance-metrics-simulation-execution-time-avg-simulation-time-np-mean-simulation-times-if-simulation-times-else-0-fitness-times-self-metrics-performance-metrics-fitness-computation-time-avg-fitness-time-np-mean-fitness-times-if-fitness-times-else-0-memory-samples-self-metrics-resource-metrics-memory-samples-avg-memory-np-mean-memory-samples-if-memory-samples-else-0-cpu-samples-self-metrics-resource-metrics-cpu-utilization-avg-cpu-np-mean-cpu-samples-if-cpu-samples-else-0-total-time-self-metrics-performance-metrics-total-optimization-time-evaluations-per-second-total-evals-total-time-if-total-time-0-else-0-generate-report-report-summary-total-evaluations-total-evals-success-rate-success-rate-best-fitness-achieved-self-metrics-pso-metrics-best-fitness-total-optimization-time-total-time-evaluations-per-second-evaluations-per-second-performance-average-controller-creation-time-ms-avg-creation-time-1000-average-simulation-time-ms-avg-simulation-time-1000-average-fitness-computation-time-ms-avg-fitness-time-1000-resources-peak-memory-usage-percent-self-metrics-resource-metrics-peak-memory-usage-average-memory-usage-percent-avg-memory-average-cpu-utilization-percent-avg-cpu-errors-controller-creation-failures-self-metrics-error-metrics-creation-failures-simulation-failures-self-metrics-error-metrics-simulation-failures-validation-failures-self-metrics-error-metrics-validation-failures-total-error-count-self-metrics-error-metrics-total-errors-alerts-self-check-performance-alerts-raw-metrics-self-metrics-return-report-def-reset-metrics-self-reset-all-metrics-for-new-monitoring-session-for-category-in-self-metrics-values-if-isinstance-category-dict-for-key-value-in-category-items-if-isinstance-value-list-category-key-elif-isinstance-value-int-float-if-best-fitness-in-key-category-key-float-inf-else-category-key-0-context-manager-for-automatic-monitoring" title="Link to this heading">Â¶</a></h1>
<p>&#64;contextmanager
def monitor_pso_performance(config: Dict[str, Any] = None): â€œâ€â€ Context manager for automatic PSO performance monitoring. Usage: with monitor_pso_performance() as monitor: # Run PSO optimization result = optimize_controller_with_pso(â€¦) # Get performance report report = monitor.generate_performance_report() â€œâ€â€ monitor = PSOPerformanceMonitor(config or {}) monitor.start_monitoring() try: yield monitor finally: monitor.stop_monitoring()</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="o">---</span>

<span class="c1">## Error Handling Reference ### Exception Hierarchy ```python</span>

<span class="k">class</span><span class="w"> </span><span class="nc">PSOFactoryError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot;Base exception for PSO factory integration errors.&quot;&quot;&quot;</span> <span class="k">pass</span> <span class="k">class</span><span class="w"> </span><span class="nc">ControllerCreationError</span><span class="p">(</span><span class="n">PSOFactoryError</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot;Raised when controller creation fails.&quot;&quot;&quot;</span> <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smc_type</span><span class="p">:</span> <span class="n">SMCType</span><span class="p">,</span> <span class="n">gains</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">smc_type</span> <span class="o">=</span> <span class="n">smc_type</span> <span class="bp">self</span><span class="o">.</span><span class="n">gains</span> <span class="o">=</span> <span class="n">gains</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to create </span><span class="si">{</span><span class="n">smc_type</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2"> controller: </span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">class</span><span class="w"> </span><span class="nc">GainValidationError</span><span class="p">(</span><span class="n">PSOFactoryError</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot;Raised when gain validation fails.&quot;&quot;&quot;</span> <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smc_type</span><span class="p">:</span> <span class="n">SMCType</span><span class="p">,</span> <span class="n">gains</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">violations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span> <span class="bp">self</span><span class="o">.</span><span class="n">smc_type</span> <span class="o">=</span> <span class="n">smc_type</span> <span class="bp">self</span><span class="o">.</span><span class="n">gains</span> <span class="o">=</span> <span class="n">gains</span> <span class="bp">self</span><span class="o">.</span><span class="n">violations</span> <span class="o">=</span> <span class="n">violations</span> <span class="n">violation_text</span> <span class="o">=</span> <span class="s2">&quot;; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">violations</span><span class="p">)</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Gain validation failed for </span><span class="si">{</span><span class="n">smc_type</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">violation_text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">class</span><span class="w"> </span><span class="nc">ConfigurationError</span><span class="p">(</span><span class="n">PSOFactoryError</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot;Raised when configuration is invalid.&quot;&quot;&quot;</span> <span class="k">pass</span> <span class="k">class</span><span class="w"> </span><span class="nc">SimulationError</span><span class="p">(</span><span class="n">PSOFactoryError</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot;Raised when simulation execution fails.&quot;&quot;&quot;</span> <span class="k">pass</span> <span class="c1"># Error handling decorators</span>
<span class="k">def</span><span class="w"> </span><span class="nf">handle_pso_errors</span><span class="p">(</span><span class="n">func</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot;Decorator for robust PSO error handling.&quot;&quot;&quot;</span> <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="k">try</span><span class="p">:</span> <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">except</span> <span class="n">GainValidationError</span><span class="p">:</span> <span class="c1"># For PSO fitness functions, return penalty value return 1000.0 except (ControllerCreationError, SimulationError) as e: # Log error and return penalty print(f&quot;PSO evaluation error: {e}&quot;) return 1000.0 except Exception as e: # Unexpected errors - log and return penalty print(f&quot;Unexpected PSO error: {e}&quot;) return 1000.0 return wrapper # Robust PSO fitness function template</span>
<span class="nd">@handle_pso_errors</span>
<span class="k">def</span><span class="w"> </span><span class="nf">robust_pso_fitness_function</span><span class="p">(</span><span class="n">gains</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">smc_type</span><span class="p">:</span> <span class="n">SMCType</span><span class="p">,</span> <span class="n">simulation_config</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot; Template for robust PSO fitness functions with error handling. Args: gains: Gain array from PSO smc_type: Controller type simulation_config: Simulation parameters Returns: Fitness value (lower is better) &quot;&quot;&quot;</span> <span class="c1"># Create controller with automatic validation controller = create_smc_for_pso(smc_type, gains.tolist()) # Run simulation with error handling result = run_simulation_with_error_handling(controller, simulation_config) # Compute fitness with validation fitness = compute_validated_fitness(result) return fitness def run_simulation_with_error_handling(controller, config: Dict[str, Any]) -&gt; Dict[str, Any]: &quot;&quot;&quot;Run simulation with error handling.&quot;&quot;&quot; try: # Pre-validate simulation configuration validate_simulation_config(config) # Run simulation with timeout with timeout_context(config.get(&#39;timeout&#39;, 30.0)): result = run_simulation(controller, config) # Post-validate simulation results validate_simulation_results(result) return result except TimeoutError: raise SimulationError(&quot;Simulation timeout exceeded&quot;) except ValueError as e: raise SimulationError(f&quot;Simulation parameter error: {e}&quot;) except Exception as e: raise SimulationError(f&quot;Simulation execution failed: {e}&quot;) @contextmanager</span>
<span class="k">def</span><span class="w"> </span><span class="nf">timeout_context</span><span class="p">(</span><span class="n">seconds</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot;Context manager for simulation timeout.&quot;&quot;&quot;</span> <span class="kn">import</span><span class="w"> </span><span class="nn">signal</span> <span class="k">def</span><span class="w"> </span><span class="nf">timeout_handler</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">TimeoutError</span><span class="p">(</span><span class="s2">&quot;Operation timed out&quot;</span><span class="p">)</span> <span class="c1"># Set timeout handler old_handler = signal.signal(signal.SIGALRM, timeout_handler) signal.alarm(int(seconds)) try: yield finally: signal.alarm(0) signal.signal(signal.SIGALRM, old_handler)</span>
</pre></div>
</div>
<hr class="docutils" />
<section id="usage-examples-complete-pso-optimization-workflow-python">
<h2>Usage Examples ### Complete PSO Optimization Workflow ```python<a class="headerlink" href="#usage-examples-complete-pso-optimization-workflow-python" title="Link to this heading">Â¶</a></h2>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id6">
<h1>example-metadata:<a class="headerlink" href="#id6" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-def-complete-pso-optimization-example-complete-example-demonstrating-pso-factory-integration-this-example-shows-1-configuration-setup-2-controller-creation-and-validation-3-pso-optimization-execution-4-performance-monitoring-5-results-analysis-and-validation-step-1-configuration-setup-pso-config-psofactoryconfig-controller-type-smctype-classical-max-force-100-0-dt-0-01-pso-params-n-particles-30-iters-100-c1-2-0-c2-2-0-w-0-9-enable-monitoring-true-strict-validation-true-step-2-simulation-configuration-simulation-config-duration-5-0-dt-0-01-initial-state-0-1-0-1-0-0-0-0-0-0-0-0-small-perturbation-disturbances-enable-true-amplitude-5-0-frequency-1-0-performance-objectives-ise-overshoot-control-effort-step-3-pso-optimization-with-monitoring-with-monitor-pso-performance-pso-config-pso-params-as-monitor-define-fitness-function-handle-pso-errors-def-fitness-function-particles-np-ndarray-np-ndarray-fitness-scores-for-gains-in-particles-start-time-time-perf-counter-try-create-controller-with-validation-controller-create-smc-for-pso-pso-config-controller-type-gains-tolist-pso-config-max-force-creation-time-time-perf-counter-start-time-monitor-log-controller-creation-true-creation-time-run-simulation-sim-start-time-perf-counter-result-run-simulation-controller-simulation-config-sim-time-time-perf-counter-sim-start-monitor-log-simulation-execution-true-sim-time-compute-fitness-fitness-start-time-perf-counter-fitness-compute-multi-objective-fitness-result-simulation-config-performance-objectives-fitness-time-time-perf-counter-fitness-start-monitor-log-fitness-evaluation-fitness-fitness-time-fitness-scores-append-fitness-except-exception-as-e-monitor-log-controller-creation-false-0-0-fitness-scores-append-1000-0-log-resource-usage-periodically-if-len-fitness-scores-10-0-monitor-log-resource-usage-return-np-array-fitness-scores-step-4-execute-pso-optimization-from-pyswarms-single-import-globalbestpso-bounds-pso-config-gain-bounds-bounds-array-np-array-bounds-optimizer-globalbestpso-n-particles-pso-config-pso-params-n-particles-dimensions-pso-config-n-gains-options-c1-pso-config-pso-params-c1-c2-pso-config-pso-params-c2-w-pso-config-pso-params-w-bounds-bounds-array-0-bounds-array-1-print-starting-pso-optimization-best-cost-best-gains-optimizer-optimize-fitness-function-iters-pso-config-pso-params-iters-verbose-true-step-5-results-analysis-performance-report-monitor-generate-performance-report-validate-optimized-controller-optimized-controller-create-smc-for-pso-pso-config-controller-type-best-gains-tolist-pso-config-max-force-run-validation-simulation-validation-result-run-simulation-optimized-controller-simulation-config-validation-metrics-compute-validation-metrics-validation-result-step-6-generate-report-optimization-report-optimization-results-best-gains-best-gains-tolist-best-fitness-float-best-cost-optimization-history-optimizer-cost-history-convergence-iteration-find-convergence-iteration-optimizer-cost-history-validation-results-controller-gains-optimized-controller-gains-performance-metrics-validation-metrics-stability-analysis-estimate-stability-properties-pso-config-controller-type-best-gains-tolist-performance-report-performance-report-configuration-pso-config-pso-config-dict-simulation-config-simulation-config-bounds-used-bounds-step-7-display-results-print-optimization-summary-optimization-report-return-optimization-report-def-print-optimization-summary-report-dict-str-any-print-formatted-optimization-summary-opt-results-report-optimization-results-val-results-report-validation-results-perf-report-report-performance-report-print-n-80-print-pso-optimization-results-summary-print-80-print-f-n-optimization-results-print-f-best-fitness-opt-results-best-fitness-6f-print-f-best-gains-opt-results-best-gains-print-f-convergence-iteration-opt-results-convergence-iteration-print-f-n-validation-metrics-for-metric-value-in-val-results-performance-metrics-items-print-f-metric-upper-value-4f-print-f-n-performance-summary-summary-perf-report-summary-print-f-total-evaluations-summary-total-evaluations-print-f-success-rate-summary-success-rate-1f-print-f-evaluations-sec-summary-evaluations-per-second-1f-print-f-total-time-summary-total-optimization-time-1f-s-perf-perf-report-performance-print-f-avg-creation-time-perf-average-controller-creation-time-ms-2f-ms-print-f-avg-simulation-time-perf-average-simulation-time-ms-2f-ms-resources-perf-report-resources-print-f-peak-memory-resources-peak-memory-usage-percent-1f-print-f-avg-cpu-resources-average-cpu-utilization-percent-1f-if-perf-report-alerts-print-f-n-performance-alerts-for-alert-in-perf-report-alerts-print-f-alert-print-n-80-def-find-convergence-iteration-cost-history-list-float-tolerance-float-1e-6-patience-int-10-int-find-iteration-where-pso-converged-if-len-cost-history-patience-return-len-cost-history-for-i-in-range-patience-len-cost-history-check-if-fitness-has-been-stable-for-patience-iterations-recent-costs-cost-history-i-patience-i-if-max-recent-costs-min-recent-costs-tolerance-return-i-patience-1-return-len-cost-history-no-convergence-detected-run-the-complete-example">
<h1>runnable: false def complete_pso_optimization_example(): â€œâ€â€ Complete example demonstrating PSO-Factory integration. This example shows: 1. Configuration setup 2. Controller creation and validation 3. PSO optimization execution 4. Performance monitoring 5. Results analysis and validation â€œâ€â€ # Step 1: Configuration setup pso_config = PSOFactoryConfig( controller_type=SMCType.CLASSICAL, max_force=100.0, dt=0.01, pso_params={ â€˜n_particlesâ€™: 30, â€˜itersâ€™: 100, â€˜c1â€™: 2.0, â€˜c2â€™: 2.0, â€˜wâ€™: 0.9 }, enable_monitoring=True, strict_validation=True ) # Step 2: Simulation configuration simulation_config = { â€˜durationâ€™: 5.0, â€˜dtâ€™: 0.01, â€˜initial_stateâ€™: [0.1, 0.1, 0.0, 0.0, 0.0, 0.0], # Small perturbation â€˜disturbancesâ€™: { â€˜enableâ€™: True, â€˜amplitudeâ€™: 5.0, â€˜frequencyâ€™: 1.0 }, â€˜performance_objectivesâ€™: [â€˜iseâ€™, â€˜overshootâ€™, â€˜control_effortâ€™] } # Step 3: PSO optimization with monitoring with monitor_pso_performance(pso_config.pso_params) as monitor: # Define fitness function &#64;handle_pso_errors def fitness_function(particles: np.ndarray) -&gt; np.ndarray: fitness_scores = [] for gains in particles: start_time = time.perf_counter() try: # Create controller with validation controller = create_smc_for_pso( pso_config.controller_type, gains.tolist(), pso_config.max_force ) creation_time = time.perf_counter() - start_time monitor.log_controller_creation(True, creation_time) # Run simulation sim_start = time.perf_counter() result = run_simulation(controller, simulation_config) sim_time = time.perf_counter() - sim_start monitor.log_simulation_execution(True, sim_time) # Compute fitness fitness_start = time.perf_counter() fitness = compute_multi_objective_fitness( result, simulation_config[â€˜performance_objectivesâ€™] ) fitness_time = time.perf_counter() - fitness_start monitor.log_fitness_evaluation(fitness, fitness_time) fitness_scores.append(fitness) except Exception as e: monitor.log_controller_creation(False, 0.0) fitness_scores.append(1000.0) # Log resource usage periodically if len(fitness_scores) % 10 == 0: monitor.log_resource_usage() return np.array(fitness_scores) # Step 4: Execute PSO optimization from pyswarms.single import GlobalBestPSO bounds = pso_config.gain_bounds bounds_array = np.array(bounds) optimizer = GlobalBestPSO( n_particles=pso_config.pso_params[â€˜n_particlesâ€™], dimensions=pso_config.n_gains, options={ â€˜c1â€™: pso_config.pso_params[â€˜c1â€™], â€˜c2â€™: pso_config.pso_params[â€˜c2â€™], â€˜wâ€™: pso_config.pso_params[â€˜wâ€™] }, bounds=(bounds_array[:, 0], bounds_array[:, 1]) ) print(â€œStarting PSO optimizationâ€¦â€) best_cost, best_gains = optimizer.optimize( fitness_function, iters=pso_config.pso_params[â€˜itersâ€™], verbose=True ) # Step 5: Results analysis performance_report = monitor.generate_performance_report() # Validate optimized controller optimized_controller = create_smc_for_pso( pso_config.controller_type, best_gains.tolist(), pso_config.max_force ) # Run validation simulation validation_result = run_simulation(optimized_controller, simulation_config) validation_metrics = compute_validation_metrics(validation_result) # Step 6: Generate report optimization_report = { â€˜optimization_resultsâ€™: { â€˜best_gainsâ€™: best_gains.tolist(), â€˜best_fitnessâ€™: float(best_cost), â€˜optimization_historyâ€™: optimizer.cost_history, â€˜convergence_iterationâ€™: find_convergence_iteration(optimizer.cost_history) }, â€˜validation_resultsâ€™: { â€˜controller_gainsâ€™: optimized_controller.gains, â€˜performance_metricsâ€™: validation_metrics, â€˜stability_analysisâ€™: estimate_stability_properties( pso_config.controller_type, best_gains.tolist() ) }, â€˜performance_reportâ€™: performance_report, â€˜configurationâ€™: { â€˜pso_configâ€™: pso_config.<strong>dict</strong>, â€˜simulation_configâ€™: simulation_config, â€˜bounds_usedâ€™: bounds } } # Step 7: Display results print_optimization_summary(optimization_report) return optimization_report def print_optimization_summary(report: Dict[str, Any]): â€œâ€â€Print formatted optimization summary.â€â€â€ opt_results = report[â€˜optimization_resultsâ€™] val_results = report[â€˜validation_resultsâ€™] perf_report = report[â€˜performance_reportâ€™] print(â€œ\nâ€ + â€œ=â€*80) print(â€œPSO OPTIMIZATION RESULTS SUMMARYâ€) print(â€œ=â€*80) print(fâ€\nğŸ“Š OPTIMIZATION RESULTS:â€) print(fâ€ Best Fitness: {opt_results[â€˜best_fitnessâ€™]:.6f}â€) print(fâ€ Best Gains: {opt_results[â€˜best_gainsâ€™]}â€) print(fâ€ Convergence: Iteration {opt_results[â€˜convergence_iterationâ€™]}â€) print(fâ€\nğŸ¯ VALIDATION METRICS:â€) for metric, value in val_results[â€˜performance_metricsâ€™].items(): print(fâ€ {metric.upper()}: {value:.4f}â€) print(fâ€\nâš¡ PERFORMANCE SUMMARY:â€) summary = perf_report[â€˜summaryâ€™] print(fâ€ Total Evaluations: {summary[â€˜total_evaluationsâ€™]}â€) print(fâ€ Success Rate: {summary[â€˜success_rateâ€™]:.1f}%â€) print(fâ€ Evaluations/sec: {summary[â€˜evaluations_per_secondâ€™]:.1f}â€) print(fâ€ Total Time: {summary[â€˜total_optimization_timeâ€™]:.1f}sâ€) perf = perf_report[â€˜performanceâ€™] print(fâ€ Avg Creation Time: {perf[â€˜average_controller_creation_time_msâ€™]:.2f}msâ€) print(fâ€ Avg Simulation Time: {perf[â€˜average_simulation_time_msâ€™]:.2f}msâ€) resources = perf_report[â€˜resourcesâ€™] print(fâ€ Peak Memory: {resources[â€˜peak_memory_usage_percentâ€™]:.1f}%â€) print(fâ€ Avg CPU: {resources[â€˜average_cpu_utilization_percentâ€™]:.1f}%â€) if perf_report[â€˜alertsâ€™]: print(fâ€\nâš ï¸ PERFORMANCE ALERTS:â€) for alert in perf_report[â€˜alertsâ€™]: print(fâ€ - {alert}â€) print(â€œ\nâ€ + â€œ=â€*80) def find_convergence_iteration(cost_history: List[float], tolerance: float = 1e-6, patience: int = 10 ) -&gt; int: â€œâ€â€Find iteration where PSO converged.â€â€â€ if len(cost_history) &lt; patience: return len(cost_history) for i in range(patience, len(cost_history)): # Check if fitness has been stable for â€˜patienceâ€™ iterations recent_costs = cost_history[i-patience:i] if max(recent_costs) - min(recent_costs) &lt; tolerance: return i - patience + 1 return len(cost_history) # No convergence detected # Run the complete example<a class="headerlink" href="#runnable-false-def-complete-pso-optimization-example-complete-example-demonstrating-pso-factory-integration-this-example-shows-1-configuration-setup-2-controller-creation-and-validation-3-pso-optimization-execution-4-performance-monitoring-5-results-analysis-and-validation-step-1-configuration-setup-pso-config-psofactoryconfig-controller-type-smctype-classical-max-force-100-0-dt-0-01-pso-params-n-particles-30-iters-100-c1-2-0-c2-2-0-w-0-9-enable-monitoring-true-strict-validation-true-step-2-simulation-configuration-simulation-config-duration-5-0-dt-0-01-initial-state-0-1-0-1-0-0-0-0-0-0-0-0-small-perturbation-disturbances-enable-true-amplitude-5-0-frequency-1-0-performance-objectives-ise-overshoot-control-effort-step-3-pso-optimization-with-monitoring-with-monitor-pso-performance-pso-config-pso-params-as-monitor-define-fitness-function-handle-pso-errors-def-fitness-function-particles-np-ndarray-np-ndarray-fitness-scores-for-gains-in-particles-start-time-time-perf-counter-try-create-controller-with-validation-controller-create-smc-for-pso-pso-config-controller-type-gains-tolist-pso-config-max-force-creation-time-time-perf-counter-start-time-monitor-log-controller-creation-true-creation-time-run-simulation-sim-start-time-perf-counter-result-run-simulation-controller-simulation-config-sim-time-time-perf-counter-sim-start-monitor-log-simulation-execution-true-sim-time-compute-fitness-fitness-start-time-perf-counter-fitness-compute-multi-objective-fitness-result-simulation-config-performance-objectives-fitness-time-time-perf-counter-fitness-start-monitor-log-fitness-evaluation-fitness-fitness-time-fitness-scores-append-fitness-except-exception-as-e-monitor-log-controller-creation-false-0-0-fitness-scores-append-1000-0-log-resource-usage-periodically-if-len-fitness-scores-10-0-monitor-log-resource-usage-return-np-array-fitness-scores-step-4-execute-pso-optimization-from-pyswarms-single-import-globalbestpso-bounds-pso-config-gain-bounds-bounds-array-np-array-bounds-optimizer-globalbestpso-n-particles-pso-config-pso-params-n-particles-dimensions-pso-config-n-gains-options-c1-pso-config-pso-params-c1-c2-pso-config-pso-params-c2-w-pso-config-pso-params-w-bounds-bounds-array-0-bounds-array-1-print-starting-pso-optimization-best-cost-best-gains-optimizer-optimize-fitness-function-iters-pso-config-pso-params-iters-verbose-true-step-5-results-analysis-performance-report-monitor-generate-performance-report-validate-optimized-controller-optimized-controller-create-smc-for-pso-pso-config-controller-type-best-gains-tolist-pso-config-max-force-run-validation-simulation-validation-result-run-simulation-optimized-controller-simulation-config-validation-metrics-compute-validation-metrics-validation-result-step-6-generate-report-optimization-report-optimization-results-best-gains-best-gains-tolist-best-fitness-float-best-cost-optimization-history-optimizer-cost-history-convergence-iteration-find-convergence-iteration-optimizer-cost-history-validation-results-controller-gains-optimized-controller-gains-performance-metrics-validation-metrics-stability-analysis-estimate-stability-properties-pso-config-controller-type-best-gains-tolist-performance-report-performance-report-configuration-pso-config-pso-config-dict-simulation-config-simulation-config-bounds-used-bounds-step-7-display-results-print-optimization-summary-optimization-report-return-optimization-report-def-print-optimization-summary-report-dict-str-any-print-formatted-optimization-summary-opt-results-report-optimization-results-val-results-report-validation-results-perf-report-report-performance-report-print-n-80-print-pso-optimization-results-summary-print-80-print-f-n-optimization-results-print-f-best-fitness-opt-results-best-fitness-6f-print-f-best-gains-opt-results-best-gains-print-f-convergence-iteration-opt-results-convergence-iteration-print-f-n-validation-metrics-for-metric-value-in-val-results-performance-metrics-items-print-f-metric-upper-value-4f-print-f-n-performance-summary-summary-perf-report-summary-print-f-total-evaluations-summary-total-evaluations-print-f-success-rate-summary-success-rate-1f-print-f-evaluations-sec-summary-evaluations-per-second-1f-print-f-total-time-summary-total-optimization-time-1f-s-perf-perf-report-performance-print-f-avg-creation-time-perf-average-controller-creation-time-ms-2f-ms-print-f-avg-simulation-time-perf-average-simulation-time-ms-2f-ms-resources-perf-report-resources-print-f-peak-memory-resources-peak-memory-usage-percent-1f-print-f-avg-cpu-resources-average-cpu-utilization-percent-1f-if-perf-report-alerts-print-f-n-performance-alerts-for-alert-in-perf-report-alerts-print-f-alert-print-n-80-def-find-convergence-iteration-cost-history-list-float-tolerance-float-1e-6-patience-int-10-int-find-iteration-where-pso-converged-if-len-cost-history-patience-return-len-cost-history-for-i-in-range-patience-len-cost-history-check-if-fitness-has-been-stable-for-patience-iterations-recent-costs-cost-history-i-patience-i-if-max-recent-costs-min-recent-costs-tolerance-return-i-patience-1-return-len-cost-history-no-convergence-detected-run-the-complete-example" title="Link to this heading">Â¶</a></h1>
<p>if <strong>name</strong> == â€œ<strong>main</strong>â€: optimization_report = complete_pso_optimization_example()
<code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">Multi-Controller</span> <span class="pre">Comparison</span> <span class="pre">Example</span></code>python</p>
<p>def multi_controller_comparison_example(): â€œâ€â€ Example demonstrating comparison of all SMC controller types. Optimizes all 4 controller types and compares their performance across multiple objectives and scenarios. â€œâ€â€ # Define test scenarios test_scenarios = [ { â€˜nameâ€™: â€˜small_disturbanceâ€™, â€˜initial_stateâ€™: [0.05, 0.05, 0.0, 0.0, 0.0, 0.0], â€˜disturbance_amplitudeâ€™: 2.0 }, { â€˜nameâ€™: â€˜large_disturbanceâ€™, â€˜initial_stateâ€™: [0.2, 0.15, 0.0, 0.0, 0.0, 0.0], â€˜disturbance_amplitudeâ€™: 10.0 }, { â€˜nameâ€™: â€˜parameter_uncertaintyâ€™, â€˜initial_stateâ€™: [0.1, 0.1, 0.0, 0.0, 0.0, 0.0], â€˜parameter_variationsâ€™: {â€˜mass_uncertaintyâ€™: 0.2} } ] # Define optimization objectives objectives = { â€˜control_performanceâ€™: {â€˜iseâ€™: 0.4, â€˜overshootâ€™: 0.3, â€˜settling_timeâ€™: 0.3}, â€˜energy_efficiencyâ€™: {â€˜iseâ€™: 0.3, â€˜control_effortâ€™: 0.5, â€˜chatteringâ€™: 0.2}, â€˜robustnessâ€™: {â€˜iseâ€™: 0.2, â€˜disturbance_rejectionâ€™: 0.4, â€˜parameter_sensitivityâ€™: 0.4} } # PSO configuration for all controllers base_pso_config = { â€˜n_particlesâ€™: 25, â€˜itersâ€™: 75, â€˜c1â€™: 2.0, â€˜c2â€™: 2.0, â€˜wâ€™: 0.9 } all_results = {} # Optimize each controller type for smc_type in SMCType: print(fâ€\n{â€˜=â€™*60}â€) print(fâ€OPTIMIZING {smc_type.value.upper()}â€) print(fâ€{â€˜=â€™*60}â€) controller_results = {} # Test each scenario for scenario in test_scenarios: print(fâ€\nScenario: {scenario[â€˜nameâ€™]}â€) scenario_results = {} # Test each objective set for obj_name, obj_weights in objectives.items(): print(fâ€ Objective: {obj_name}â€) # Create simulation config for this scenario sim_config = { â€˜durationâ€™: 5.0, â€˜dtâ€™: 0.01, â€˜initial_stateâ€™: scenario[â€˜initial_stateâ€™], â€˜disturbance_amplitudeâ€™: scenario.get(â€˜disturbance_amplitudeâ€™, 0.0), â€˜parameter_variationsâ€™: scenario.get(â€˜parameter_variationsâ€™, {}), â€˜objectivesâ€™: obj_weights } # Run PSO optimization result = optimize_single_controller( smc_type, sim_config, base_pso_config ) scenario_results[obj_name] = result controller_results[scenario[â€˜nameâ€™]] = scenario_results all_results[smc_type.value] = controller_results # Generate comparison analysis comparison_analysis = analyze_controller_comparison(all_results, test_scenarios, objectives) # Display results display_comparison_results(comparison_analysis) return comparison_analysis def optimize_single_controller(smc_type: SMCType, sim_config: Dict[str, Any], pso_config: Dict[str, Any] ) -&gt; Dict[str, Any]: â€œâ€â€Optimize single controller for given scenario.â€â€â€ # Get PSO bounds bounds = get_gain_bounds_for_pso(smc_type) bounds_array = np.array(bounds) # Create fitness function def fitness_function(particles: np.ndarray) -&gt; np.ndarray: fitness_scores = [] for gains in particles: try: controller = create_smc_for_pso(smc_type, gains.tolist()) result = run_simulation(controller, sim_config) fitness = compute_multi_objective_fitness(result, sim_config[â€˜objectivesâ€™]) fitness_scores.append(fitness) except: fitness_scores.append(1000.0) return np.array(fitness_scores) # Run PSO from pyswarms.single import GlobalBestPSO optimizer = GlobalBestPSO( n_particles=pso_config[â€˜n_particlesâ€™], dimensions=len(bounds), options={ â€˜c1â€™: pso_config[â€˜c1â€™], â€˜c2â€™: pso_config[â€˜c2â€™], â€˜wâ€™: pso_config[â€˜wâ€™] }, bounds=(bounds_array[:, 0], bounds_array[:, 1]) ) best_cost, best_gains = optimizer.optimize( fitness_function, iters=pso_config[â€˜itersâ€™], verbose=False ) # Validate result final_controller = create_smc_for_pso(smc_type, best_gains.tolist()) validation_result = run_simulation(final_controller, sim_config) return { â€˜best_gainsâ€™: best_gains.tolist(), â€˜best_fitnessâ€™: float(best_cost), â€˜validation_metricsâ€™: compute_validation_metrics(validation_result), â€˜optimization_historyâ€™: optimizer.cost_history } def analyze_controller_comparison(results: Dict[str, Any], scenarios: List[Dict[str, Any]], objectives: Dict[str, Any] ) -&gt; Dict[str, Any]: â€œâ€â€Analyze comparison results across controllers.â€â€â€ analysis = { â€˜overall_rankingâ€™: {}, â€˜scenario_performanceâ€™: {}, â€˜objective_performanceâ€™: {}, â€˜robustness_analysisâ€™: {}, â€˜recommendationsâ€™: {} } # Rank controllers by overall performance controller_scores = {} for controller_type in results.keys(): total_score = 0 count = 0 for scenario_name in results[controller_type].keys(): for obj_name in results[controller_type][scenario_name].keys(): fitness = results[controller_type][scenario_name][obj_name][â€˜best_fitnessâ€™] total_score += fitness count += 1 controller_scores[controller_type] = total_score / count if count &gt; 0 else float(â€˜infâ€™) # Sort by performance (lower is better) analysis[â€˜overall_rankingâ€™] = dict(sorted( controller_scores.items(), key=lambda x: x[1] )) # Analyze performance by scenario for scenario in scenarios: scenario_name = scenario[â€˜nameâ€™] scenario_scores = {} for controller_type in results.keys(): if scenario_name in results[controller_type]: avg_fitness = np.mean([ results[controller_type][scenario_name][obj][â€˜best_fitnessâ€™] for obj in results[controller_type][scenario_name].keys() ]) scenario_scores[controller_type] = avg_fitness analysis[â€˜scenario_performanceâ€™][scenario_name] = dict(sorted( scenario_scores.items(), key=lambda x: x[1] )) # Analyze performance by objective for obj_name in objectives.keys(): objective_scores = {} for controller_type in results.keys(): obj_scores = [] for scenario_name in results[controller_type].keys(): if obj_name in results[controller_type][scenario_name]: obj_scores.append( results[controller_type][scenario_name][obj_name][â€˜best_fitnessâ€™] ) if obj_scores: objective_scores[controller_type] = np.mean(obj_scores) analysis[â€˜objective_performanceâ€™][obj_name] = dict(sorted( objective_scores.items(), key=lambda x: x[1] )) # Generate recommendations analysis[â€˜recommendationsâ€™] = generate_controller_recommendations(analysis) return analysis def generate_controller_recommendations(analysis: Dict[str, Any]) -&gt; Dict[str, str]: â€œâ€â€Generate recommendations based on comparison analysis.â€â€â€ recommendations = {} # Overall best controller best_overall = list(analysis[â€˜overall_rankingâ€™].keys())[0] recommendations[â€˜best_overallâ€™] = ( fâ€{best_overall} shows the best overall performance across â€œ fâ€all scenarios and objectives.â€ ) # Scenario-specific recommendations for scenario, ranking in analysis[â€˜scenario_performanceâ€™].items(): best_for_scenario = list(ranking.keys())[0] recommendations[fâ€™best_for_{scenario}â€™] = ( fâ€{best_for_scenario} performs best for {scenario} scenarios.â€ ) # Objective-specific recommendations for objective, ranking in analysis[â€˜objective_performanceâ€™].items(): best_for_objective = list(ranking.keys())[0] recommendations[fâ€™best_for_{objective}â€™] = ( fâ€{best_for_objective} excels at {objective} objectives.â€ ) return recommendations def display_comparison_results(analysis: Dict[str, Any]): â€œâ€â€Display formatted comparison results.â€â€â€ print(â€œ\nâ€ + â€œ=â€*80) print(â€œMULTI-CONTROLLER COMPARISON RESULTSâ€) print(â€œ=â€*80) print(â€œ\nğŸ† OVERALL RANKING:â€) for i, (controller, score) in enumerate(analysis[â€˜overall_rankingâ€™].items(), 1): print(fâ€ {i}. {controller.upper()}: {score:.4f}â€) print(â€œ\nğŸ“Š SCENARIO PERFORMANCE:â€) for scenario, ranking in analysis[â€˜scenario_performanceâ€™].items(): print(fâ€\n {scenario.upper()}:â€) for i, (controller, score) in enumerate(ranking.items(), 1): print(fâ€ {i}. {controller}: {score:.4f}â€) print(â€œ\nğŸ¯ OBJECTIVE PERFORMANCE:â€) for objective, ranking in analysis[â€˜objective_performanceâ€™].items(): print(fâ€\n {objective.upper()}:â€) for i, (controller, score) in enumerate(ranking.items(), 1): print(fâ€ {i}. {controller}: {score:.4f}â€) print(â€œ\nğŸ’¡ RECOMMENDATIONS:â€) for key, recommendation in analysis[â€˜recommendationsâ€™].items(): print(fâ€ â€¢ {recommendation}â€) print(â€œ\nâ€ + â€œ=â€*80) # Run the comparison example
if <strong>name</strong> == â€œ<strong>main</strong>â€: comparison_results = multi_controller_comparison_example()</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="o">---</span>

<span class="n">This</span> <span class="n">PSO</span> <span class="n">Factory</span> <span class="n">Integration</span> <span class="n">API</span> <span class="n">Reference</span> <span class="n">provides</span> <span class="n">complete</span> <span class="n">documentation</span> <span class="k">for</span> <span class="nb">all</span> <span class="n">aspects</span> <span class="n">of</span> <span class="n">the</span> <span class="n">factory</span> <span class="n">pattern</span> <span class="n">implementation</span> <span class="ow">and</span> <span class="n">PSO</span> <span class="n">optimization</span> <span class="n">framework</span><span class="o">.</span> <span class="n">The</span> <span class="n">API</span> <span class="ow">is</span> <span class="n">designed</span> <span class="n">to</span> <span class="n">support</span> <span class="n">both</span> <span class="n">simple</span> <span class="n">single</span><span class="o">-</span><span class="n">controller</span> <span class="n">optimization</span> <span class="ow">and</span> <span class="nb">complex</span> <span class="n">multi</span><span class="o">-</span><span class="n">objective</span><span class="p">,</span> <span class="n">multi</span><span class="o">-</span><span class="n">controller</span> <span class="n">research</span> <span class="n">workflows</span> <span class="k">while</span> <span class="n">maintaining</span> <span class="n">mathematical</span> <span class="n">rigor</span> <span class="ow">and</span> <span class="n">production</span><span class="o">-</span><span class="n">quality</span> <span class="n">performance</span><span class="o">.</span>

<span class="o">---</span>

<span class="o">**</span><span class="n">Document</span> <span class="n">Status</span><span class="o">**</span><span class="p">:</span> <span class="n">Complete</span> <span class="n">API</span> <span class="n">Reference</span> <span class="n">Documentation</span>
<span class="o">**</span><span class="n">Last</span> <span class="n">Updated</span><span class="o">**</span><span class="p">:</span> <span class="n">September</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">2024</span>
<span class="o">**</span><span class="n">API</span> <span class="n">Version</span><span class="o">**</span><span class="p">:</span> <span class="n">GitHub</span> <span class="n">Issue</span> <span class="c1">#6 Production Release</span>
<span class="o">**</span><span class="n">Coverage</span><span class="o">**</span><span class="p">:</span> <span class="mi">100</span><span class="o">%</span> <span class="n">Factory</span> <span class="n">Integration</span> <span class="o">+</span> <span class="n">PSO</span> <span class="n">Framework</span>
<span class="o">**</span><span class="n">Validation</span> <span class="n">Level</span><span class="o">**</span><span class="p">:</span> <span class="n">Production</span> <span class="n">Ready</span>
</pre></div>
</div>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Research Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">PSO Factory Integration API Reference</a><ul>
<li><a class="reference internal" href="#complete-documentation-for-pso-optimized-controller-factory-table-of-contents">Complete Documentation for PSO-Optimized Controller Factory ### Table of Contents</a></li>
<li><a class="reference internal" href="#api-overview-the-pso-factory-integration-api-provides-a-framework-for-optimizing-sliding-mode-controllers-using-particle-swarm-optimization-the-api-is-designed-with-the-following-principles-design-philosophy">API Overview The PSO Factory Integration API provides a framework for optimizing sliding mode controllers using Particle Swarm Optimization. The API is designed with the following principles: ### Design Philosophy</a></li>
<li><a class="reference internal" href="#core-pso-integration-classes-smctype-enumeration-python">Core PSO Integration Classes ### SMCType Enumeration ```python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-metadata">example-metadata:</a></li>
<li><a class="reference internal" href="#runnable-false-class-smctype-enum-enumeration-of-supported-smc-controller-types-for-pso-optimization-each-type-corresponds-to-a-specific-sliding-mode-control-algorithm-with-distinct-mathematical-properties-and-parameter-requirements-classical-classical-smc-classical-sliding-mode-controller-with-boundary-layer-mathematical-model-u-u-eq-u-sw-u-eq-gb-1-gf-x-s-ref-u-sw-ktanh-s-gain-parameters-k1-k2-1-2-k-kd-k1-k2-position-gains-for-pendulum-1-and-2-1-2-surface-gains-for-pendulum-1-and-2-k-switching-gain-kd-damping-gain-mathematical-constraints-1-2-k-0-stability-requirement-kd-0-non-negative-damping-pso-bounds-0-1-50-0-1-50-1-50-1-50-1-200-0-50-super-twisting-sta-smc-super-twisting-sliding-mode-controller-second-order-mathematical-model-u-k1sign-s-k2sign-s-s-x-sliding-surface-gain-parameters-k1-k2-1-2-1-2-k1-primary-twisting-gain-k2-secondary-twisting-gain-1-2-surface-gains-1-2-higher-order-surface-parameters-mathematical-constraints-k1-k2-0-finite-time-convergence-1-2-1-2-0-stability-pso-bounds-2-100-1-99-1-50-1-50-1-50-1-50-adaptive-adaptive-smc-adaptive-sliding-mode-controller-with-online-gain-tuning-mathematical-model-u-u-eq-u-sw-k-s-k-adaptation-law-gain-parameters-k1-k2-1-2-k1-k2-position-gains-1-2-surface-gains-adaptation-rate-mathematical-constraints-k1-k2-1-2-0-stability-0-1-20-0-bounded-adaptation-pso-bounds-0-1-50-0-1-50-1-50-1-50-0-1-20-hybrid-hybrid-adaptive-sta-smc-hybrid-adaptive-super-twisting-controller-mathematical-model-u-u-adaptive-u-sta-mode-switching-gain-parameters-k1-k2-1-2-k1-k2-surface-gains-for-pendulum-1-and-2-1-2-higher-order-surface-gains-mathematical-constraints-all-parameters-0-stability-pso-bounds-1-50-1-50-1-50-1-50-property-def-gain-count-self-int-return-number-of-gain-parameters-for-this-controller-type-return-smctype-classical-6-smctype-super-twisting-6-smctype-adaptive-5-smctype-hybrid-4-self-property-def-mathematical-constraints-self-dict-str-str-return-mathematical-constraints-as-human-readable-strings-return-smctype-classical-1-2-k-0-kd-0-smctype-super-twisting-k1-k2-0-1-2-1-2-0-smctype-adaptive-k1-k2-1-2-0-0-1-20-0-smctype-hybrid-k1-k2-1-2-0-self">runnable: false class SMCType(Enum): â€œâ€â€ Enumeration of supported SMC controller types for PSO optimization. Each type corresponds to a specific sliding mode control algorithm with distinct mathematical properties and parameter requirements. â€œâ€â€ CLASSICAL = â€œclassical_smcâ€ â€œâ€â€ Classical sliding mode controller with boundary layer. Mathematical Model: u = u_eq + u_sw u_eq = (GB)^(-1)[-Gf(x) + á¹¡_ref] u_sw = -KÂ·tanh(s/Ï†) Gain Parameters: [k1, k2, Î»1, Î»2, K, kd] k1, k2: Position gains for pendulum 1 and 2 Î»1, Î»2: Surface gains for pendulum 1 and 2 K: Switching gain kd: Damping gain Mathematical Constraints: - Î»1, Î»2, K &gt; 0 (stability requirement) - kd â‰¥ 0 (non-negative damping) PSO Bounds: [(0.1,50), (0.1,50), (1,50), (1,50), (1,200), (0,50)] â€œâ€â€ SUPER_TWISTING = â€œsta_smcâ€ â€œâ€â€ Super-twisting sliding mode controller (second-order). Mathematical Model: uÌ‡ = -K1Â·sign(s) - K2Â·sign(á¹¡) s = Ïƒ(x) (sliding surface) Gain Parameters: [K1, K2, Î»1, Î»2, Î±1, Î±2] K1: Primary twisting gain K2: Secondary twisting gain Î»1, Î»2: Surface gains Î±1, Î±2: Higher-order surface parameters Mathematical Constraints: - K1 &gt; K2 &gt; 0 (finite-time convergence) - Î»1, Î»2, Î±1, Î±2 &gt; 0 (stability) PSO Bounds: [(2,100), (1,99), (1,50), (1,50), (1,50), (1,50)] â€œâ€â€ ADAPTIVE = â€œadaptive_smcâ€ â€œâ€â€ Adaptive sliding mode controller with online gain tuning. Mathematical Model: u = u_eq + u_sw KÌ‡ = Î³|s| - ÏƒK (adaptation law) Gain Parameters: [k1, k2, Î»1, Î»2, Î³] k1, k2: Position gains Î»1, Î»2: Surface gains Î³: Adaptation rate Mathematical Constraints: - k1, k2, Î»1, Î»2 &gt; 0 (stability) - 0.1 â‰¤ Î³ â‰¤ 20.0 (bounded adaptation) PSO Bounds: [(0.1,50), (0.1,50), (1,50), (1,50), (0.1,20)] â€œâ€â€ HYBRID = â€œhybrid_adaptive_sta_smcâ€ â€œâ€â€ Hybrid adaptive super-twisting controller. Mathematical Model: u = u_adaptive + u_sta (mode switching) Gain Parameters: [k1, k2, Î»1, Î»2] k1, k2: Surface gains for pendulum 1 and 2 Î»1, Î»2: Higher-order surface gains Mathematical Constraints: - All parameters &gt; 0 (stability) PSO Bounds: [(1,50), (1,50), (1,50), (1,50)] â€œâ€â€ &#64;property def gain_count(self) -&gt; int: â€œâ€â€Return number of gain parameters for this controller type.â€â€â€ return { SMCType.CLASSICAL: 6, SMCType.SUPER_TWISTING: 6, SMCType.ADAPTIVE: 5, SMCType.HYBRID: 4 }[self] &#64;property def mathematical_constraints(self) -&gt; Dict[str, str]: â€œâ€â€Return mathematical constraints as human-readable strings.â€â€â€ return { SMCType.CLASSICAL: â€œÎ»1,Î»2,K &gt; 0; kd â‰¥ 0â€, SMCType.SUPER_TWISTING: â€œK1 &gt; K2 &gt; 0; Î»1,Î»2,Î±1,Î±2 &gt; 0â€, SMCType.ADAPTIVE: â€œk1,k2,Î»1,Î»2 &gt; 0; 0.1 â‰¤ Î³ â‰¤ 20.0â€, SMCType.HYBRID: â€œk1,k2,Î»1,Î»2 &gt; 0â€ }[self]</a></li>
<li><a class="reference internal" href="#id1">example-metadata:</a></li>
<li><a class="reference internal" href="#runnable-false-dataclass-frozen-true">runnable: false &#64;dataclass(frozen=True)</a><ul>
<li><a class="reference internal" href="#pso-controller-wrapper-psocontrollerwrapper-class-python">PSO Controller Wrapper ### PSOControllerWrapper Class ```python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id2">example-metadata:</a></li>
<li><a class="reference internal" href="#runnable-false-class-psocontrollerwrapper-pso-optimized-wrapper-providing-simplified-interface-for-smc-controllers-this-wrapper-is-specifically-designed-for-pso-fitness-evaluation-with-simplified-control-interface-single-state-input-automatic-state-management-for-stateful-controllers-unified-output-format-numpy-array-robust-error-handling-for-pso-robustness-performance-optimization-for-repeated-evaluations-the-wrapper-handles-the-complexity-of-different-smc-controller-interfaces-while-providing-a-consistent-pso-friendly-api-mathematical-foundation-the-wrapper-preserves-the-mathematical-properties-of-the-underlying-smc-controller-while-simplifying-the-interface-input-state-1-2-x-1-2-x-6-output-u-scalar-control-force-internal-state-management-classical-smc-stateless-empty-state-vars-sta-smc-maintains-z-for-integration-adaptive-smc-tracks-adaptation-variables-hybrid-smc-manages-mode-switching-state-performance-characteristics-control-computation-0-1ms-typical-memory-overhead-500b-per-wrapper-thread-safety-read-operations-only-error-recovery-graceful-degradation-for-invalid-inputs-def-init-self-controller-smcprotocol-initialize-pso-wrapper-with-smc-controller-args-controller-smc-controller-implementing-smcprotocol-raises-typeerror-if-controller-doesn-t-implement-required-interface-valueerror-if-controller-configuration-is-invalid-validate-controller-interface-if-not-hasattr-controller-compute-control-raise-typeerror-controller-must-implement-compute-control-method-if-not-hasattr-controller-gains-raise-typeerror-controller-must-have-gains-property-self-controller-controller-self-history-initialize-empty-history-initialize-controller-specific-state-variables-controller-name-type-controller-name-if-supertwisting-in-controller-name-or-sta-in-controller-name-sta-smc-maintains-integration-variables-z-self-state-vars-0-0-0-0-initial-z-0-0-elif-hybrid-in-controller-name-hybrid-controller-tracks-adaptive-gains-and-integration-self-state-vars-getattr-controller-k1-init-5-0-k1-prev-getattr-controller-k2-init-3-0-k2-prev-0-0-u-int-prev-elif-adaptive-in-controller-name-adaptive-smc-may-track-adaptation-state-self-state-vars-getattr-controller-initial-state-else-classical-smc-and-others-use-empty-state-self-state-vars-performance-tracking-self-call-count-0-self-total-compute-time-0-0-self-last-error-none-def-compute-control-self-state-np-ndarray-state-vars-optional-any-none-history-optional-dict-str-any-none-np-ndarray-compute-control-with-flexible-interface-supporting-both-1-simplified-pso-interface-compute-control-state-2-full-interface-compute-control-state-state-vars-history-mathematical-interface-input-state-vector-x-1-2-x-cart-1-2-x-cart-1-2-pendulum-angles-rad-x-cart-cart-position-m-1-2-angular-velocities-rad-s-x-cart-cart-velocity-m-s-output-control-u-scalar-control-force-n-bounded-by-actuator-limits-args-state-system-state-vector-6-element-numpy-array-state-vars-controller-state-variables-optional-history-controller-history-optional-returns-control-output-as-1-element-numpy-array-u-raises-valueerror-if-state-has-wrong-dimensions-runtimeerror-if-control-computation-fails-performance-typical-computation-time-0-01-0-1ms-memory-allocation-minimal-output-array-only-error-handling-graceful-fallback-to-zero-control-pso-usage-pattern-python-def-pso-fitness-gains-controller-create-smc-for-pso-smctype-classical-gains-simplified-interface-for-pso-total-error-0-0-for-state-in-test-states-u-controller-compute-control-state-returns-u-use-u-0-for-scalar-control-value-total-error-evaluate-single-step-state-u-0-return-total-error-state-management-the-wrapper-automatically-manages-controller-state-between-calls-classical-smc-no-state-management-needed-sta-smc-updates-integration-variables-z-adaptive-smc-updates-adaptation-parameters-hybrid-smc-updates-mode-and-adaptation-state-error-recovery-if-control-computation-fails-1-log-error-for-debugging-2-return-safe-fallback-control-zero-3-increment-error-counter-for-monitoring-4-continue-operation-don-t-crash-pso-import-time-performance-tracking-start-time-time-perf-counter-self-call-count-1-try-input-validation-if-not-isinstance-state-np-ndarray-state-np-array-state-if-state-shape-6-raise-valueerror-f-state-must-be-6-element-array-got-shape-state-shape-if-not-np-all-np-isfinite-state-raise-valueerror-state-contains-non-finite-values-nan-or-inf-use-provided-parameters-or-defaults-final-state-vars-state-vars-if-state-vars-is-not-none-else-self-state-vars-final-history-history-if-history-is-not-none-else-self-history-call-underlying-controller-result-self-controller-compute-control-state-final-state-vars-final-history-extract-control-value-from-result-handle-different-controller-output-formats-if-hasattr-result-u-standard-controller-output-with-u-attribute-control-value-result-u-update-state-variables-if-available-if-hasattr-result-state-vars-self-state-vars-result-state-vars-elif-hasattr-result-control-alternative-output-format-with-control-attribute-control-value-result-control-elif-isinstance-result-dict-dictionary-output-format-if-u-in-result-control-value-result-u-elif-control-in-result-control-value-result-control-else-raise-valueerror-dictionary-result-missing-control-value-update-state-if-provided-if-state-vars-in-result-self-state-vars-result-state-vars-elif-isinstance-result-tuple-tuple-output-e-g-early-return-from-some-controllers-control-value-result-0-first-element-is-control-if-len-result-1-self-state-vars-result-1-second-element-is-state-else-assume-result-is-the-control-value-directly-control-value-result-convert-to-scalar-if-needed-if-isinstance-control-value-np-ndarray-if-control-value-size-1-control-value-float-control-value-else-control-value-float-control-value-0-elif-not-isinstance-control-value-int-float-control-value-float-control-value-validate-output-if-not-np-isfinite-control-value-raise-valueerror-controller-returned-non-finite-control-value-apply-saturation-defensive-programming-max-force-getattr-self-controller-max-force-100-0-control-saturated-np-clip-control-value-max-force-max-force-for-simplified-interface-pso-usage-return-numpy-array-if-state-vars-is-none-and-history-is-none-output-np-array-control-saturated-else-for-full-interface-return-in-format-expected-by-simulation-output-control-saturated-performance-tracking-compute-time-time-perf-counter-start-time-self-total-compute-time-compute-time-return-output-except-exception-as-e-error-handling-for-robust-pso-operation-self-last-error-str-e-log-error-for-debugging-in-production-use-proper-logging-print-f-warning-control-computation-failed-e-return-safe-fallback-control-if-state-vars-is-none-and-history-is-none-return-np-array-0-0-pso-interface-else-return-0-0-full-interface-property-def-gains-self-list-float-return-controller-gains-returns-list-of-controller-gain-parameters-usage-python-controller-create-smc-for-pso-smctype-classical-gains-print-f-controller-gains-controller-gains-return-self-controller-gains-property-def-performance-stats-self-dict-str-any-return-performance-statistics-for-monitoring-returns-dictionary-with-performance-metrics-call-count-number-of-control-computations-total-time-total-computation-time-s-average-time-average-computation-time-ms-last-error-last-error-message-if-any-usage-python-after-pso-optimization-stats-controller-performance-stats-print-f-average-computation-time-stats-average-time-3f-ms-avg-time-ms-self-total-compute-time-self-call-count-1000-if-self-call-count-0-else-0-0-return-call-count-self-call-count-total-time-self-total-compute-time-average-time-avg-time-ms-last-error-self-last-error-def-reset-performance-stats-self-none-reset-performance-tracking-statistics-self-call-count-0-self-total-compute-time-0-0-self-last-error-none-def-validate-state-input-self-state-np-ndarray-tuple-bool-str-validate-state-input-for-control-computation-args-state-state-vector-to-validate-returns-tuple-of-is-valid-error-message-usage-python-is-valid-error-controller-validate-state-input-test-state-if-not-is-valid-print-f-invalid-state-error-try-if-not-isinstance-state-np-ndarray-return-false-state-must-be-numpy-array-if-state-shape-6-return-false-f-state-must-be-6-element-array-got-state-shape-if-not-np-all-np-isfinite-state-return-false-state-contains-non-finite-values-check-reasonable-ranges-optional-angles-state-2-1-2-if-np-any-np-abs-angles-2-np-pi-return-false-angles-exceed-reasonable-range-2-velocities-state-3-1-2-x-if-np-any-np-abs-velocities-100-return-false-velocities-exceed-reasonable-range-100-return-true-except-exception-as-e-return-false-f-validation-error-e-def-repr-self-str-string-representation-for-debugging-controller-type-type-self-controller-name-return-f-psocontrollerwrapper-controller-type-gains-self-gains">runnable: false class PSOControllerWrapper: â€œâ€â€ PSO-optimized wrapper providing simplified interface for SMC controllers. This wrapper is specifically designed for PSO fitness evaluation with: - Simplified control interface (single state input) - Automatic state management for stateful controllers - Unified output format (numpy array) - Robust error handling for PSO robustness - Performance optimization for repeated evaluations The wrapper handles the complexity of different SMC controller interfaces while providing a consistent, PSO-friendly API. Mathematical Foundation: The wrapper preserves the mathematical properties of the underlying SMC controller while simplifying the interface: Input: state = [Î¸â‚, Î¸â‚‚, x, Î¸Ì‡â‚, Î¸Ì‡â‚‚, áº‹] âˆˆ â„â¶ Output: u âˆˆ â„ (scalar control force) Internal State Management: - Classical SMC: Stateless (empty state_vars) - STA SMC: Maintains (z, Ïƒ) for integration - Adaptive SMC: Tracks adaptation variables - Hybrid SMC: Manages mode switching state Performance Characteristics: - Control computation: &lt;0.1ms typical - Memory overhead: &lt;500B per wrapper - Thread safety: Read operations only - Error recovery: Graceful degradation for invalid inputs â€œâ€â€ def <strong>init</strong>(self, controller: SMCProtocol): â€œâ€â€ Initialize PSO wrapper with SMC controller. Args: controller: SMC controller implementing SMCProtocol Raises: TypeError: If controller doesnâ€™t implement required interface ValueError: If controller configuration is invalid â€œâ€â€ # Validate controller interface if not hasattr(controller, â€˜compute_controlâ€™): raise TypeError(â€œController must implement compute_control methodâ€) if not hasattr(controller, â€˜gainsâ€™): raise TypeError(â€œController must have gains propertyâ€) self.controller = controller self._history = {} # Initialize empty history # Initialize controller-specific state variables controller_name = type(controller).<strong>name</strong> if â€˜SuperTwistingâ€™ in controller_name or â€˜STAâ€™ in controller_name: # STA-SMC maintains integration variables (z, Ïƒ) self._state_vars = (0.0, 0.0) # Initial (z=0, Ïƒ=0) elif â€˜Hybridâ€™ in controller_name: # Hybrid controller tracks adaptive gains and integration self._state_vars = ( getattr(controller, â€˜k1_initâ€™, 5.0), # k1_prev getattr(controller, â€˜k2_initâ€™, 3.0), # k2_prev 0.0 # u_int_prev ) elif â€˜Adaptiveâ€™ in controller_name: # Adaptive SMC may track adaptation state self._state_vars = getattr(controller, â€˜_initial_stateâ€™, ()) else: # Classical SMC and others use empty state self._state_vars = () # Performance tracking self._call_count = 0 self._total_compute_time = 0.0 self._last_error = None def compute_control(self, state: np.ndarray, state_vars: Optional[Any] = None, history: Optional[Dict[str, Any]] = None ) -&gt; np.ndarray: â€œâ€â€ Compute control with flexible interface supporting both: 1. Simplified PSO interface: compute_control(state) 2. Full interface: compute_control(state, state_vars, history) Mathematical Interface: Input state vector: x = [Î¸â‚, Î¸â‚‚, x_cart, Î¸Ì‡â‚, Î¸Ì‡â‚‚, áº‹_cart] - Î¸â‚, Î¸â‚‚: Pendulum angles [rad] - x_cart: Cart position [m] - Î¸Ì‡â‚, Î¸Ì‡â‚‚: Angular velocities [rad/s] - áº‹_cart: Cart velocity [m/s] Output control: u âˆˆ â„ - Scalar control force [N] - Bounded by actuator limits Args: state: System state vector (6-element numpy array) state_vars: Controller state variables (optional) history: Controller history (optional) Returns: Control output as 1-element numpy array [u] Raises: ValueError: If state has wrong dimensions RuntimeError: If control computation fails Performance: - Typical computation time: 0.01-0.1ms - Memory allocation: Minimal (output array only) - Error handling: Graceful fallback to zero control PSO Usage Pattern: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">def</span> <span class="pre">pso_fitness(gains):</span> <span class="pre">controller</span> <span class="pre">=</span> <span class="pre">create_smc_for_pso(SMCType.CLASSICAL,</span> <span class="pre">gains)</span> <span class="pre">#</span> <span class="pre">Simplified</span> <span class="pre">interface</span> <span class="pre">for</span> <span class="pre">PSO</span> <span class="pre">total_error</span> <span class="pre">=</span> <span class="pre">0.0</span> <span class="pre">for</span> <span class="pre">state</span> <span class="pre">in</span> <span class="pre">test_states:</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">controller.compute_control(state)</span> <span class="pre">#</span> <span class="pre">Returns</span> <span class="pre">[u]</span> <span class="pre">#</span> <span class="pre">Use</span> <span class="pre">u[0]</span> <span class="pre">for</span> <span class="pre">scalar</span> <span class="pre">control</span> <span class="pre">value</span> <span class="pre">total_error</span> <span class="pre">+=</span> <span class="pre">evaluate_single_step(state,</span> <span class="pre">u[0])</span> <span class="pre">return</span> <span class="pre">total_error</span> </code> State Management: The wrapper automatically manages controller state between calls: - Classical SMC: No state management needed - STA SMC: Updates integration variables (z, Ïƒ) - Adaptive SMC: Updates adaptation parameters - Hybrid SMC: Updates mode and adaptation state Error Recovery: If control computation fails: 1. Log error for debugging 2. Return safe fallback control (zero) 3. Increment error counter for monitoring 4. Continue operation (donâ€™t crash PSO) â€œâ€â€ import time # Performance tracking start_time = time.perf_counter() self._call_count += 1 try: # Input validation if not isinstance(state, np.ndarray): state = np.array(state) if state.shape != (6,): raise ValueError(fâ€State must be 6-element array, got shape {state.shape}â€) if not np.all(np.isfinite(state)): raise ValueError(â€œState contains non-finite values (NaN or inf)â€) # Use provided parameters or defaults final_state_vars = state_vars if state_vars is not None else self._state_vars final_history = history if history is not None else self._history # Call underlying controller result = self.controller.compute_control(state, final_state_vars, final_history) # Extract control value from result # Handle different controller output formats if hasattr(result, â€˜uâ€™): # Standard controller output with .u attribute control_value = result.u # Update state variables if available if hasattr(result, â€˜state_varsâ€™): self._state_vars = result.state_vars elif hasattr(result, â€˜controlâ€™): # Alternative output format with .control attribute control_value = result.control elif isinstance(result, dict): # Dictionary output format if â€˜uâ€™ in result: control_value = result[â€˜uâ€™] elif â€˜controlâ€™ in result: control_value = result[â€˜controlâ€™] else: raise ValueError(â€œDictionary result missing control valueâ€) # Update state if provided if â€˜state_varsâ€™ in result: self._state_vars = result[â€˜state_varsâ€™] elif isinstance(result, tuple): # Tuple output (e.g., early return from some controllers) control_value = result[0] # First element is control if len(result) &gt; 1: self._state_vars = result[1] # Second element is state else: # Assume result is the control value directly control_value = result # Convert to scalar if needed if isinstance(control_value, np.ndarray): if control_value.size == 1: control_value = float(control_value) else: control_value = float(control_value[0]) elif not isinstance(control_value, (int, float)): control_value = float(control_value) # Validate output if not np.isfinite(control_value): raise ValueError(â€œController returned non-finite control valueâ€) # Apply saturation (defensive programming) max_force = getattr(self.controller, â€˜max_forceâ€™, 100.0) control_saturated = np.clip(control_value, -max_force, max_force) # For simplified interface (PSO usage), return numpy array if state_vars is None and history is None: output = np.array([control_saturated]) else: # For full interface, return in format expected by simulation output = control_saturated # Performance tracking compute_time = time.perf_counter() - start_time self._total_compute_time += compute_time return output except Exception as e: # Error handling for robust PSO operation self._last_error = str(e) # Log error for debugging (in production, use proper logging) print(fâ€Warning: Control computation failed: {e}â€) # Return safe fallback control if state_vars is None and history is None: return np.array([0.0]) # PSO interface else: return 0.0 # Full interface &#64;property def gains(self) -&gt; List[float]: â€œâ€â€ Return controller gains. Returns: List of controller gain parameters Usage: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">controller</span> <span class="pre">=</span> <span class="pre">create_smc_for_pso(SMCType.CLASSICAL,</span> <span class="pre">gains)</span> <span class="pre">print(f&quot;Controller</span> <span class="pre">gains:</span> <span class="pre">{controller.gains}&quot;)</span> </code> â€œâ€â€ return self.controller.gains &#64;property def performance_stats(self) -&gt; Dict[str, Any]: â€œâ€â€ Return performance statistics for monitoring. Returns: Dictionary with performance metrics: - call_count: Number of control computations - total_time: Total computation time [s] - average_time: Average computation time [ms] - last_error: Last error message (if any) Usage: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">#</span> <span class="pre">After</span> <span class="pre">PSO</span> <span class="pre">optimization</span> <span class="pre">stats</span> <span class="pre">=</span> <span class="pre">controller.performance_stats</span> <span class="pre">print(f&quot;Average</span> <span class="pre">computation</span> <span class="pre">time:</span> <span class="pre">{stats['average_time']:.3f}ms&quot;)</span> </code> â€œâ€â€ avg_time_ms = (self._total_compute_time / self._call_count * 1000 if self._call_count &gt; 0 else 0.0) return { â€˜call_countâ€™: self._call_count, â€˜total_timeâ€™: self._total_compute_time, â€˜average_timeâ€™: avg_time_ms, â€˜last_errorâ€™: self._last_error } def reset_performance_stats(self) -&gt; None: â€œâ€â€Reset performance tracking statistics.â€â€â€ self._call_count = 0 self._total_compute_time = 0.0 self._last_error = None def validate_state_input(self, state: np.ndarray) -&gt; Tuple[bool, str]: â€œâ€â€ Validate state input for control computation. Args: state: State vector to validate Returns: Tuple of (is_valid, error_message) Usage: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">is_valid,</span> <span class="pre">error</span> <span class="pre">=</span> <span class="pre">controller.validate_state_input(test_state)</span> <span class="pre">if</span> <span class="pre">not</span> <span class="pre">is_valid:</span> <span class="pre">print(f&quot;Invalid</span> <span class="pre">state:</span> <span class="pre">{error}&quot;)</span> </code> â€œâ€â€ try: if not isinstance(state, np.ndarray): return False, â€œState must be numpy arrayâ€ if state.shape != (6,): return False, fâ€State must be 6-element array, got {state.shape}â€ if not np.all(np.isfinite(state)): return False, â€œState contains non-finite valuesâ€ # Check reasonable ranges (optional) angles = state[:2] # Î¸â‚, Î¸â‚‚ if np.any(np.abs(angles) &gt; 2*np.pi): return False, â€œAngles exceed reasonable range (Â±2Ï€)â€ velocities = state[3:] # Î¸Ì‡â‚, Î¸Ì‡â‚‚, áº‹ if np.any(np.abs(velocities) &gt; 100): return False, â€œVelocities exceed reasonable range (Â±100)â€ return True, â€œâ€ except Exception as e: return False, fâ€Validation error: {e}â€ def <strong>repr</strong>(self) -&gt; str: â€œâ€â€String representation for debugging.â€â€â€ controller_type = type(self.controller).<strong>name</strong> return fâ€PSOControllerWrapper({controller_type}, gains={self.gains})â€</a><ul>
<li><a class="reference internal" href="#configuration-schema-api-factory-configuration-classes-python">Configuration Schema API ### Factory Configuration Classes ```python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id3">example-metadata:</a></li>
<li><a class="reference internal" href="#id4">runnable: false &#64;dataclass(frozen=True)</a><ul>
<li><a class="reference internal" href="#performance-monitoring-api-real-time-performance-monitoring-python">Performance Monitoring API ### Real-Time Performance Monitoring ```python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id5">example-metadata:</a></li>
<li><a class="reference internal" href="#runnable-false-class-psoperformancemonitor-real-time-performance-monitoring-for-pso-factory-integration-provides-monitoring-of-pso-convergence-metrics-controller-creation-performance-simulation-execution-times-memory-usage-tracking-error-rate-monitoring-def-init-self-monitoring-config-dict-str-any-self-config-monitoring-config-self-metrics-pso-metrics-total-evaluations-0-successful-evaluations-0-failed-evaluations-0-average-fitness-0-0-best-fitness-float-inf-convergence-rate-0-0-performance-metrics-controller-creation-time-simulation-execution-time-fitness-computation-time-total-optimization-time-0-0-resource-metrics-peak-memory-usage-0-0-average-memory-usage-0-0-cpu-utilization-memory-samples-error-metrics-creation-failures-0-simulation-failures-0-validation-failures-0-total-errors-0-self-start-time-none-self-monitoring-active-false-def-start-monitoring-self-start-performance-monitoring-session-import-time-self-start-time-time-time-self-monitoring-active-true-self-reset-metrics-def-stop-monitoring-self-dict-str-any-stop-monitoring-and-return-complete-performance-report-import-time-if-self-start-time-self-metrics-performance-metrics-total-optimization-time-time-time-self-start-time-self-monitoring-active-false-return-self-generate-performance-report-def-log-controller-creation-self-success-bool-creation-time-float-log-controller-creation-event-if-not-self-monitoring-active-return-self-metrics-performance-metrics-controller-creation-time-append-creation-time-if-success-self-metrics-pso-metrics-successful-evaluations-1-else-self-metrics-error-metrics-creation-failures-1-self-metrics-pso-metrics-failed-evaluations-1-def-log-simulation-execution-self-success-bool-execution-time-float-log-simulation-execution-event-if-not-self-monitoring-active-return-if-success-self-metrics-performance-metrics-simulation-execution-time-append-execution-time-else-self-metrics-error-metrics-simulation-failures-1-def-log-fitness-evaluation-self-fitness-value-float-computation-time-float-log-fitness-evaluation-result-if-not-self-monitoring-active-return-self-metrics-performance-metrics-fitness-computation-time-append-computation-time-self-metrics-pso-metrics-total-evaluations-1-update-best-fitness-if-fitness-value-self-metrics-pso-metrics-best-fitness-self-metrics-pso-metrics-best-fitness-fitness-value-update-average-fitness-running-average-total-evals-self-metrics-pso-metrics-total-evaluations-current-avg-self-metrics-pso-metrics-average-fitness-self-metrics-pso-metrics-average-fitness-current-avg-total-evals-1-fitness-value-total-evals-def-log-resource-usage-self-log-current-resource-usage-if-not-self-monitoring-active-return-try-import-psutil-memory-usage-memory-info-psutil-virtual-memory-current-memory-memory-info-percent-self-metrics-resource-metrics-memory-samples-append-current-memory-update-peak-memory-if-current-memory-self-metrics-resource-metrics-peak-memory-usage-self-metrics-resource-metrics-peak-memory-usage-current-memory-cpu-utilization-cpu-percent-psutil-cpu-percent-interval-none-self-metrics-resource-metrics-cpu-utilization-append-cpu-percent-except-importerror-pass-psutil-not-available-def-check-performance-alerts-self-list-str-check-for-performance-issues-and-return-alerts-alerts-memory-usage-alerts-if-self-metrics-resource-metrics-peak-memory-usage-90-alerts-append-f-high-memory-usage-self-metrics-resource-metrics-peak-memory-usage-1f-error-rate-alerts-total-evals-self-metrics-pso-metrics-total-evaluations-if-total-evals-0-error-rate-self-metrics-error-metrics-total-errors-total-evals-if-error-rate-0-1-alerts-append-f-high-error-rate-error-rate-1-performance-alerts-creation-times-self-metrics-performance-metrics-controller-creation-time-if-creation-times-and-np-mean-creation-times-0-002-2ms-threshold-alerts-append-f-slow-controller-creation-np-mean-creation-times-1000-2f-ms-average-return-alerts-def-generate-performance-report-self-dict-str-any-generate-performance-report-calculate-derived-metrics-total-evals-self-metrics-pso-metrics-total-evaluations-success-rate-self-metrics-pso-metrics-successful-evaluations-total-evals-100-if-total-evals-0-else-0-creation-times-self-metrics-performance-metrics-controller-creation-time-avg-creation-time-np-mean-creation-times-if-creation-times-else-0-simulation-times-self-metrics-performance-metrics-simulation-execution-time-avg-simulation-time-np-mean-simulation-times-if-simulation-times-else-0-fitness-times-self-metrics-performance-metrics-fitness-computation-time-avg-fitness-time-np-mean-fitness-times-if-fitness-times-else-0-memory-samples-self-metrics-resource-metrics-memory-samples-avg-memory-np-mean-memory-samples-if-memory-samples-else-0-cpu-samples-self-metrics-resource-metrics-cpu-utilization-avg-cpu-np-mean-cpu-samples-if-cpu-samples-else-0-total-time-self-metrics-performance-metrics-total-optimization-time-evaluations-per-second-total-evals-total-time-if-total-time-0-else-0-generate-report-report-summary-total-evaluations-total-evals-success-rate-success-rate-best-fitness-achieved-self-metrics-pso-metrics-best-fitness-total-optimization-time-total-time-evaluations-per-second-evaluations-per-second-performance-average-controller-creation-time-ms-avg-creation-time-1000-average-simulation-time-ms-avg-simulation-time-1000-average-fitness-computation-time-ms-avg-fitness-time-1000-resources-peak-memory-usage-percent-self-metrics-resource-metrics-peak-memory-usage-average-memory-usage-percent-avg-memory-average-cpu-utilization-percent-avg-cpu-errors-controller-creation-failures-self-metrics-error-metrics-creation-failures-simulation-failures-self-metrics-error-metrics-simulation-failures-validation-failures-self-metrics-error-metrics-validation-failures-total-error-count-self-metrics-error-metrics-total-errors-alerts-self-check-performance-alerts-raw-metrics-self-metrics-return-report-def-reset-metrics-self-reset-all-metrics-for-new-monitoring-session-for-category-in-self-metrics-values-if-isinstance-category-dict-for-key-value-in-category-items-if-isinstance-value-list-category-key-elif-isinstance-value-int-float-if-best-fitness-in-key-category-key-float-inf-else-category-key-0-context-manager-for-automatic-monitoring">runnable: false class PSOPerformanceMonitor: â€œâ€â€ Real-time performance monitoring for PSO-Factory integration. Provides monitoring of: - PSO convergence metrics - Controller creation performance - Simulation execution times - Memory usage tracking - Error rate monitoring â€œâ€â€ def <strong>init</strong>(self, monitoring_config: Dict[str, Any]): self.config = monitoring_config self.metrics = { â€˜pso_metricsâ€™: { â€˜total_evaluationsâ€™: 0, â€˜successful_evaluationsâ€™: 0, â€˜failed_evaluationsâ€™: 0, â€˜average_fitnessâ€™: 0.0, â€˜best_fitnessâ€™: float(â€˜infâ€™), â€˜convergence_rateâ€™: 0.0 }, â€˜performance_metricsâ€™: { â€˜controller_creation_timeâ€™: [], â€˜simulation_execution_timeâ€™: [], â€˜fitness_computation_timeâ€™: [], â€˜total_optimization_timeâ€™: 0.0 }, â€˜resource_metricsâ€™: { â€˜peak_memory_usageâ€™: 0.0, â€˜average_memory_usageâ€™: 0.0, â€˜cpu_utilizationâ€™: [], â€˜memory_samplesâ€™: [] }, â€˜error_metricsâ€™: { â€˜creation_failuresâ€™: 0, â€˜simulation_failuresâ€™: 0, â€˜validation_failuresâ€™: 0, â€˜total_errorsâ€™: 0 } } self.start_time = None self.monitoring_active = False def start_monitoring(self): â€œâ€â€Start performance monitoring session.â€â€â€ import time self.start_time = time.time() self.monitoring_active = True self._reset_metrics() def stop_monitoring(self) -&gt; Dict[str, Any]: â€œâ€â€Stop monitoring and return complete performance report.â€â€â€ import time if self.start_time: self.metrics[â€˜performance_metricsâ€™][â€˜total_optimization_timeâ€™] = ( time.time() - self.start_time ) self.monitoring_active = False return self.generate_performance_report() def log_controller_creation(self, success: bool, creation_time: float): â€œâ€â€Log controller creation event.â€â€â€ if not self.monitoring_active: return self.metrics[â€˜performance_metricsâ€™][â€˜controller_creation_timeâ€™].append(creation_time) if success: self.metrics[â€˜pso_metricsâ€™][â€˜successful_evaluationsâ€™] += 1 else: self.metrics[â€˜error_metricsâ€™][â€˜creation_failuresâ€™] += 1 self.metrics[â€˜pso_metricsâ€™][â€˜failed_evaluationsâ€™] += 1 def log_simulation_execution(self, success: bool, execution_time: float): â€œâ€â€Log simulation execution event.â€â€â€ if not self.monitoring_active: return if success: self.metrics[â€˜performance_metricsâ€™][â€˜simulation_execution_timeâ€™].append(execution_time) else: self.metrics[â€˜error_metricsâ€™][â€˜simulation_failuresâ€™] += 1 def log_fitness_evaluation(self, fitness_value: float, computation_time: float): â€œâ€â€Log fitness evaluation result.â€â€â€ if not self.monitoring_active: return self.metrics[â€˜performance_metricsâ€™][â€˜fitness_computation_timeâ€™].append(computation_time) self.metrics[â€˜pso_metricsâ€™][â€˜total_evaluationsâ€™] += 1 # Update best fitness if fitness_value &lt; self.metrics[â€˜pso_metricsâ€™][â€˜best_fitnessâ€™]: self.metrics[â€˜pso_metricsâ€™][â€˜best_fitnessâ€™] = fitness_value # Update average fitness (running average) total_evals = self.metrics[â€˜pso_metricsâ€™][â€˜total_evaluationsâ€™] current_avg = self.metrics[â€˜pso_metricsâ€™][â€˜average_fitnessâ€™] self.metrics[â€˜pso_metricsâ€™][â€˜average_fitnessâ€™] = ( (current_avg * (total_evals - 1) + fitness_value) / total_evals ) def log_resource_usage(self): â€œâ€â€Log current resource usage.â€â€â€ if not self.monitoring_active: return try: import psutil # Memory usage memory_info = psutil.virtual_memory() current_memory = memory_info.percent self.metrics[â€˜resource_metricsâ€™][â€˜memory_samplesâ€™].append(current_memory) # Update peak memory if current_memory &gt; self.metrics[â€˜resource_metricsâ€™][â€˜peak_memory_usageâ€™]: self.metrics[â€˜resource_metricsâ€™][â€˜peak_memory_usageâ€™] = current_memory # CPU utilization cpu_percent = psutil.cpu_percent(interval=None) self.metrics[â€˜resource_metricsâ€™][â€˜cpu_utilizationâ€™].append(cpu_percent) except ImportError: pass # psutil not available def check_performance_alerts(self) -&gt; List[str]: â€œâ€â€Check for performance issues and return alerts.â€â€â€ alerts = [] # Memory usage alerts if self.metrics[â€˜resource_metricsâ€™][â€˜peak_memory_usageâ€™] &gt; 90: alerts.append(fâ€High memory usage: {self.metrics[â€˜resource_metricsâ€™][â€˜peak_memory_usageâ€™]:.1f}%â€) # Error rate alerts total_evals = self.metrics[â€˜pso_metricsâ€™][â€˜total_evaluationsâ€™] if total_evals &gt; 0: error_rate = self.metrics[â€˜error_metricsâ€™][â€˜total_errorsâ€™] / total_evals if error_rate &gt; 0.1: alerts.append(fâ€High error rate: {error_rate:.1%}â€) # Performance alerts creation_times = self.metrics[â€˜performance_metricsâ€™][â€˜controller_creation_timeâ€™] if creation_times and np.mean(creation_times) &gt; 0.002: # 2ms threshold alerts.append(fâ€Slow controller creation: {np.mean(creation_times)*1000:.2f}ms averageâ€) return alerts def generate_performance_report(self) -&gt; Dict[str, Any]: â€œâ€â€Generate performance report.â€â€â€ # Calculate derived metrics total_evals = self.metrics[â€˜pso_metricsâ€™][â€˜total_evaluationsâ€™] success_rate = (self.metrics[â€˜pso_metricsâ€™][â€˜successful_evaluationsâ€™] / total_evals * 100 if total_evals &gt; 0 else 0) creation_times = self.metrics[â€˜performance_metricsâ€™][â€˜controller_creation_timeâ€™] avg_creation_time = np.mean(creation_times) if creation_times else 0 simulation_times = self.metrics[â€˜performance_metricsâ€™][â€˜simulation_execution_timeâ€™] avg_simulation_time = np.mean(simulation_times) if simulation_times else 0 fitness_times = self.metrics[â€˜performance_metricsâ€™][â€˜fitness_computation_timeâ€™] avg_fitness_time = np.mean(fitness_times) if fitness_times else 0 memory_samples = self.metrics[â€˜resource_metricsâ€™][â€˜memory_samplesâ€™] avg_memory = np.mean(memory_samples) if memory_samples else 0 cpu_samples = self.metrics[â€˜resource_metricsâ€™][â€˜cpu_utilizationâ€™] avg_cpu = np.mean(cpu_samples) if cpu_samples else 0 total_time = self.metrics[â€˜performance_metricsâ€™][â€˜total_optimization_timeâ€™] evaluations_per_second = total_evals / total_time if total_time &gt; 0 else 0 # Generate report report = { â€˜summaryâ€™: { â€˜total_evaluationsâ€™: total_evals, â€˜success_rateâ€™: success_rate, â€˜best_fitness_achievedâ€™: self.metrics[â€˜pso_metricsâ€™][â€˜best_fitnessâ€™], â€˜total_optimization_timeâ€™: total_time, â€˜evaluations_per_secondâ€™: evaluations_per_second }, â€˜performanceâ€™: { â€˜average_controller_creation_time_msâ€™: avg_creation_time * 1000, â€˜average_simulation_time_msâ€™: avg_simulation_time * 1000, â€˜average_fitness_computation_time_msâ€™: avg_fitness_time * 1000 }, â€˜resourcesâ€™: { â€˜peak_memory_usage_percentâ€™: self.metrics[â€˜resource_metricsâ€™][â€˜peak_memory_usageâ€™], â€˜average_memory_usage_percentâ€™: avg_memory, â€˜average_cpu_utilization_percentâ€™: avg_cpu }, â€˜errorsâ€™: { â€˜controller_creation_failuresâ€™: self.metrics[â€˜error_metricsâ€™][â€˜creation_failuresâ€™], â€˜simulation_failuresâ€™: self.metrics[â€˜error_metricsâ€™][â€˜simulation_failuresâ€™], â€˜validation_failuresâ€™: self.metrics[â€˜error_metricsâ€™][â€˜validation_failuresâ€™], â€˜total_error_countâ€™: self.metrics[â€˜error_metricsâ€™][â€˜total_errorsâ€™] }, â€˜alertsâ€™: self.check_performance_alerts(), â€˜raw_metricsâ€™: self.metrics } return report def _reset_metrics(self): â€œâ€â€Reset all metrics for new monitoring session.â€â€â€ for category in self.metrics.values(): if isinstance(category, dict): for key, value in category.items(): if isinstance(value, list): category[key] = [] elif isinstance(value, (int, float)): if â€˜best_fitnessâ€™ in key: category[key] = float(â€˜infâ€™) else: category[key] = 0 # Context manager for automatic monitoring</a><ul>
<li><a class="reference internal" href="#usage-examples-complete-pso-optimization-workflow-python">Usage Examples ### Complete PSO Optimization Workflow ```python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id6">example-metadata:</a></li>
<li><a class="reference internal" href="#runnable-false-def-complete-pso-optimization-example-complete-example-demonstrating-pso-factory-integration-this-example-shows-1-configuration-setup-2-controller-creation-and-validation-3-pso-optimization-execution-4-performance-monitoring-5-results-analysis-and-validation-step-1-configuration-setup-pso-config-psofactoryconfig-controller-type-smctype-classical-max-force-100-0-dt-0-01-pso-params-n-particles-30-iters-100-c1-2-0-c2-2-0-w-0-9-enable-monitoring-true-strict-validation-true-step-2-simulation-configuration-simulation-config-duration-5-0-dt-0-01-initial-state-0-1-0-1-0-0-0-0-0-0-0-0-small-perturbation-disturbances-enable-true-amplitude-5-0-frequency-1-0-performance-objectives-ise-overshoot-control-effort-step-3-pso-optimization-with-monitoring-with-monitor-pso-performance-pso-config-pso-params-as-monitor-define-fitness-function-handle-pso-errors-def-fitness-function-particles-np-ndarray-np-ndarray-fitness-scores-for-gains-in-particles-start-time-time-perf-counter-try-create-controller-with-validation-controller-create-smc-for-pso-pso-config-controller-type-gains-tolist-pso-config-max-force-creation-time-time-perf-counter-start-time-monitor-log-controller-creation-true-creation-time-run-simulation-sim-start-time-perf-counter-result-run-simulation-controller-simulation-config-sim-time-time-perf-counter-sim-start-monitor-log-simulation-execution-true-sim-time-compute-fitness-fitness-start-time-perf-counter-fitness-compute-multi-objective-fitness-result-simulation-config-performance-objectives-fitness-time-time-perf-counter-fitness-start-monitor-log-fitness-evaluation-fitness-fitness-time-fitness-scores-append-fitness-except-exception-as-e-monitor-log-controller-creation-false-0-0-fitness-scores-append-1000-0-log-resource-usage-periodically-if-len-fitness-scores-10-0-monitor-log-resource-usage-return-np-array-fitness-scores-step-4-execute-pso-optimization-from-pyswarms-single-import-globalbestpso-bounds-pso-config-gain-bounds-bounds-array-np-array-bounds-optimizer-globalbestpso-n-particles-pso-config-pso-params-n-particles-dimensions-pso-config-n-gains-options-c1-pso-config-pso-params-c1-c2-pso-config-pso-params-c2-w-pso-config-pso-params-w-bounds-bounds-array-0-bounds-array-1-print-starting-pso-optimization-best-cost-best-gains-optimizer-optimize-fitness-function-iters-pso-config-pso-params-iters-verbose-true-step-5-results-analysis-performance-report-monitor-generate-performance-report-validate-optimized-controller-optimized-controller-create-smc-for-pso-pso-config-controller-type-best-gains-tolist-pso-config-max-force-run-validation-simulation-validation-result-run-simulation-optimized-controller-simulation-config-validation-metrics-compute-validation-metrics-validation-result-step-6-generate-report-optimization-report-optimization-results-best-gains-best-gains-tolist-best-fitness-float-best-cost-optimization-history-optimizer-cost-history-convergence-iteration-find-convergence-iteration-optimizer-cost-history-validation-results-controller-gains-optimized-controller-gains-performance-metrics-validation-metrics-stability-analysis-estimate-stability-properties-pso-config-controller-type-best-gains-tolist-performance-report-performance-report-configuration-pso-config-pso-config-dict-simulation-config-simulation-config-bounds-used-bounds-step-7-display-results-print-optimization-summary-optimization-report-return-optimization-report-def-print-optimization-summary-report-dict-str-any-print-formatted-optimization-summary-opt-results-report-optimization-results-val-results-report-validation-results-perf-report-report-performance-report-print-n-80-print-pso-optimization-results-summary-print-80-print-f-n-optimization-results-print-f-best-fitness-opt-results-best-fitness-6f-print-f-best-gains-opt-results-best-gains-print-f-convergence-iteration-opt-results-convergence-iteration-print-f-n-validation-metrics-for-metric-value-in-val-results-performance-metrics-items-print-f-metric-upper-value-4f-print-f-n-performance-summary-summary-perf-report-summary-print-f-total-evaluations-summary-total-evaluations-print-f-success-rate-summary-success-rate-1f-print-f-evaluations-sec-summary-evaluations-per-second-1f-print-f-total-time-summary-total-optimization-time-1f-s-perf-perf-report-performance-print-f-avg-creation-time-perf-average-controller-creation-time-ms-2f-ms-print-f-avg-simulation-time-perf-average-simulation-time-ms-2f-ms-resources-perf-report-resources-print-f-peak-memory-resources-peak-memory-usage-percent-1f-print-f-avg-cpu-resources-average-cpu-utilization-percent-1f-if-perf-report-alerts-print-f-n-performance-alerts-for-alert-in-perf-report-alerts-print-f-alert-print-n-80-def-find-convergence-iteration-cost-history-list-float-tolerance-float-1e-6-patience-int-10-int-find-iteration-where-pso-converged-if-len-cost-history-patience-return-len-cost-history-for-i-in-range-patience-len-cost-history-check-if-fitness-has-been-stable-for-patience-iterations-recent-costs-cost-history-i-patience-i-if-max-recent-costs-min-recent-costs-tolerance-return-i-patience-1-return-len-cost-history-no-convergence-detected-run-the-complete-example">runnable: false def complete_pso_optimization_example(): â€œâ€â€ Complete example demonstrating PSO-Factory integration. This example shows: 1. Configuration setup 2. Controller creation and validation 3. PSO optimization execution 4. Performance monitoring 5. Results analysis and validation â€œâ€â€ # Step 1: Configuration setup pso_config = PSOFactoryConfig( controller_type=SMCType.CLASSICAL, max_force=100.0, dt=0.01, pso_params={ â€˜n_particlesâ€™: 30, â€˜itersâ€™: 100, â€˜c1â€™: 2.0, â€˜c2â€™: 2.0, â€˜wâ€™: 0.9 }, enable_monitoring=True, strict_validation=True ) # Step 2: Simulation configuration simulation_config = { â€˜durationâ€™: 5.0, â€˜dtâ€™: 0.01, â€˜initial_stateâ€™: [0.1, 0.1, 0.0, 0.0, 0.0, 0.0], # Small perturbation â€˜disturbancesâ€™: { â€˜enableâ€™: True, â€˜amplitudeâ€™: 5.0, â€˜frequencyâ€™: 1.0 }, â€˜performance_objectivesâ€™: [â€˜iseâ€™, â€˜overshootâ€™, â€˜control_effortâ€™] } # Step 3: PSO optimization with monitoring with monitor_pso_performance(pso_config.pso_params) as monitor: # Define fitness function &#64;handle_pso_errors def fitness_function(particles: np.ndarray) -&gt; np.ndarray: fitness_scores = [] for gains in particles: start_time = time.perf_counter() try: # Create controller with validation controller = create_smc_for_pso( pso_config.controller_type, gains.tolist(), pso_config.max_force ) creation_time = time.perf_counter() - start_time monitor.log_controller_creation(True, creation_time) # Run simulation sim_start = time.perf_counter() result = run_simulation(controller, simulation_config) sim_time = time.perf_counter() - sim_start monitor.log_simulation_execution(True, sim_time) # Compute fitness fitness_start = time.perf_counter() fitness = compute_multi_objective_fitness( result, simulation_config[â€˜performance_objectivesâ€™] ) fitness_time = time.perf_counter() - fitness_start monitor.log_fitness_evaluation(fitness, fitness_time) fitness_scores.append(fitness) except Exception as e: monitor.log_controller_creation(False, 0.0) fitness_scores.append(1000.0) # Log resource usage periodically if len(fitness_scores) % 10 == 0: monitor.log_resource_usage() return np.array(fitness_scores) # Step 4: Execute PSO optimization from pyswarms.single import GlobalBestPSO bounds = pso_config.gain_bounds bounds_array = np.array(bounds) optimizer = GlobalBestPSO( n_particles=pso_config.pso_params[â€˜n_particlesâ€™], dimensions=pso_config.n_gains, options={ â€˜c1â€™: pso_config.pso_params[â€˜c1â€™], â€˜c2â€™: pso_config.pso_params[â€˜c2â€™], â€˜wâ€™: pso_config.pso_params[â€˜wâ€™] }, bounds=(bounds_array[:, 0], bounds_array[:, 1]) ) print(â€œStarting PSO optimizationâ€¦â€) best_cost, best_gains = optimizer.optimize( fitness_function, iters=pso_config.pso_params[â€˜itersâ€™], verbose=True ) # Step 5: Results analysis performance_report = monitor.generate_performance_report() # Validate optimized controller optimized_controller = create_smc_for_pso( pso_config.controller_type, best_gains.tolist(), pso_config.max_force ) # Run validation simulation validation_result = run_simulation(optimized_controller, simulation_config) validation_metrics = compute_validation_metrics(validation_result) # Step 6: Generate report optimization_report = { â€˜optimization_resultsâ€™: { â€˜best_gainsâ€™: best_gains.tolist(), â€˜best_fitnessâ€™: float(best_cost), â€˜optimization_historyâ€™: optimizer.cost_history, â€˜convergence_iterationâ€™: find_convergence_iteration(optimizer.cost_history) }, â€˜validation_resultsâ€™: { â€˜controller_gainsâ€™: optimized_controller.gains, â€˜performance_metricsâ€™: validation_metrics, â€˜stability_analysisâ€™: estimate_stability_properties( pso_config.controller_type, best_gains.tolist() ) }, â€˜performance_reportâ€™: performance_report, â€˜configurationâ€™: { â€˜pso_configâ€™: pso_config.<strong>dict</strong>, â€˜simulation_configâ€™: simulation_config, â€˜bounds_usedâ€™: bounds } } # Step 7: Display results print_optimization_summary(optimization_report) return optimization_report def print_optimization_summary(report: Dict[str, Any]): â€œâ€â€Print formatted optimization summary.â€â€â€ opt_results = report[â€˜optimization_resultsâ€™] val_results = report[â€˜validation_resultsâ€™] perf_report = report[â€˜performance_reportâ€™] print(â€œ\nâ€ + â€œ=â€*80) print(â€œPSO OPTIMIZATION RESULTS SUMMARYâ€) print(â€œ=â€*80) print(fâ€\nğŸ“Š OPTIMIZATION RESULTS:â€) print(fâ€ Best Fitness: {opt_results[â€˜best_fitnessâ€™]:.6f}â€) print(fâ€ Best Gains: {opt_results[â€˜best_gainsâ€™]}â€) print(fâ€ Convergence: Iteration {opt_results[â€˜convergence_iterationâ€™]}â€) print(fâ€\nğŸ¯ VALIDATION METRICS:â€) for metric, value in val_results[â€˜performance_metricsâ€™].items(): print(fâ€ {metric.upper()}: {value:.4f}â€) print(fâ€\nâš¡ PERFORMANCE SUMMARY:â€) summary = perf_report[â€˜summaryâ€™] print(fâ€ Total Evaluations: {summary[â€˜total_evaluationsâ€™]}â€) print(fâ€ Success Rate: {summary[â€˜success_rateâ€™]:.1f}%â€) print(fâ€ Evaluations/sec: {summary[â€˜evaluations_per_secondâ€™]:.1f}â€) print(fâ€ Total Time: {summary[â€˜total_optimization_timeâ€™]:.1f}sâ€) perf = perf_report[â€˜performanceâ€™] print(fâ€ Avg Creation Time: {perf[â€˜average_controller_creation_time_msâ€™]:.2f}msâ€) print(fâ€ Avg Simulation Time: {perf[â€˜average_simulation_time_msâ€™]:.2f}msâ€) resources = perf_report[â€˜resourcesâ€™] print(fâ€ Peak Memory: {resources[â€˜peak_memory_usage_percentâ€™]:.1f}%â€) print(fâ€ Avg CPU: {resources[â€˜average_cpu_utilization_percentâ€™]:.1f}%â€) if perf_report[â€˜alertsâ€™]: print(fâ€\nâš ï¸ PERFORMANCE ALERTS:â€) for alert in perf_report[â€˜alertsâ€™]: print(fâ€ - {alert}â€) print(â€œ\nâ€ + â€œ=â€*80) def find_convergence_iteration(cost_history: List[float], tolerance: float = 1e-6, patience: int = 10 ) -&gt; int: â€œâ€â€Find iteration where PSO converged.â€â€â€ if len(cost_history) &lt; patience: return len(cost_history) for i in range(patience, len(cost_history)): # Check if fitness has been stable for â€˜patienceâ€™ iterations recent_costs = cost_history[i-patience:i] if max(recent_costs) - min(recent_costs) &lt; tolerance: return i - patience + 1 return len(cost_history) # No convergence detected # Run the complete example</a></li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=8d563738"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=46bd48cc"></script>
    </body>
</html>