<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../genindex.html"><link rel="search" title="Search" href="../search.html"><link rel="next" title="Performance Benchmarks Reference Status: ğŸš§ Under Construction This document will contain performance benchmarking documentation including: ## Planned Content ### Benchmark Methodology" href="performance_benchmarks.html"><link rel="prev" title="PSO Optimization Guide Status: ğŸš§ Under Construction This document will contain PSO optimization documentation including: ## Planned Content ### PSO Algorithm Fundamentals" href="pso_optimization.html">

    <!-- Generated with Sphinx 7.4.7 and Furo 2025.09.25 -->
        <title>Simulation Engine API Reference Project: Double-Inverted Pendulum SMC Control System - DIP_SMC_PSO Documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d111a655" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=580074bf" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=8dab3a3b" />
    
    


<style>
  body {
    --color-code-background: #f2f2f2;
  --color-code-foreground: #1e1e1e;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">DIP_SMC_PSO Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  <span class="sidebar-brand-text">DIP_SMC_PSO Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../ACADEMIC_INTEGRITY_STATEMENT.html">Academic Integrity Statement <strong>Status:</strong> To be completed in Phase B (Citation System Implementation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CHANGELOG.html">Changelog All notable changes to the ResearchPlan validation system will be documented in this file. The format is based on Keep a Changelog,</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CITATIONS.html">Citations &amp; Academic Attribution <strong>Project:</strong> Double Inverted Pendulum - Sliding Mode Control with PSO Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CITATIONS_ACADEMIC.html">Academic Theory Citations &amp; References <strong>Project:</strong> Double Inverted Pendulum - Sliding Mode Control with PSO Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CITATION_SYSTEM.html">Citation System Documentation <strong>Status:</strong> To be completed in Phase B (Citation System Implementation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CONTRIBUTING.html">Contributing â€“ ResearchPlanSpec Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CONTROLLER_FACTORY.html">Controller Factory Documentation &gt; <strong>Note:</strong> This document has been consolidated into the Factory System Guide. ## Quick Links - <strong><span class="xref myst">Factory System Guide</span></strong> - Complete controller factory documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CROSS_REFERENCE_AUDIT_REPORT.html">Documentation Cross-Reference Audit Report <strong>Report Date:</strong> 2025-10-07</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DEPENDENCIES.html">Software Dependencies &amp; Citations <strong>Project:</strong> Double Inverted Pendulum - Sliding Mode Control with PSO Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DOCUMENTATION_COVERAGE_MATRIX.html">Documentation Coverage Matrix</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DOCUMENTATION_IMPLEMENTATION_PLAN.html">Documentation Coverage Implementation Plan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DOCUMENTATION_INVENTORY_SUMMARY.html">DIP-SMC-PSO Documentation Inventory Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DOCUMENTATION_STYLE_GUIDE.html">Documentation Style Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DOCUMENTATION_SYSTEM.html">ğŸ“š World-Class Documentation System for DIP_SMC_PSO ## ğŸŒŸ Overview This repository now features a <strong>world-class technical documentation system</strong> designed for research-grade publications. The system provides LaTeX-quality mathematical rendering, professional citation management, and cross-referencing features. ## âœ¨ Features ### ğŸ”¬ Research-Grade Mathematics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../EXAMPLE_VALIDATION_REPORT.html">Documentation Code Example Validation Report <strong>Report Date:</strong> 2025-10-07</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LICENSES.html">License Compliance &amp; Attribution <strong>Project:</strong> Double Inverted Pendulum - Sliding Mode Control with PSO Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PACKAGE_CONTENTS.html">Sphinx Documentation Implementation Package ## ğŸ“ Package Contents for ChatGPT Review This package contains the complete implementation of production-grade Sphinx documentation with GitHub CI/CD based on expert recommendations. ### ğŸš€ Core Implementation Files #### GitHub Workflows (Enhanced CI/CD)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PATTERNS.html">Software Design Patterns &amp; Architecture Attribution <strong>Project:</strong> Double Inverted Pendulum - Sliding Mode Control with PSO Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PATTERNS.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PATTERNS.html#runnable-false-src-controllers-factory-py-lines-507-543-def-create-controller-controller-type-str-config-optional-any-none-gains-optional-union-list-np-ndarray-none-any-create-a-controller-instance-of-the-specified-type-this-function-is-thread-safe-and-can-be-called-concurrently-supported-types-classical-smc-sta-smc-adaptive-smc-hybrid-adaptive-sta-smc-mpc-controller-normalize-controller-type-handles-aliases-controller-type-canonicalize-controller-type-controller-type-retrieve-from-registry-controller-info-get-controller-info-controller-type-controller-class-controller-info-class-resolve-gains-from-config-defaults-controller-gains-resolve-controller-gains-gains-config-controller-type-validate-gains-with-controller-specific-rules-validate-controller-gains-controller-gains-controller-info-create-and-return-configured-instance-return-controller-class-controller-gains-kwargs">runnable: false # src/controllers/factory.py (lines 507-543) def create_controller(controller_type: str, config: Optional[Any] = None, gains: Optional[Union[list, np.ndarray]] = None) -&gt; Any: â€œâ€â€ Create a controller instance of the specified type. This function is thread-safe and can be called concurrently. Supported types: â€˜classical_smcâ€™, â€˜sta_smcâ€™, â€˜adaptive_smcâ€™, â€˜hybrid_adaptive_sta_smcâ€™, â€˜mpc_controllerâ€™ â€œâ€â€ # Normalize controller type (handles aliases) controller_type = _canonicalize_controller_type(controller_type) # Retrieve from registry controller_info = _get_controller_info(controller_type) controller_class = controller_info[â€˜classâ€™] # Resolve gains from config/defaults controller_gains = _resolve_controller_gains(gains, config, controller_type) # Validate gains with controller-specific rules _validate_controller_gains(controller_gains, controller_info) # Create and return configured instance return controller_class(controller_gains, **kwargs)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PATTERNS.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PATTERNS.html#runnable-false-src-utils-validation-parameter-validators-py-def-validate-gains-n-expected-int-decorator-to-validate-gain-array-length-def-decorator-func-def-wrapper-self-gains-args-kwargs-if-len-gains-n-expected-raise-valueerror-f-expected-n-expected-gains-got-len-gains-return-func-self-gains-args-kwargs-return-wrapper-return-decorator-usage">runnable: false # src/utils/validation/parameter_validators.py def validate_gains(n_expected: int): â€œâ€â€Decorator to validate gain array length.â€â€â€ def decorator(func): def wrapper(self, gains, *args, **kwargs): if len(gains) != n_expected: raise ValueError(fâ€Expected {n_expected} gains, got {len(gains)}â€) return func(self, gains, *args, **kwargs) return wrapper return decorator # Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PLANT_CONFIGURATION.html">Plant Configuration Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PSO_Documentation_Validation_Report.html">PSO Documentation Validation Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PSO_INTEGRATION_GUIDE.html">PSO Integration Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../QUICKSTART_VALIDATION.html">Quick Start: Issue #12 Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Optimal Sliding Mode Control for a Double-Inverted Pendulum via PSO </a></li>
<li class="toctree-l1"><a class="reference internal" href="../RELEASE_CHECKLIST.html">Release Checklist Use this checklist when preparing a new release of the ResearchPlan validation system. ## Pre-Release ### Code &amp; Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_100_PERCENT_COMPLETION_REPORT.html">Sphinx Documentation - 100% Warning Elimination Complete</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE10_COMPLETION_REPORT.html">Sphinx Phase 10 Completion Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE11_COMPLETION_REPORT.html">Sphinx Phase 11 Completion Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE2_COMPLETION_REPORT.html">Phase 2 Completion Report: Live Python Code Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE3_COMPLETION_REPORT.html">Phase 3 Completion Report: Plotly Interactive Charts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE4_COMPLETION_REPORT.html">Phase 4: Jupyter Notebooks Integration - Completion Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE5_COMPLETION_REPORT.html">Phase 5 Completion Report: Mathematical Visualization Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE6_COMPLETION_REPORT.html">Phase 6 Completion Report: Progressive Web App (PWA)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE8_SUMMARY.html">Sphinx Documentation Phase 8 - Final Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE9_PROGRESS_REPORT.html">Sphinx Documentation Phase 9 - Final Progress Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TESTING.html">Testing Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../analysis_plan.html">5. Analysis &amp; Verification Plan ## ğŸ”§ <strong>Recent Testing Infrastructure Improvements</strong> (September 2024) ### <strong>Vector Simulation Engine Robustness</strong> The vector simulation engine (<code class="docutils literal notranslate"><span class="pre">src/simulation/engines/vector_sim.py</span></code>) has been enhanced with edge case handling and improved reliability: #### <strong>âœ… Fixes Applied</strong> 1. <strong>Scalar Control Input Support</strong> - <strong>Issue</strong>: <code class="docutils literal notranslate"><span class="pre">IndexError</span></code> when control input was 0-dimensional scalar - <strong>Fix</strong>: Added proper scalar handling with <code class="docutils literal notranslate"><span class="pre">.item()</span></code> extraction for 0D arrays - <strong>Benefit</strong>: Supports simplified test scenarios and edge cases 2. <strong>Flexible Control Sequence Length</strong> - <strong>Issue</strong>: Crashes when simulation horizon exceeded control input sequence length - <strong>Fix</strong>: Implemented graceful bounds checking with <code class="docutils literal notranslate"><span class="pre">min(i,</span> <span class="pre">length-1)</span></code> indexing strategy - <strong>Benefit</strong>: Uses last available control input when sequence is exhausted 3. <strong>Empty State Array Handling</strong> - <strong>Issue</strong>: Tests expected exceptions for empty arrays, but function handled them gracefully - <strong>Fix</strong>: Updated test expectations to match actual behavior (returns <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">0)</span></code> shaped array) - <strong>Benefit</strong>: Consistent behavior for degenerate cases 4. <strong>Mock Function Accuracy</strong> - <strong>Issue</strong>: Test mocks didnâ€™t reflect actual physics-based state evolution - <strong>Fix</strong>: Updated mock dynamics to properly simulate <code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">+</span> <span class="pre">dt</span> <span class="pre">*</span> <span class="pre">state_derivative</span></code> evolution - <strong>Benefit</strong>: Tests now validate realistic controller-plant interactions #### <strong>âœ… Test Coverage Improvements</strong> <strong>Vector Simulation Test Suite</strong>: Now <strong>100% passing</strong> (20/21 tests pass, 1 skipped)</a></li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">API Reference Documentation</a><input aria-label="Toggle navigation of API Reference Documentation" checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="controller_api_reference.html">Controller API Reference &gt; <strong>Note:</strong> Controller API documentation has been consolidated into references. ## Quick Links - <strong><span class="xref myst">Factory System API</span></strong> - Complete factory and controller creation API</a></li>
<li class="toctree-l2"><a class="reference internal" href="controller_theory.html">Controller Theory Reference <strong>Status:</strong> ğŸš§ Under Construction This document will contain controller theory documentation including: ## Planned Content ### Sliding Mode Control Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html">Factory System API Reference <strong>Module:</strong> <code class="docutils literal notranslate"><span class="pre">src.controllers.factory</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#runnable-false-thread-safe-factory-operations-with-timeout-protection">runnable: false # Thread-safe factory operations with timeout protection</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#runnable-false-def-list-available-controllers-list">runnable: false def list_available_controllers() -&gt; list</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#example-return-values">Example return values</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#runnable-false-controller-registry-dict-str-dict-str-any-controller-type-class-controllerclass-controller-class-reference-config-class-configclass-configuration-class-reference-default-gains-list-float-default-gain-vector-gain-count-int-expected-number-of-gains-description-str-human-readable-description-supports-dynamics-bool-whether-controller-uses-dynamics-model-required-params-list-str-required-configuration-parameters">runnable: false CONTROLLER_REGISTRY: Dict[str, Dict[str, Any]] = { â€˜controller_typeâ€™: { â€˜classâ€™: ControllerClass, # Controller class reference â€˜config_classâ€™: ConfigClass, # Configuration class reference â€˜default_gainsâ€™: List[float], # Default gain vector â€˜gain_countâ€™: int, # Expected number of gains â€˜descriptionâ€™: str, # Human-readable description â€˜supports_dynamicsâ€™: bool, # Whether controller uses dynamics model â€˜required_paramsâ€™: List[str] # Required configuration parameters }</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#runnable-false-class-psocontrollerwrapper-wrapper-for-smc-controllers-to-provide-pso-compatible-interface-def-init-self-controller-n-gains-int-controller-type-str-self-controller-controller-self-n-gains-n-gains-self-controller-type-controller-type-self-max-force-getattr-controller-max-force-150-0-self-dynamics-model-getattr-controller-dynamics-model-none-def-validate-gains-self-particles-np-ndarray-np-ndarray-validate-gain-particles-for-pso-optimization-checks-gain-count-finiteness-positivity-and-controller-specific-constraints-def-compute-control-self-state-np-ndarray-np-ndarray-pso-compatible-control-computation-interface-simplified-interface-for-pso-fitness-evaluation">runnable: false class PSOControllerWrapper: â€œâ€â€Wrapper for SMC controllers to provide PSO-compatible interface.â€â€â€ def <strong>init</strong>(self, controller, n_gains: int, controller_type: str): self.controller = controller self.n_gains = n_gains self.controller_type = controller_type self.max_force = getattr(controller, â€˜max_forceâ€™, 150.0) self.dynamics_model = getattr(controller, â€˜dynamics_modelâ€™, None) def validate_gains(self, particles: np.ndarray) -&gt; np.ndarray: â€œâ€â€Validate gain particles for PSO optimization.â€â€â€ # Checks gain count, finiteness, positivity, and controller-specific constraints â€¦ def compute_control(self, state: np.ndarray) -&gt; np.ndarray: â€œâ€â€PSO-compatible control computation interface.â€â€â€ # Simplified interface for PSO fitness evaluation â€¦</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#runnable-false-src-controllers-new-controller-py-import-numpy-as-np">runnable: false # src/controllers/new_controller.py import numpy as np</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#runnable-false-src-controllers-new-controller-config-py-from-dataclasses-import-dataclass">runnable: false # src/controllers/new_controller_config.py from dataclasses import dataclass</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#import-new-controller">Import new controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#add-aliases-for-convenience">Add aliases for convenience</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#runnable-false-add-to-smctype-enum">runnable: false # Add to SMCType enum</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#test-new-controller-py-from-src-controllers-factory-import-create-controller-get-default-gains">test_new_controller.py from src.controllers.factory import create_controller, get_default_gains</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#id7">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#runnable-false">runnable: false â€œâ€â€</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#id8">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#id9">runnable: false â€œâ€â€</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_reference.html">Factory API Reference ## Controller Factory System - GitHub Issue #6 Implementation ### Overview The Controller Factory System provides a unified, type-safe interface for creating and managing sliding mode control (SMC) controllers in the DIP-SMC-PSO project. This system implements the factory pattern to ensure consistent controller instantiation, parameter validation, and optimization integration. ### Architecture #### Core Components 1. <strong>Main Factory</strong> (<code class="docutils literal notranslate"><span class="pre">src/controllers/factory.py</span></code>) - Central controller registry and creation interface - Thread-safe operations with RLock protection - error handling and validation - Legacy compatibility support 2. <strong>SMC Factory</strong> (<code class="docutils literal notranslate"><span class="pre">src/controllers/factory/smc_factory.py</span></code>) - Specialized factory for SMC controllers - PSO optimization integration - Type-safe parameter handling 3. <strong>Legacy Factory</strong> (<code class="docutils literal notranslate"><span class="pre">src/controllers/factory/legacy_factory.py</span></code>) - Backward compatibility interface - Deprecation handling and migration support ### Supported Controllers | Controller Type | Class | Gains | Description |</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html">Factory Methods API Reference ## Overview This document provides API reference documentation for the Enterprise Controller Factory system. The factory provides thread-safe, type-safe controller instantiation with deep PSO integration and robust error handling. ## Table of Contents 1. <span class="xref myst">Core Factory Functions</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#basic-usage-with-default-parameters">Basic usage with default parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#runnable-false-def-list-available-controllers-list-str">runnable: false def list_available_controllers() -&gt; List[str]</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#output-classical-smc-sta-smc-adaptive-smc-hybrid-adaptive-sta-smc">Output: [â€˜classical_smcâ€™, â€˜sta_smcâ€™, â€˜adaptive_smcâ€™, â€˜hybrid_adaptive_sta_smcâ€™]</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#note-mpc-controller-only-included-if-optional-dependencies-available">Note: â€˜mpc_controllerâ€™ only included if optional dependencies available</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#runnable-false-def-get-default-gains-controller-type-str-list-float">runnable: false def get_default_gains(controller_type: str) -&gt; List[float]</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#runnable-false-get-default-gains-for-different-controllers">runnable: false # Get default gains for different controllers</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#output-20-0-15-0-12-0-8-0-35-0-5-0-adaptive-gains-get-default-gains-adaptive-smc">Output: [20.0, 15.0, 12.0, 8.0, 35.0, 5.0] adaptive_gains = get_default_gains(â€˜adaptive_smcâ€™)</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#output-25-0-18-0-15-0-10-0-4-0-use-as-starting-point-for-optimization">Output: [25.0, 18.0, 15.0, 10.0, 4.0] # Use as starting point for optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#runnable-false-create-factory-once-expensive-operation">runnable: false # Create factory once (expensive operation)</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#runnable-false-def-validate-smc-gains-smc-type-smctype-gains-union-list-np-ndarray-bool">runnable: false def validate_smc_gains(smc_type: SMCType, gains: Union[list, np.ndarray]) -&gt; bool</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#runnable-false-validate-gains-before-expensive-simulation">runnable: false # Validate gains before expensive simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#pattern-1-direct-controller-configuration">Pattern 1: Direct controller configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#type-aliases-for-better-type-safety">Type aliases for better type safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_methods_reference.html#runnable-false-class-controllerprotocol-protocol-protocol-defining-the-standard-controller-interface-def-compute-control-self-state-statevector-last-control-float-history-configdict-controloutput-compute-control-output-for-given-state-def-reset-self-none-reset-controller-internal-state-property-def-gains-self-list-float-return-controller-gains">runnable: false class ControllerProtocol(Protocol): â€œâ€â€Protocol defining the standard controller interface.â€â€â€ def compute_control( self, state: StateVector, last_control: float, history: ConfigDict ) -&gt; ControlOutput: â€œâ€â€Compute control output for given state.â€â€â€ â€¦ def reset(self) -&gt; None: â€œâ€â€Reset controller internal state.â€â€â€ â€¦ @property def gains(self) -&gt; List[float]: â€œâ€â€Return controller gains.â€â€â€ â€¦</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html">Optimization Module API Reference <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#runnable-false-usr-bin-env-python3">runnable: false #!/usr/bin/env python3</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#configuration">Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#config-path-config-yaml">============================================================================ CONFIG_PATH = â€œconfig.yamlâ€</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#convergence-monitoring-callback">Convergence Monitoring Callback</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#class-convergencemonitor-callback-for-real-time-convergence-monitoring-def-init-self-analyzer-enhancedconvergenceanalyzer-self-analyzer-analyzer-self-metrics-history-def-call-self-iteration-int-best-fitness-float-mean-fitness-float-fitness-std-float-swarm-positions-np-ndarray-check-convergence-at-each-iteration-status-metrics-self-analyzer-check-convergence-iteration-iteration-best-fitness-best-fitness-mean-fitness-mean-fitness-fitness-std-fitness-std-swarm-positions-swarm-positions-self-metrics-history-append-metrics-log-key-metrics-if-iteration-10-0-print-f-iter-iteration-3d-status-status-value-20s-f-best-metrics-best-fitness-6f-f-diversity-metrics-population-diversity-4f-f-conv-velocity-metrics-convergence-velocity-4e-f-predicted-remaining-metrics-predicted-iterations-remaining-3d-early-stopping-if-status-convergencestatus-converged-print-f-n-convergence-detected-at-iteration-iteration-return-true-signal-early-stop-elif-status-convergencestatus-stagnated-print-f-n-stagnation-detected-at-iteration-iteration-return-true-signal-early-stop-return-false-continue">============================================================================ class ConvergenceMonitor: â€œâ€â€Callback for real-time convergence monitoring.â€â€â€ def <strong>init</strong>(self, analyzer: EnhancedConvergenceAnalyzer): self.analyzer = analyzer self.metrics_history = [] def <strong>call</strong>(self, iteration: int, best_fitness: float, mean_fitness: float, fitness_std: float, swarm_positions: np.ndarray): â€œâ€â€Check convergence at each iteration.â€â€â€ status, metrics = self.analyzer.check_convergence( iteration=iteration, best_fitness=best_fitness, mean_fitness=mean_fitness, fitness_std=fitness_std, swarm_positions=swarm_positions ) self.metrics_history.append(metrics) # Log key metrics if iteration % 10 == 0: print(fâ€Iter {iteration:3d} | Status: {status.value:20s} | â€œ fâ€Best: {metrics.best_fitness:.6f} | â€œ fâ€Diversity: {metrics.population_diversity:.4f} | â€œ fâ€Conv. Velocity: {metrics.convergence_velocity:.4e} | â€œ fâ€Predicted Remaining: {metrics.predicted_iterations_remaining:3d}â€) # Early stopping if status == ConvergenceStatus.CONVERGED: print(fâ€\n&gt;&gt;&gt; CONVERGENCE DETECTED at iteration {iteration} &lt;&lt;&lt;â€) return True # Signal early stop elif status == ConvergenceStatus.STAGNATED: print(fâ€\n&gt;&gt;&gt; STAGNATION DETECTED at iteration {iteration} &lt;&lt;&lt;â€) return True # Signal early stop return False # Continue # ============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#main">Main</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#def-main-load-configuration-config-load-config-config-path-initialize-convergence-analyzer-with-custom-criteria-criteria-convergencecriteria-fitness-tolerance-1e-6-relative-improvement-threshold-1e-4-min-diversity-threshold-1e-3-max-stagnation-iterations-50-enable-performance-prediction-true-premature-convergence-detection-true-analyzer-enhancedconvergenceanalyzer-criteria-criteria-controller-type-smctype-sta-monitor-convergencemonitor-analyzer-create-controller-factory-controller-factory-partial-create-controller-controller-type-controller-type-config-config-initialize-pso-tuner-tuner-psotuner-controller-factory-controller-factory-config-config-seed-seed-run-optimization-with-monitoring-print-f-running-pso-optimization-with-real-time-convergence-monitoring-print-f-120-result-tuner-optimise-print-f-120-n-plot-convergence-metrics-metrics-monitor-metrics-history-iterations-m-iteration-for-m-in-metrics-best-fitness-m-best-fitness-for-m-in-metrics-diversity-m-population-diversity-for-m-in-metrics-conv-velocity-m-convergence-velocity-for-m-in-metrics-fig-axes-plt-subplots-3-1-figsize-12-10-best-fitness-axes-0-plot-iterations-best-fitness-linewidth-2-color-blue-axes-0-set-ylabel-best-fitness-fontsize-12-axes-0-set-yscale-log-axes-0-set-title-convergence-monitoring-sta-smc-fontsize-14-fontweight-bold-axes-0-grid-true-alpha-0-3-population-diversity-axes-1-plot-iterations-diversity-linewidth-2-color-green-axes-1-set-ylabel-population-diversity-fontsize-12-axes-1-grid-true-alpha-0-3-convergence-velocity-axes-2-plot-iterations-conv-velocity-linewidth-2-color-red-axes-2-set-ylabel-convergence-velocity-fontsize-12-axes-2-set-xlabel-iteration-fontsize-12-axes-2-grid-true-alpha-0-3-plt-tight-layout-plt-savefig-pso-convergence-monitoring-png-dpi-300-print-convergence-monitoring-plot-saved-pso-convergence-monitoring-png-if-name-main-main">============================================================================ def main(): # Load configuration config = load_config(CONFIG_PATH) # Initialize convergence analyzer with custom criteria criteria = ConvergenceCriteria( fitness_tolerance=1e-6, relative_improvement_threshold=1e-4, min_diversity_threshold=1e-3, max_stagnation_iterations=50, enable_performance_prediction=True, premature_convergence_detection=True ) analyzer = EnhancedConvergenceAnalyzer( criteria=criteria, controller_type=SMCType.STA ) monitor = ConvergenceMonitor(analyzer) # Create controller factory controller_factory = partial( create_controller, controller_type=CONTROLLER_TYPE, config=config ) # Initialize PSO tuner tuner = PSOTuner( controller_factory=controller_factory, config=config, seed=SEED ) # Run optimization with monitoring print(fâ€Running PSO optimization with real-time convergence monitoringâ€¦â€) print(fâ€{â€˜=â€™*120}â€) result = tuner.optimise() print(fâ€{â€˜=â€™*120}\nâ€) # Plot convergence metrics metrics = monitor.metrics_history iterations = [m.iteration for m in metrics] best_fitness = [m.best_fitness for m in metrics] diversity = [m.population_diversity for m in metrics] conv_velocity = [m.convergence_velocity for m in metrics] fig, axes = plt.subplots(3, 1, figsize=(12, 10)) # Best fitness axes[0].plot(iterations, best_fitness, linewidth=2, color=â€™blueâ€™) axes[0].set_ylabel(â€˜Best Fitnessâ€™, fontsize=12) axes[0].set_yscale(â€˜logâ€™) axes[0].set_title(â€˜Convergence Monitoring - STA SMCâ€™, fontsize=14, fontweight=â€™boldâ€™) axes[0].grid(True, alpha=0.3) # Population diversity axes[1].plot(iterations, diversity, linewidth=2, color=â€™greenâ€™) axes[1].set_ylabel(â€˜Population Diversityâ€™, fontsize=12) axes[1].grid(True, alpha=0.3) # Convergence velocity axes[2].plot(iterations, conv_velocity, linewidth=2, color=â€™redâ€™) axes[2].set_ylabel(â€˜Convergence Velocityâ€™, fontsize=12) axes[2].set_xlabel(â€˜Iterationâ€™, fontsize=12) axes[2].grid(True, alpha=0.3) plt.tight_layout() plt.savefig(â€˜pso_convergence_monitoring.pngâ€™, dpi=300) print(â€œConvergence monitoring plot saved: pso_convergence_monitoring.pngâ€) if <strong>name</strong> == â€œ<strong>main</strong>â€: main()</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#expected-output-running-pso-optimization-with-real-time-convergence-monitoring"><code class="docutils literal notranslate"><span class="pre">**Expected</span> <span class="pre">Output:**</span></code>
Running PSO optimization with real-time convergence monitoringâ€¦</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#id2">runnable: false #!/usr/bin/env python3</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#id3">Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#id4">============================================================================ CONFIG_PATH = â€œconfig.yamlâ€</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#id5">Main</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#def-main-load-configuration-config-load-config-config-path-initialize-meta-optimizer-print-initializing-pso-hyperparameter-optimizer-meta-optimizer-psohyperparameteroptimizer-config-run-meta-optimization-print-f-nrunning-meta-optimization-for-controller-type-value-print-f-max-evaluations-max-meta-evaluations-print-f-trials-per-evaluation-n-trials-per-eval-print-f-objective-optimizationobjective-multi-objective-value-print-80-result-meta-optimizer-optimize-hyperparameters-controller-type-controller-type-objective-optimizationobjective-multi-objective-max-evaluations-max-meta-evaluations-n-trials-per-evaluation-n-trials-per-eval-display-results-print-n-80-print-hyperparameter-optimization-results-print-80-print-f-noptimized-hyperparameters-print-f-inertia-weight-w-result-hyperparameters-w-6f-print-f-cognitive-c1-result-hyperparameters-c1-6f-print-f-social-c2-result-hyperparameters-c2-6f-print-f-swarm-size-result-hyperparameters-n-particles-print-f-nbaseline-hyperparameters-print-f-inertia-weight-w-result-baseline-hyperparameters-w-6f-print-f-cognitive-c1-result-baseline-hyperparameters-c1-6f-print-f-social-c2-result-baseline-hyperparameters-c2-6f-print-f-swarm-size-result-baseline-hyperparameters-n-particles-print-f-nperformance-improvements-vs-baseline-print-f-convergence-speedup-result-convergence-improvement-2f-x-print-f-quality-improvement-result-quality-improvement100-2f-print-f-robustness-improvement-result-robustness-improvement100-2f-print-f-efficiency-score-result-efficiency-score-4f-print-80-visualize-comparison-fig-axes-plt-subplots-2-2-figsize-12-10-categories-w-c1-c2-n-baseline-values-result-baseline-hyperparameters-w-result-baseline-hyperparameters-c1-result-baseline-hyperparameters-c2-result-baseline-hyperparameters-n-particles-optimized-values-result-hyperparameters-w-result-hyperparameters-c1-result-hyperparameters-c2-result-hyperparameters-n-particles-x-np-arange-len-categories-width-0-35-axes-0-0-bar-x-width-2-baseline-values-width-label-baseline-alpha-0-7-axes-0-0-bar-x-width-2-optimized-values-width-label-optimized-alpha-0-7-axes-0-0-set-ylabel-value-axes-0-0-set-title-hyperparameter-comparison-axes-0-0-set-xticks-x-axes-0-0-set-xticklabels-categories-axes-0-0-legend-axes-0-0-grid-true-alpha-0-3-performance-metrics-metrics-convergence-nspeed-solution-nquality-robustness-improvements-result-convergence-improvement-1-result-quality-improvement-1-result-robustness-improvement-axes-0-1-bar-metrics-improvements-color-blue-green-orange-alpha-0-7-axes-0-1-axhline-y-1-0-color-red-linestyle-label-baseline-axes-0-1-set-ylabel-improvement-factor-axes-0-1-set-title-performance-improvements-axes-0-1-legend-axes-0-1-grid-true-alpha-0-3-convergence-history-if-available-if-hasattr-result-optimization-history-axes-1-0-plot-result-optimization-history-best-objective-linewidth-2-axes-1-0-set-xlabel-meta-optimization-iteration-axes-1-0-set-ylabel-objective-value-axes-1-0-set-title-meta-optimization-convergence-axes-1-0-grid-true-alpha-0-3-hide-unused-subplot-axes-1-1-axis-off-plt-tight-layout-plt-savefig-pso-hyperparameter-optimization-png-dpi-300-print-nvisualization-saved-pso-hyperparameter-optimization-png-if-name-main-main">============================================================================ def main(): # Load configuration config = load_config(CONFIG_PATH) # Initialize meta-optimizer print(â€œInitializing PSO Hyperparameter Optimizerâ€¦â€) meta_optimizer = PSOHyperparameterOptimizer(config) # Run meta-optimization print(fâ€\nRunning meta-optimization for {CONTROLLER_TYPE.value}â€¦â€) print(fâ€Max evaluations: {MAX_META_EVALUATIONS}â€) print(fâ€Trials per evaluation: {N_TRIALS_PER_EVAL}â€) print(fâ€Objective: {OptimizationObjective.MULTI_OBJECTIVE.value}â€) print(â€œ=â€*80) result = meta_optimizer.optimize_hyperparameters( controller_type=CONTROLLER_TYPE, objective=OptimizationObjective.MULTI_OBJECTIVE, max_evaluations=MAX_META_EVALUATIONS, n_trials_per_evaluation=N_TRIALS_PER_EVAL ) # Display results print(â€œ\nâ€ + â€œ=â€<em>80) print(â€œHYPERPARAMETER OPTIMIZATION RESULTSâ€) print(â€œ=â€<em>80) print(fâ€\nOptimized Hyperparameters:â€) print(fâ€ Inertia weight (w): {result.hyperparameters.w:.6f}â€) print(fâ€ Cognitive (c1): {result.hyperparameters.c1:.6f}â€) print(fâ€ Social (c2): {result.hyperparameters.c2:.6f}â€) print(fâ€ Swarm size: {result.hyperparameters.n_particles}â€) print(fâ€\nBaseline Hyperparameters:â€) print(fâ€ Inertia weight (w): {result.baseline_hyperparameters.w:.6f}â€) print(fâ€ Cognitive (c1): {result.baseline_hyperparameters.c1:.6f}â€) print(fâ€ Social (c2): {result.baseline_hyperparameters.c2:.6f}â€) print(fâ€ Swarm size: {result.baseline_hyperparameters.n_particles}â€) print(fâ€\nPerformance Improvements vs. Baseline:â€) print(fâ€ Convergence speedup: {result.convergence_improvement:.2f}xâ€) print(fâ€ Quality improvement: {result.quality_improvement</em>100:.2f}%â€) print(fâ€ Robustness improvement: {result.robustness_improvement</em>100:.2f}%â€) print(fâ€ Efficiency score: {result.efficiency_score:.4f}â€) print(â€œ=â€*80) # Visualize comparison fig, axes = plt.subplots(2, 2, figsize=(12, 10)) categories = [â€˜wâ€™, â€˜c1â€™, â€˜c2â€™, â€˜Nâ€™] baseline_values = [ result.baseline_hyperparameters.w, result.baseline_hyperparameters.c1, result.baseline_hyperparameters.c2, result.baseline_hyperparameters.n_particles ] optimized_values = [ result.hyperparameters.w, result.hyperparameters.c1, result.hyperparameters.c2, result.hyperparameters.n_particles ] x = np.arange(len(categories)) width = 0.35 axes[0, 0].bar(x - width/2, baseline_values, width, label=â€™Baselineâ€™, alpha=0.7) axes[0, 0].bar(x + width/2, optimized_values, width, label=â€™Optimizedâ€™, alpha=0.7) axes[0, 0].set_ylabel(â€˜Valueâ€™) axes[0, 0].set_title(â€˜Hyperparameter Comparisonâ€™) axes[0, 0].set_xticks(x) axes[0, 0].set_xticklabels(categories) axes[0, 0].legend() axes[0, 0].grid(True, alpha=0.3) # Performance metrics metrics = [â€˜Convergence\nSpeedâ€™, â€˜Solution\nQualityâ€™, â€˜Robustnessâ€™] improvements = [ result.convergence_improvement, 1 + result.quality_improvement, 1 + result.robustness_improvement ] axes[0, 1].bar(metrics, improvements, color=[â€˜blueâ€™, â€˜greenâ€™, â€˜orangeâ€™], alpha=0.7) axes[0, 1].axhline(y=1.0, color=â€™redâ€™, linestyle=â€™â€“â€™, label=â€™Baselineâ€™) axes[0, 1].set_ylabel(â€˜Improvement Factorâ€™) axes[0, 1].set_title(â€˜Performance Improvementsâ€™) axes[0, 1].legend() axes[0, 1].grid(True, alpha=0.3) # Convergence history (if available) if hasattr(result, â€˜optimization_historyâ€™): axes[1, 0].plot(result.optimization_history[â€˜best_objectiveâ€™], linewidth=2) axes[1, 0].set_xlabel(â€˜Meta-Optimization Iterationâ€™) axes[1, 0].set_ylabel(â€˜Objective Valueâ€™) axes[1, 0].set_title(â€˜Meta-Optimization Convergenceâ€™) axes[1, 0].grid(True, alpha=0.3) # Hide unused subplot axes[1, 1].axis(â€˜offâ€™) plt.tight_layout() plt.savefig(â€˜pso_hyperparameter_optimization.pngâ€™, dpi=300) print(â€œ\nVisualization saved: pso_hyperparameter_optimization.pngâ€) if <strong>name</strong> == â€œ<strong>main</strong>â€: main()</a></li>
<li class="toctree-l2"><a class="reference internal" href="pso_optimization.html">PSO Optimization Guide <strong>Status:</strong> ğŸš§ Under Construction This document will contain PSO optimization documentation including: ## Planned Content ### PSO Algorithm Fundamentals</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Simulation Engine API Reference <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="#runnable-false-class-dynamicsmodel-protocol-protocol-for-plant-dynamics-models-def-compute-dynamics-self-state-np-ndarray-control-input-np-ndarray-time-float-0-0-kwargs-any-dynamicsresult-compute-system-dynamics-at-given-state-and-input-def-get-physics-matrices-self-state-np-ndarray-tuple-np-ndarray-np-ndarray-np-ndarray-get-physics-matrices-m-c-g-at-current-state-def-validate-state-self-state-np-ndarray-bool-validate-state-vector-format-and-bounds-def-get-state-dimension-self-int-get-dimension-of-state-vector-def-get-control-dimension-self-int-get-dimension-of-control-input-vector">runnable: false class DynamicsModel(Protocol): â€œâ€â€Protocol for plant dynamics models.â€â€â€ def compute_dynamics( self, state: np.ndarray, control_input: np.ndarray, time: float = 0.0, **kwargs: Any ) -&gt; DynamicsResult: â€œâ€â€Compute system dynamics at given state and input.â€â€â€ â€¦ def get_physics_matrices( self, state: np.ndarray ) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]: â€œâ€â€Get physics matrices M, C, G at current state.â€â€â€ â€¦ def validate_state(self, state: np.ndarray) -&gt; bool: â€œâ€â€Validate state vector format and bounds.â€â€â€ â€¦ def get_state_dimension(self) -&gt; int: â€œâ€â€Get dimension of state vector.â€â€â€ â€¦ def get_control_dimension(self) -&gt; int: â€œâ€â€Get dimension of control input vector.â€â€â€ â€¦</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="#runnable-false-abstractmethod">runnable: false @abstractmethod</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="#runnable-false-class-orchestrator-abc-base-interface-for-simulation-execution-strategies-abstractmethod-def-execute-self-initial-state-np-ndarray-control-inputs-np-ndarray-dt-float-horizon-int-kwargs-resultcontainer-execute-simulation-with-specified-strategy-pass">runnable: false class Orchestrator(ABC): â€œâ€â€Base interface for simulation execution strategies.â€â€â€ @abstractmethod def execute( self, initial_state: np.ndarray, control_inputs: np.ndarray, dt: float, horizon: int, **kwargs ) -&gt; ResultContainer: â€œâ€â€Execute simulation with specified strategy.â€â€â€ pass</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="#runnable-false-class-batchorchestrator-baseorchestrator-batch-simulation-orchestrator-for-vectorized-execution-def-execute-self-initial-state-np-ndarray-control-inputs-np-ndarray-dt-float-horizon-int-kwargs-resultcontainer-execute-batch-simulation">runnable: false class BatchOrchestrator(BaseOrchestrator): â€œâ€â€Batch simulation orchestrator for vectorized execution.â€â€â€ def execute( self, initial_state: np.ndarray, control_inputs: np.ndarray, dt: float, horizon: int, **kwargs ) -&gt; ResultContainer: â€œâ€â€Execute batch simulation.â€â€â€</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-1-load-configuration">STEP 1: Load Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-2-create-controller">STEP 2: Create Controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-3-create-dynamics-model">STEP 3: Create Dynamics Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-4-run-simulation">STEP 4: Run Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-5-analyze-results">STEP 5: Analyze Results</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-6-plot-results">STEP 6: Plot Results</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id9">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance_benchmarks.html">Performance Benchmarks Reference <strong>Status:</strong> ğŸš§ Under Construction This document will contain performance benchmarking documentation including: ## Planned Content ### Benchmark Methodology</a></li>
<li class="toctree-l2"><a class="reference internal" href="configuration_schema.html">Configuration Schema Reference <strong>Status:</strong> ğŸš§ Under Construction This document will contain configuration schema documentation including: ## Planned Content ### YAML Configuration Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_1_completion_report.html">Phase 4.1 Controller API Documentation Completion Report <strong>Date:</strong> 2025-10-07</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_1_completion_report.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_1_completion_report.html#runnable-false">runnable: false</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_1_completion_report.html#examples-section">Examples section</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_2_completion_report.html">Phase 4.2 Completion Report: Factory System API Documentation <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_2_completion_report.html#tests-test-factory-examples-py-import-pytest">tests/test_factory_examples.py import pytest</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_3_progress_report.html">Phase 4.3 Progress Report: Optimization Module API Documentation <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_3_progress_report.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_3_progress_report.html#runnable-false-def-optimize-bounds-for-controller-self-controller-type-smctype-strategy-boundsoptimizationstrategy-boundsoptimizationstrategy-hybrid-max-optimization-time-float-300-0">runnable: false def optimize_bounds_for_controller( self, controller_type: SMCType, strategy: BoundsOptimizationStrategy = BoundsOptimizationStrategy.HYBRID, max_optimization_time: float = 300.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_3_completion_report.html">Phase 4.3 Completion Report: Optimization Module API Documentation <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_4_completion_report.html">Phase 4.4 Completion Report: Simulation Engine API Documentation <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../architecture.html">3. System Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../architecture_control_room.html">System Architecture Control Room</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../benchmarks/index.html">Performance Benchmarks</a><input aria-label="Toggle navigation of Performance Benchmarks" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../benchmarks/controller_performance_benchmarks.html">Controller Performance Benchmarks with Statistical Analysis <strong>Project:</strong> Double-Inverted Pendulum Sliding Mode Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../benchmarks/phase_3_2_completion_report.html">Phase 3.2 Completion Report: Controller Performance Benchmarks <strong>Project:</strong> Double-Inverted Pendulum Sliding Mode Control</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html">Benchmarks &amp; Methodology This project includes benchmarking features for statistical analysis and performance comparison of sliding mode controllers. The benchmarking system provides standardized evaluation protocols and robust statistical metrics. ## Overview The benchmarking framework evaluates controllers across multiple dimensions: - <strong>Performance metrics</strong>: ISE, ITAE, RMS control effort, overshoot, constraint violations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#base-seed-for-reproducibility">Base seed for reproducibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#configurable-noise-standard-deviation">Configurable noise standard deviation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#example-5-degree-initial-angle-variation">Example: Â±5 degree initial angle variation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#test-with-physics-uncertainty-and-sensor-noise">Test with physics uncertainty and sensor noise</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#runnable-false-controllers-classical-smc-sta-smc-adaptive-smc">runnable: false controllers = [â€˜classical_smcâ€™, â€˜sta_smcâ€™, â€˜adaptive_smcâ€™]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#runnable-false-benchmark-metadata-timestamp-datetime-now-isoformat-config-hash-hashlib-md5-config-content-hexdigest-random-seed-1234-n-trials-30-environment-python-version-sys-version-numpy-version-np-version-platform-platform-platform">runnable: false benchmark_metadata = { â€˜timestampâ€™: datetime.now().isoformat(), â€˜config_hashâ€™: hashlib.md5(config_content).hexdigest(), â€˜random_seedâ€™: 1234, â€˜n_trialsâ€™: 30, â€˜environmentâ€™: { â€˜python_versionâ€™: sys.version, â€˜numpy_versionâ€™: np.<strong>version</strong>, â€˜platformâ€™: platform.platform() }</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bibliography.html">Bibliography &amp; Academic References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../claude-backup.html">Automated Git Backup System</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html">Configuration Integration Documentation ## Overview This document provides guidance on integrating the configuration system with the Enterprise Controller Factory. The DIP SMC-PSO project features a sophisticated configuration architecture that supports multiple sources, type safety, validation, and integration with controller creation workflows. ## Table of Contents 1. <span class="xref myst">Configuration Architecture</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#config-yaml-complete-configuration-example-global-settings">config.yaml - Complete configuration example # Global settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#runnable-false-from-pydantic-import-basemodel-field-validator">runnable: false from pydantic import BaseModel, Field, validator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#runnable-false-def-resolve-controller-gains-gains-optional-union-list-float-np-ndarray-config-optional-any-controller-type-str-controller-info-dict-str-any">runnable: false def _resolve_controller_gains( gains: Optional[Union[List[float], np.ndarray]], config: Optional[Any], controller_type: str, controller_info: Dict[str, Any]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#runnable-false-nested-dictionary-configuration">runnable: false # Nested dictionary configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#runnable-false-class-attributeconfig-configuration-using-attributes-def-init-self-create-controller-configurations-as-attributes-self-classical-smc-type-config-gains-25-20-15-10-40-6-max-force-160-0-boundary-layer-0-025-dt-0-001-self-adaptive-smc-type-config-gains-30-22-18-12-5-0-max-force-160-0-dt-0-001-leak-rate-0-02-initialize-controllers-namespace">runnable: false class AttributeConfig: â€œâ€â€Configuration using attributes.â€â€â€ def <strong>init</strong>(self): # Create controller configurations as attributes self.classical_smc = type(â€˜Configâ€™, (), { â€˜gainsâ€™: [25, 20, 15, 10, 40, 6], â€˜max_forceâ€™: 160.0, â€˜boundary_layerâ€™: 0.025, â€˜dtâ€™: 0.001 })() self.adaptive_smc = type(â€˜Configâ€™, (), { â€˜gainsâ€™: [30, 22, 18, 12, 5.0], â€˜max_forceâ€™: 160.0, â€˜dtâ€™: 0.001, â€˜leak_rateâ€™: 0.02 })() # Initialize controllers namespace</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#generated-configuration-for-system-name">Generated configuration for {{ system_name }}</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_schema_validation.html">Configuration Schema Validation Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_schema_validation.html#config-yaml-master-configuration-file">config.yaml - Master Configuration File</a></li>
<li class="toctree-l1"><a class="reference internal" href="../context.html">2. Application Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../control_law_testing_standards.html">Control Law Testing Standards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../controller_pso_interface_api_documentation.html">Controller-PSO Interface API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coverage_analysis_methodology.html">Coverage Analysis Methodology Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coverage_analysis_methodology.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coverage_analysis_methodology.html#runnable-false-mathematical-model-for-isolated-coverage">runnable: false # Mathematical Model for Isolated Coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deployment/DEPLOYMENT_GUIDE.html">ğŸš€ Sphinx Documentation System - Deployment Guide ## âœ… System Successfully Deployed! Your production-grade Sphinx documentation system is now <strong>ready for use</strong>. All expert recommendations have been implemented and the system has been committed to your repository. ## ğŸ“‹ Next Steps for Activation ### 1. GitHub Repository Settings To activate the documentation system, configure these GitHub settings: #### <strong>GitHub Pages:</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../deployment/STREAMLIT_DEPLOYMENT.html">Streamlit Deployment Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deployment/docker.html">Docker Deployment Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deployment_validation_checklists.html">Deployment Validation Checklists and Quality Gates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../documentation_structure.html">Documentation Structure &amp; Site Map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault_detection_guide.html">Fault Detection &amp; Isolation (FDI) Guide ## Overview The DIP_SMC_PSO system includes a Fault Detection and Isolation (FDI) module that monitors system health in real-time. The FDI system compares model predictions with actual measurements to detect deviations that may indicate component failures, sensor faults, or unexpected disturbances. ## Architecture The FDI system uses a <strong>model-based residual approach</strong>: ```</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault_detection_system_documentation.html">Fault Detection and Isolation (FDI) System - Technical Documentation ## Table of Contents 1. <span class="xref myst">Mathematical Foundations</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="../fdi_threshold_calibration_methodology.html">FDI Threshold Calibration Methodology <strong>Issue</strong>: #18 - FDI Threshold Too Sensitive - False Positives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/getting-started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/getting-started.html#or-on-some-systems">OR on some systems:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/getting-started.html#clone-repository">Clone repository</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/getting-started.html#you-should-see-simulate-py-config-yaml-src-tests-docs-etc">You should see: simulate.py, config.yaml, src/, tests/, docs/, etc.</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/getting-started-validation-report.html">Getting Started Guide Validation Report <strong>Phase 5.1: Getting Started Guide Validation</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../hil_quickstart.html">Hardware-in-the-Loop (HIL) Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html">Mathematical Algorithm Validation Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#runnable-false-def-compute-control-self-state-np-ndarray-target-np-ndarray-float-compute-smc-control-signal-extract-state-variables-theta1-theta2-x-theta1-dot-theta2-dot-x-dot-state-compute-errors-e1-theta1-target-0-position-error-pendulum-1-e2-theta2-target-1-position-error-pendulum-2-e1-dot-theta1-dot-target-3-velocity-error-pendulum-1-e2-dot-theta2-dot-target-4-velocity-error-pendulum-2-sliding-surface-s-1e1-2e2-e1-e2-s-self-lambda1-e1-self-lambda2-e2-e1-dot-e2-dot-control-law-u-u-eq-u-sw-u-equivalent-self-compute-equivalent-control-state-target-u-switching-self-k-np-sign-s-return-u-equivalent-u-switching">runnable: false def compute_control(self, state: np.ndarray, target: np.ndarray) -&gt; float: â€œâ€â€Compute SMC control signal.â€â€â€ # Extract state variables theta1, theta2, x, theta1_dot, theta2_dot, x_dot = state # Compute errors e1 = theta1 - target[0] # Position error pendulum 1 e2 = theta2 - target[1] # Position error pendulum 2 e1_dot = theta1_dot - target[3] # Velocity error pendulum 1 e2_dot = theta2_dot - target[4] # Velocity error pendulum 2 # Sliding surface: s = Î»â‚eâ‚ + Î»â‚‚eâ‚‚ + Ä—â‚ + Ä—â‚‚ s = self.lambda1 * e1 + self.lambda2 * e2 + e1_dot + e2_dot # Control law: u = u_eq + u_sw u_equivalent = self._compute_equivalent_control(state, target) u_switching = -self.K * np.sign(s) return u_equivalent + u_switching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#runnable-false-def-compute-control-self-state-np-ndarray-target-np-ndarray-float-compute-super-twisting-control-signal-compute-sliding-surface-s-self-compute-sliding-surface-state-target-super-twisting-control-law-u1-1-s-1-2-sign-s-u1-self-alpha1-np-power-np-abs-s-0-5-np-sign-s-u2-2-sign-s-dt-self-integral-term-self-alpha2-np-sign-s-self-dt-return-u1-self-integral-term">runnable: false def compute_control(self, state: np.ndarray, target: np.ndarray) -&gt; float: â€œâ€â€Compute Super-Twisting control signal.â€â€â€ # Compute sliding surface s = self._compute_sliding_surface(state, target) # Super-Twisting control law # uâ‚ = -Î±â‚|s|^(1/2) sign(s) u1 = -self.alpha1 * np.power(np.abs(s), 0.5) * np.sign(s) # uâ‚‚ = âˆ«(-Î±â‚‚ sign(s)) dt self.integral_term += -self.alpha2 * np.sign(s) * self.dt return u1 + self.integral_term</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#runnable-false-def-update-particles-self-update-particle-velocities-and-positions-for-i-in-range-self-n-particles-random-coefficients-r1-r2-np-random-random-2-velocity-update-with-constriction-factor-self-velocities-i-self-chi-self-w-self-velocities-i-self-c1-r1-self-personal-best-positions-i-self-positions-i-self-c2-r2-self-global-best-position-self-positions-i-position-update-self-positions-i-self-velocities-i-boundary-handling-self-positions-i-np-clip-self-positions-i-self-bounds-min-self-bounds-max">runnable: false def update_particles(self): â€œâ€â€Update particle velocities and positions.â€â€â€ for i in range(self.n_particles): # Random coefficients r1, r2 = np.random.random(2) # Velocity update with constriction factor self.velocities[i] = self.chi * ( self.w * self.velocities[i] + self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i]) + self.c2 * r2 * (self.global_best_position - self.positions[i]) ) # Position update self.positions[i] += self.velocities[i] # Boundary handling self.positions[i] = np.clip(self.positions[i], self.bounds_min, self.bounds_max)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#runnable-false-class-testmathematicalcorrectness-test-mathematical-properties-of-implementations-def-test-lyapunov-function-properties-self-test-lyapunov-function-is-positive-definite-controller-classicalsmc-for-in-range-1000-state-np-random-uniform-6-v-controller-compute-lyapunov-function-state-property-1-v-0-assert-v-0-property-2-v-0-only-at-equilibrium-if-not-np-allclose-state-0-assert-v-0-def-test-sliding-surface-stability-self-test-sliding-surface-leads-to-stable-dynamics-controller-classicalsmc-lambda1-2-0-lambda2-1-5-test-exponential-stability-on-sliding-surface-dt-0-01-times-np-arange-0-5-dt-for-initial-error-in-0-1-0-5-1-0-e1-history-initial-error-e2-history-initial-error-for-t-in-times-1-sliding-dynamics-e1-1e1-0-e2-2e2-0-e1-new-e1-history-1-np-exp-controller-lambda1-dt-e2-new-e2-history-1-np-exp-controller-lambda2-dt-e1-history-append-e1-new-e2-history-append-e2-new-verify-exponential-decay-assert-e1-history-1-0-01-initial-error-assert-e2-history-1-0-01-initial-error">runnable: false class TestMathematicalCorrectness: â€œâ€â€Test mathematical properties of implementations.â€â€â€ def test_lyapunov_function_properties(self): â€œâ€â€Test Lyapunov function is positive definite.â€â€â€ controller = ClassicalSMC() for _ in range(1000): state = np.random.uniform(-Ï€, Ï€, 6) V = controller.compute_lyapunov_function(state) # Property 1: V â‰¥ 0 assert V &gt;= 0 # Property 2: V = 0 only at equilibrium if not np.allclose(state, 0): assert V &gt; 0 def test_sliding_surface_stability(self): â€œâ€â€Test sliding surface leads to stable dynamics.â€â€â€ controller = ClassicalSMC(lambda1=2.0, lambda2=1.5) # Test exponential stability on sliding surface dt = 0.01 times = np.arange(0, 5, dt) for initial_error in [0.1, 0.5, 1.0]: e1_history = [initial_error] e2_history = [initial_error] for t in times[1:]: # Sliding dynamics: Ä—â‚ + Î»â‚eâ‚ = 0, Ä—â‚‚ + Î»â‚‚eâ‚‚ = 0 e1_new = e1_history[-1] * np.exp(-controller.lambda1 * dt) e2_new = e2_history[-1] * np.exp(-controller.lambda2 * dt) e1_history.append(e1_new) e2_history.append(e2_new) # Verify exponential decay assert e1_history[-1] &lt; 0.01 * initial_error assert e2_history[-1] &lt; 0.01 * initial_error</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#id4">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#runnable-false-def-test-end-to-end-mathematical-properties-test-mathematical-properties-in-complete-system-initialize-system-system-doubleinvertedpendulum-controller-classicalsmc-initial-condition-away-from-equilibrium-x0-np-array-0-2-0-1-0-0-0-0-0-0-0-0-target-np-zeros-6-simulate-system-trajectory-simulate-system-system-controller-x0-target-t-final-10-0-mathematical-property-verification-1-verify-lyapunov-function-decreases-v-values-controller-compute-lyapunov-function-state-for-state-in-trajectory-states-assert-np-all-np-diff-v-values-0-lyapunov-function-must-be-non-increasing-2-verify-convergence-to-target-final-error-np-linalg-norm-trajectory-states-1-target-assert-final-error-0-01-f-final-error-final-error-too-large-3-verify-control-signal-bounds-max-control-np-max-np-abs-trajectory-controls-assert-max-control-controller-u-max-control-signal-exceeds-limits">runnable: false def test_end_to_end_mathematical_properties(): â€œâ€â€Test mathematical properties in complete system.â€â€â€ # Initialize system system = DoubleInvertedPendulum() controller = ClassicalSMC() # Initial condition away from equilibrium x0 = np.array([0.2, 0.1, 0.0, 0.0, 0.0, 0.0]) target = np.zeros(6) # Simulate system trajectory = simulate_system(system, controller, x0, target, t_final=10.0) # Mathematical property verification # 1. Verify Lyapunov function decreases V_values = [controller.compute_lyapunov_function(state) for state in trajectory.states] assert np.all(np.diff(V_values) &lt;= 0), â€œLyapunov function must be non-increasingâ€ # 2. Verify convergence to target final_error = np.linalg.norm(trajectory.states[-1] - target) assert final_error &lt; 0.01, fâ€Final error {final_error} too largeâ€ # 3. Verify control signal bounds max_control = np.max(np.abs(trajectory.controls)) assert max_control &lt;= controller.u_max, â€œControl signal exceeds limitsâ€</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../mathematical_foundations/index.html">Mathematical Foundations</a><input aria-label="Toggle navigation of Mathematical Foundations" class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/README.html">SMC Mathematical Foundations Documentation This directory contains mathematical documentation for all SMC algorithm fixes and validation methodology implemented for GitHub Issue #5. ## ğŸ“‹ Documentation Overview This mathematical foundation documentation provides: - <strong>Complete mathematical theory</strong> behind all SMC algorithm implementations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/smc_complete_theory.html">Complete Sliding Mode Control Mathematical Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/smc_theory.html">SMC Mathematical Theory Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/sliding_surface_analysis.html">Sliding Surface Mathematical Properties and Stability Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/boundary_layer_derivations.html">Boundary Layer Mathematical Derivations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/controller_comparison_theory.html">SMC Controller Comparison Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html">Advanced Algorithms Guide <strong>Technical Reference for Optimization, Numerical Stability, and Algorithm Comparison</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#configure-inertia-weight-schedule-in-config-yaml">Configure inertia weight schedule in config.yaml:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#pso">pso:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#w-schedule-0-9-0-4-start-at-0-9-end-at-0-4">w_schedule: [0.9, 0.4] # Start at 0.9, end at 0.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#iters-100">iters: 100</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#n-particles-30-result-tuner-optimise-uses-w-schedule-from-config-manual-iteration-loop-for-custom-control">n_particles: 30 result = tuner.optimise() # Uses w_schedule from config # Manual iteration loop for custom control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#runnable-false-configure-physics-uncertainty-in-config-yaml">runnable: false # Configure physics uncertainty in config.yaml:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#physics-uncertainty">physics_uncertainty:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#n-evals-5-5-perturbed-models-per-evaluation">n_evals: 5 # 5 perturbed models per evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#cart-mass-0-10-10">cart_mass: 0.10 # Â±10%</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#pendulum1-mass-0-15-15">pendulum1_mass: 0.15 # Â±15%</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#pendulum2-mass-0-15-15">pendulum2_mass: 0.15 # Â±15%</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#pendulum1-length-0-05-5">pendulum1_length: 0.05 # Â±5%</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#pendulum2-length-0-05-5-tuner-psotuner-controller-factory-controller-factory-config-config-seed-42">pendulum2_length: 0.05 # Â±5% tuner = PSOTuner( controller_factory=controller_factory, config=config, seed=42</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#cost-aggregation-0-7-mean-0-3-max">Cost aggregation: 0.7 * mean + 0.3 * max</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html">SMC Algorithm Fixes and Mathematical Validation Summary This document provides a summary of all mathematical algorithm fixes, validation improvements, and corrected implementations in the SMC controller system for GitHub Issue #5. ## 1. Executive Summary The SMC mathematical foundation has been completely restructured and validated with the following major improvements: - <strong>Boundary Layer Mathematics</strong>: Corrected chattering reduction theory and implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-compute-switching-function-self-surface-value-float-float-compute-continuous-switching-function-with-adaptive-boundary-layer-adaptive-boundary-layer-thickness-surface-derivative-self-get-surface-derivative-effective-thickness-self-base-thickness-self-slope-abs-surface-derivative-continuous-switching-approximation-if-self-switch-method-tanh-return-np-tanh-surface-value-effective-thickness-elif-self-switch-method-linear-return-np-clip-surface-value-effective-thickness-1-0-1-0-else-sign-return-np-sign-surface-value-3-validation-rules-python-if-thickness-0-raise-valueerror-boundary-layer-thickness-must-be-positive-if-slope-0-raise-valueerror-boundary-layer-slope-must-be-non-negative-mathematical-impact">runnable: false def compute_switching_function(self, surface_value: float) -&gt; float: â€œâ€â€Compute continuous switching function with adaptive boundary layer.â€â€â€ # Adaptive boundary layer thickness surface_derivative = self._get_surface_derivative() effective_thickness = self.base_thickness + self.slope * abs(surface_derivative) # Continuous switching approximation if self.switch_method == â€œtanhâ€: return np.tanh(surface_value / effective_thickness) elif self.switch_method == â€œlinearâ€: return np.clip(surface_value / effective_thickness, -1.0, 1.0) else: # â€œsignâ€ return np.sign(surface_value) <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Validation</span> <span class="pre">Rules:**</span></code>python if thickness &lt;= 0: raise ValueError(â€œBoundary layer thickness must be positiveâ€) if slope &lt; 0: raise ValueError(â€œBoundary layer slope must be non-negativeâ€) ``` <strong>Mathematical Impact:</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-compute-self-state-np-ndarray-float-compute-linear-sliding-surface-with-numerical-safeguards-input-validation-if-len-state-6-raise-valueerror-state-must-have-at-least-6-elements-handle-non-finite-values-if-not-np-all-np-isfinite-state-state-np-where-np-isfinite-state-state-0-0-extract-components-theta1-theta1-dot-state-2-state-3-theta2-theta2-dot-state-4-state-5-linear-sliding-surface-s-11-k11-22-k22-s-self-lam1-theta1-dot-self-k1-theta1-self-lam2-theta2-dot-self-k2-theta2-numerical-safety-return-0-0-if-not-np-isfinite-s-else-float-s-2-stability-analysis-integration-python">runnable: false def compute(self, state: np.ndarray) -&gt; float: â€œâ€â€Compute linear sliding surface with numerical safeguards.â€â€â€ # Input validation if len(state) &lt; 6: raise ValueError(â€œState must have at least 6 elementsâ€) # Handle non-finite values if not np.all(np.isfinite(state)): state = np.where(np.isfinite(state), state, 0.0) # Extract components theta1, theta1_dot = state[2], state[3] theta2, theta2_dot = state[4], state[5] # Linear sliding surface: s = Î»â‚Î¸Ì‡â‚ + kâ‚Î¸â‚ + Î»â‚‚Î¸Ì‡â‚‚ + kâ‚‚Î¸â‚‚ s = (self.lam1 * theta1_dot + self.k1 * theta1 + self.lam2 * theta2_dot + self.k2 * theta2) # Numerical safety return 0.0 if not np.isfinite(s) else float(s) <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Stability</span> <span class="pre">Analysis</span> <span class="pre">Integration:**</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-validate-gains-self-none-validate-gains-according-to-hurwitz-stability-requirements-check-finite-values-if-not-np-all-np-isfinite-self-gains-invalid-indices-np-where-np-isfinite-self-gains-0-raise-valueerror-f-gains-contain-nan-infinite-values-at-indices-invalid-indices-positivity-requirement-for-stability-if-len-self-gains-4-if-any-g-0-for-g-in-self-gains-4-raise-valueerror-surface-gains-k1-k2-1-2-must-be-positive-for-stability-minimum-threshold-for-numerical-stability-if-any-g-1e-12-for-g-in-self-gains-4-raise-valueerror-gains-too-small-min-1e-12-numerical-instability-risk-3-mathematical-property-verification-linearity-s-x1-x2-s-x1-s-x2-homogeneity-s-x-s-x-continuity-lim-xx0-s-x-s-x0-differentiability-ds-dt-exists-and-is-computable-mathematical-impact">runnable: false def _validate_gains(self) -&gt; None: â€œâ€â€Validate gains according to Hurwitz stability requirements.â€â€â€ # Check finite values if not np.all(np.isfinite(self.gains)): invalid_indices = np.where(~np.isfinite(self.gains))[0] raise ValueError(fâ€Gains contain NaN/infinite values at indices: {invalid_indices}â€) # Positivity requirement for stability if len(self.gains) &gt;= 4: if any(g &lt;= 0 for g in self.gains[:4]): raise ValueError(â€œSurface gains [k1, k2, Î»1, Î»2] must be positive for stabilityâ€) # Minimum threshold for numerical stability if any(g &lt; 1e-12 for g in self.gains[:4]): raise ValueError(â€œGains too small (min: 1e-12) - numerical instability riskâ€) ``` 3. <strong>Mathematical Property Verification:</strong> - <strong>Linearity</strong>: <code class="docutils literal notranslate"><span class="pre">s(Î±xâ‚</span> <span class="pre">+</span> <span class="pre">Î²xâ‚‚)</span> <span class="pre">=</span> <span class="pre">Î±s(xâ‚)</span> <span class="pre">+</span> <span class="pre">Î²s(xâ‚‚)</span></code> - <strong>Homogeneity</strong>: <code class="docutils literal notranslate"><span class="pre">s(Î±x)</span> <span class="pre">=</span> <span class="pre">Î±s(x)</span></code> - <strong>Continuity</strong>: <code class="docutils literal notranslate"><span class="pre">lim_{xâ†’xâ‚€}</span> <span class="pre">s(x)</span> <span class="pre">=</span> <span class="pre">s(xâ‚€)</span></code> - <strong>Differentiability</strong>: <code class="docutils literal notranslate"><span class="pre">ds/dt</span></code> exists and is computable <strong>Mathematical Impact:</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-dataclass-frozen-true-class-classicalsmcconfig-type-safe-configuration-with-mathematical-validation-def-post-init-self-validate-configuration-after-creation-self-validate-gains-self-validate-parameters-self-validate-mathematical-constraints-def-validate-gains-self-none-validate-gain-vector-according-to-smc-theory-if-len-self-gains-6-raise-valueerror-classical-smc-requires-exactly-6-gains-k1-k2-lam1-lam2-k-kd-self-gains-surface-gains-positive-for-hurwitz-stability-if-any-g-0-for-g-in-k1-k2-lam1-lam2-raise-valueerror-surface-gains-must-be-positive-for-stability-switching-gain-positive-for-reaching-condition-if-k-0-raise-valueerror-switching-gain-k-must-be-positive-derivative-gain-non-negative-for-damping-if-kd-0-raise-valueerror-derivative-gain-kd-must-be-non-negative-def-validate-mathematical-constraints-self-none-validate-constraints-from-mathematical-theory-damping-ratio-bounds-for-each-subsystem-zeta1-self-lam1-2-np-sqrt-self-k1-zeta2-self-lam2-2-np-sqrt-self-k2-if-zeta1-0-1-or-zeta2-0-1-raise-valueerror-damping-ratios-too-low-may-cause-oscillations-if-zeta1-10-0-or-zeta2-10-0-raise-valueerror-damping-ratios-too-high-may-cause-sluggish-response-2-edge-case-handling-python-def-get-effective-controllability-threshold-self-float-auto-compute-threshold-based-on-system-parameters-if-self-controllability-threshold-is-not-none-return-self-controllability-threshold-scale-with-surface-gains-for-adaptive-behavior-base-threshold-0-05-self-k1-self-k2-bound-within-reasonable-limits-return-np-clip-base-threshold-0-01-1-0-mathematical-impact">runnable: false @dataclass(frozen=True) class ClassicalSMCConfig: â€œâ€â€Type-safe configuration with mathematical validation.â€â€â€ def <strong>post_init</strong>(self): â€œâ€â€Validate configuration after creation.â€â€â€ self._validate_gains() self._validate_parameters() self._validate_mathematical_constraints() def _validate_gains(self) -&gt; None: â€œâ€â€Validate gain vector according to SMC theory.â€â€â€ if len(self.gains) != 6: raise ValueError(â€œClassical SMC requires exactly 6 gainsâ€) k1, k2, lam1, lam2, K, kd = self.gains # Surface gains: positive for Hurwitz stability if any(g &lt;= 0 for g in [k1, k2, lam1, lam2]): raise ValueError(â€œSurface gains must be positive for stabilityâ€) # Switching gain: positive for reaching condition if K &lt;= 0: raise ValueError(â€œSwitching gain K must be positiveâ€) # Derivative gain: non-negative for damping if kd &lt; 0: raise ValueError(â€œDerivative gain kd must be non-negativeâ€) def _validate_mathematical_constraints(self) -&gt; None: â€œâ€â€Validate constraints from mathematical theory.â€â€â€ # Damping ratio bounds for each subsystem zeta1 = self.lam1 / (2 * np.sqrt(self.k1)) zeta2 = self.lam2 / (2 * np.sqrt(self.k2)) if zeta1 &lt; 0.1 or zeta2 &lt; 0.1: raise ValueError(â€œDamping ratios too low - may cause oscillationsâ€) if zeta1 &gt; 10.0 or zeta2 &gt; 10.0: raise ValueError(â€œDamping ratios too high - may cause sluggish responseâ€) <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Edge</span> <span class="pre">Case</span> <span class="pre">Handling:**</span></code>python def get_effective_controllability_threshold(self) -&gt; float: â€œâ€â€Auto-compute threshold based on system parameters.â€â€â€ if self.controllability_threshold is not None: return self.controllability_threshold # Scale with surface gains for adaptive behavior base_threshold = 0.05 * (self.k1 + self.k2) # Bound within reasonable limits return np.clip(base_threshold, 0.01, 1.0) ``` <strong>Mathematical Impact:</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-given-gains-st-lists-st-floats-min-value-0-1-max-value-50-0-min-size-4-max-size-4-state-st-lists-st-floats-min-value-10-0-max-value-10-0-min-size-6-max-size-6-def-test-sliding-surface-linearity-property-self-gains-state-test-linearity-property-for-all-valid-parameter-combinations-surface-linearslidingsurface-gains-state1-np-array-state-state2-np-random-uniform-10-10-6-s1-surface-compute-state1-s2-surface-compute-state2-s-combined-surface-compute-state1-state2-mathematical-property-s-x1-x2-s-x1-s-x2-assert-abs-s-combined-s1-s2-1e-10-2-boundary-layer-monotonicity-python">runnable: false @given( gains=st.lists(st.floats(min_value=0.1, max_value=50.0), min_size=4, max_size=4), state=st.lists(st.floats(min_value=-10.0, max_value=10.0), min_size=6, max_size=6) ) def test_sliding_surface_linearity_property(self, gains, state): â€œâ€â€Test linearity property for all valid parameter combinations.â€â€â€ surface = LinearSlidingSurface(gains) state1 = np.array(state) state2 = np.random.uniform(-10, 10, 6) s1 = surface.compute(state1) s2 = surface.compute(state2) s_combined = surface.compute(state1 + state2) # Mathematical property: s(x1 + x2) = s(x1) + s(x2) assert abs(s_combined - (s1 + s2)) &lt; 1e-10 <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Boundary</span> <span class="pre">Layer</span> <span class="pre">Monotonicity:**</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-test-boundary-layer-monotonicity-all-methods-self-test-monotonicity-for-all-switching-methods-methods-tanh-linear-sign-for-method-in-methods-boundary-layer-boundarylayer-thickness-0-1-switch-method-method-s-values-np-linspace-2-2-1000-switch-values-boundary-layer-compute-switching-function-s-for-s-in-s-values-must-be-monotonically-increasing-for-i-in-range-len-switch-values-1-assert-switch-values-i-1-switch-values-i-3-configuration-validation-coverage-python">runnable: false def test_boundary_layer_monotonicity_all_methods(self): â€œâ€â€Test monotonicity for all switching methods.â€â€â€ methods = [â€œtanhâ€, â€œlinearâ€, â€œsignâ€] for method in methods: boundary_layer = BoundaryLayer(thickness=0.1, switch_method=method) s_values = np.linspace(-2, 2, 1000) switch_values = [boundary_layer.compute_switching_function(s) for s in s_values] # Must be monotonically increasing for i in range(len(switch_values) - 1): assert switch_values[i+1] &gt;= switch_values[i] <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Configuration</span> <span class="pre">Validation</span> <span class="pre">Coverage:**</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-class-testconfigurationvalidationcoverage-coverage-of-all-validation-rules-pytest-mark-parametrize-invalid-gain-index-0-1-2-3-def-test-zero-surface-gains-rejection-self-invalid-gain-index-test-rejection-of-zero-surface-gains-gains-5-0-3-0-4-0-2-0-10-0-1-0-gains-invalid-gain-index-0-0-with-pytest-raises-valueerror-match-must-be-positive-classicalsmcconfig-gains-gains-max-force-100-dt-0-01-boundary-layer-0-01-pytest-mark-parametrize-invalid-gain-index-0-1-2-3-def-test-negative-surface-gains-rejection-self-invalid-gain-index-test-rejection-of-negative-surface-gains-gains-5-0-3-0-4-0-2-0-10-0-1-0-gains-invalid-gain-index-1-0-with-pytest-raises-valueerror-match-must-be-positive-classicalsmcconfig-gains-gains-max-force-100-dt-0-01-boundary-layer-0-01-3-2-numerical-stability-testing-enhanced-numerical-robustness-tests-1-extreme-value-testing-python">runnable: false class TestConfigurationValidationCoverage: â€œâ€â€coverage of all validation rules.â€â€â€ @pytest.mark.parametrize(â€œinvalid_gain_indexâ€, [0, 1, 2, 3]) def test_zero_surface_gains_rejection(self, invalid_gain_index): â€œâ€â€Test rejection of zero surface gains.â€â€â€ gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] gains[invalid_gain_index] = 0.0 with pytest.raises(ValueError, match=â€must be positiveâ€): ClassicalSMCConfig(gains=gains, max_force=100, dt=0.01, boundary_layer=0.01) @pytest.mark.parametrize(â€œinvalid_gain_indexâ€, [0, 1, 2, 3]) def test_negative_surface_gains_rejection(self, invalid_gain_index): â€œâ€â€Test rejection of negative surface gains.â€â€â€ gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] gains[invalid_gain_index] = -1.0 with pytest.raises(ValueError, match=â€must be positiveâ€): ClassicalSMCConfig(gains=gains, max_force=100, dt=0.01, boundary_layer=0.01) <code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">3.2</span> <span class="pre">Numerical</span> <span class="pre">Stability</span> <span class="pre">Testing</span> <span class="pre">**Enhanced</span> <span class="pre">Numerical</span> <span class="pre">Robustness</span> <span class="pre">Tests:**</span> <span class="pre">1.</span> <span class="pre">**Extreme</span> <span class="pre">Value</span> <span class="pre">Testing:**</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id7">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-test-numerical-stability-extreme-values-self-test-behavior-with-extreme-but-valid-parameter-values-very-small-gains-but-above-minimum-threshold-small-gains-1e-10-1e-10-1e-10-1e-10-1e-8-0-0-config-small-classicalsmcconfig-gains-small-gains-max-force-1e-6-dt-1e-6-boundary-layer-1e-8-very-large-gains-large-gains-1e6-1e6-1e6-1e6-1e8-1e4-config-large-classicalsmcconfig-gains-large-gains-max-force-1e8-dt-1e-3-boundary-layer-1-0-both-should-create-valid-controllers-controller-small-modularclassicalsmc-config-config-small-controller-large-modularclassicalsmc-config-config-large-test-with-moderate-state-values-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-result-small-controller-small-compute-control-state-result-large-controller-large-compute-control-state-both-should-produce-finite-bounded-results-assert-np-all-np-isfinite-result-small-get-control-output-0-assert-np-all-np-isfinite-result-large-get-control-output-0-2-precision-consistency-testing-python">runnable: false def test_numerical_stability_extreme_values(self): â€œâ€â€Test behavior with extreme but valid parameter values.â€â€â€ # Very small gains (but above minimum threshold) small_gains = [1e-10, 1e-10, 1e-10, 1e-10, 1e-8, 0.0] config_small = ClassicalSMCConfig(gains=small_gains, max_force=1e-6, dt=1e-6, boundary_layer=1e-8) # Very large gains large_gains = [1e6, 1e6, 1e6, 1e6, 1e8, 1e4] config_large = ClassicalSMCConfig(gains=large_gains, max_force=1e8, dt=1e-3, boundary_layer=1.0) # Both should create valid controllers controller_small = ModularClassicalSMC(config=config_small) controller_large = ModularClassicalSMC(config=config_large) # Test with moderate state values state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) result_small = controller_small.compute_control(state, {}, {}) result_large = controller_large.compute_control(state, {}, {}) # Both should produce finite, bounded results assert np.all(np.isfinite(result_small.get(â€˜control_outputâ€™, [0]))) assert np.all(np.isfinite(result_large.get(â€˜control_outputâ€™, [0]))) <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Precision</span> <span class="pre">Consistency</span> <span class="pre">Testing:**</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id8">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-test-computation-precision-consistency-self-test-that-repeated-computations-maintain-precision-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-state-np-array-0-123456789-0-987654321-0-456789123-0-321654987-0-789123456-0-654987321-compute-control-1000-times-results-for-in-range-1000-result-controller-compute-control-state-control-result-get-control-output-result-get-control-0-results-append-control-results-np-array-results-standard-deviation-should-be-zero-deterministic-computation-std-dev-np-std-results-axis-0-if-results-ndim-1-else-np-std-results-assert-np-all-std-dev-1e-15-machine-precision-level-4-implementation-architecture-improvements-4-1-modular-component-design-before-monolithic-single-458-line-controller-with-mixed-concerns">runnable: false def test_computation_precision_consistency(self): â€œâ€â€Test that repeated computations maintain precision.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) state = np.array([0.123456789, 0.987654321, 0.456789123, 0.321654987, 0.789123456, 0.654987321]) # Compute control 1000 times results = [] for _ in range(1000): result = controller.compute_control(state, {}, {}) control = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, 0)) results.append(control) results = np.array(results) # Standard deviation should be zero (deterministic computation) std_dev = np.std(results, axis=0) if results.ndim &gt; 1 else np.std(results) assert np.all(std_dev &lt; 1e-15) # Machine precision level ``` ## 4. Implementation Architecture Improvements ### 4.1 Modular Component Design <strong>Before (Monolithic):</strong> Single 458-line controller with mixed concerns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id9">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-class-slidingsurface-abc-abstract-interface-for-sliding-surface-calculations-abstractmethod-def-compute-self-state-np-ndarray-float-compute-sliding-surface-value-pass-abstractmethod-def-compute-derivative-self-state-np-ndarray-state-dot-np-ndarray-float-compute-sliding-surface-derivative-pass-abstractmethod-def-validate-gains-self-none-validate-gains-for-mathematical-correctness-pass-class-boundarylayer-interface-for-boundary-layer-implementations-def-compute-switching-function-self-surface-value-float-float-compute-continuous-switching-function-pass-def-compute-switching-control-self-surface-value-float-gain-float-surface-derivative-float-0-0-float-compute-switching-control-with-boundary-layer-pass">runnable: false class SlidingSurface(ABC): â€œâ€â€Abstract interface for sliding surface calculations.â€â€â€ @abstractmethod def compute(self, state: np.ndarray) -&gt; float: â€œâ€â€Compute sliding surface value.â€â€â€ pass @abstractmethod def compute_derivative(self, state: np.ndarray, state_dot: np.ndarray) -&gt; float: â€œâ€â€Compute sliding surface derivative.â€â€â€ pass @abstractmethod def _validate_gains(self) -&gt; None: â€œâ€â€Validate gains for mathematical correctness.â€â€â€ pass class BoundaryLayer: â€œâ€â€Interface for boundary layer implementations.â€â€â€ def compute_switching_function(self, surface_value: float) -&gt; float: â€œâ€â€Compute continuous switching function.â€â€â€ pass def compute_switching_control(self, surface_value: float, gain: float, surface_derivative: float = 0.0) -&gt; float: â€œâ€â€Compute switching control with boundary layer.â€â€â€ pass</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/pso_algorithm_theory.html">Particle Swarm Optimization: Mathematical Theory <strong>Module:</strong> Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/pso_algorithm_theory.html#balanced-recommended-for-smc">Balanced (recommended for SMC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/optimization_landscape_analysis.html">Optimization Landscape Analysis for Controller Gain Tuning</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/dynamics_derivations.html">Double Inverted Pendulum Dynamics: Complete Derivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/numerical_integration_theory.html">Numerical Integration Methods: Theory and Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/simulation_architecture_guide.html">Simulation Architecture Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/config_validation_specification.html">ClassicalSMCConfig Parameters and Validation Rules This document provides specification of the <code class="docutils literal notranslate"><span class="pre">ClassicalSMCConfig</span></code> parameters, their mathematical foundations, validation rules, and edge case handling. ## 1. Configuration Schema Overview The <code class="docutils literal notranslate"><span class="pre">ClassicalSMCConfig</span></code> dataclass provides type-safe, validated configuration for Classical Sliding Mode Control with the following parameter categories: - <strong>Control Parameters</strong>: Core SMC gains and timing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html">Mathematical Test Validation Methodology This document describes the methodology for validating mathematical properties and algorithm correctness in the SMC controller implementations. ## 1. Overview The test validation methodology ensures that all mathematical algorithms and fixes in the SMC system are rigorously validated through: - <strong>Property-based testing</strong>: Verification of mathematical properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-def-test-sliding-surface-linearity-test-that-sliding-surface-is-linear-in-state-surface-linearslidingsurface-gains-5-3-4-2-state1-np-array-0-1-0-1-0-1-0-05-0-05-0-05-state2-np-array-0-2-0-2-0-2-0-1-0-1-0-1-s1-surface-compute-state1-s2-surface-compute-state2-s-combined-surface-compute-state1-state2-linearity-s-x1-x2-s-x1-s-x2-assert-abs-s-combined-s1-s2-1e-10-2-homogeneity-property-python-def-test-sliding-surface-homogeneity-test-that-sliding-surface-is-homogeneous-of-degree-1-surface-linearslidingsurface-gains-5-3-4-2-state-np-array-0-1-0-1-0-1-0-05-0-05-0-05-alpha-2-5-s-original-surface-compute-state-s-scaled-surface-compute-alpha-state-homogeneity-s-x-s-x-assert-abs-s-scaled-alpha-s-original-1e-10-3-gain-sensitivity-python">runnable: false def test_sliding_surface_linearity(): â€œâ€â€Test that sliding surface is linear in state.â€â€â€ surface = LinearSlidingSurface(gains=[5, 3, 4, 2]) state1 = np.array([0.1, 0.1, 0.1, 0.05, 0.05, 0.05]) state2 = np.array([0.2, 0.2, 0.2, 0.1, 0.1, 0.1]) s1 = surface.compute(state1) s2 = surface.compute(state2) s_combined = surface.compute(state1 + state2) # Linearity: s(x1 + x2) = s(x1) + s(x2) assert abs(s_combined - (s1 + s2)) &lt; 1e-10 <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Homogeneity</span> <span class="pre">Property**:</span></code>python def test_sliding_surface_homogeneity(): â€œâ€â€Test that sliding surface is homogeneous of degree 1.â€â€â€ surface = LinearSlidingSurface(gains=[5, 3, 4, 2]) state = np.array([0.1, 0.1, 0.1, 0.05, 0.05, 0.05]) alpha = 2.5 s_original = surface.compute(state) s_scaled = surface.compute(alpha * state) # Homogeneity: s(Î±Â·x) = Î±Â·s(x) assert abs(s_scaled - alpha * s_original) &lt; 1e-10 <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Gain</span> <span class="pre">Sensitivity**:</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-def-test-sliding-surface-gain-sensitivity-test-that-surface-responds-correctly-to-gain-changes-gains1-5-3-4-2-gains2-10-6-8-4-doubled-gains-surface1-linearslidingsurface-gains1-surface2-linearslidingsurface-gains2-state-np-array-0-1-0-1-0-1-0-05-0-05-0-05-s1-surface1-compute-state-s2-surface2-compute-state-surface-value-should-double-with-doubled-gains-assert-abs-s2-2-s1-1e-10-2-1-2-boundary-layer-properties-test-suite-tests-test-controllers-smc-algorithms-classical-test-boundary-layer-py-mathematical-properties-validated-1-continuity-python">runnable: false def test_sliding_surface_gain_sensitivity(): â€œâ€â€Test that surface responds correctly to gain changes.â€â€â€ gains1 = [5, 3, 4, 2] gains2 = [10, 6, 8, 4] # Doubled gains surface1 = LinearSlidingSurface(gains1) surface2 = LinearSlidingSurface(gains2) state = np.array([0.1, 0.1, 0.1, 0.05, 0.05, 0.05]) s1 = surface1.compute(state) s2 = surface2.compute(state) # Surface value should double with doubled gains assert abs(s2 - 2 * s1) &lt; 1e-10 <code class="docutils literal notranslate"><span class="pre">####</span> <span class="pre">2.1.2</span> <span class="pre">Boundary</span> <span class="pre">Layer</span> <span class="pre">Properties</span> <span class="pre">**Test</span> <span class="pre">Suite:**</span> <span class="pre">`tests/test_controllers/smc/algorithms/classical/test_boundary_layer.py`</span> <span class="pre">**Mathematical</span> <span class="pre">Properties</span> <span class="pre">Validated:**</span> <span class="pre">1.</span> <span class="pre">**Continuity**:</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-def-test-boundary-layer-continuity-test-that-boundary-layer-provides-continuous-switching-boundary-layer-boundarylayer-thickness-0-1-switch-method-tanh-test-continuity-at-surface-s-0-epsilon-1e-8-switch-left-boundary-layer-compute-switching-function-epsilon-switch-right-boundary-layer-compute-switching-function-epsilon-switch-center-boundary-layer-compute-switching-function-0-0-values-should-be-very-close-at-the-boundary-assert-abs-switch-left-switch-center-1e-6-assert-abs-switch-right-switch-center-1e-6-2-monotonicity-python-def-test-boundary-layer-monotonicity-test-that-switching-function-is-monotonic-boundary-layer-boundarylayer-thickness-0-1-switch-method-tanh-s-values-np-linspace-1-1-100-switch-values-boundary-layer-compute-switching-function-s-for-s-in-s-values-switching-function-should-be-strictly-increasing-for-i-in-range-len-switch-values-1-assert-switch-values-i-1-switch-values-i-3-asymptotic-behavior-python-def-test-boundary-layer-asymptotic-behavior-test-asymptotic-limits-of-switching-function-boundary-layer-boundarylayer-thickness-0-1-switch-method-tanh-large-positive-surface-value-switch-pos-boundary-layer-compute-switching-function-10-0-assert-abs-switch-pos-1-0-1e-3-large-negative-surface-value-switch-neg-boundary-layer-compute-switching-function-10-0-assert-abs-switch-neg-1-0-1e-3-2-2-configuration-validation-tests-test-suite-tests-test-controllers-smc-algorithms-classical-test-config-validation-py-2-2-1-parameter-validationpython">runnable: false def test_boundary_layer_continuity(): â€œâ€â€Test that boundary layer provides continuous switching.â€â€â€ boundary_layer = BoundaryLayer(thickness=0.1, switch_method=â€tanhâ€) # Test continuity at surface (s=0) epsilon = 1e-8 switch_left = boundary_layer.compute_switching_function(-epsilon) switch_right = boundary_layer.compute_switching_function(epsilon) switch_center = boundary_layer.compute_switching_function(0.0) # Values should be very close at the boundary assert abs(switch_left - switch_center) &lt; 1e-6 assert abs(switch_right - switch_center) &lt; 1e-6 <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Monotonicity**:</span></code>python def test_boundary_layer_monotonicity(): â€œâ€â€Test that switching function is monotonic.â€â€â€ boundary_layer = BoundaryLayer(thickness=0.1, switch_method=â€tanhâ€) s_values = np.linspace(-1, 1, 100) switch_values = [boundary_layer.compute_switching_function(s) for s in s_values] # Switching function should be strictly increasing for i in range(len(switch_values) - 1): assert switch_values[i+1] &gt;= switch_values[i] <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Asymptotic</span> <span class="pre">Behavior**:</span></code>python def test_boundary_layer_asymptotic_behavior(): â€œâ€â€Test asymptotic limits of switching function.â€â€â€ boundary_layer = BoundaryLayer(thickness=0.1, switch_method=â€tanhâ€) # Large positive surface value switch_pos = boundary_layer.compute_switching_function(10.0) assert abs(switch_pos - 1.0) &lt; 1e-3 # Large negative surface value switch_neg = boundary_layer.compute_switching_function(-10.0) assert abs(switch_neg - (-1.0)) &lt; 1e-3 <code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">2.2</span> <span class="pre">Configuration</span> <span class="pre">Validation</span> <span class="pre">Tests</span> <span class="pre">**Test</span> <span class="pre">Suite:**</span> <span class="pre">`tests/test_controllers/smc/algorithms/classical/test_config_validation.py`</span> <span class="pre">####</span> <span class="pre">2.2.1</span> <span class="pre">Parameter</span> <span class="pre">Validation</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-class-testclassicalsmcconfigvalidation-test-configuration-parameter-validation-def-test-positive-gain-requirement-self-test-that-all-surface-gains-must-be-positive-valid-configuration-valid-gains-5-0-3-0-4-0-2-0-10-0-1-0-config-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-01-invalid-zero-gain-with-pytest-raises-valueerror-match-must-be-positive-invalid-gains-0-0-3-0-4-0-2-0-10-0-1-0-classicalsmcconfig-gains-invalid-gains-max-force-100-dt-0-01-boundary-layer-0-01-invalid-negative-gain-with-pytest-raises-valueerror-match-must-be-positive-invalid-gains-5-0-3-0-4-0-2-0-10-0-1-0-classicalsmcconfig-gains-invalid-gains-max-force-100-dt-0-01-boundary-layer-0-01-def-test-switching-gain-validation-self-test-switching-gain-must-be-positive-with-pytest-raises-valueerror-match-switching-gain-k-must-be-positive-invalid-gains-5-0-3-0-4-0-2-0-10-0-1-0-k-0-classicalsmcconfig-gains-invalid-gains-max-force-100-dt-0-01-boundary-layer-0-01-def-test-boundary-layer-validation-self-test-boundary-layer-thickness-validation-valid-boundary-layer-valid-gains-5-0-3-0-4-0-2-0-10-0-1-0-config-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-05-invalid-zero-boundary-layer-with-pytest-raises-valueerror-match-boundary-layer-must-be-positive-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-0-invalid-negative-boundary-layer-with-pytest-raises-valueerror-match-boundary-layer-must-be-positive-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-01">runnable: false class TestClassicalSMCConfigValidation: â€œâ€â€Test configuration parameter validation.â€â€â€ def test_positive_gain_requirement(self): â€œâ€â€Test that all surface gains must be positive.â€â€â€ # Valid configuration valid_gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] config = ClassicalSMCConfig(gains=valid_gains, max_force=100, dt=0.01, boundary_layer=0.01) # Invalid: zero gain with pytest.raises(ValueError, match=â€must be positiveâ€): invalid_gains = [0.0, 3.0, 4.0, 2.0, 10.0, 1.0] ClassicalSMCConfig(gains=invalid_gains, max_force=100, dt=0.01, boundary_layer=0.01) # Invalid: negative gain with pytest.raises(ValueError, match=â€must be positiveâ€): invalid_gains = [5.0, -3.0, 4.0, 2.0, 10.0, 1.0] ClassicalSMCConfig(gains=invalid_gains, max_force=100, dt=0.01, boundary_layer=0.01) def test_switching_gain_validation(self): â€œâ€â€Test switching gain must be positive.â€â€â€ with pytest.raises(ValueError, match=â€Switching gain K must be positiveâ€): invalid_gains = [5.0, 3.0, 4.0, 2.0, -10.0, 1.0] # K &lt; 0 ClassicalSMCConfig(gains=invalid_gains, max_force=100, dt=0.01, boundary_layer=0.01) def test_boundary_layer_validation(self): â€œâ€â€Test boundary layer thickness validation.â€â€â€ # Valid boundary layer valid_gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] config = ClassicalSMCConfig(gains=valid_gains, max_force=100, dt=0.01, boundary_layer=0.05) # Invalid: zero boundary layer with pytest.raises(ValueError, match=â€boundary_layer must be positiveâ€): ClassicalSMCConfig(gains=valid_gains, max_force=100, dt=0.01, boundary_layer=0.0) # Invalid: negative boundary layer with pytest.raises(ValueError, match=â€boundary_layer must be positiveâ€): ClassicalSMCConfig(gains=valid_gains, max_force=100, dt=0.01, boundary_layer=-0.01)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-def-test-hurwitz-stability-check-test-that-gain-combinations-satisfy-hurwitz-stability-def-check-stability-k1-k2-lam1-lam2-check-if-gains-produce-stable-sliding-dynamics-for-each-2x2-subsystem-s2-is-ci-0-stability-requires-i-0-and-ci-0-return-k1-0-and-k2-0-and-lam1-0-and-lam2-0-stable-configuration-stable-gains-5-0-3-0-4-0-2-0-10-0-1-0-config-classicalsmcconfig-gains-stable-gains-max-force-100-dt-0-01-boundary-layer-0-01-assert-check-stability-config-k1-config-k2-config-lam1-config-lam2-check-damping-ratios-zeta1-config-lam1-2-np-sqrt-config-k1-zeta2-config-lam2-2-np-sqrt-config-k2-both-subsystems-should-have-positive-damping-assert-zeta1-0-assert-zeta2-0">runnable: false def test_hurwitz_stability_check(): â€œâ€â€Test that gain combinations satisfy Hurwitz stability.â€â€â€ def check_stability(k1, k2, lam1, lam2): â€œâ€â€Check if gains produce stable sliding dynamics.â€â€â€ # For each 2x2 subsystem: sÂ² + Î»áµ¢s + cáµ¢ = 0 # Stability requires Î»áµ¢ &gt; 0 and cáµ¢ &gt; 0 return k1 &gt; 0 and k2 &gt; 0 and lam1 &gt; 0 and lam2 &gt; 0 # Stable configuration stable_gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] config = ClassicalSMCConfig(gains=stable_gains, max_force=100, dt=0.01, boundary_layer=0.01) assert check_stability(config.k1, config.k2, config.lam1, config.lam2) # Check damping ratios zeta1 = config.lam1 / (2 * np.sqrt(config.k1)) zeta2 = config.lam2 / (2 * np.sqrt(config.k2)) # Both subsystems should have positive damping assert zeta1 &gt; 0 assert zeta2 &gt; 0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-class-testnumericalaccuracy-test-numerical-accuracy-and-precision-def-test-floating-point-consistency-self-test-that-computations-are-consistent-across-repeated-calls-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-compute-control-multiple-times-results-for-in-range-100-result-controller-compute-control-state-control-result-get-control-output-result-get-control-result-get-u-if-control-is-not-none-results-append-control-if-results-results-np-array-results-all-results-should-be-identical-deterministic-computation-std-dev-np-std-results-axis-0-assert-np-all-std-dev-1e-15-machine-precision-def-test-numerical-stability-small-values-self-test-numerical-stability-with-very-small-state-values-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-very-small-state-values-near-machine-precision-small-state-np-array-1e-15-1e-15-1e-15-1e-15-1e-15-1e-15-result-controller-compute-control-small-state-control-result-get-control-output-result-get-control-result-get-u-if-control-is-not-none-control-should-be-finite-and-small-assert-np-all-np-isfinite-control-assert-np-all-np-abs-control-1-0-def-test-numerical-stability-large-values-self-test-numerical-stability-with-large-state-values-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-large-state-values-but-within-reasonable-bounds-large-state-np-array-10-0-5-0-3-0-2-0-2-0-1-0-result-controller-compute-control-large-state-control-result-get-control-output-result-get-control-result-get-u-if-control-is-not-none-control-should-be-finite-and-saturated-assert-np-all-np-isfinite-control-assert-np-all-np-abs-control-config-max-force-1-01-within-saturation">runnable: false class TestNumericalAccuracy: â€œâ€â€Test numerical accuracy and precision.â€â€â€ def test_floating_point_consistency(self): â€œâ€â€Test that computations are consistent across repeated calls.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) # Compute control multiple times results = [] for _ in range(100): result = controller.compute_control(state, {}, {}) control = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, result.get(â€˜uâ€™))) if control is not None: results.append(control) if results: results = np.array(results) # All results should be identical (deterministic computation) std_dev = np.std(results, axis=0) assert np.all(std_dev &lt; 1e-15) # Machine precision def test_numerical_stability_small_values(self): â€œâ€â€Test numerical stability with very small state values.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) # Very small state values (near machine precision) small_state = np.array([1e-15, 1e-15, 1e-15, 1e-15, 1e-15, 1e-15]) result = controller.compute_control(small_state, {}, {}) control = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, result.get(â€˜uâ€™))) if control is not None: # Control should be finite and small assert np.all(np.isfinite(control)) assert np.all(np.abs(control) &lt; 1.0) def test_numerical_stability_large_values(self): â€œâ€â€Test numerical stability with large state values.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) # Large state values (but within reasonable bounds) large_state = np.array([10.0, 5.0, 3.0, 2.0, 2.0, 1.0]) result = controller.compute_control(large_state, {}, {}) control = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, result.get(â€˜uâ€™))) if control is not None: # Control should be finite and saturated assert np.all(np.isfinite(control)) assert np.all(np.abs(control) &lt;= config.max_force * 1.01) # Within saturation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-class-testsystemlevelmathematics-test-mathematical-consistency-across-system-components-def-test-control-law-decomposition-self-test-that-control-law-components-sum-correctly-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-get-overall-control-output-result-controller-compute-control-state-total-control-result-get-control-output-result-get-control-result-get-u-get-individual-components-if-available-in-debug-output-components-result-get-debug-if-u-equivalent-in-components-and-u-switching-in-components-and-u-derivative-in-components-u-eq-components-u-equivalent-u-sw-components-u-switching-u-d-components-u-derivative-before-saturation-should-sum-correctly-u-unsaturated-u-eq-u-sw-u-d-after-saturation-u-saturated-np-clip-u-unsaturated-config-max-force-config-max-force-should-match-total-control-before-any-additional-processing-if-total-control-is-not-none-assert-np-allclose-u-saturated-total-control-rtol-1e-10-def-test-lyapunov-function-properties-self-test-lyapunov-function-properties-for-stability-analysis-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-surface-linearslidingsurface-config-get-surface-gains-multiple-test-states-states-np-array-0-1-0-05-0-08-0-02-0-03-0-01-np-array-0-2-0-1-0-15-0-05-0-08-0-03-np-array-0-1-0-05-0-08-0-02-0-03-0-01-for-state-in-states-s-surface-compute-state-lyapunov-function-candidate-v-0-5-s2-v-0-5-s-2-v-should-be-non-negative-assert-v-0-v-0-if-and-only-if-s-0-if-abs-s-1e-10-assert-v-1e-15-else-assert-v-0-def-test-reaching-law-satisfaction-self-test-that-reaching-law-is-satisfied-ss-s-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-surface-linearslidingsurface-config-get-surface-gains-test-state-away-from-surface-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-s-surface-compute-state-simplified-reaching-law-check-without-full-dynamics-for-switching-control-u-sw-k-sign-s-the-reaching-condition-ss-s-should-be-satisfied-when-k-is-chosen-large-enough-this-is-a-simplified-test-full-test-would-require-dynamics-model-if-abs-s-config-boundary-layer-outside-boundary-layer-should-have-strong-reaching-behavior-expected-reaching-rate-config-k-abs-s-max-abs-s-config-boundary-layer-assert-expected-reaching-rate-0-should-be-moving-toward-surface">runnable: false class TestSystemLevelMathematics: â€œâ€â€Test mathematical consistency across system components.â€â€â€ def test_control_law_decomposition(self): â€œâ€â€Test that control law components sum correctly.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) # Get overall control output result = controller.compute_control(state, {}, {}) total_control = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, result.get(â€˜uâ€™))) # Get individual components (if available in debug output) components = result.get(â€˜debugâ€™, {}) if â€˜u_equivalentâ€™ in components and â€˜u_switchingâ€™ in components and â€˜u_derivativeâ€™ in components: u_eq = components[â€˜u_equivalentâ€™] u_sw = components[â€˜u_switchingâ€™] u_d = components[â€˜u_derivativeâ€™] # Before saturation, should sum correctly u_unsaturated = u_eq + u_sw + u_d # After saturation u_saturated = np.clip(u_unsaturated, -config.max_force, config.max_force) # Should match total control (before any additional processing) if total_control is not None: assert np.allclose(u_saturated, total_control, rtol=1e-10) def test_lyapunov_function_properties(self): â€œâ€â€Test Lyapunov function properties for stability analysis.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) surface = LinearSlidingSurface(config.get_surface_gains()) # Multiple test states states = [ np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]), np.array([0.2, 0.1, 0.15, 0.05, 0.08, 0.03]), np.array([-0.1, -0.05, -0.08, -0.02, -0.03, -0.01]) ] for state in states: s = surface.compute(state) # Lyapunov function candidate: V = 0.5 * sÂ² V = 0.5 * s**2 # V should be non-negative assert V &gt;= 0 # V = 0 if and only if s = 0 if abs(s) &lt; 1e-10: assert V &lt; 1e-15 else: assert V &gt; 0 def test_reaching_law_satisfaction(self): â€œâ€â€Test that reaching law is satisfied: s<em>á¹¡ â‰¤ -Î·|s|.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) surface = LinearSlidingSurface(config.get_surface_gains()) # Test state away from surface state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) s = surface.compute(state) # Simplified reaching law check (without full dynamics) # For switching control: u_sw = -K * sign(s) # The reaching condition s</em>á¹¡ â‰¤ -Î·|s| should be satisfied # when K is chosen large enough # This is a simplified test - full test would require dynamics model if abs(s) &gt; config.boundary_layer: # Outside boundary layer, should have strong reaching behavior expected_reaching_rate = -config.K * abs(s) / max(abs(s), config.boundary_layer) assert expected_reaching_rate &lt; 0 # Should be moving toward surface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#fast-unit-tests-mathematical-properties">Fast unit tests (mathematical properties)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#extended-property-based-testing">Extended property-based testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/validation_framework_guide.html">Validation Framework Guide <strong>System Reliability Foundation: Robust Parameter Validation &amp; Scientific Verification</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/validation_framework_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/validation_framework_guide.html#runnable-false-good-validate-once-at-construction">runnable: false # âœ… GOOD: Validate once at construction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/validation_framework_guide.html#good-single-validation-for-array">âœ… GOOD: Single validation for array</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_validation_procedures.html">Mathematical Validation Procedures for Control Systems ## Executive Summary This document establishes mathematical validation procedures for the double-inverted pendulum sliding mode control (DIP-SMC) project, ensuring theoretical soundness and implementation correctness through rigorous mathematical property verification. The procedures integrate control theory, optimization theory, and numerical analysis validation with automated testing frameworks. <strong>Core Mathematical Domains:</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_management_patterns.html">Controller Memory Management Patterns (Issue #15 Resolution) <strong>Date:</strong> 2025-10-01</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_management_patterns.html#no-explicit-cleanup-needed-automatic-via-del">No explicit cleanup needed (automatic via <strong>del</strong>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_management_patterns.html#controller-automatically-cleaned-up-when-out-of-scope">Controller automatically cleaned up when out of scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_management_patterns.html#explicit-cleanup-recommended">Explicit cleanup recommended</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_management_patterns.html#cleanup-every-n-iterations">Cleanup every N iterations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_management_quick_reference.html">Controller Memory Management Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../numerical_stability_guide.html">Numerical Stability Guide <strong>Version</strong>: 1.2.0 | <strong>Last Updated</strong>: 2025-10-01 ## Overview This guide documents the adaptive matrix regularization system implemented in the double-inverted pendulum control framework. The system provides robust numerical stability for matrix operations in plant dynamics, controllers, and optimization algorithms.</a></li>
<li class="toctree-l1"><a class="reference internal" href="../numerical_stability_guide.html#for-well-conditioned-systems-or-debugging">For well-conditioned systems or debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plant_model.html">1.x Plant Model</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../production/index.html">Production Deployment</a><input aria-label="Toggle navigation of Production Deployment" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../production/production_readiness_assessment_v2.html">Production Readiness Assessment v2.0 <strong>Date</strong>: 2025-09-29</a></li>
<li class="toctree-l2"><a class="reference internal" href="../production_readiness_final.html">Production Readiness Assessment - Final Report <strong>Date:</strong> 2025-09-29</a></li>
<li class="toctree-l2"><a class="reference internal" href="../production_readiness_framework.html">Production Readiness Assessment Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../production_documentation_summary.html">Production Documentation Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html">PSO Configuration Schema Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#top-level-pso-configuration-structure">Top-level PSO configuration structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#runnable-false-class-constraintpropagator-intelligent-constraint-propagation-for-interdependent-pso-parameters-def-init-self-controller-type-str-self-controller-type-controller-type-self-constraint-graph-self-build-constraint-graph-def-propagate-constraints-self-initial-bounds-dict-dict-propagate-constraints-through-parameter-dependency-graph-example-if-1-is-constrained-to-0-1-5-0-for-issue-2-then-c1-bounds-must-ensure-1-1-2c1-0-69-0-8-propagated-bounds-initial-bounds-copy-iterative-constraint-propagation-converged-false-max-iterations-10-iteration-0-while-not-converged-and-iteration-max-iterations-old-bounds-propagated-bounds-copy-apply-constraint-rules-for-constraint-in-self-constraint-graph-propagated-bounds-self-apply-constraint-rule-constraint-propagated-bounds-check-convergence-converged-self-bounds-converged-old-bounds-propagated-bounds-iteration-1-return-propagated-bounds-def-apply-constraint-rule-self-constraint-dict-bounds-dict-dict-apply-individual-constraint-rule-with-mathematical-validation-if-constraint-type-damping-ratio-2c-constraint-propagation-lambda-idx-constraint-lambda-idx-c-idx-constraint-c-idx-target-zeta-range-constraint-zeta-range-lambda-min-lambda-max-bounds-min-lambda-idx-bounds-max-lambda-idx-derive-c-bounds-from-lambda-bounds-and-zeta-constraints-for-min-2c-max-c-min-2-max-2-c-max-2-min-2-c-min-from-lambda-lambda-min-2-target-zeta-range-1-2-c-max-from-lambda-lambda-max-2-target-zeta-range-0-2-update-c-bounds-with-constraint-propagation-bounds-min-c-idx-max-bounds-min-c-idx-c-min-from-lambda-bounds-max-c-idx-min-bounds-max-c-idx-c-max-from-lambda-elif-constraint-type-sta-stability-k1-k2-constraint-with-margin-k1-idx-k2-idx-constraint-k1-idx-constraint-k2-idx-margin-constraint-get-margin-0-1-ensure-k1-min-k2-max-margin-bounds-min-k1-idx-max-bounds-min-k1-idx-bounds-max-k2-idx-margin-return-bounds-def-build-constraint-graph-self-list-build-constraint-dependency-graph-for-controller-type-if-self-controller-type-classical-smc-return-type-damping-ratio-lambda-idx-1-c-idx-0-zeta-range-0-6-0-8-type-damping-ratio-lambda-idx-3-c-idx-2-zeta-range-0-6-0-8-type-actuator-saturation-gain-indices-4-5-k-kd-max-total-150-0-elif-self-controller-type-sta-smc-return-type-sta-stability-k1-idx-0-k2-idx-1-margin-0-1-type-damping-ratio-lambda-idx-4-c-idx-2-lambda1-k1-zeta-range-0-69-0-8-issue-2-requirement-type-damping-ratio-lambda-idx-5-c-idx-3-lambda2-k2-zeta-range-0-69-0-8-issue-2-requirement-return">runnable: false class ConstraintPropagator: â€œâ€â€ Intelligent constraint propagation for interdependent PSO parameters. â€œâ€â€ def <strong>init</strong>(self, controller_type: str): self.controller_type = controller_type self.constraint_graph = self._build_constraint_graph() def propagate_constraints(self, initial_bounds: dict) -&gt; dict: â€œâ€â€ Propagate constraints through parameter dependency graph. Example: If Î»â‚ is constrained to [0.1, 5.0] for Issue #2, then câ‚ bounds must ensure Î¶â‚ = Î»â‚/(2âˆšcâ‚) âˆˆ [0.69, 0.8] â€œâ€â€ propagated_bounds = initial_bounds.copy() # Iterative constraint propagation converged = False max_iterations = 10 iteration = 0 while not converged and iteration &lt; max_iterations: old_bounds = propagated_bounds.copy() # Apply constraint rules for constraint in self.constraint_graph: propagated_bounds = self._apply_constraint_rule( constraint, propagated_bounds ) # Check convergence converged = self._bounds_converged(old_bounds, propagated_bounds) iteration += 1 return propagated_bounds def _apply_constraint_rule(self, constraint: dict, bounds: dict) -&gt; dict: â€œâ€â€ Apply individual constraint rule with mathematical validation. â€œâ€â€ if constraint[â€˜typeâ€™] == â€˜damping_ratioâ€™: # Î¶ = Î»/(2âˆšc) constraint propagation lambda_idx = constraint[â€˜lambda_idxâ€™] c_idx = constraint[â€˜c_idxâ€™] target_zeta_range = constraint[â€˜zeta_rangeâ€™] lambda_min, lambda_max = bounds[â€˜minâ€™][lambda_idx], bounds[â€˜maxâ€™][lambda_idx] # Derive c bounds from lambda bounds and zeta constraints # For Î¶_min â‰¤ Î»/(2âˆšc) â‰¤ Î¶_max: # c_min = (Î»/(2Î¶_max))Â², c_max = (Î»/(2Î¶_min))Â² c_min_from_lambda = (lambda_min / (2 * target_zeta_range[1]))**2 c_max_from_lambda = (lambda_max / (2 * target_zeta_range[0]))**2 # Update c bounds with constraint propagation bounds[â€˜minâ€™][c_idx] = max(bounds[â€˜minâ€™][c_idx], c_min_from_lambda) bounds[â€˜maxâ€™][c_idx] = min(bounds[â€˜maxâ€™][c_idx], c_max_from_lambda) elif constraint[â€˜typeâ€™] == â€˜sta_stabilityâ€™: # Kâ‚ &gt; Kâ‚‚ constraint with margin k1_idx, k2_idx = constraint[â€˜k1_idxâ€™], constraint[â€˜k2_idxâ€™] margin = constraint.get(â€˜marginâ€™, 0.1) # Ensure Kâ‚_min &gt; Kâ‚‚_max + margin bounds[â€˜minâ€™][k1_idx] = max( bounds[â€˜minâ€™][k1_idx], bounds[â€˜maxâ€™][k2_idx] + margin ) return bounds def _build_constraint_graph(self) -&gt; list: â€œâ€â€ Build constraint dependency graph for controller type. â€œâ€â€ if self.controller_type == â€˜classical_smcâ€™: return [ { â€˜typeâ€™: â€˜damping_ratioâ€™, â€˜lambda_idxâ€™: 1, â€˜c_idxâ€™: 0, â€˜zeta_rangeâ€™: [0.6, 0.8] }, { â€˜typeâ€™: â€˜damping_ratioâ€™, â€˜lambda_idxâ€™: 3, â€˜c_idxâ€™: 2, â€˜zeta_rangeâ€™: [0.6, 0.8] }, { â€˜typeâ€™: â€˜actuator_saturationâ€™, â€˜gain_indicesâ€™: [4, 5], # K, kd â€˜max_totalâ€™: 150.0 } ] elif self.controller_type == â€˜sta_smcâ€™: return [ { â€˜typeâ€™: â€˜sta_stabilityâ€™, â€˜k1_idxâ€™: 0, â€˜k2_idxâ€™: 1, â€˜marginâ€™: 0.1 }, { â€˜typeâ€™: â€˜damping_ratioâ€™, â€˜lambda_idxâ€™: 4, â€˜c_idxâ€™: 2, # lambda1, k1 â€˜zeta_rangeâ€™: [0.69, 0.8] # Issue #2 requirement }, { â€˜typeâ€™: â€˜damping_ratioâ€™, â€˜lambda_idxâ€™: 5, â€˜c_idxâ€™: 3, # lambda2, k2 â€˜zeta_rangeâ€™: [0.69, 0.8] # Issue #2 requirement } ] return []</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#configuration-schema-version-metadata">Configuration schema version metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#runnable-false-class-configurationmigrator-automatic-migration-framework-for-pso-configuration-schema-evolution-def-init-self-self-migration-rules-1-0-self-migrate-from-v1-0-1-5-self-migrate-from-v1-5-2-0-self-migrate-from-v2-0-def-migrate-configuration-self-config-dict-source-version-str-tuple-migrate-configuration-from-source-version-to-current-schema-returns-tuple-migrated-config-migration-warnings-compatibility-issues-if-source-version-not-in-self-migration-rules-raise-valueerror-f-unsupported-source-version-source-version-migrated-config-config-copy-warnings-issues-apply-migration-rules-in-sequence-current-version-source-version-while-current-version-current-schema-version-migrator-self-migration-rules-current-version-migrated-config-step-warnings-migrator-migrated-config-warnings-extend-step-warnings-current-version-self-get-next-version-current-version-validate-migrated-configuration-validation-result-pso-configurationvalidator-validate-complete-config-migrated-config-if-not-validation-result-is-valid-issues-extend-validation-result-errors-return-migrated-config-warnings-issues-def-migrate-from-v1-0-self-config-dict-tuple-migrate-from-v1-0-to-v1-5-remove-deprecated-fields-update-bounds-migrated-config-copy-warnings-remove-deprecated-fields-deprecated-fields-n-processes-hyper-trials-hyper-search-study-timeout-for-field-in-deprecated-fields-if-field-in-migrated-get-pso-del-migrated-pso-field-warnings-append-f-removed-deprecated-field-field-update-pso-bounds-structure-if-pso-in-migrated-and-bounds-in-migrated-pso-old-bounds-migrated-pso-bounds-new-bounds-self-restructure-bounds-v1-5-old-bounds-migrated-pso-bounds-new-bounds-warnings-append-restructured-bounds-for-controller-specific-optimization-return-migrated-warnings-def-migrate-from-v2-0-self-config-dict-tuple-migrate-from-v2-0-to-v2-1-issue-2-bounds-updates-and-enhanced-features-migrated-config-copy-warnings-update-sta-smc-bounds-for-issue-2-compliance-if-pso-in-migrated-and-bounds-in-migrated-pso-bounds-migrated-pso-bounds-if-sta-smc-in-bounds-sta-bounds-bounds-sta-smc-check-for-issue-2-problematic-bounds-if-max-in-sta-bounds-and-len-sta-bounds-max-6-lambda1-max-lambda2-max-sta-bounds-max-4-sta-bounds-max-5-if-lambda1-max-10-0-or-lambda2-max-10-0-apply-issue-2-corrections-sta-bounds-max-4-min-lambda1-max-10-0-lambda1-sta-bounds-max-5-min-lambda2-max-10-0-lambda2-warnings-append-applied-issue-2-lambda-bounds-corrections-for-overshoot-mitigation-add-enhanced-features-if-missing-if-enhanced-features-not-in-migrated-get-pso-migrated-pso-enhanced-features-w-schedule-0-9-0-4-velocity-clamp-0-1-0-2-early-stopping-patience-50-tolerance-1e-6-warnings-append-added-enhanced-pso-features-for-improved-convergence-return-migrated-warnings-def-generate-migration-report-self-old-config-dict-new-config-dict-warnings-list-issues-list-str-generate-migration-report-for-documentation-report-f">runnable: false class ConfigurationMigrator: â€œâ€â€ Automatic migration framework for PSO configuration schema evolution. â€œâ€â€ def <strong>init</strong>(self): self.migration_rules = { â€œ1.0â€: self._migrate_from_v1_0, â€œ1.5â€: self._migrate_from_v1_5, â€œ2.0â€: self._migrate_from_v2_0 } def migrate_configuration(self, config: dict, source_version: str) -&gt; tuple: â€œâ€â€ Migrate configuration from source version to current schema. Returns: tuple: (migrated_config, migration_warnings, compatibility_issues) â€œâ€â€ if source_version not in self.migration_rules: raise ValueError(fâ€Unsupported source version: {source_version}â€) migrated_config = config.copy() warnings = [] issues = [] # Apply migration rules in sequence current_version = source_version while current_version != CURRENT_SCHEMA_VERSION: migrator = self.migration_rules[current_version] migrated_config, step_warnings = migrator(migrated_config) warnings.extend(step_warnings) current_version = self._get_next_version(current_version) # Validate migrated configuration validation_result = PSO_ConfigurationValidator().validate_complete_config(migrated_config) if not validation_result.is_valid: issues.extend(validation_result.errors) return migrated_config, warnings, issues def _migrate_from_v1_0(self, config: dict) -&gt; tuple: â€œâ€â€ Migrate from v1.0 to v1.5: Remove deprecated fields, update bounds. â€œâ€â€ migrated = config.copy() warnings = [] # Remove deprecated fields deprecated_fields = [â€˜n_processesâ€™, â€˜hyper_trialsâ€™, â€˜hyper_searchâ€™, â€˜study_timeoutâ€™] for field in deprecated_fields: if field in migrated.get(â€˜psoâ€™, {}): del migrated[â€˜psoâ€™][field] warnings.append(fâ€Removed deprecated field: {field}â€) # Update PSO bounds structure if â€˜psoâ€™ in migrated and â€˜boundsâ€™ in migrated[â€˜psoâ€™]: old_bounds = migrated[â€˜psoâ€™][â€˜boundsâ€™] new_bounds = self._restructure_bounds_v1_5(old_bounds) migrated[â€˜psoâ€™][â€˜boundsâ€™] = new_bounds warnings.append(â€œRestructured bounds for controller-specific optimizationâ€) return migrated, warnings def _migrate_from_v2_0(self, config: dict) -&gt; tuple: â€œâ€â€ Migrate from v2.0 to v2.1: Issue #2 bounds updates and enhanced features. â€œâ€â€ migrated = config.copy() warnings = [] # Update STA-SMC bounds for Issue #2 compliance if â€˜psoâ€™ in migrated and â€˜boundsâ€™ in migrated[â€˜psoâ€™]: bounds = migrated[â€˜psoâ€™][â€˜boundsâ€™] if â€˜sta_smcâ€™ in bounds: sta_bounds = bounds[â€˜sta_smcâ€™] # Check for Issue #2 problematic bounds if â€˜maxâ€™ in sta_bounds and len(sta_bounds[â€˜maxâ€™]) &gt;= 6: lambda1_max, lambda2_max = sta_bounds[â€˜maxâ€™][4], sta_bounds[â€˜maxâ€™][5] if lambda1_max &gt; 10.0 or lambda2_max &gt; 10.0: # Apply Issue #2 corrections sta_bounds[â€˜maxâ€™][4] = min(lambda1_max, 10.0) # lambda1 sta_bounds[â€˜maxâ€™][5] = min(lambda2_max, 10.0) # lambda2 warnings.append(â€œApplied Issue #2 lambda bounds corrections for overshoot mitigationâ€) # Add enhanced features if missing if â€˜enhanced_featuresâ€™ not in migrated.get(â€˜psoâ€™, {}): migrated[â€˜psoâ€™][â€˜enhanced_featuresâ€™] = { â€˜w_scheduleâ€™: [0.9, 0.4], â€˜velocity_clampâ€™: [0.1, 0.2], â€˜early_stoppingâ€™: {â€˜patienceâ€™: 50, â€˜toleranceâ€™: 1e-6} } warnings.append(â€œAdded enhanced PSO features for improved convergenceâ€) return migrated, warnings def generate_migration_report(self, old_config: dict, new_config: dict, warnings: list, issues: list) -&gt; str: â€œâ€â€ Generate migration report for documentation. â€œâ€â€ report = fâ€â€â€</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#pso-configuration-migration-report-summary">PSO Configuration Migration Report ## Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#runnable-false-class-configurationerrorhandler-error-handling-and-diagnostic-system-for-pso-configuration-error-categories-syntax-severity-critical-auto-fixable-false-description-yaml-syntax-or-structure-errors-type-severity-critical-auto-fixable-true-description-data-type-mismatches-bounds-severity-high-auto-fixable-true-description-parameter-bounds-violations-mathematical-severity-high-auto-fixable-false-description-mathematical-consistency-violations-performance-severity-medium-auto-fixable-true-description-suboptimal-performance-configuration-compatibility-severity-medium-auto-fixable-true-description-controller-compatibility-issues-def-diagnose-configuration-errors-self-config-dict-controller-type-str-none-dict-configuration-error-diagnosis-with-auto-fix-suggestions-diagnosis-errors-warnings-auto-fixes-manual-actions-overall-status-unknown-run-diagnostic-checks-for-category-info-in-self-error-categories-items-category-errors-self-check-category-category-config-controller-type-for-error-in-category-errors-error-category-category-error-severity-info-severity-error-auto-fixable-info-auto-fixable-if-error-severity-critical-diagnosis-errors-append-error-else-diagnosis-warnings-append-error-generate-fix-suggestions-if-error-auto-fixable-fix-self-generate-auto-fix-error-config-if-fix-diagnosis-auto-fixes-append-fix-else-manual-action-self-generate-manual-action-error-if-manual-action-diagnosis-manual-actions-append-manual-action-determine-overall-status-if-diagnosis-errors-diagnosis-overall-status-critical-elif-len-diagnosis-warnings-5-diagnosis-overall-status-needs-attention-elif-diagnosis-warnings-diagnosis-overall-status-minor-issues-else-diagnosis-overall-status-healthy-return-diagnosis-def-check-category-self-category-str-config-dict-controller-type-str-list-check-specific-error-category-and-return-found-issues-errors-if-category-mathematical-pso-convergence-check-if-algorithm-params-in-config-params-config-algorithm-params-if-c1-in-params-and-c2-in-params-phi-params-c1-params-c2-if-phi-4-0-errors-append-code-pso-convergence-risk-message-f-pso-may-not-converge-c1-c2-phi-3f-4-0-location-algorithm-params-c1-algorithm-params-c2-impact-optimization-may-fail-to-converge-elif-category-bounds-and-controller-type-issue-2-specific-checks-for-sta-smc-if-controller-type-sta-smc-and-bounds-in-config-bounds-config-bounds-if-sta-smc-in-bounds-and-max-in-bounds-sta-smc-max-bounds-bounds-sta-smc-max-if-len-max-bounds-6-lambda1-max-lambda2-max-max-bounds-4-max-bounds-5-if-lambda1-max-10-0-or-lambda2-max-10-0-errors-append-code-issue2-bounds-violation-message-f-sta-smc-lambda-bounds-may-cause-overshoot-1-max-lambda1-max-2-max-lambda2-max-location-bounds-sta-smc-max-4-6-impact-may-cause-5-overshoot-issue-2-regression-elif-category-performance-suboptimal-parameter-detection-if-algorithm-params-in-config-params-config-algorithm-params-if-n-particles-in-params-n-particles-params-n-particles-if-n-particles-10-or-n-particles-50-errors-append-code-suboptimal-swarm-size-message-f-swarm-size-n-particles-outside-optimal-range-10-50-location-algorithm-params-n-particles-impact-suboptimal-convergence-speed-or-quality-return-errors-def-generate-auto-fix-self-error-dict-config-dict-dict-generate-automatic-fix-for-fixable-errors-if-error-code-pso-convergence-risk-return-error-code-error-code-fix-type-parameter-adjustment-action-increase-c1-and-c2-to-ensure-4-changes-algorithm-params-c1-2-1-algorithm-params-c2-2-1-justification-ensures-pso-convergence-with-4-2-4-elif-error-code-issue2-bounds-violation-return-error-code-error-code-fix-type-bounds-correction-action-apply-issue-2-lambda-bounds-corrections-changes-bounds-sta-smc-max-4-10-0-lambda1-bounds-sta-smc-max-5-10-0-lambda2-justification-prevents-overshoot-regression-from-issue-2-elif-error-code-suboptimal-swarm-size-current-size-config-algorithm-params-n-particles-optimal-size-np-clip-current-size-15-25-clamp-to-optimal-range-return-error-code-error-code-fix-type-parameter-optimization-action-f-adjust-swarm-size-to-optimal-range-changes-algorithm-params-n-particles-optimal-size-justification-f-optimizes-convergence-for-optimal-size-particles-return-none-def-apply-auto-fixes-self-config-dict-fixes-list-tuple-apply-automatic-fixes-to-configuration-returns-tuple-fixed-config-applied-fixes-failed-fixes-fixed-config-config-copy-applied-fixes-failed-fixes-for-fix-in-fixes-try-for-path-new-value-in-fix-changes-items-self-set-nested-value-fixed-config-path-new-value-applied-fixes-append-fix-except-exception-as-e-fix-error-str-e-failed-fixes-append-fix-return-fixed-config-applied-fixes-failed-fixes-def-set-nested-value-self-config-dict-path-str-value-any-none-set-nested-configuration-value-using-dot-notation-path-keys-path-split-current-config-for-key-in-keys-1-if-in-key-and-in-key-handle-array-indexing-array-key-index-str-key-split-index-int-index-str-rstrip-if-array-key-not-in-current-current-array-key-current-current-array-key-extend-array-if-necessary-while-len-current-index-current-append-none-current-current-index-else-if-key-not-in-current-current-key-current-current-key-set-the-final-value-final-key-keys-1-if-in-final-key-and-in-final-key-array-key-index-str-final-key-split-index-int-index-str-rstrip-if-array-key-not-in-current-current-array-key-while-len-current-array-key-index-current-array-key-append-none-current-array-key-index-value-else-current-final-key-value">runnable: false class ConfigurationErrorHandler: â€œâ€â€ error handling and diagnostic system for PSO configuration. â€œâ€â€ ERROR_CATEGORIES = { â€˜SYNTAXâ€™: { â€˜severityâ€™: â€˜CRITICALâ€™, â€˜auto_fixableâ€™: False, â€˜descriptionâ€™: â€˜YAML syntax or structure errorsâ€™ }, â€˜TYPEâ€™: { â€˜severityâ€™: â€˜CRITICALâ€™, â€˜auto_fixableâ€™: True, â€˜descriptionâ€™: â€˜Data type mismatchesâ€™ }, â€˜BOUNDSâ€™: { â€˜severityâ€™: â€˜HIGHâ€™, â€˜auto_fixableâ€™: True, â€˜descriptionâ€™: â€˜Parameter bounds violationsâ€™ }, â€˜MATHEMATICALâ€™: { â€˜severityâ€™: â€˜HIGHâ€™, â€˜auto_fixableâ€™: False, â€˜descriptionâ€™: â€˜Mathematical consistency violationsâ€™ }, â€˜PERFORMANCEâ€™: { â€˜severityâ€™: â€˜MEDIUMâ€™, â€˜auto_fixableâ€™: True, â€˜descriptionâ€™: â€˜Suboptimal performance configurationâ€™ }, â€˜COMPATIBILITYâ€™: { â€˜severityâ€™: â€˜MEDIUMâ€™, â€˜auto_fixableâ€™: True, â€˜descriptionâ€™: â€˜Controller compatibility issuesâ€™ } } def diagnose_configuration_errors(self, config: dict, controller_type: str = None) -&gt; dict: â€œâ€â€ configuration error diagnosis with auto-fix suggestions. â€œâ€â€ diagnosis = { â€˜errorsâ€™: [], â€˜warningsâ€™: [], â€˜auto_fixesâ€™: [], â€˜manual_actionsâ€™: [], â€˜overall_statusâ€™: â€˜UNKNOWNâ€™ } # Run diagnostic checks for category, info in self.ERROR_CATEGORIES.items(): category_errors = self._check_category(category, config, controller_type) for error in category_errors: error[â€˜categoryâ€™] = category error[â€˜severityâ€™] = info[â€˜severityâ€™] error[â€˜auto_fixableâ€™] = info[â€˜auto_fixableâ€™] if error[â€˜severityâ€™] == â€˜CRITICALâ€™: diagnosis[â€˜errorsâ€™].append(error) else: diagnosis[â€˜warningsâ€™].append(error) # Generate fix suggestions if error[â€˜auto_fixableâ€™]: fix = self._generate_auto_fix(error, config) if fix: diagnosis[â€˜auto_fixesâ€™].append(fix) else: manual_action = self._generate_manual_action(error) if manual_action: diagnosis[â€˜manual_actionsâ€™].append(manual_action) # Determine overall status if diagnosis[â€˜errorsâ€™]: diagnosis[â€˜overall_statusâ€™] = â€˜CRITICALâ€™ elif len(diagnosis[â€˜warningsâ€™]) &gt; 5: diagnosis[â€˜overall_statusâ€™] = â€˜NEEDS_ATTENTIONâ€™ elif diagnosis[â€˜warningsâ€™]: diagnosis[â€˜overall_statusâ€™] = â€˜MINOR_ISSUESâ€™ else: diagnosis[â€˜overall_statusâ€™] = â€˜HEALTHYâ€™ return diagnosis def _check_category(self, category: str, config: dict, controller_type: str) -&gt; list: â€œâ€â€ Check specific error category and return found issues. â€œâ€â€ errors = [] if category == â€˜MATHEMATICALâ€™: # PSO convergence check if â€˜algorithm_paramsâ€™ in config: params = config[â€˜algorithm_paramsâ€™] if â€˜c1â€™ in params and â€˜c2â€™ in params: phi = params[â€˜c1â€™] + params[â€˜c2â€™] if phi &lt;= 4.0: errors.append({ â€˜codeâ€™: â€˜PSO_CONVERGENCE_RISKâ€™, â€˜messageâ€™: fâ€™PSO may not converge: Ï† = câ‚ + câ‚‚ = {phi:.3f} â‰¤ 4.0â€™, â€˜locationâ€™: â€˜algorithm_params.c1, algorithm_params.c2â€™, â€˜impactâ€™: â€˜Optimization may fail to convergeâ€™ }) elif category == â€˜BOUNDSâ€™ and controller_type: # Issue #2 specific checks for STA-SMC if controller_type == â€˜sta_smcâ€™ and â€˜boundsâ€™ in config: bounds = config[â€˜boundsâ€™] if â€˜sta_smcâ€™ in bounds and â€˜maxâ€™ in bounds[â€˜sta_smcâ€™]: max_bounds = bounds[â€˜sta_smcâ€™][â€˜maxâ€™] if len(max_bounds) &gt;= 6: lambda1_max, lambda2_max = max_bounds[4], max_bounds[5] if lambda1_max &gt; 10.0 or lambda2_max &gt; 10.0: errors.append({ â€˜codeâ€™: â€˜ISSUE2_BOUNDS_VIOLATIONâ€™, â€˜messageâ€™: fâ€™STA-SMC lambda bounds may cause overshoot: Î»â‚_max={lambda1_max}, Î»â‚‚_max={lambda2_max}â€™, â€˜locationâ€™: â€˜bounds.sta_smc.max[4:6]â€™, â€˜impactâ€™: â€˜May cause &gt;5% overshoot (Issue #2 regression)â€™ }) elif category == â€˜PERFORMANCEâ€™: # Suboptimal parameter detection if â€˜algorithm_paramsâ€™ in config: params = config[â€˜algorithm_paramsâ€™] if â€˜n_particlesâ€™ in params: n_particles = params[â€˜n_particlesâ€™] if n_particles &lt; 10 or n_particles &gt; 50: errors.append({ â€˜codeâ€™: â€˜SUBOPTIMAL_SWARM_SIZEâ€™, â€˜messageâ€™: fâ€™Swarm size {n_particles} outside optimal range [10, 50]â€™, â€˜locationâ€™: â€˜algorithm_params.n_particlesâ€™, â€˜impactâ€™: â€˜Suboptimal convergence speed or qualityâ€™ }) return errors def _generate_auto_fix(self, error: dict, config: dict) -&gt; dict: â€œâ€â€ Generate automatic fix for fixable errors. â€œâ€â€ if error[â€˜codeâ€™] == â€˜PSO_CONVERGENCE_RISKâ€™: return { â€˜error_codeâ€™: error[â€˜codeâ€™], â€˜fix_typeâ€™: â€˜parameter_adjustmentâ€™, â€˜actionâ€™: â€˜Increase câ‚ and câ‚‚ to ensure Ï† &gt; 4â€™, â€˜changesâ€™: { â€˜algorithm_params.c1â€™: 2.1, â€˜algorithm_params.c2â€™: 2.1 }, â€˜justificationâ€™: â€˜Ensures PSO convergence with Ï† = 4.2 &gt; 4â€™ } elif error[â€˜codeâ€™] == â€˜ISSUE2_BOUNDS_VIOLATIONâ€™: return { â€˜error_codeâ€™: error[â€˜codeâ€™], â€˜fix_typeâ€™: â€˜bounds_correctionâ€™, â€˜actionâ€™: â€˜Apply Issue #2 lambda bounds correctionsâ€™, â€˜changesâ€™: { â€˜bounds.sta_smc.max[4]â€™: 10.0, # lambda1 â€˜bounds.sta_smc.max[5]â€™: 10.0 # lambda2 }, â€˜justificationâ€™: â€˜Prevents overshoot regression from Issue #2â€™ } elif error[â€˜codeâ€™] == â€˜SUBOPTIMAL_SWARM_SIZEâ€™: current_size = config[â€˜algorithm_paramsâ€™][â€˜n_particlesâ€™] optimal_size = np.clip(current_size, 15, 25) # Clamp to optimal range return { â€˜error_codeâ€™: error[â€˜codeâ€™], â€˜fix_typeâ€™: â€˜parameter_optimizationâ€™, â€˜actionâ€™: fâ€™Adjust swarm size to optimal rangeâ€™, â€˜changesâ€™: { â€˜algorithm_params.n_particlesâ€™: optimal_size }, â€˜justificationâ€™: fâ€™Optimizes convergence for {optimal_size} particlesâ€™ } return None def apply_auto_fixes(self, config: dict, fixes: list) -&gt; tuple: â€œâ€â€ Apply automatic fixes to configuration. Returns: tuple: (fixed_config, applied_fixes, failed_fixes) â€œâ€â€ fixed_config = config.copy() applied_fixes = [] failed_fixes = [] for fix in fixes: try: for path, new_value in fix[â€˜changesâ€™].items(): self._set_nested_value(fixed_config, path, new_value) applied_fixes.append(fix) except Exception as e: fix[â€˜errorâ€™] = str(e) failed_fixes.append(fix) return fixed_config, applied_fixes, failed_fixes def _set_nested_value(self, config: dict, path: str, value: any) -&gt; None: â€œâ€â€ Set nested configuration value using dot notation path. â€œâ€â€ keys = path.split(â€˜.â€™) current = config for key in keys[:-1]: if â€˜[â€™ in key and â€˜]â€™ in key: # Handle array indexing array_key, index_str = key.split(â€˜[â€™) index = int(index_str.rstrip(â€˜]â€™)) if array_key not in current: current[array_key] = [] current = current[array_key] # Extend array if necessary while len(current) &lt;= index: current.append(None) current = current[index] else: if key not in current: current[key] = {} current = current[key] # Set the final value final_key = keys[-1] if â€˜[â€™ in final_key and â€˜]â€™ in final_key: array_key, index_str = final_key.split(â€˜[â€™) index = int(index_str.rstrip(â€˜]â€™)) if array_key not in current: current[array_key] = [] while len(current[array_key]) &lt;= index: current[array_key].append(None) current[array_key][index] = value else: current[final_key] = value</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_factory_integration_patterns.html">PSO-Factory Integration Patterns Documentation ## Overview This document provides guidance on integrating the factory system with Particle Swarm Optimization (PSO) workflows. The DIP SMC-PSO project features native PSO integration patterns that streamline controller optimization while maintaining scientific rigor and performance. ## Table of Contents 1. <span class="xref myst">PSO Integration Architecture</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_factory_integration_patterns.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_factory_integration_patterns.html#runnable-false-def-adaptive-pso-optimization-controller-type-smctype-tuple-np-ndarray-float-adaptive-pso-with-dynamic-parameter-adjustment-factory-create-pso-controller-factory-controller-type-class-adaptivepsocontroller-adaptive-pso-controller-with-factory-integration-def-init-self-self-iteration-0-self-best-fitness-history-self-stagnation-counter-0-self-current-bounds-get-gain-bounds-for-pso-controller-type-def-adapt-parameters-self-current-best-fitness-float-dict-str-float-adapt-pso-parameters-based-on-progress-check-for-stagnation-if-len-self-best-fitness-history-0-and-abs-current-best-fitness-self-best-fitness-history-1-1e-6-self-stagnation-counter-1-else-self-stagnation-counter-0-self-best-fitness-history-append-current-best-fitness-adaptive-parameter-adjustment-if-self-stagnation-counter-10-increase-exploration-w-0-9-high-inertia-c1-c2-2-5-1-5-high-cognitive-low-social-expand-search-bounds-slightly-lower-upper-self-current-bounds-expansion-0-1-self-current-bounds-l-1-expansion-for-l-in-lower-u-1-expansion-for-u-in-upper-elif-self-iteration-50-early-exploration-phase-w-0-9-c1-c2-2-0-2-0-else-late-exploitation-phase-w-0-4-c1-c2-1-5-2-5-self-iteration-1-return-w-w-c1-c1-c2-c2-bounds-self-current-bounds-def-fitness-function-self-gains-np-ndarray-float-adaptive-fitness-function-with-dynamic-objectives-try-controller-factory-gains-metrics-evaluate-controller-performance-controller-dynamic-objective-weighting-based-on-iteration-if-self-iteration-30-early-phase-focus-on-basic-performance-return-0-7-metrics-ise-0-3-metrics-control-effort-elif-self-iteration-80-middle-phase-balance-performance-and-robustness-return-0-4-metrics-ise-0-3-metrics-control-effort-0-3-metrics-robustness-penalty-else-late-phase-focus-on-refinement-return-0-3-metrics-ise-0-2-metrics-control-effort-0-3-metrics-robustness-penalty-0-2-metrics-chattering-penalty-except-return-float-inf-run-adaptive-pso-adaptive-controller-adaptivepsocontroller-initial-pso-configuration-pso-params-adaptive-controller-adapt-parameters-float-inf-optimizer-psotuner-controller-factory-adaptive-controller-fitness-function-config-config-adaptive-callback-adaptive-controller-adapt-parameters-return-optimizer-optimize-adaptive">runnable: false def adaptive_pso_optimization(controller_type: SMCType) -&gt; Tuple[np.ndarray, float]: â€œâ€â€Adaptive PSO with dynamic parameter adjustment.â€â€â€ factory = create_pso_controller_factory(controller_type) class AdaptivePSOController: â€œâ€â€Adaptive PSO controller with factory integration.â€â€â€ def <strong>init</strong>(self): self.iteration = 0 self.best_fitness_history = [] self.stagnation_counter = 0 self.current_bounds = get_gain_bounds_for_pso(controller_type) def adapt_parameters(self, current_best_fitness: float) -&gt; Dict[str, float]: â€œâ€â€Adapt PSO parameters based on progress.â€â€â€ # Check for stagnation if (len(self.best_fitness_history) &gt; 0 and abs(current_best_fitness - self.best_fitness_history[-1]) &lt; 1e-6): self.stagnation_counter += 1 else: self.stagnation_counter = 0 self.best_fitness_history.append(current_best_fitness) # Adaptive parameter adjustment if self.stagnation_counter &gt; 10: # Increase exploration w = 0.9 # High inertia c1, c2 = 2.5, 1.5 # High cognitive, low social # Expand search bounds slightly lower, upper = self.current_bounds expansion = 0.1 self.current_bounds = ( [l * (1 - expansion) for l in lower], [u * (1 + expansion) for u in upper] ) elif self.iteration &lt; 50: # Early exploration phase w = 0.9 c1, c2 = 2.0, 2.0 else: # Late exploitation phase w = 0.4 c1, c2 = 1.5, 2.5 self.iteration += 1 return { â€˜wâ€™: w, â€˜c1â€™: c1, â€˜c2â€™: c2, â€˜boundsâ€™: self.current_bounds } def fitness_function(self, gains: np.ndarray) -&gt; float: â€œâ€â€Adaptive fitness function with dynamic objectives.â€â€â€ try: controller = factory(gains) metrics = evaluate_controller_performance(controller) # Dynamic objective weighting based on iteration if self.iteration &lt; 30: # Early phase: focus on basic performance return 0.7 * metrics[â€˜iseâ€™] + 0.3 * metrics[â€˜control_effortâ€™] elif self.iteration &lt; 80: # Middle phase: balance performance and robustness return (0.4 * metrics[â€˜iseâ€™] + 0.3 * metrics[â€˜control_effortâ€™] + 0.3 * metrics[â€˜robustness_penaltyâ€™]) else: # Late phase: focus on refinement return (0.3 * metrics[â€˜iseâ€™] + 0.2 * metrics[â€˜control_effortâ€™] + 0.3 * metrics[â€˜robustness_penaltyâ€™] + 0.2 * metrics[â€˜chattering_penaltyâ€™]) except: return float(â€˜infâ€™) # Run adaptive PSO adaptive_controller = AdaptivePSOController() # Initial PSO configuration pso_params = adaptive_controller.adapt_parameters(float(â€˜infâ€™)) optimizer = PSOTuner( controller_factory=adaptive_controller.fitness_function, config=config, adaptive_callback=adaptive_controller.adapt_parameters ) return optimizer.optimize_adaptive()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_factory_integration_patterns.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_factory_integration_patterns.html#runnable-false-usr-bin-env-python3">runnable: false #!/usr/bin/env python3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html">PSO Integration Technical Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-def-controller-factory-gains-np-ndarray-controller-pso-compatible-controller-factory-interface-mathematical-foundation-the-factory-must-instantiate-controllers-with-gain-vector-g-n-where-n-is-controller-specific-dimensionality-classical-smc-g-6-c1-1-c2-2-k-kd-sta-smc-g-6-k1-k2-k1-k2-1-2-adaptive-smc-g-5-c1-1-c2-2-hybrid-adaptive-sta-smc-g-4-c1-1-c2-2-parameters-gains-np-ndarray-shape-n-controller-gain-vector-with-validated-bounds-returns-controller-configured-smc-instance-with-required-attributes-max-force-float-actuator-saturation-limit-validate-gains-optional-callable-pre-filtering-function-interface-contracts-1-factory-function-must-have-attribute-n-gains-specifying-dimensionality-2-returned-controller-must-implement-control-computation-interface-3-all-gains-must-be-positive-and-within-specified-bounds-4-controller-must-handle-edge-cases-singularities-saturation-return-create-controller-controller-type-config-gains-gains-required-factory-attribute">runnable: false def controller_factory(gains: np.ndarray) -&gt; Controller: â€œâ€â€ PSO-compatible controller factory interface. Mathematical Foundation: The factory must instantiate controllers with gain vector G âˆˆ â„â¿ where n is controller-specific dimensionality: - Classical SMC: G âˆˆ â„â¶ (câ‚, Î»â‚, câ‚‚, Î»â‚‚, K, kd) - STA-SMC: G âˆˆ â„â¶ (Kâ‚, Kâ‚‚, kâ‚, kâ‚‚, Î»â‚, Î»â‚‚) - Adaptive SMC: G âˆˆ â„âµ (câ‚, Î»â‚, câ‚‚, Î»â‚‚, Î³) - Hybrid Adaptive STA-SMC: G âˆˆ â„â´ (câ‚, Î»â‚, câ‚‚, Î»â‚‚) Parameters â€”â€”â€”- gains : np.ndarray, shape (n,) Controller gain vector with validated bounds Returns â€”â€”- Controller Configured SMC instance with required attributes: - max_force: float (actuator saturation limit) - validate_gains: Optional[Callable] (pre-filtering function) Interface Contracts â€”â€”â€”â€”â€”â€” 1. Factory function MUST have attribute â€˜n_gainsâ€™ specifying dimensionality 2. Returned controller MUST implement control computation interface 3. All gains MUST be positive and within specified bounds 4. Controller MUST handle edge cases (singularities, saturation) â€œâ€â€ return create_controller(controller_type, config, gains=gains) # Required factory attribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-controller-registry-with-pso-integration-metadata">runnable: false # Controller Registry with PSO Integration Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-def-validate-controller-gains-controller-type-str-gains-np-ndarray-np-ndarray-validate-gain-vectors-for-controller-specific-stability-requirements-mathematical-validation-rules-classical-smc-all-gains-0-positive-definiteness-sliding-surface-gains-c1-1-c2-2-ensure-hurwitz-characteristic-polynomial-switching-gains-k-kd-provide-reaching-condition-satisfaction-sta-smc-super-twisting-algorithmic-gains-k1-k2-0-stability-condition-surface-coefficients-1-2-for-target-damping-ratio-0-6-0-8-finite-time-convergence-k12-4k2-12-parameters-controller-type-str-controller-identifier-from-registry-gains-np-ndarray-shape-b-n-batch-of-gain-vectors-to-validate-returns-np-ndarray-shape-b-dtype-bool-validity-mask-for-each-gain-vector-registry-info-controller-registry-controller-type-bounds-registry-info-gain-bounds-basic-bounds-checking-valid-mask-np-ones-gains-shape-0-dtype-bool-for-i-min-val-max-val-in-enumerate-bounds-valid-mask-gains-i-min-val-gains-i-max-val-controller-specific-stability-checks-if-controller-type-sta-smc-k1-k2-condition-for-sta-stability-valid-mask-gains-0-gains-1-surface-coefficient-bounds-for-target-damping-lambda1-lambda2-gains-4-gains-5-damping-ratio-lambda2-2-np-sqrt-lambda1-valid-mask-damping-ratio-0-6-damping-ratio-0-8-return-valid-mask">runnable: false def validate_controller_gains(controller_type: str, gains: np.ndarray) -&gt; np.ndarray: â€œâ€â€ Validate gain vectors for controller-specific stability requirements. Mathematical Validation Rules: Classical SMC: - All gains &gt; 0 (positive definiteness) - Sliding surface gains câ‚, Î»â‚, câ‚‚, Î»â‚‚ ensure Hurwitz characteristic polynomial - Switching gains K, kd provide reaching condition satisfaction STA-SMC (Super-Twisting): - Algorithmic gains: Kâ‚ &gt; Kâ‚‚ &gt; 0 (stability condition) - Surface coefficients: Î»â‚, Î»â‚‚ for target damping ratio Î¶ âˆˆ [0.6, 0.8] - Finite-time convergence: Kâ‚Â² &gt; 4Kâ‚‚|Î»â‚Î»â‚‚| Parameters â€”â€”â€”- controller_type : str Controller identifier from registry gains : np.ndarray, shape (B, n) Batch of gain vectors to validate Returns â€”â€”- np.ndarray, shape (B,), dtype=bool Validity mask for each gain vector â€œâ€â€ registry_info = CONTROLLER_REGISTRY[controller_type] bounds = registry_info[â€˜gain_boundsâ€™] # Basic bounds checking valid_mask = np.ones(gains.shape[0], dtype=bool) for i, (min_val, max_val) in enumerate(bounds): valid_mask &amp;= (gains[:, i] &gt;= min_val) &amp; (gains[:, i] &lt;= max_val) # Controller-specific stability checks if controller_type == â€˜sta_smcâ€™: # Kâ‚ &gt; Kâ‚‚ condition for STA stability valid_mask &amp;= gains[:, 0] &gt; gains[:, 1] # Surface coefficient bounds for target damping lambda1, lambda2 = gains[:, 4], gains[:, 5] damping_ratio = lambda2 / (2 * np.sqrt(lambda1)) valid_mask &amp;= (damping_ratio &gt;= 0.6) &amp; (damping_ratio &lt;= 0.8) return valid_mask</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-def-compute-fitness-cost-t-np-ndarray-x-np-ndarray-u-np-ndarray-sigma-np-ndarray-float-multi-objective-fitness-function-for-pso-optimization-mathematical-formulation-j-w10-e-t-2dt-w20-u2-t-dt-w30-du-dt-2dt-w40-2-t-dt-p-where-e-t-x-t-x-ref-state-error-vector-u-t-control-effort-du-dt-control-rate-chattering-penalty-t-sliding-variable-magnitude-p-instability-penalty-for-early-termination-cost-function-components-1-state-error-ise-0-e-t-2dt-2-control-effort-0-u2-t-dt-3-control-rate-0-du-dt-2dt-4-sliding-variable-energy-0-2-t-dt-5-stability-penalty-graded-penalty-for-premature-failure-dt-np-diff-t-dt-matrix-dt-none-shape-1-n-1-state-error-integration-all-state-components-state-error-sq-np-sum-x-1-2-dt-matrix-none-axis-1-2-control-effort-integration-control-effort-sq-np-sum-u2-dt-matrix-axis-1-control-rate-penalty-anti-chattering-du-np-diff-u-axis-1-prepend-u-0-1-control-rate-sq-np-sum-du2-dt-matrix-axis-1-sliding-variable-energy-sliding-energy-np-sum-sigma2-dt-matrix-axis-1-instability-detection-and-penalty-instability-mask-detect-instability-x-u-sigma-stability-penalty-compute-graded-penalty-instability-mask-t-weighted-cost-aggregation-total-cost-weights-state-error-normalize-state-error-sq-norms-ise-weights-control-effort-normalize-control-effort-sq-norms-control-weights-control-rate-normalize-control-rate-sq-norms-rate-weights-stability-normalize-sliding-energy-norms-sliding-stability-penalty-return-total-cost">runnable: false def compute_fitness_cost(t: np.ndarray, x: np.ndarray, u: np.ndarray, sigma: np.ndarray) -&gt; float: â€œâ€â€ Multi-objective fitness function for PSO optimization. Mathematical Formulation: J = wâ‚âˆ«â‚€áµ€||e(t)||Â²dt + wâ‚‚âˆ«â‚€áµ€uÂ²(t)dt + wâ‚ƒâˆ«â‚€áµ€(du/dt)Â²dt + wâ‚„âˆ«â‚€áµ€ÏƒÂ²(t)dt + P Where: - e(t) = x(t) - x_ref: state error vector - u(t): control effort - du/dt: control rate (chattering penalty) - Ïƒ(t): sliding variable magnitude - P: instability penalty for early termination Cost Function Components: 1. State Error (ISE): âˆ«â‚€áµ€||e(t)||Â²dt 2. Control Effort: âˆ«â‚€áµ€uÂ²(t)dt 3. Control Rate: âˆ«â‚€áµ€(du/dt)Â²dt 4. Sliding Variable Energy: âˆ«â‚€áµ€ÏƒÂ²(t)dt 5. Stability Penalty: Graded penalty for premature failure â€œâ€â€ dt = np.diff(t) dt_matrix = dt[None, :] # Shape (1, N-1) # State error integration (all state components) state_error_sq = np.sum(x[:, :-1, :]<strong>2 * dt_matrix[:, :, None], axis=(1, 2)) # Control effort integration control_effort_sq = np.sum(u</strong>2 * dt_matrix, axis=1) # Control rate penalty (anti-chattering) du = np.diff(u, axis=1, prepend=u[:, 0:1]) control_rate_sq = np.sum(du<strong>2 * dt_matrix, axis=1) # Sliding variable energy sliding_energy = np.sum(sigma</strong>2 * dt_matrix, axis=1) # Instability detection and penalty instability_mask = detect_instability(x, u, sigma) stability_penalty = compute_graded_penalty(instability_mask, t) # Weighted cost aggregation total_cost = ( weights.state_error * normalize(state_error_sq, norms.ise) + weights.control_effort * normalize(control_effort_sq, norms.control) + weights.control_rate * normalize(control_rate_sq, norms.rate) + weights.stability * normalize(sliding_energy, norms.sliding) + stability_penalty ) return total_cost</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#id4">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-class-pso-convergencemonitor-advanced-convergence-monitoring-with-multiple-termination-criteria-def-init-self-patience-int-50-tolerance-float-1e-6-diversity-threshold-float-1e-8-self-patience-patience-self-tolerance-tolerance-self-diversity-threshold-diversity-threshold-self-best-cost-history-self-diversity-history-self-stagnation-counter-0-def-check-convergence-self-swarm-positions-np-ndarray-swarm-costs-np-ndarray-tuple-bool-str-multi-criteria-convergence-detection-1-cost-improvement-stagnation-2-swarm-diversity-collapse-3-gradient-based-local-optimum-detection-current-best-np-min-swarm-costs-self-best-cost-history-append-current-best-swarm-diversity-standard-deviation-of-positions-diversity-np-mean-np-std-swarm-positions-axis-0-self-diversity-history-append-diversity-check-improvement-stagnation-if-len-self-best-cost-history-2-improvement-abs-self-best-cost-history-2-current-best-relative-improvement-improvement-abs-current-best-1e-12-if-relative-improvement-self-tolerance-self-stagnation-counter-1-else-self-stagnation-counter-0-convergence-conditions-if-self-stagnation-counter-self-patience-return-true-f-cost-stagnation-self-stagnation-counter-iterations-without-improvement-if-diversity-self-diversity-threshold-return-true-f-diversity-collapse-diversity-2e-self-diversity-threshold-2e-return-false-optimization-continuing">runnable: false class PSO_ConvergenceMonitor: â€œâ€â€ Advanced convergence monitoring with multiple termination criteria. â€œâ€â€ def <strong>init</strong>(self, patience: int = 50, tolerance: float = 1e-6, diversity_threshold: float = 1e-8): self.patience = patience self.tolerance = tolerance self.diversity_threshold = diversity_threshold self.best_cost_history = [] self.diversity_history = [] self.stagnation_counter = 0 def check_convergence(self, swarm_positions: np.ndarray, swarm_costs: np.ndarray) -&gt; tuple[bool, str]: â€œâ€â€ Multi-criteria convergence detection: 1. Cost improvement stagnation 2. Swarm diversity collapse 3. Gradient-based local optimum detection â€œâ€â€ current_best = np.min(swarm_costs) self.best_cost_history.append(current_best) # Swarm diversity (standard deviation of positions) diversity = np.mean(np.std(swarm_positions, axis=0)) self.diversity_history.append(diversity) # Check improvement stagnation if len(self.best_cost_history) &gt;= 2: improvement = abs(self.best_cost_history[-2] - current_best) relative_improvement = improvement / (abs(current_best) + 1e-12) if relative_improvement &lt; self.tolerance: self.stagnation_counter += 1 else: self.stagnation_counter = 0 # Convergence conditions if self.stagnation_counter &gt;= self.patience: return True, fâ€Cost stagnation: {self.stagnation_counter} iterations without improvementâ€ if diversity &lt; self.diversity_threshold: return True, fâ€Diversity collapse: Ïƒ = {diversity:.2e} &lt; {self.diversity_threshold:.2e}â€ return False, â€œOptimization continuingâ€</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#id5">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-def-robust-optimization-under-uncertainty-pso-tuner-psotuner-uncertainty-config-physicsuncertaintyschema-dict-monte-carlo-robust-optimization-with-uncertainty-quantification-methodology-1-sample-n-physics-realizations-from-uncertainty-distributions-2-evaluate-each-particle-against-all-realizations-3-aggregate-costs-using-risk-sensitive-criteria-mean-std-4-report-confidence-intervals-for-optimal-gains-mathematical-framework-uncertain-parameters-n-0-2-for-each-physics-parameter-robust-cost-j-robust-e-j-g-std-j-g-risk-parameter-0-1-balancing-mean-vs-variance-generate-uncertainty-samples-physics-samples-generate-physics-samples-uncertainty-config-multi-realization-evaluation-costs-per-realization-for-physics-params-in-physics-samples-evaluate-swarm-under-this-realization-realization-costs-pso-tuner-evaluate-swarm-with-physics-physics-params-costs-per-realization-append-realization-costs-risk-sensitive-aggregation-mean-costs-np-mean-costs-per-realization-axis-0-std-costs-np-std-costs-per-realization-axis-0-robust-costs-mean-costs-uncertainty-config-risk-factor-std-costs-return-robust-costs-robust-costs-mean-costs-mean-costs-std-costs-std-costs-confidence-intervals-compute-confidence-intervals-costs-per-realization-physics-samples-physics-samples">runnable: false def robust_optimization_under_uncertainty(pso_tuner: PSOTuner, uncertainty_config: PhysicsUncertaintySchema) -&gt; dict: â€œâ€â€ Monte Carlo robust optimization with uncertainty quantification. Methodology: 1. Sample N physics realizations from uncertainty distributions 2. Evaluate each particle against all realizations 3. Aggregate costs using risk-sensitive criteria (mean + Î±Â·std) 4. Report confidence intervals for optimal gains Mathematical Framework: - Uncertain parameters: Î¸ ~ N(Î¸â‚€, ÏƒÂ²) for each physics parameter - Robust cost: J_robust = E[J(G,Î¸)] + Î±Â·Std[J(G,Î¸)] - Risk parameter: Î± âˆˆ [0, 1] balancing mean vs variance â€œâ€â€ # Generate uncertainty samples physics_samples = generate_physics_samples(uncertainty_config) # Multi-realization evaluation costs_per_realization = [] for physics_params in physics_samples: # Evaluate swarm under this realization realization_costs = pso_tuner.evaluate_swarm_with_physics(physics_params) costs_per_realization.append(realization_costs) # Risk-sensitive aggregation mean_costs = np.mean(costs_per_realization, axis=0) std_costs = np.std(costs_per_realization, axis=0) robust_costs = mean_costs + uncertainty_config.risk_factor * std_costs return { â€˜robust_costsâ€™: robust_costs, â€˜mean_costsâ€™: mean_costs, â€˜std_costsâ€™: std_costs, â€˜confidence_intervalsâ€™: compute_confidence_intervals(costs_per_realization), â€˜physics_samplesâ€™: physics_samples }</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#version-1-0-legacy-deprecated">Version 1.0 (Legacy) - Deprecated</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#id6">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-def-migrate-pso-configuration-legacy-config-dict-psoconfig-migrate-legacy-pso-configuration-to-current-schema-with-validation-migration-rules-1-remove-deprecated-fields-with-warnings-2-update-bounds-for-issue-2-resolution-compatibility-3-add-new-enhanced-features-with-sensible-defaults-4-validate-mathematical-consistency-of-migrated-parameters-warnings-remove-deprecated-fields-deprecated-fields-n-processes-hyper-trials-hyper-search-study-timeout-for-field-in-deprecated-fields-if-field-in-legacy-config-warnings-append-f-deprecated-field-field-removed-during-migration-del-legacy-config-field-update-bounds-for-issue-2-compatibility-if-bounds-in-legacy-config-old-bounds-legacy-config-bounds-if-max-in-old-bounds-and-len-old-bounds-max-6-check-for-problematic-lambda-bounds-from-issue-2-if-old-bounds-max-4-10-0-or-old-bounds-max-5-10-0-warnings-append-updated-lambda-bounds-for-issue-2-overshoot-resolution-old-bounds-max-4-min-old-bounds-max-4-10-0-old-bounds-max-5-min-old-bounds-max-5-10-0-add-enhanced-features-if-missing-if-w-schedule-not-in-legacy-config-legacy-config-w-schedule-0-9-0-4-warnings-append-added-inertia-weight-scheduling-for-improved-convergence-if-velocity-clamp-not-in-legacy-config-legacy-config-velocity-clamp-0-1-0-2-warnings-append-added-velocity-clamping-for-stability-validate-migrated-configuration-migrated-config-psoconfig-legacy-config-validation-result-pso-configvalidator-validate-hyperparameters-migrated-config-if-not-validation-result-is-valid-raise-configurationerror-f-migration-failed-validation-validation-result-errors-return-migrated-config-warnings">runnable: false def migrate_pso_configuration(legacy_config: dict) -&gt; PSOConfig: â€œâ€â€ Migrate legacy PSO configuration to current schema with validation. Migration Rules: 1. Remove deprecated fields with warnings 2. Update bounds for Issue #2 resolution compatibility 3. Add new enhanced features with sensible defaults 4. Validate mathematical consistency of migrated parameters â€œâ€â€ warnings = [] # Remove deprecated fields deprecated_fields = [â€˜n_processesâ€™, â€˜hyper_trialsâ€™, â€˜hyper_searchâ€™, â€˜study_timeoutâ€™] for field in deprecated_fields: if field in legacy_config: warnings.append(fâ€Deprecated field â€˜{field}â€™ removed during migrationâ€) del legacy_config[field] # Update bounds for Issue #2 compatibility if â€˜boundsâ€™ in legacy_config: old_bounds = legacy_config[â€˜boundsâ€™] if â€˜maxâ€™ in old_bounds and len(old_bounds[â€˜maxâ€™]) &gt;= 6: # Check for problematic lambda bounds from Issue #2 if old_bounds[â€˜maxâ€™][4] &gt; 10.0 or old_bounds[â€˜maxâ€™][5] &gt; 10.0: warnings.append(â€œUpdated lambda bounds for Issue #2 overshoot resolutionâ€) old_bounds[â€˜maxâ€™][4] = min(old_bounds[â€˜maxâ€™][4], 10.0) old_bounds[â€˜maxâ€™][5] = min(old_bounds[â€˜maxâ€™][5], 10.0) # Add enhanced features if missing if â€˜w_scheduleâ€™ not in legacy_config: legacy_config[â€˜w_scheduleâ€™] = [0.9, 0.4] warnings.append(â€œAdded inertia weight scheduling for improved convergenceâ€) if â€˜velocity_clampâ€™ not in legacy_config: legacy_config[â€˜velocity_clampâ€™] = [0.1, 0.2] warnings.append(â€œAdded velocity clamping for stabilityâ€) # Validate migrated configuration migrated_config = PSOConfig(**legacy_config) validation_result = PSO_ConfigValidator.validate_hyperparameters(migrated_config) if not validation_result.is_valid: raise ConfigurationError(fâ€Migration failed validation: {validation_result.errors}â€) return migrated_config, warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html">PSO Optimization Workflow Specifications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#runnable-false-class-optimizationworkflowmanager-management-of-pso-optimization-workflow-execution-def-init-self-config-dict-controller-type-str-self-config-config-self-controller-type-controller-type-self-monitors-performance-performancemonitor-convergence-convergencemonitor-memory-memorymonitor-safety-safetymonitor-self-workflow-state-workflowstate-def-execute-optimization-workflow-self-controller-factory-callable-optimizationresult-execute-complete-pso-optimization-workflow-with-monitoring-workflow-phases-1-pre-optimization-setup-and-validation-2-pso-tuner-initialization-3-optimization-loop-execution-4-real-time-monitoring-and-adaptation-5-post-optimization-validation-6-result-analysis-and-reporting-workflow-start-time-time-time-result-optimizationresult-try-phase-1-pre-optimization-setup-setup-result-self-execute-setup-phase-controller-factory-result-setup-results-setup-result-if-not-setup-result-success-result-status-setup-failed-return-result-phase-2-pso-tuner-initialization-tuner-result-self-execute-tuner-initialization-result-tuner-results-tuner-result-if-not-tuner-result-success-result-status-tuner-failed-return-result-phase-3-optimization-execution-optimization-result-self-execute-optimization-loop-result-optimization-results-optimization-result-if-not-optimization-result-success-result-status-optimization-failed-return-result-phase-4-post-optimization-validation-validation-result-self-execute-validation-phase-optimization-result-result-validation-results-validation-result-phase-5-result-analysis-analysis-result-self-execute-analysis-phase-optimization-result-result-analysis-results-analysis-result-result-status-success-result-total-time-time-time-workflow-start-time-except-exception-as-e-result-status-error-result-error-message-str-e-result-total-time-time-time-workflow-start-time-return-result-def-execute-setup-phase-self-controller-factory-callable-setupresult-execute-pre-optimization-setup-and-validation-setup-result-setupresult-validate-controller-factory-if-not-hasattr-controller-factory-n-gains-setup-result-errors-append-controller-factory-missing-n-gains-attribute-setup-result-success-false-return-setup-result-validate-factory-functionality-try-test-gains-np-ones-controller-factory-n-gains-test-controller-controller-factory-test-gains-if-not-hasattr-test-controller-max-force-setup-result-warnings-append-controller-missing-max-force-attribute-except-exception-as-e-setup-result-errors-append-f-controller-factory-test-failed-str-e-setup-result-success-false-return-setup-result-setup-monitoring-systems-for-name-monitor-in-self-monitors-items-try-monitor-initialize-self-config-setup-result-monitors-initialized-append-name-except-exception-as-e-setup-result-errors-append-f-monitor-name-initialization-failed-str-e-validate-memory-availability-available-memory-psutil-virtual-memory-available-1024-3-gb-required-memory-self-estimate-memory-requirement-if-available-memory-required-memory-setup-result-warnings-append-f-low-memory-available-memory-1f-gb-available-required-memory-1f-gb-recommended-setup-result-success-len-setup-result-errors-0-return-setup-result-def-execute-optimization-loop-self-optimizationloopresult-execute-pso-optimization-loop-with-real-time-monitoring-result-optimizationloopresult-try-initialize-pso-tuner-tuner-psotuner-controller-factory-self-controller-factory-config-self-config-seed-self-config-get-pso-get-execution-get-seed-42-setup-optimization-monitoring-optimization-monitor-optimizationmonitor-monitors-self-monitors-config-self-config-execute-optimization-with-monitoring-pso-result-tuner-optimise-extract-results-result-best-cost-pso-result-best-cost-result-best-gains-pso-result-best-pos-result-cost-history-pso-result-history-cost-result-position-history-pso-result-history-pos-get-monitoring-data-result-performance-metrics-optimization-monitor-get-performance-summary-result-convergence-analysis-optimization-monitor-get-convergence-analysis-result-success-true-except-exception-as-e-result-success-false-result-error-message-str-e-return-result">runnable: false class OptimizationWorkflowManager: â€œâ€â€ management of PSO optimization workflow execution. â€œâ€â€ def <strong>init</strong>(self, config: dict, controller_type: str): self.config = config self.controller_type = controller_type self.monitors = { â€˜performanceâ€™: PerformanceMonitor(), â€˜convergenceâ€™: ConvergenceMonitor(), â€˜memoryâ€™: MemoryMonitor(), â€˜safetyâ€™: SafetyMonitor() } self.workflow_state = WorkflowState() def execute_optimization_workflow(self, controller_factory: Callable) -&gt; OptimizationResult: â€œâ€â€ Execute complete PSO optimization workflow with monitoring. Workflow Phases: 1. Pre-optimization setup and validation 2. PSO tuner initialization 3. Optimization loop execution 4. Real-time monitoring and adaptation 5. Post-optimization validation 6. Result analysis and reporting â€œâ€â€ workflow_start_time = time.time() result = OptimizationResult() try: # Phase 1: Pre-optimization Setup setup_result = self._execute_setup_phase(controller_factory) result.setup_results = setup_result if not setup_result.success: result.status = â€˜SETUP_FAILEDâ€™ return result # Phase 2: PSO Tuner Initialization tuner_result = self._execute_tuner_initialization() result.tuner_results = tuner_result if not tuner_result.success: result.status = â€˜TUNER_FAILEDâ€™ return result # Phase 3: Optimization Execution optimization_result = self._execute_optimization_loop() result.optimization_results = optimization_result if not optimization_result.success: result.status = â€˜OPTIMIZATION_FAILEDâ€™ return result # Phase 4: Post-optimization Validation validation_result = self._execute_validation_phase(optimization_result) result.validation_results = validation_result # Phase 5: Result Analysis analysis_result = self._execute_analysis_phase(optimization_result) result.analysis_results = analysis_result result.status = â€˜SUCCESSâ€™ result.total_time = time.time() - workflow_start_time except Exception as e: result.status = â€˜ERRORâ€™ result.error_message = str(e) result.total_time = time.time() - workflow_start_time return result def _execute_setup_phase(self, controller_factory: Callable) -&gt; SetupResult: â€œâ€â€ Execute pre-optimization setup and validation. â€œâ€â€ setup_result = SetupResult() # Validate controller factory if not hasattr(controller_factory, â€˜n_gainsâ€™): setup_result.errors.append(â€˜Controller factory missing n_gains attributeâ€™) setup_result.success = False return setup_result # Validate factory functionality try: test_gains = np.ones(controller_factory.n_gains) test_controller = controller_factory(test_gains) if not hasattr(test_controller, â€˜max_forceâ€™): setup_result.warnings.append(â€˜Controller missing max_force attributeâ€™) except Exception as e: setup_result.errors.append(fâ€™Controller factory test failed: {str(e)}â€™) setup_result.success = False return setup_result # Setup monitoring systems for name, monitor in self.monitors.items(): try: monitor.initialize(self.config) setup_result.monitors_initialized.append(name) except Exception as e: setup_result.errors.append(fâ€™Monitor {name} initialization failed: {str(e)}â€™) # Validate memory availability available_memory = psutil.virtual_memory().available / (1024**3) # GB required_memory = self._estimate_memory_requirement() if available_memory &lt; required_memory: setup_result.warnings.append(fâ€™Low memory: {available_memory:.1f}GB available, {required_memory:.1f}GB recommendedâ€™) setup_result.success = len(setup_result.errors) == 0 return setup_result def _execute_optimization_loop(self) -&gt; OptimizationLoopResult: â€œâ€â€ Execute PSO optimization loop with real-time monitoring. â€œâ€â€ result = OptimizationLoopResult() try: # Initialize PSO tuner tuner = PSOTuner( controller_factory=self.controller_factory, config=self.config, seed=self.config.get(â€˜psoâ€™, {}).get(â€˜executionâ€™, {}).get(â€˜seedâ€™, 42) ) # Setup optimization monitoring optimization_monitor = OptimizationMonitor( monitors=self.monitors, config=self.config ) # Execute optimization with monitoring pso_result = tuner.optimise() # Extract results result.best_cost = pso_result[â€˜best_costâ€™] result.best_gains = pso_result[â€˜best_posâ€™] result.cost_history = pso_result[â€˜historyâ€™][â€˜costâ€™] result.position_history = pso_result[â€˜historyâ€™][â€˜posâ€™] # Get monitoring data result.performance_metrics = optimization_monitor.get_performance_summary() result.convergence_analysis = optimization_monitor.get_convergence_analysis() result.success = True except Exception as e: result.success = False result.error_message = str(e) return result</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#runnable-false-class-optimizationmonitor-real-time-monitoring-system-for-pso-optimization-with-adaptive-features-def-init-self-monitors-dict-config-dict-self-monitors-monitors-self-config-config-self-monitoring-data-iteration-times-memory-usage-cost-improvements-diversity-metrics-constraint-violations-safety-alerts-def-monitor-iteration-self-iteration-int-swarm-state-dict-monitoringresult-monitor-single-pso-iteration-with-metrics-collection-iteration-start-time-time-result-monitoringresult-performance-monitoring-perf-metrics-self-monitors-performance-collect-metrics-swarm-state-self-monitoring-data-iteration-times-append-perf-metrics-iteration-time-self-monitoring-data-memory-usage-append-perf-metrics-memory-mb-convergence-monitoring-conv-metrics-self-monitors-convergence-analyze-convergence-swarm-state-self-monitoring-data-cost-improvements-append-conv-metrics-cost-improvement-self-monitoring-data-diversity-metrics-append-conv-metrics-diversity-constraint-validation-constraint-result-self-validate-constraints-realtime-swarm-state-self-monitoring-data-constraint-violations-extend-constraint-result-violations-safety-monitoring-safety-result-self-monitors-safety-check-safety-conditions-swarm-state-if-safety-result-alerts-self-monitoring-data-safety-alerts-extend-safety-result-alerts-adaptive-parameter-adjustment-if-self-should-adapt-parameters-iteration-swarm-state-adaptations-self-compute-parameter-adaptations-swarm-state-result-parameter-adaptations-adaptations-issue-2-specific-monitoring-for-sta-smc-if-self-config-get-controller-type-sta-smc-issue2-result-self-monitor-issue2-compliance-swarm-state-result-issue2-compliance-issue2-result-result-monitoring-data-self-monitoring-data-result-iteration-time-time-time-iteration-start-return-result-def-validate-constraints-realtime-self-swarm-state-dict-dict-real-time-validation-of-mathematical-and-physical-constraints-violations-particles-swarm-state-get-positions-np-array-if-particles-size-0-return-violations-violations-controller-type-self-config-get-controller-type-classical-smc-controller-specific-constraint-checking-if-controller-type-sta-smc-and-particles-shape-1-6-k1-k2-constraint-k1-particles-k2-particles-particles-0-particles-1-k1-le-k2-mask-k1-particles-k2-particles-if-np-any-k1-le-k2-mask-violation-count-np-sum-k1-le-k2-mask-violations-append-type-sta-stability-violation-count-violation-count-particles-np-where-k1-le-k2-mask-0-tolist-severity-high-issue-2-damping-ratio-constraint-if-particles-shape-1-6-lambda1-lambda2-particles-4-particles-5-k1-k2-particles-2-particles-3-safe-computation-with-epsilon-to-avoid-division-by-zero-epsilon-1e-12-zeta1-lambda1-2-np-sqrt-k1-epsilon-zeta2-lambda2-2-np-sqrt-k2-epsilon-check-issue-2-requirement-0-69-zeta1-violation-zeta1-0-69-zeta2-violation-zeta2-0-69-if-np-any-zeta1-violation-or-np-any-zeta2-violation-violation-particles-np-where-zeta1-violation-zeta2-violation-0-violations-append-type-issue2-damping-violation-count-len-violation-particles-particles-violation-particles-tolist-severity-high-details-min-zeta1-np-min-zeta1-min-zeta2-np-min-zeta2-requirement-0-69-for-5-overshoot-return-violations-violations-def-monitor-issue2-compliance-self-swarm-state-dict-dict-specialized-monitoring-for-issue-2-overshoot-compliance-particles-swarm-state-get-positions-np-array-if-particles-size-0-or-particles-shape-1-6-return-status-insufficient-data-extract-surface-coefficients-lambda1-lambda2-particles-4-particles-5-k1-k2-particles-2-particles-3-compute-damping-ratios-epsilon-1e-12-zeta1-lambda1-2-np-sqrt-k1-epsilon-zeta2-lambda2-2-np-sqrt-k2-epsilon-issue-2-compliance-analysis-compliance-stats-compliant-particles-0-total-particles-len-particles-min-damping-ratio-min-np-min-zeta1-np-min-zeta2-avg-damping-ratio-np-mean-zeta1-np-mean-zeta2-2-predicted-overshoot-range-lambda-bounds-status-unknown-count-compliant-particles-0-69-compliant-mask-zeta1-0-69-zeta2-0-69-compliance-stats-compliant-particles-np-sum-compliant-mask-predict-overshoot-for-representative-particles-for-i-in-range-min-5-len-particles-sample-first-5-particles-zeta-avg-zeta1-i-zeta2-i-2-if-zeta-avg-1-0-underdamped-predicted-overshoot-100-np-exp-zeta-avg-np-pi-np-sqrt-1-zeta-avg-2-else-overdamped-predicted-overshoot-0-0-compliance-stats-predicted-overshoot-range-append-predicted-overshoot-check-lambda-bounds-status-max-lambda1-max-lambda2-np-max-lambda1-np-max-lambda2-if-max-lambda1-10-0-and-max-lambda2-10-0-compliance-stats-lambda-bounds-status-compliant-else-compliance-stats-lambda-bounds-status-violation-return-compliance-stats">runnable: false class OptimizationMonitor: â€œâ€â€ Real-time monitoring system for PSO optimization with adaptive features. â€œâ€â€ def <strong>init</strong>(self, monitors: dict, config: dict): self.monitors = monitors self.config = config self.monitoring_data = { â€˜iteration_timesâ€™: [], â€˜memory_usageâ€™: [], â€˜cost_improvementsâ€™: [], â€˜diversity_metricsâ€™: [], â€˜constraint_violationsâ€™: [], â€˜safety_alertsâ€™: [] } def monitor_iteration(self, iteration: int, swarm_state: dict) -&gt; MonitoringResult: â€œâ€â€ Monitor single PSO iteration with metrics collection. â€œâ€â€ iteration_start = time.time() result = MonitoringResult() # Performance monitoring perf_metrics = self.monitors[â€˜performanceâ€™].collect_metrics(swarm_state) self.monitoring_data[â€˜iteration_timesâ€™].append(perf_metrics[â€˜iteration_timeâ€™]) self.monitoring_data[â€˜memory_usageâ€™].append(perf_metrics[â€˜memory_mbâ€™]) # Convergence monitoring conv_metrics = self.monitors[â€˜convergenceâ€™].analyze_convergence(swarm_state) self.monitoring_data[â€˜cost_improvementsâ€™].append(conv_metrics[â€˜cost_improvementâ€™]) self.monitoring_data[â€˜diversity_metricsâ€™].append(conv_metrics[â€˜diversityâ€™]) # Constraint validation constraint_result = self._validate_constraints_realtime(swarm_state) self.monitoring_data[â€˜constraint_violationsâ€™].extend(constraint_result[â€˜violationsâ€™]) # Safety monitoring safety_result = self.monitors[â€˜safetyâ€™].check_safety_conditions(swarm_state) if safety_result[â€˜alertsâ€™]: self.monitoring_data[â€˜safety_alertsâ€™].extend(safety_result[â€˜alertsâ€™]) # Adaptive parameter adjustment if self._should_adapt_parameters(iteration, swarm_state): adaptations = self._compute_parameter_adaptations(swarm_state) result.parameter_adaptations = adaptations # Issue #2 specific monitoring for STA-SMC if self.config.get(â€˜controller_typeâ€™) == â€˜sta_smcâ€™: issue2_result = self._monitor_issue2_compliance(swarm_state) result.issue2_compliance = issue2_result result.monitoring_data = self.monitoring_data result.iteration_time = time.time() - iteration_start return result def _validate_constraints_realtime(self, swarm_state: dict) -&gt; dict: â€œâ€â€ Real-time validation of mathematical and physical constraints. â€œâ€â€ violations = [] particles = swarm_state.get(â€˜positionsâ€™, np.array([])) if particles.size == 0: return {â€˜violationsâ€™: violations} controller_type = self.config.get(â€˜controller_typeâ€™, â€˜classical_smcâ€™) # Controller-specific constraint checking if controller_type == â€˜sta_smcâ€™ and particles.shape[1] &gt;= 6: # Kâ‚ &gt; Kâ‚‚ constraint k1_particles, k2_particles = particles[:, 0], particles[:, 1] k1_le_k2_mask = k1_particles &lt;= k2_particles if np.any(k1_le_k2_mask): violation_count = np.sum(k1_le_k2_mask) violations.append({ â€˜typeâ€™: â€˜STA_STABILITY_VIOLATIONâ€™, â€˜countâ€™: violation_count, â€˜particlesâ€™: np.where(k1_le_k2_mask)[0].tolist(), â€˜severityâ€™: â€˜HIGHâ€™ }) # Issue #2 damping ratio constraint if particles.shape[1] &gt;= 6: lambda1, lambda2 = particles[:, 4], particles[:, 5] k1, k2 = particles[:, 2], particles[:, 3] # Safe computation with epsilon to avoid division by zero epsilon = 1e-12 zeta1 = lambda1 / (2 * np.sqrt(k1 + epsilon)) zeta2 = lambda2 / (2 * np.sqrt(k2 + epsilon)) # Check Issue #2 requirement: Î¶ â‰¥ 0.69 zeta1_violation = zeta1 &lt; 0.69 zeta2_violation = zeta2 &lt; 0.69 if np.any(zeta1_violation) or np.any(zeta2_violation): violation_particles = np.where(zeta1_violation | zeta2_violation)[0] violations.append({ â€˜typeâ€™: â€˜ISSUE2_DAMPING_VIOLATIONâ€™, â€˜countâ€™: len(violation_particles), â€˜particlesâ€™: violation_particles.tolist(), â€˜severityâ€™: â€˜HIGHâ€™, â€˜detailsâ€™: { â€˜min_zeta1â€™: np.min(zeta1), â€˜min_zeta2â€™: np.min(zeta2), â€˜requirementâ€™: â€˜Î¶ â‰¥ 0.69 for &lt;5% overshootâ€™ } }) return {â€˜violationsâ€™: violations} def _monitor_issue2_compliance(self, swarm_state: dict) -&gt; dict: â€œâ€â€ Specialized monitoring for Issue #2 overshoot compliance. â€œâ€â€ particles = swarm_state.get(â€˜positionsâ€™, np.array([])) if particles.size == 0 or particles.shape[1] &lt; 6: return {â€˜statusâ€™: â€˜insufficient_dataâ€™} # Extract surface coefficients lambda1, lambda2 = particles[:, 4], particles[:, 5] k1, k2 = particles[:, 2], particles[:, 3] # Compute damping ratios epsilon = 1e-12 zeta1 = lambda1 / (2 * np.sqrt(k1 + epsilon)) zeta2 = lambda2 / (2 * np.sqrt(k2 + epsilon)) # Issue #2 compliance analysis compliance_stats = { â€˜compliant_particlesâ€™: 0, â€˜total_particlesâ€™: len(particles), â€˜min_damping_ratioâ€™: min(np.min(zeta1), np.min(zeta2)), â€˜avg_damping_ratioâ€™: (np.mean(zeta1) + np.mean(zeta2)) / 2, â€˜predicted_overshoot_rangeâ€™: [], â€˜lambda_bounds_statusâ€™: â€˜unknownâ€™ } # Count compliant particles (Î¶ â‰¥ 0.69) compliant_mask = (zeta1 &gt;= 0.69) &amp; (zeta2 &gt;= 0.69) compliance_stats[â€˜compliant_particlesâ€™] = np.sum(compliant_mask) # Predict overshoot for representative particles for i in range(min(5, len(particles))): # Sample first 5 particles zeta_avg = (zeta1[i] + zeta2[i]) / 2 if zeta_avg &lt; 1.0: # Underdamped predicted_overshoot = 100 * np.exp(-zeta_avg * np.pi / np.sqrt(1 - zeta_avg**2)) else: # Overdamped predicted_overshoot = 0.0 compliance_stats[â€˜predicted_overshoot_rangeâ€™].append(predicted_overshoot) # Check lambda bounds status max_lambda1, max_lambda2 = np.max(lambda1), np.max(lambda2) if max_lambda1 &lt;= 10.0 and max_lambda2 &lt;= 10.0: compliance_stats[â€˜lambda_bounds_statusâ€™] = â€˜compliantâ€™ else: compliance_stats[â€˜lambda_bounds_statusâ€™] = â€˜violationâ€™ return compliance_stats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#runnable-false-class-qualitygatesystem-automated-quality-gate-system-for-pso-optimization-workflow-def-init-self-config-dict-self-config-config-self-quality-gates-configurationqualitygate-optimizationqualitygate-performancequalitygate-safetyqualitygate-issue2compliancequalitygate-regressionqualitygate-def-evaluate-quality-gates-self-workflow-result-dict-qualitygatereport-evaluate-all-quality-gates-and-generate-report-report-qualitygatereport-for-gate-in-self-quality-gates-gate-result-gate-evaluate-workflow-result-self-config-report-add-gate-result-gate-name-gate-result-generate-overall-assessment-report-generate-overall-assessment-return-report-class-issue2compliancequalitygate-qualitygate-quality-gate-specifically-for-issue-2-overshoot-compliance-def-init-self-self-name-issue2-overshoot-compliance-self-acceptance-criteria-max-predicted-overshoot-5-0-maximum-theoretical-overshoot-min-damping-ratio-0-69-minimum-damping-for-compliance-max-lambda-bounds-10-0-maximum-lambda-values-simulation-overshoot-limit-5-0-maximum-measured-overshoot-def-evaluate-self-workflow-result-dict-config-dict-qualitygateresult-evaluate-issue-2-overshoot-compliance-result-qualitygateresult-gate-name-self-name-skip-if-not-sta-smc-if-config-get-controller-type-sta-smc-result-status-skipped-result-message-issue-2-compliance-only-applies-to-sta-smc-return-result-optimized-gains-workflow-result-get-best-gains-if-optimized-gains-is-none-or-len-optimized-gains-6-result-status-failed-result-message-missing-or-insufficient-optimized-gains-return-result-extract-surface-coefficients-lambda1-lambda2-optimized-gains-4-optimized-gains-5-k1-k2-optimized-gains-2-optimized-gains-3-check-1-lambda-bounds-compliance-lambda-bounds-ok-lambda1-self-acceptance-criteria-max-lambda-bounds-and-lambda2-self-acceptance-criteria-max-lambda-bounds-check-2-damping-ratio-compliance-zeta1-lambda1-2-np-sqrt-k1-zeta2-lambda2-2-np-sqrt-k2-damping-ok-zeta1-self-acceptance-criteria-min-damping-ratio-and-zeta2-self-acceptance-criteria-min-damping-ratio-check-3-predicted-overshoot-avg-zeta-zeta1-zeta2-2-if-avg-zeta-1-0-predicted-overshoot-100-np-exp-avg-zeta-np-pi-np-sqrt-1-avg-zeta-2-else-predicted-overshoot-0-0-overshoot-prediction-ok-predicted-overshoot-self-acceptance-criteria-max-predicted-overshoot-check-4-simulation-validation-if-available-simulation-ok-true-measured-overshoot-none-if-overshoot-measurement-in-workflow-result-overshoot-data-workflow-result-overshoot-measurement-measured-overshoot-overshoot-data-get-measured-overshoot-percent-0-simulation-ok-measured-overshoot-self-acceptance-criteria-simulation-overshoot-limit-overall-assessment-all-checks-pass-lambda-bounds-ok-and-damping-ok-and-overshoot-prediction-ok-and-simulation-ok-if-all-checks-pass-result-status-passed-result-message-f-issue-2-compliance-verified-predicted-overshoot-predicted-overshoot-2f-else-result-status-failed-failed-checks-if-not-lambda-bounds-ok-failed-checks-append-f-lambda-bounds-1-lambda1-3f-2-lambda2-3f-self-acceptance-criteria-max-lambda-bounds-if-not-damping-ok-failed-checks-append-f-damping-ratios-1-zeta1-3f-2-zeta2-3f-self-acceptance-criteria-min-damping-ratio-if-not-overshoot-prediction-ok-failed-checks-append-f-predicted-overshoot-predicted-overshoot-2f-self-acceptance-criteria-max-predicted-overshoot-if-not-simulation-ok-and-measured-overshoot-is-not-none-failed-checks-append-f-measured-overshoot-measured-overshoot-2f-self-acceptance-criteria-simulation-overshoot-limit-result-message-f-issue-2-compliance-failed-join-failed-checks-add-detailed-metrics-result-metrics-lambda1-lambda1-lambda2-lambda2-damping-ratio-1-zeta1-damping-ratio-2-zeta2-predicted-overshoot-percent-predicted-overshoot-measured-overshoot-percent-measured-overshoot-lambda-bounds-compliant-lambda-bounds-ok-damping-compliant-damping-ok-overshoot-prediction-compliant-overshoot-prediction-ok-simulation-compliant-simulation-ok-return-result">runnable: false class QualityGateSystem: â€œâ€â€ Automated quality gate system for PSO optimization workflow. â€œâ€â€ def <strong>init</strong>(self, config: dict): self.config = config self.quality_gates = [ ConfigurationQualityGate(), OptimizationQualityGate(), PerformanceQualityGate(), SafetyQualityGate(), Issue2ComplianceQualityGate(), RegressionQualityGate() ] def evaluate_quality_gates(self, workflow_result: dict) -&gt; QualityGateReport: â€œâ€â€ Evaluate all quality gates and generate report. â€œâ€â€ report = QualityGateReport() for gate in self.quality_gates: gate_result = gate.evaluate(workflow_result, self.config) report.add_gate_result(gate.name, gate_result) # Generate overall assessment report.generate_overall_assessment() return report class Issue2ComplianceQualityGate(QualityGate): â€œâ€â€ Quality gate specifically for Issue #2 overshoot compliance. â€œâ€â€ def <strong>init</strong>(self): self.name = â€œIssue2_Overshoot_Complianceâ€ self.acceptance_criteria = { â€˜max_predicted_overshootâ€™: 5.0, # % maximum theoretical overshoot â€˜min_damping_ratioâ€™: 0.69, # Minimum damping for compliance â€˜max_lambda_boundsâ€™: 10.0, # Maximum lambda values â€˜simulation_overshoot_limitâ€™: 5.0 # % maximum measured overshoot } def evaluate(self, workflow_result: dict, config: dict) -&gt; QualityGateResult: â€œâ€â€ Evaluate Issue #2 overshoot compliance. â€œâ€â€ result = QualityGateResult(gate_name=self.name) # Skip if not STA-SMC if config.get(â€˜controller_typeâ€™) != â€˜sta_smcâ€™: result.status = â€˜SKIPPEDâ€™ result.message = â€˜Issue #2 compliance only applies to STA-SMCâ€™ return result optimized_gains = workflow_result.get(â€˜best_gainsâ€™) if optimized_gains is None or len(optimized_gains) &lt; 6: result.status = â€˜FAILEDâ€™ result.message = â€˜Missing or insufficient optimized gainsâ€™ return result # Extract surface coefficients lambda1, lambda2 = optimized_gains[4], optimized_gains[5] k1, k2 = optimized_gains[2], optimized_gains[3] # Check 1: Lambda bounds compliance lambda_bounds_ok = (lambda1 &lt;= self.acceptance_criteria[â€˜max_lambda_boundsâ€™] and lambda2 &lt;= self.acceptance_criteria[â€˜max_lambda_boundsâ€™]) # Check 2: Damping ratio compliance zeta1 = lambda1 / (2 * np.sqrt(k1)) zeta2 = lambda2 / (2 * np.sqrt(k2)) damping_ok = (zeta1 &gt;= self.acceptance_criteria[â€˜min_damping_ratioâ€™] and zeta2 &gt;= self.acceptance_criteria[â€˜min_damping_ratioâ€™]) # Check 3: Predicted overshoot avg_zeta = (zeta1 + zeta2) / 2 if avg_zeta &lt; 1.0: predicted_overshoot = 100 * np.exp(-avg_zeta * np.pi / np.sqrt(1 - avg_zeta**2)) else: predicted_overshoot = 0.0 overshoot_prediction_ok = predicted_overshoot &lt;= self.acceptance_criteria[â€˜max_predicted_overshootâ€™] # Check 4: Simulation validation (if available) simulation_ok = True measured_overshoot = None if â€˜overshoot_measurementâ€™ in workflow_result: overshoot_data = workflow_result[â€˜overshoot_measurementâ€™] measured_overshoot = overshoot_data.get(â€˜measured_overshoot_percentâ€™, 0) simulation_ok = measured_overshoot &lt;= self.acceptance_criteria[â€˜simulation_overshoot_limitâ€™] # Overall assessment all_checks_pass = lambda_bounds_ok and damping_ok and overshoot_prediction_ok and simulation_ok if all_checks_pass: result.status = â€˜PASSEDâ€™ result.message = fâ€™Issue #2 compliance verified: predicted overshoot {predicted_overshoot:.2f}%â€™ else: result.status = â€˜FAILEDâ€™ failed_checks = [] if not lambda_bounds_ok: failed_checks.append(fâ€™Lambda bounds: Î»â‚={lambda1:.3f}, Î»â‚‚={lambda2:.3f} &gt; {self.acceptance_criteria[â€œmax_lambda_boundsâ€]}â€™) if not damping_ok: failed_checks.append(fâ€™Damping ratios: Î¶â‚={zeta1:.3f}, Î¶â‚‚={zeta2:.3f} &lt; {self.acceptance_criteria[â€œmin_damping_ratioâ€]}â€™) if not overshoot_prediction_ok: failed_checks.append(fâ€™Predicted overshoot: {predicted_overshoot:.2f}% &gt; {self.acceptance_criteria[â€œmax_predicted_overshootâ€]}%â€™) if not simulation_ok and measured_overshoot is not None: failed_checks.append(fâ€™Measured overshoot: {measured_overshoot:.2f}% &gt; {self.acceptance_criteria[â€œsimulation_overshoot_limitâ€]}%â€™) result.message = fâ€™Issue #2 compliance failed: {â€; â€œ.join(failed_checks)}â€™ # Add detailed metrics result.metrics = { â€˜lambda1â€™: lambda1, â€˜lambda2â€™: lambda2, â€˜damping_ratio_1â€™: zeta1, â€˜damping_ratio_2â€™: zeta2, â€˜predicted_overshoot_percentâ€™: predicted_overshoot, â€˜measured_overshoot_percentâ€™: measured_overshoot, â€˜lambda_bounds_compliantâ€™: lambda_bounds_ok, â€˜damping_compliantâ€™: damping_ok, â€˜overshoot_prediction_compliantâ€™: overshoot_prediction_ok, â€˜simulation_compliantâ€™: simulation_ok } return result</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#runnable-false-class-workflowperformanceoptimizer-adaptive-optimization-of-workflow-performance-based-on-runtime-metrics-def-init-self-self-performance-history-self-optimization-strategies-memory-optimization-self-optimize-memory-usage-convergence-acceleration-self-accelerate-convergence-bounds-tightening-self-tighten-bounds-dynamically-parameter-adaptation-self-adapt-pso-parameters-def-optimize-workflow-performance-self-current-metrics-dict-workflow-config-dict-optimizationresult-analyze-current-performance-and-apply-optimization-strategies-result-optimizationresult-analyze-performance-trends-performance-analysis-self-analyze-performance-trends-current-metrics-apply-relevant-optimization-strategies-for-strategy-name-strategy-func-in-self-optimization-strategies-items-if-self-should-apply-strategy-strategy-name-performance-analysis-strategy-result-strategy-func-current-metrics-workflow-config-result-add-strategy-result-strategy-name-strategy-result-return-result-def-accelerate-convergence-self-metrics-dict-config-dict-dict-apply-convergence-acceleration-strategies-based-on-performance-analysis-acceleration-result-applied-optimizations-expected-improvement-0-0-check-convergence-rate-convergence-rate-metrics-get-convergence-rate-0-0-if-convergence-rate-0-05-slow-convergence-detected-suggest-inertia-weight-adjustment-current-w-config-get-pso-get-algorithm-params-get-w-0-7-if-current-w-0-5-suggested-w-max-0-4-current-w-0-1-acceleration-result-applied-optimizations-append-parameter-inertia-weight-current-value-current-w-suggested-value-suggested-w-justification-reduce-inertia-for-faster-exploitation-acceleration-result-expected-improvement-15-0-15-improvement-check-diversity-metrics-diversity-metrics-get-swarm-diversity-1-0-if-diversity-1e-8-very-low-diversity-acceleration-result-applied-optimizations-append-parameter-restart-mechanism-action-enable-fraction-0-2-justification-restart-20-of-particles-to-escape-local-optimum-acceleration-result-expected-improvement-20-0-20-improvement-return-acceleration-result">runnable: false class WorkflowPerformanceOptimizer: â€œâ€â€ Adaptive optimization of workflow performance based on runtime metrics. â€œâ€â€ def <strong>init</strong>(self): self.performance_history = [] self.optimization_strategies = { â€˜memory_optimizationâ€™: self._optimize_memory_usage, â€˜convergence_accelerationâ€™: self._accelerate_convergence, â€˜bounds_tighteningâ€™: self._tighten_bounds_dynamically, â€˜parameter_adaptationâ€™: self._adapt_pso_parameters } def optimize_workflow_performance(self, current_metrics: dict, workflow_config: dict) -&gt; OptimizationResult: â€œâ€â€ Analyze current performance and apply optimization strategies. â€œâ€â€ result = OptimizationResult() # Analyze performance trends performance_analysis = self._analyze_performance_trends(current_metrics) # Apply relevant optimization strategies for strategy_name, strategy_func in self.optimization_strategies.items(): if self._should_apply_strategy(strategy_name, performance_analysis): strategy_result = strategy_func(current_metrics, workflow_config) result.add_strategy_result(strategy_name, strategy_result) return result def _accelerate_convergence(self, metrics: dict, config: dict) -&gt; dict: â€œâ€â€ Apply convergence acceleration strategies based on performance analysis. â€œâ€â€ acceleration_result = { â€˜applied_optimizationsâ€™: [], â€˜expected_improvementâ€™: 0.0 } # Check convergence rate convergence_rate = metrics.get(â€˜convergence_rateâ€™, 0.0) if convergence_rate &lt; 0.05: # Slow convergence detected # Suggest inertia weight adjustment current_w = config.get(â€˜psoâ€™, {}).get(â€˜algorithm_paramsâ€™, {}).get(â€˜wâ€™, 0.7) if current_w &gt; 0.5: suggested_w = max(0.4, current_w - 0.1) acceleration_result[â€˜applied_optimizationsâ€™].append({ â€˜parameterâ€™: â€˜inertia_weightâ€™, â€˜current_valueâ€™: current_w, â€˜suggested_valueâ€™: suggested_w, â€˜justificationâ€™: â€˜Reduce inertia for faster exploitationâ€™ }) acceleration_result[â€˜expected_improvementâ€™] += 15.0 # 15% improvement # Check diversity metrics diversity = metrics.get(â€˜swarm_diversityâ€™, 1.0) if diversity &lt; 1e-8: # Very low diversity acceleration_result[â€˜applied_optimizationsâ€™].append({ â€˜parameterâ€™: â€˜restart_mechanismâ€™, â€˜actionâ€™: â€˜enableâ€™, â€˜fractionâ€™: 0.2, â€˜justificationâ€™: â€˜Restart 20% of particles to escape local optimumâ€™ }) acceleration_result[â€˜expected_improvementâ€™] += 20.0 # 20% improvement return acceleration_result</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_user_guide.html">PSO Optimization Workflow User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_troubleshooting_maintenance_manual.html">PSO Troubleshooting and Maintenance Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_troubleshooting_maintenance_manual.html#pso-health-monitor-sh-regular-pso-system-health-monitoring-log-file-var-log-pso-health-log">pso_health_monitor.sh - Regular PSO system health monitoring LOG_FILE=â€/var/log/pso_health.logâ€</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_troubleshooting_maintenance_manual.html#emergency-recovery-sh-emergency-pso-system-recovery-echo-pso-emergency-recovery-procedure">emergency_recovery.sh - Emergency PSO system recovery echo â€œğŸš¨ PSO EMERGENCY RECOVERY PROCEDUREâ€</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_troubleshooting_maintenance_manual.html#recovery-restore-from-backup-backup-index-1">recovery.restore_from_backup(backup_index=1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_troubleshooting_maintenance_manual.html#recovery-restore-factory-defaults">recovery.restore_factory_defaults()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quality_gate_independence_framework.html">Quality Gate Independence Framework ## Executive Summary The Quality Gate Independence Framework establishes resilient, parallel validation paths that operate independently to prevent cascade failures and ensure robust quality assessment for the double-inverted pendulum sliding mode control (DIP-SMC) project. This framework addresses the critical issue identified in GitHub Issue #9 where single component failures could prevent system validation. <strong>Core Principle:</strong> No single point of failure should block system quality assessment. ## 1. Framework Architecture ### 1.1 Independent Validation Paths The framework implements <strong>four parallel, independent validation paths</strong> that can operate and report results independently: ```python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quality_gate_independence_framework.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quality_gate_independence_framework.html#runnable-false-class-independentvalidationpaths-four-independent-validation-paths-preventing-cascade-failures-def-init-self-self-validation-paths-coverage-validation-coveragevalidationpath-mathematical-validation-mathematicalvalidationpath-performance-validation-performancevalidationpath-compliance-validation-compliancevalidationpath-def-execute-independent-validation-self-independentvalidationresults-execute-all-validation-paths-independently-with-failure-isolation-results-for-path-name-validator-in-self-validation-paths-items-try-each-path-executes-in-complete-isolation-results-path-name-validator-validate-independently-except-exception-as-e-failure-isolation-one-path-failure-doesn-t-affect-others-results-path-name-validationresult-status-failed-error-str-e-partial-results-validator-get-partial-results-return-independentvalidationresults-path-results-results-overall-status-self-calculate-composite-status-results-deployment-recommendation-self-make-deployment-decision-results">runnable: false class IndependentValidationPaths: â€œâ€â€Four independent validation paths preventing cascade failures.â€â€â€ def <strong>init</strong>(self): self.validation_paths = { â€˜coverage_validationâ€™: CoverageValidationPath(), â€˜mathematical_validationâ€™: MathematicalValidationPath(), â€˜performance_validationâ€™: PerformanceValidationPath(), â€˜compliance_validationâ€™: ComplianceValidationPath() } def execute_independent_validation(self) -&gt; IndependentValidationResults: â€œâ€â€Execute all validation paths independently with failure isolation.â€â€â€ results = {} for path_name, validator in self.validation_paths.items(): try: # Each path executes in complete isolation results[path_name] = validator.validate_independently() except Exception as e: # Failure isolation: one path failure doesnâ€™t affect others results[path_name] = ValidationResult( status=â€™failedâ€™, error=str(e), partial_results=validator.get_partial_results() ) return IndependentValidationResults( path_results=results, overall_status=self._calculate_composite_status(results), deployment_recommendation=self._make_deployment_decision(results) )</a></li>
<li class="toctree-l1"><a class="reference internal" href="../results_readme.html">Results &amp; Plots</a></li>
<li class="toctree-l1"><a class="reference internal" href="../safety_system_validation_protocols.html">Safety System Validation Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sitemap_cards.html">Visual Documentation Navigator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sitemap_interactive.html">Interactive Documentation Map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sitemap_visual.html">Visual Documentation Map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../streamlit_dashboard_guide.html">Streamlit Dashboard User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symbols.html">Symbols &amp; Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_execution_guide.html">Test Execution Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_guide.html">Test Execution Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_guide.html#quick-development-testing-unit-tests-only">Quick development testing (unit tests only)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_guide.html#recommended-pre-commit-test-sequence">Recommended pre-commit test sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_guide.html#test-algorithm-convergence-properties">Test algorithm convergence properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_guide.html#quality-gate-sh-production-deployment-validation-set-e-echo-starting-quality-gate-validation-1-fast-unit-tests">quality_gate.sh - Production deployment validation set -e echo â€œğŸš€ Starting quality gate validationâ€¦â€ # 1. Fast unit tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_guide.html#pre-commit-config-yaml">.pre-commit-config.yaml</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html">Test Infrastructure Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html#run-only-unit-tests-fast-execution">Run only unit tests (fast execution)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html#full-test-suite-with-coverage">Full test suite with coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html#convergence-and-stability-analysis">Convergence and stability analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html#all-tests-except-known-failing-concurrent-tests">All tests except known failing concurrent tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html#automatic-configuration-in-tests-conftest-py">Automatic configuration in tests/conftest.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html#quality-gate-sh-production-deployment-gate-echo-running-quality-gate-validation-1-unit-and-integration-tests">quality_gate.sh - Production deployment gate echo â€œRunning quality gate validationâ€¦â€ # 1. Unit and integration tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_validation_report.html">Test Infrastructure Validation Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_protocols.html">Test Protocols</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../testing/index.html">Testing &amp; Quality Assurance</a><input aria-label="Toggle navigation of Testing &amp; Quality Assurance" class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../testing/BROWSER_TESTING_CHECKLIST.html">Browser Testing Checklist - Collapsible Code Blocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/PHASE5_SETUP_COMPLETE.html">Phase 5:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/PHASE6_TEST_EXECUTION_REPORT.html">Phase 6: Automated Browser Testing - Execution Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/README.html">Testing Documentation Index ## Overview testing documentation and analysis for the DIP SMC PSO project. This directory contains organized test reports, workflow documentation, standards, and quality gate specifications. ## Directory Structure ```</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/TESTING_PROCEDURES.html">Collapsible Code Blocks - Testing Procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html">Benchmarking Framework Technical Guide <strong>DIP-SMC-PSO Project</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#benchmarks-integration-numerical-methods-py-class-eulerintegrator-forward-euler-integration-method-first-order-accurate-o-h-def-init-self-dynamics-self-dynamics-dynamics-def-integrate-self-x0-np-ndarray-t-span-tuple-dt-float-controller-optional-any-none-dict-integrate-dynamics-using-forward-euler-parameters-x0-np-ndarray-initial-state-t-span-tuple-t-start-t-end-dt-float-time-step-controller-object-optional-controller-for-closed-loop-simulation-returns-dict-t-time-vector-x-state-history-u-control-history-if-controller-provided-t-start-t-end-t-span-t-np-arange-t-start-t-end-dt-dt-n-steps-len-t-x-np-zeros-n-steps-len-x0-x-0-x0-if-controller-u-np-zeros-n-steps-1-for-i-in-range-n-steps-1-if-controller-result-controller-compute-control-x-i-u-i-result-get-control-output-result-get-control-0-0-x-dot-self-dynamics-dynamics-x-i-u-i-else-x-dot-self-dynamics-dynamics-x-i-0-0-x-i-1-x-i-dt-x-dot-result-t-t-x-x-if-controller-result-u-u-return-result-class-rk4integrator-fourth-order-runge-kutta-integration-fourth-order-accurate-o-h4-def-init-self-dynamics-self-dynamics-dynamics-def-integrate-self-x0-np-ndarray-t-span-tuple-dt-float-controller-optional-any-none-dict-integrate-using-rk4-method-t-start-t-end-t-span-t-np-arange-t-start-t-end-dt-dt-n-steps-len-t-x-np-zeros-n-steps-len-x0-x-0-x0-if-controller-u-np-zeros-n-steps-1-for-i-in-range-n-steps-1-if-controller-result-controller-compute-control-x-i-u-i-result-get-control-output-result-get-control-0-0-u-current-u-i-else-u-current-0-0-rk4-stages-k1-self-dynamics-dynamics-x-i-u-current-k2-self-dynamics-dynamics-x-i-0-5dtk1-u-current-k3-self-dynamics-dynamics-x-i-0-5dtk2-u-current-k4-self-dynamics-dynamics-x-i-dtk3-u-current-x-i-1-x-i-dt-6-k1-2k2-2-k3-k4-result-t-t-x-x-if-controller-result-u-u-return-result-class-adaptiverk45integrator-adaptive-runge-kutta-4-5-method-dormand-prince-variable-step-size-for-error-control-def-init-self-dynamics-self-dynamics-dynamics-def-integrate-self-x0-np-ndarray-t-span-tuple-rtol-float-1e-6-atol-float-1e-9-controller-optional-any-none-dict-integrate-using-adaptive-rk45-from-scipy-integrate-import-solve-ivp-if-controller-def-dynamics-func-t-x-result-controller-compute-control-x-u-result-get-control-output-result-get-control-0-0-return-self-dynamics-dynamics-x-u-else-def-dynamics-func-t-x-return-self-dynamics-dynamics-x-0-0-sol-solve-ivp-dynamics-func-t-span-x0-method-rk45-rtol-rtol-atol-atol-return-t-sol-t-x-sol-y-t">benchmarks/integration/numerical_methods.py class EulerIntegrator: â€œâ€â€Forward Euler integration method. First-order accurate: O(h) â€œâ€â€ def <strong>init</strong>(self, dynamics): self.dynamics = dynamics def integrate(self, x0: np.ndarray, t_span: tuple, dt: float, controller: Optional[Any] = None) -&gt; dict: â€œâ€â€Integrate dynamics using Forward Euler. Parameters â€”â€”â€”- x0 : np.ndarray Initial state t_span : tuple (t_start, t_end) dt : float Time step controller : object, optional Controller for closed-loop simulation Returns â€”â€”- dict { â€˜tâ€™: time vector, â€˜xâ€™: state history, â€˜uâ€™: control history (if controller provided) } â€œâ€â€ t_start, t_end = t_span t = np.arange(t_start, t_end + dt, dt) n_steps = len(t) x = np.zeros((n_steps, len(x0))) x[0] = x0 if controller: u = np.zeros(n_steps - 1) for i in range(n_steps - 1): if controller: result = controller.compute_control(x[i], {}, {}) u[i] = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, 0.0)) x_dot = self.dynamics.dynamics(x[i], u[i]) else: x_dot = self.dynamics.dynamics(x[i], 0.0) x[i+1] = x[i] + dt * x_dot result = {â€˜tâ€™: t, â€˜xâ€™: x} if controller: result[â€˜uâ€™] = u return result class RK4Integrator: â€œâ€â€Fourth-order Runge-Kutta integration. Fourth-order accurate: O(hâ´) â€œâ€â€ def <strong>init</strong>(self, dynamics): self.dynamics = dynamics def integrate(self, x0: np.ndarray, t_span: tuple, dt: float, controller: Optional[Any] = None) -&gt; dict: â€œâ€â€Integrate using RK4 method.â€â€â€ t_start, t_end = t_span t = np.arange(t_start, t_end + dt, dt) n_steps = len(t) x = np.zeros((n_steps, len(x0))) x[0] = x0 if controller: u = np.zeros(n_steps - 1) for i in range(n_steps - 1): if controller: result = controller.compute_control(x[i], {}, {}) u[i] = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, 0.0)) u_current = u[i] else: u_current = 0.0 # RK4 stages k1 = self.dynamics.dynamics(x[i], u_current) k2 = self.dynamics.dynamics(x[i] + 0.5<em>dt</em>k1, u_current) k3 = self.dynamics.dynamics(x[i] + 0.5<em>dt</em>k2, u_current) k4 = self.dynamics.dynamics(x[i] + dt<em>k3, u_current) x[i+1] = x[i] + (dt/6) * (k1 + 2</em>k2 + 2*k3 + k4) result = {â€˜tâ€™: t, â€˜xâ€™: x} if controller: result[â€˜uâ€™] = u return result class AdaptiveRK45Integrator: â€œâ€â€Adaptive Runge-Kutta 4-5 method (Dormand-Prince). Variable step size for error control. â€œâ€â€ def <strong>init</strong>(self, dynamics): self.dynamics = dynamics def integrate(self, x0: np.ndarray, t_span: tuple, rtol: float = 1e-6, atol: float = 1e-9, controller: Optional[Any] = None) -&gt; dict: â€œâ€â€Integrate using adaptive RK45.â€â€â€ from scipy.integrate import solve_ivp if controller: def dynamics_func(t, x): result = controller.compute_control(x, {}, {}) u = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, 0.0)) return self.dynamics.dynamics(x, u) else: def dynamics_func(t, x): return self.dynamics.dynamics(x, 0.0) sol = solve_ivp( dynamics_func, t_span, x0, method=â€™RK45â€™, rtol=rtol, atol=atol ) return { â€˜tâ€™: sol.t, â€˜xâ€™: sol.y.T }</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#runnable-false-benchmarks-analysis-accuracy-metrics-py-def-compute-energy-conservation-t-np-ndarray-x-np-ndarray-physics-params-dict-dict-analyze-energy-conservation-for-hamiltonian-systems-parameters-t-np-ndarray-time-vector-x-np-ndarray-state-trajectories-physics-params-dict-physics-parameters-returns-dict-initial-energy-float-final-energy-float-max-drift-float-relative-drift-float-def-compute-energy-state-kinetic-energy-x-dot-theta1-dot-theta2-dot-state-3-state-4-state-5-ke-0-5-physics-params-m-x-dot-2-cart-pendulum-kinetic-energy-potential-energy-theta1-theta2-state-1-state-2-pe-physics-params-m1-physics-params-g-physics-params-l1-1-np-cos-theta1-second-pendulum-pe-return-ke-pe-energies-np-array-compute-energy-state-for-state-in-x-initial-energy-energies-0-final-energy-energies-1-max-drift-np-max-np-abs-energies-initial-energy-relative-drift-max-drift-initial-energy-if-initial-energy-0-else-np-inf-return-initial-energy-float-initial-energy-final-energy-float-final-energy-max-drift-float-max-drift-relative-drift-float-relative-drift-energies-energies-def-estimate-convergence-order-integrator-x0-np-ndarray-t-span-tuple-dt-values-list-float-dict-estimate-numerical-convergence-order-uses-richardson-extrapolation-to-estimate-p-in-e-h-ch-p-parameters-integrator-object-integration-method-instance-x0-np-ndarray-initial-state-t-span-tuple-time-span-dt-values-list-of-float-decreasing-time-steps-for-convergence-analysis-returns-dict-convergence-order-float-errors-list-of-float-dt-values-list-of-float-get-reference-solution-finest-dt-ref-dt-min-dt-values-4-ref-result-integrator-integrate-x0-t-span-ref-dt-ref-x-final-ref-result-x-1-errors-for-dt-in-dt-values-result-integrator-integrate-x0-t-span-dt-x-final-result-x-1-error-np-linalg-norm-x-final-ref-x-final-errors-append-error-estimate-convergence-order-p-log-e-h1-e-h2-log-h1-h2-orders-for-i-in-range-len-errors-1-if-errors-i-1-0-order-np-log-errors-i-errors-i-1-np-log-dt-values-i-dt-values-i-1-orders-append-order-avg-order-np-mean-orders-if-orders-else-np-nan-return-convergence-order-float-avg-order-errors-float-e-for-e-in-errors-dt-values-dt-values">runnable: false # benchmarks/analysis/accuracy_metrics.py def compute_energy_conservation(t: np.ndarray, x: np.ndarray, physics_params: dict) -&gt; dict: â€œâ€â€Analyze energy conservation for Hamiltonian systems. Parameters â€”â€”â€”- t : np.ndarray Time vector x : np.ndarray State trajectories physics_params : dict Physics parameters Returns â€”â€”- dict { â€˜initial_energyâ€™: float, â€˜final_energyâ€™: float, â€˜max_driftâ€™: float, â€˜relative_driftâ€™: float } â€œâ€â€ def compute_energy(state): # Kinetic energy x_dot, theta1_dot, theta2_dot = state[3], state[4], state[5] KE = 0.5 * physics_params[â€˜Mâ€™] * x_dot**2 # Cart # â€¦ (pendulum kinetic energy) # Potential energy theta1, theta2 = state[1], state[2] PE = physics_params[â€˜m1â€™] * physics_params[â€˜gâ€™] * physics_params[â€˜L1â€™] * (1 - np.cos(theta1)) # â€¦ (second pendulum PE) return KE + PE energies = np.array([compute_energy(state) for state in x]) initial_energy = energies[0] final_energy = energies[-1] max_drift = np.max(np.abs(energies - initial_energy)) relative_drift = max_drift / initial_energy if initial_energy != 0 else np.inf return { â€˜initial_energyâ€™: float(initial_energy), â€˜final_energyâ€™: float(final_energy), â€˜max_driftâ€™: float(max_drift), â€˜relative_driftâ€™: float(relative_drift), â€˜energiesâ€™: energies } def estimate_convergence_order(integrator, x0: np.ndarray, t_span: tuple, dt_values: List[float]) -&gt; dict: â€œâ€â€Estimate numerical convergence order. Uses Richardson extrapolation to estimate p in: e_h = CÂ·h^p Parameters â€”â€”â€”- integrator : object Integration method instance x0 : np.ndarray Initial state t_span : tuple Time span dt_values : list of float Decreasing time steps for convergence analysis Returns â€”â€”- dict { â€˜convergence_orderâ€™: float, â€˜errorsâ€™: list of float, â€˜dt_valuesâ€™: list of float } â€œâ€â€ # Get reference solution (finest dt) ref_dt = min(dt_values) / 4 ref_result = integrator.integrate(x0, t_span, ref_dt) ref_x_final = ref_result[â€˜xâ€™][-1] errors = [] for dt in dt_values: result = integrator.integrate(x0, t_span, dt) x_final = result[â€˜xâ€™][-1] error = np.linalg.norm(x_final - ref_x_final) errors.append(error) # Estimate convergence order: p = log(e_h1/e_h2) / log(h1/h2) orders = [] for i in range(len(errors) - 1): if errors[i+1] &gt; 0: order = np.log(errors[i] / errors[i+1]) / np.log(dt_values[i] / dt_values[i+1]) orders.append(order) avg_order = np.mean(orders) if orders else np.nan return { â€˜convergence_orderâ€™: float(avg_order), â€˜errorsâ€™: [float(e) for e in errors], â€˜dt_valuesâ€™: dt_values }</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#benchmarks-comparison-method-comparison-py-class-integrationmethodcomparator-systematic-comparison-of-integration-methods-def-init-self-dynamics-physics-params-dict-self-dynamics-dynamics-self-physics-params-physics-params-def-compare-methods-self-methods-list-str-x0-np-ndarray-t-span-tuple-dt-values-list-float-dict-compare-multiple-integration-methods-parameters-methods-list-of-str-method-names-euler-rk4-rk45-x0-np-ndarray-initial-state-t-span-tuple-time-span-dt-values-list-of-float-time-steps-to-test-returns-dict-comparison-results-for-all-methods-from-benchmarks-integration-import-eulerintegrator-rk4integrator-adaptiverk45integrator-from-benchmarks-analysis-import-compute-energy-conservation-estimate-convergence-order-integrators-euler-eulerintegrator-self-dynamics-rk4-rk4integrator-self-dynamics-rk45-adaptiverk45integrator-self-dynamics-results-for-method-name-in-methods-integrator-integrators-method-name-convergence-analysis-convergence-estimate-convergence-order-integrator-x0-t-span-dt-values-energy-conservation-for-frictionless-system-result-integrator-integrate-x0-t-span-dt-min-dt-values-energy-analysis-compute-energy-conservation-result-t-result-x-self-physics-params-performance-measurement-import-time-start-time-time-integrator-integrate-x0-t-span-dt-min-dt-values-elapsed-time-time-start-results-method-name-convergence-order-convergence-convergence-order-energy-drift-energy-analysis-relative-drift-computation-time-elapsed-errors-convergence-errors-return-results">benchmarks/comparison/method_comparison.py class IntegrationMethodComparator: â€œâ€â€Systematic comparison of integration methods.â€â€â€ def <strong>init</strong>(self, dynamics, physics_params: dict): self.dynamics = dynamics self.physics_params = physics_params def compare_methods(self, methods: List[str], x0: np.ndarray, t_span: tuple, dt_values: List[float]) -&gt; dict: â€œâ€â€Compare multiple integration methods. Parameters â€”â€”â€”- methods : list of str Method names: [â€˜Eulerâ€™, â€˜RK4â€™, â€˜RK45â€™] x0 : np.ndarray Initial state t_span : tuple Time span dt_values : list of float Time steps to test Returns â€”â€”- dict Comparison results for all methods â€œâ€â€ from benchmarks.integration import EulerIntegrator, RK4Integrator, AdaptiveRK45Integrator from benchmarks.analysis import compute_energy_conservation, estimate_convergence_order integrators = { â€˜Eulerâ€™: EulerIntegrator(self.dynamics), â€˜RK4â€™: RK4Integrator(self.dynamics), â€˜RK45â€™: AdaptiveRK45Integrator(self.dynamics) } results = {} for method_name in methods: integrator = integrators[method_name] # Convergence analysis convergence = estimate_convergence_order(integrator, x0, t_span, dt_values) # Energy conservation (for frictionless system) result = integrator.integrate(x0, t_span, dt=min(dt_values)) energy_analysis = compute_energy_conservation( result[â€˜tâ€™], result[â€˜xâ€™], self.physics_params ) # Performance measurement import time start = time.time() _ = integrator.integrate(x0, t_span, dt=min(dt_values)) elapsed = time.time() - start results[method_name] = { â€˜convergence_orderâ€™: convergence[â€˜convergence_orderâ€™], â€˜energy_driftâ€™: energy_analysis[â€˜relative_driftâ€™], â€˜computation_timeâ€™: elapsed, â€˜errorsâ€™: convergence[â€˜errorsâ€™] } return results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#config-yaml-benchmark-configuration-benchmarks-statistical-n-trials-30-clt-compliance-confidence-level-0-95-95-ci-seed-42-reproducibility-physics-uncertainty-enabled-true-n-scenarios-10-variations-cart-mass-0-05-5-pendulum1-mass-0-10-10-pendulum2-mass-0-10-10-pendulum1-length-0-05-5-pendulum2-length-0-05-5-friction-cart-0-20-20-sensor-noise-enabled-false-std-position-0-001-1mm-std-angle-0-001-0-06-integration-methods-euler-rk4-rk45-dt-values-0-05-0-01-0-005-0-001-convergence-analysis-true-energy-conservation-check-true-performance-regression-threshold-0-05-5-slowdown-alert-baseline-file-benchmarks-baseline-json">config.yaml - Benchmark configuration benchmarks: statistical: n_trials: 30 # CLT compliance confidence_level: 0.95 # 95% CI seed: 42 # Reproducibility physics_uncertainty: enabled: true n_scenarios: 10 variations: cart_mass: 0.05 # Â±5% pendulum1_mass: 0.10 # Â±10% pendulum2_mass: 0.10 # Â±10% pendulum1_length: 0.05 # Â±5% pendulum2_length: 0.05 # Â±5% friction_cart: 0.20 # Â±20% sensor_noise: enabled: false std_position: 0.001 # 1mm std_angle: 0.001 # ~0.06Â° integration: methods: [â€˜Eulerâ€™, â€˜RK4â€™, â€˜RK45â€™] dt_values: [0.05, 0.01, 0.005, 0.001] convergence_analysis: true energy_conservation_check: true performance: regression_threshold: 0.05 # 5% slowdown alert baseline_file: â€˜benchmarks/baseline.jsonâ€™</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/code_collapse_validation_report.html">Code Collapse Feature - Validation Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html">Testing Framework Technical Guide <strong>DIP-SMC-PSO Project</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#tests-conftest-py">tests/conftest.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#id1">tests/conftest.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#tests-conftest-py-top-of-file-before-any-imports">tests/conftest.py (top of file, before any imports)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#id2">tests/conftest.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#install-pytest-xdist-for-parallel-execution">Install pytest-xdist for parallel execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#run-all-tests">Run all tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#generate-html-coverage-report">Generate HTML coverage report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#open-coverage-html-report-index-html-generate-terminal-coverage-report">Open coverage_html_report/index.html # Generate terminal coverage report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#test-specific-class">Test specific class</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#drop-into-debugger-on-failure">Drop into debugger on failure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html">Testing Workflows &amp; Best Practices <strong>DIP-SMC-PSO Project</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#runnable-false-step-1-red-write-failing-test">runnable: false # Step 1: RED - Write failing test</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#tests-test-controllers-smc-algorithms-classical-test-new-feature-py-def-test-chattering-reduction-effectiveness-test-that-chattering-reduction-algorithm-reduces-control-rate-controller-classicalsmc-gains-10-8-15-12-50-5-max-force-100-boundary-layer-0-01-chattering-reduction-true-new-feature-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-control-history-for-in-range-100-result-controller-compute-control-state-control-result-control-control-history-append-control-calculate-control-rate-control-rate-np-std-np-diff-control-history-should-be-significantly-lower-than-baseline-assert-control-rate-5-0-f-chattering-reduction-ineffective-rate-control-rate-run-test-fails-feature-not-implemented">tests/test_controllers/smc/algorithms/classical/test_new_feature.py def test_chattering_reduction_effectiveness(): â€œâ€â€Test that chattering reduction algorithm reduces control rate.â€â€â€ controller = ClassicalSMC( gains=[10, 8, 15, 12, 50, 5], max_force=100, boundary_layer=0.01, chattering_reduction=True # New feature ) state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) control_history = [] for _ in range(100): result = controller.compute_control(state, {}, {}) control = result[â€˜controlâ€™] control_history.append(control) # Calculate control rate control_rate = np.std(np.diff(control_history)) # Should be significantly lower than baseline assert control_rate &lt; 5.0, fâ€Chattering reduction ineffective: rate={control_rate}â€ # Run test â†’ FAILS (feature not implemented)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#pytest-tests-test-controllers-smc-algorithms-classical-test-new-feature-py-v">pytest tests/test_controllers/smc/algorithms/classical/test_new_feature.py -v</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#runnable-false-step-2-green-implement-minimal-code-to-pass">runnable: false # Step 2: GREEN - Implement minimal code to pass</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#src-controllers-smc-classic-smc-py-class-classicalsmc-def-init-self-gains-max-force-boundary-layer-0-01-chattering-reduction-false-self-gains-gains-self-max-force-max-force-self-boundary-layer-boundary-layer-self-chattering-reduction-chattering-reduction-self-last-control-0-0-def-compute-control-self-state-state-vars-history-existing-smc-logic-control-u-eq-u-switch-u-derivative-if-self-chattering-reduction-simple-low-pass-filter-alpha-0-8-control-alpha-self-last-control-1-alpha-control-self-last-control-control-saturation-control-np-clip-control-self-max-force-self-max-force-return-control-control-run-test-passes">src/controllers/smc/classic_smc.py class ClassicalSMC: def <strong>init</strong>(self, gains, max_force, boundary_layer=0.01, chattering_reduction=False): self.gains = gains self.max_force = max_force self.boundary_layer = boundary_layer self.chattering_reduction = chattering_reduction self.last_control = 0.0 def compute_control(self, state, state_vars, history): # â€¦ existing SMC logic â€¦ control = u_eq + u_switch + u_derivative if self.chattering_reduction: # Simple low-pass filter alpha = 0.8 control = alpha * self.last_control + (1 - alpha) * control self.last_control = control # Saturation control = np.clip(control, -self.max_force, self.max_force) return {â€˜controlâ€™: control} # Run test â†’ PASSES</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#runnable-false-step-3-refactor-clean-up-implementation">runnable: false # Step 3: REFACTOR - Clean up implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#run-full-test-suite-all-pass">Run full test suite â†’ ALL PASS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#runnable-false-step-1-write-interface-tests-first">runnable: false # Step 1: Write interface tests FIRST</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#tests-test-controllers-smc-algorithms-adaptive-sta-test-adaptive-sta-interface-py-class-testadaptivestainterface-test-interface-compliance-for-adaptive-sta-smc-def-test-implements-controller-protocol-self-test-controller-implements-required-protocol-from-src-controllers-interfaces-import-controllerprotocol-controller-adaptivestasmc-gains-20-15-12-10-max-force-100-adaptation-rate-0-5-assert-isinstance-controller-controllerprotocol-assert-hasattr-controller-compute-control-assert-callable-controller-compute-control-def-test-compute-control-signature-self-test-compute-control-has-correct-signature-controller-adaptivestasmc-gains-20-15-12-10-max-force-100-state-np-zeros-6-result-controller-compute-control-state-assert-isinstance-result-dict-assert-control-in-result-assert-isinstance-result-control-int-float-np-ndarray-step-2-write-functionality-tests">tests/test_controllers/smc/algorithms/adaptive_sta/test_adaptive_sta_interface.py class TestAdaptiveSTAInterface: â€œâ€â€Test interface compliance for Adaptive STA SMC.â€â€â€ def test_implements_controller_protocol(self): â€œâ€â€Test controller implements required protocol.â€â€â€ from src.controllers.interfaces import ControllerProtocol controller = AdaptiveSTASMC( gains=[20, 15, 12, 10], max_force=100, adaptation_rate=0.5 ) assert isinstance(controller, ControllerProtocol) assert hasattr(controller, â€˜compute_controlâ€™) assert callable(controller.compute_control) def test_compute_control_signature(self): â€œâ€â€Test compute_control has correct signature.â€â€â€ controller = AdaptiveSTASMC(gains=[20,15,12,10], max_force=100) state = np.zeros(6) result = controller.compute_control(state, {}, {}) assert isinstance(result, dict) assert â€˜controlâ€™ in result assert isinstance(result[â€˜controlâ€™], (int, float, np.ndarray)) # Step 2: Write functionality tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#src-controllers-smc-algorithms-adaptive-sta-adaptive-sta-smc-py-class-adaptivestasmc-adaptive-super-twisting-sliding-mode-controller-def-init-self-gains-max-force-adaptation-rate-0-5-self-initial-gains-np-array-gains-self-current-gains-self-initial-gains-copy-self-max-force-max-force-self-adaptation-rate-adaptation-rate-def-compute-control-self-state-state-vars-history-super-twisting-control-logic-adaptive-gain-update-return-control-control-def-get-current-gains-self-return-self-current-gains-copy">src/controllers/smc/algorithms/adaptive_sta/adaptive_sta_smc.py class AdaptiveSTASMC: â€œâ€â€Adaptive Super-Twisting Sliding Mode Controller.â€â€â€ def <strong>init</strong>(self, gains, max_force, adaptation_rate=0.5): self.initial_gains = np.array(gains) self.current_gains = self.initial_gains.copy() self.max_force = max_force self.adaptation_rate = adaptation_rate def compute_control(self, state, state_vars, history): # â€¦ Super-twisting control logic â€¦ # â€¦ Adaptive gain update â€¦ return {â€˜controlâ€™: control} def get_current_gains(self): return self.current_gains.copy()</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#level-1-component-level-tests">Level 1: Component-level tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#run-specific-failing-test-with-maximum-verbosity">1. Run specific failing test with maximum verbosity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#tests-test-property-based-debug-py">tests/test_property_based_debug.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#reproduce-failure-6-82-0-b-aaaa-to-reproduce">@reproduce_failure(â€˜6.82.0â€™, bâ€™AAAAâ€¦â€™) to reproduce</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#quick-test-while-developing">Quick test while developing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#full-validation-checklist">Full validation checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#by-marker">By marker</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#auto-detect-cpu-cores">Auto-detect CPU cores</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/validation_methodology_guide.html">Validation Methodology Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html">Control Systems Unit Testing Guide ## Overview This guide provides testing patterns for sliding mode control (SMC) implementations in the double-inverted pendulum control system. It covers state space validation, controller interface compliance, optimal gains interpretation, and production-ready testing methodologies. ## Table of Contents 1. <span class="xref myst">SMC Controller Testing Patterns</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#runnable-false-def-test-classical-smc-initialization-test-classical-smc-initialization-with-valid-parameters-optimal-gains-from-pso-optimization-report-log-line-2-gains-77-62-44-45-17-31-14-25-18-66-9-76-boundary-layer-9-76-matched-to-kd-for-chattering-reduction-max-force-20-0-controller-classicalsmc-gains-gains-max-force-max-force-boundary-layer-boundary-layer-switch-method-tanh-verify-gains-unpacked-correctly-assert-controller-k1-pytest-approx-77-62-rel-1e-6-assert-controller-k2-pytest-approx-44-45-rel-1e-6-assert-controller-lam1-pytest-approx-17-31-rel-1e-6-assert-controller-lam2-pytest-approx-14-25-rel-1e-6-assert-controller-k-pytest-approx-18-66-rel-1e-6-assert-controller-kd-pytest-approx-9-76-rel-1e-6-verify-boundary-layer-for-chattering-reduction-assert-controller-epsilon0-pytest-approx-9-76-verify-control-authority-limits-assert-controller-max-force-20-0">runnable: false def test_classical_smc_initialization(): â€œâ€â€Test Classical SMC initialization with valid parameters.â€â€â€ # Optimal gains from PSO optimization (report.log line 2) gains = [77.62, 44.45, 17.31, 14.25, 18.66, 9.76] boundary_layer = 9.76 # Matched to kd for chattering reduction max_force = 20.0 controller = ClassicalSMC( gains=gains, max_force=max_force, boundary_layer=boundary_layer, switch_method=â€™tanhâ€™ ) # Verify gains unpacked correctly assert controller.k1 == pytest.approx(77.62, rel=1e-6) assert controller.k2 == pytest.approx(44.45, rel=1e-6) assert controller.lam1 == pytest.approx(17.31, rel=1e-6) assert controller.lam2 == pytest.approx(14.25, rel=1e-6) assert controller.K == pytest.approx(18.66, rel=1e-6) assert controller.kd == pytest.approx(9.76, rel=1e-6) # Verify boundary layer for chattering reduction assert controller.epsilon0 == pytest.approx(9.76) # Verify control authority limits assert controller.max_force == 20.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#runnable-false-def-test-lyapunov-decrease-property-test-lyapunov-decrease-property-v-0-when-0-controller-create-test-controller-test-states-with-non-zero-sliding-surface-values-test-states-np-array-0-0-0-1-0-0-0-0-0-0-0-0-pendulum-1-displaced-np-array-0-0-0-0-0-1-0-0-0-0-0-0-pendulum-2-displaced-np-array-0-0-0-05-0-05-0-0-0-1-0-1-both-displaced-with-velocity-history-for-state-in-test-states-result-controller-compute-control-state-history-extract-sliding-surface-from-history-assert-sigma-in-history-sigma-history-sigma-1-lyapunov-function-v-0-5-sigma-2-v-0-5-sigma-2-for-non-zero-sigma-ensure-control-acts-to-reduce-v-if-abs-sigma-1e-6-control-should-oppose-sigma-to-drive-v-0-for-classical-smc-u-u-eq-ksat-kd-the-robust-term-k-sat-should-have-opposite-sign-to">runnable: false def test_lyapunov_decrease_property(): â€œâ€â€Test Lyapunov decrease property: VÌ‡ &lt; 0 when |Ïƒ| &gt; 0.â€â€â€ controller = create_test_controller() # Test states with non-zero sliding surface values test_states = [ np.array([0.0, 0.1, 0.0, 0.0, 0.0, 0.0]), # Pendulum 1 displaced np.array([0.0, 0.0, 0.1, 0.0, 0.0, 0.0]), # Pendulum 2 displaced np.array([0.0, 0.05, 0.05, 0.0, 0.1, 0.1]), # Both displaced with velocity ] history = {} for state in test_states: result = controller.compute_control(state, (), history) # Extract sliding surface from history assert â€˜sigmaâ€™ in history sigma = history[â€˜sigmaâ€™][-1] # Lyapunov function V = 0.5 * sigma^2 V = 0.5 * sigma**2 # For non-zero sigma, ensure control acts to reduce V if abs(sigma) &gt; 1e-6: # Control should oppose sigma to drive VÌ‡ &lt; 0 # For classical SMC: u = u_eq - K<em>sat(Ïƒ/Îµ) - kd</em>Ïƒ # The robust term -K*sat(Ïƒ/Îµ) should have opposite sign to Ïƒ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#runnable-false-def-test-controller-interface-compliance-test-compliance-with-basecontroller-interface-controller-create-test-controller-test-required-properties-assert-hasattr-controller-gains-must-expose-gains-property-assert-hasattr-controller-n-gains-must-declare-n-gains-for-pso-assert-controller-n-gains-6-classical-smc-requires-6-gains-test-required-methods-assert-hasattr-controller-compute-control-must-implement-compute-control-assert-hasattr-controller-reset-must-implement-reset-assert-hasattr-controller-initialize-state-must-implement-initialize-state-assert-hasattr-controller-initialize-history-must-implement-initialize-history-test-gains-property-returns-copy-gains1-controller-gains-gains2-controller-gains-assert-gains1-gains2-gains-should-be-consistent-gains1-0-999-0-try-to-mutate-assert-controller-gains-0-999-0-gains-property-should-return-copy">runnable: false def test_controller_interface_compliance(): â€œâ€â€Test compliance with BaseController interface.â€â€â€ controller = create_test_controller() # Test required properties assert hasattr(controller, â€˜gainsâ€™), â€œMust expose gains propertyâ€ assert hasattr(controller, â€˜n_gainsâ€™), â€œMust declare n_gains for PSOâ€ assert controller.n_gains == 6, â€œClassical SMC requires 6 gainsâ€ # Test required methods assert hasattr(controller, â€˜compute_controlâ€™), â€œMust implement compute_controlâ€ assert hasattr(controller, â€˜resetâ€™), â€œMust implement resetâ€ assert hasattr(controller, â€˜initialize_stateâ€™), â€œMust implement initialize_stateâ€ assert hasattr(controller, â€˜initialize_historyâ€™), â€œMust implement initialize_historyâ€ # Test gains property returns copy gains1 = controller.gains gains2 = controller.gains assert gains1 == gains2, â€œGains should be consistentâ€ gains1[0] = 999.0 # Try to mutate assert controller.gains[0] != 999.0, â€œGains property should return copyâ€</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#runnable-false-def-test-history-telemetry-test-that-controller-properly-tracks-telemetry-in-history-controller-create-test-controller-state-np-array-0-1-0-2-0-1-0-0-0-3-0-2-history-result-controller-compute-control-state-history-verify-all-required-telemetry-is-tracked-required-keys-sigma-epsilon-eff-u-eq-u-robust-u-total-u-for-key-in-required-keys-assert-key-in-history-f-missing-required-history-key-key-assert-len-history-key-1-f-history-key-key-should-have-1-entry-run-multiple-steps-and-verify-accumulation-for-in-range-5-controller-compute-control-state-history-for-key-in-required-keys-assert-len-history-key-6-f-history-key-key-should-accumulate-expected-6-got-len-history-key">runnable: false def test_history_telemetry(): â€œâ€â€Test that controller properly tracks telemetry in history.â€â€â€ controller = create_test_controller() state = np.array([0.1, 0.2, -0.1, 0.0, 0.3, -0.2]) history = {} result = controller.compute_control(state, (), history) # Verify all required telemetry is tracked required_keys = [â€˜sigmaâ€™, â€˜epsilon_effâ€™, â€˜u_eqâ€™, â€˜u_robustâ€™, â€˜u_totalâ€™, â€˜uâ€™] for key in required_keys: assert key in history, fâ€Missing required history key: {key}â€ assert len(history[key]) == 1, fâ€History key {key} should have 1 entryâ€ # Run multiple steps and verify accumulation for _ in range(5): controller.compute_control(state, (), history) for key in required_keys: assert len(history[key]) == 6, \ fâ€History key {key} should accumulate (expected 6, got {len(history[key])})â€</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#runnable-false-def-create-test-controller-create-controller-with-optimal-gains-for-testing-optimal-gains-77-62-44-45-17-31-14-25-18-66-9-76-return-classicalsmc-gains-optimal-gains-max-force-20-0-boundary-layer-9-76-switch-method-tanh-regularization-1e-10">runnable: false def create_test_controller(): â€œâ€â€Create controller with optimal gains for testing.â€â€â€ optimal_gains = [77.62, 44.45, 17.31, 14.25, 18.66, 9.76] return ClassicalSMC( gains=optimal_gains, max_force=20.0, boundary_layer=9.76, switch_method=â€™tanhâ€™, regularization=1e-10 )</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/test_infrastructure_guide.html">Test Infrastructure Guide ## Overview This document provides guidance for the DIP SMC PSO test infrastructure, including pytest configuration, test execution procedures, and troubleshooting guidelines. ## Pytest Configuration ### Test Markers The project uses an extensive set of pytest markers for test categorization: #### Core Test Categories</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/test_infrastructure_guide.html#run-all-tests">Run all tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/test_infrastructure_guide.html#parallel-execution-if-pytest-xdist-installed">Parallel execution (if pytest-xdist installed)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/property_based_testing.html">Property-Based Testing for Control Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/integration_workflows.html">Integration Testing Workflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/performance_benchmarking.html">Performance Benchmarking Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/coverage_quality_gates_runbook.html">Coverage Quality Gates Runbook</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/coverage_quality_gates_troubleshooting.html">Coverage Quality Gates Troubleshooting Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/coverage_quality_gates_troubleshooting.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/coverage_quality_gates_troubleshooting.html#runnable-false-def-calculate-coverage-production-score-gate-results-calculate-coverage-contribution-to-overall-production-readiness-score-current-production-readiness-6-1-10-target-production-readiness-8-5-10-coverage-weight-25-of-total-score-weights-infrastructure-health-0-15-safety-critical-coverage-0-40-highest-weight-critical-components-coverage-0-25-overall-coverage-0-20-coverage-score-0-0-for-gate-id-weight-in-weights-items-if-gate-results-get-gate-id-get-status-passed-coverage-score-weight-scale-to-0-10-production-contribution-coverage-score-10-return-coverage-production-score-production-contribution-production-ready-production-contribution-8-0-improvement-needed-max-0-8-0-production-contribution">runnable: false def calculate_coverage_production_score(gate_results): â€œâ€â€ Calculate coverage contribution to overall production readiness score. Current Production Readiness: 6.1/10 Target Production Readiness: 8.5/10 Coverage Weight: 25% of total score â€œâ€â€ weights = { â€˜infrastructure_healthâ€™: 0.15, â€˜safety_critical_coverageâ€™: 0.40, # Highest weight â€˜critical_components_coverageâ€™: 0.25, â€˜overall_coverageâ€™: 0.20 } coverage_score = 0.0 for gate_id, weight in weights.items(): if gate_results.get(gate_id, {}).get(â€˜statusâ€™) == â€˜passedâ€™: coverage_score += weight # Scale to 0-10 production_contribution = coverage_score * 10 return { â€˜coverage_production_scoreâ€™: production_contribution, â€˜production_readyâ€™: production_contribution &gt;= 8.0, â€˜improvement_neededâ€™: max(0, 8.0 - production_contribution) }</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/coverage_local_development_guide.html">Coverage Local Development Integration Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/coverage_integration_summary.html">Coverage Quality Gates Integration Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/coverage_baseline.html">Coverage Baseline Report <strong>Generated:</strong> 2025-10-05</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/integration_workflows.html">Integration Testing Workflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/performance_benchmarking.html">Performance Benchmarking Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html">Benchmarking Framework Technical Guide <strong>DIP-SMC-PSO Project</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#benchmarks-integration-numerical-methods-py-class-eulerintegrator-forward-euler-integration-method-first-order-accurate-o-h-def-init-self-dynamics-self-dynamics-dynamics-def-integrate-self-x0-np-ndarray-t-span-tuple-dt-float-controller-optional-any-none-dict-integrate-dynamics-using-forward-euler-parameters-x0-np-ndarray-initial-state-t-span-tuple-t-start-t-end-dt-float-time-step-controller-object-optional-controller-for-closed-loop-simulation-returns-dict-t-time-vector-x-state-history-u-control-history-if-controller-provided-t-start-t-end-t-span-t-np-arange-t-start-t-end-dt-dt-n-steps-len-t-x-np-zeros-n-steps-len-x0-x-0-x0-if-controller-u-np-zeros-n-steps-1-for-i-in-range-n-steps-1-if-controller-result-controller-compute-control-x-i-u-i-result-get-control-output-result-get-control-0-0-x-dot-self-dynamics-dynamics-x-i-u-i-else-x-dot-self-dynamics-dynamics-x-i-0-0-x-i-1-x-i-dt-x-dot-result-t-t-x-x-if-controller-result-u-u-return-result-class-rk4integrator-fourth-order-runge-kutta-integration-fourth-order-accurate-o-h4-def-init-self-dynamics-self-dynamics-dynamics-def-integrate-self-x0-np-ndarray-t-span-tuple-dt-float-controller-optional-any-none-dict-integrate-using-rk4-method-t-start-t-end-t-span-t-np-arange-t-start-t-end-dt-dt-n-steps-len-t-x-np-zeros-n-steps-len-x0-x-0-x0-if-controller-u-np-zeros-n-steps-1-for-i-in-range-n-steps-1-if-controller-result-controller-compute-control-x-i-u-i-result-get-control-output-result-get-control-0-0-u-current-u-i-else-u-current-0-0-rk4-stages-k1-self-dynamics-dynamics-x-i-u-current-k2-self-dynamics-dynamics-x-i-0-5dtk1-u-current-k3-self-dynamics-dynamics-x-i-0-5dtk2-u-current-k4-self-dynamics-dynamics-x-i-dtk3-u-current-x-i-1-x-i-dt-6-k1-2k2-2-k3-k4-result-t-t-x-x-if-controller-result-u-u-return-result-class-adaptiverk45integrator-adaptive-runge-kutta-4-5-method-dormand-prince-variable-step-size-for-error-control-def-init-self-dynamics-self-dynamics-dynamics-def-integrate-self-x0-np-ndarray-t-span-tuple-rtol-float-1e-6-atol-float-1e-9-controller-optional-any-none-dict-integrate-using-adaptive-rk45-from-scipy-integrate-import-solve-ivp-if-controller-def-dynamics-func-t-x-result-controller-compute-control-x-u-result-get-control-output-result-get-control-0-0-return-self-dynamics-dynamics-x-u-else-def-dynamics-func-t-x-return-self-dynamics-dynamics-x-0-0-sol-solve-ivp-dynamics-func-t-span-x0-method-rk45-rtol-rtol-atol-atol-return-t-sol-t-x-sol-y-t">benchmarks/integration/numerical_methods.py class EulerIntegrator: â€œâ€â€Forward Euler integration method. First-order accurate: O(h) â€œâ€â€ def <strong>init</strong>(self, dynamics): self.dynamics = dynamics def integrate(self, x0: np.ndarray, t_span: tuple, dt: float, controller: Optional[Any] = None) -&gt; dict: â€œâ€â€Integrate dynamics using Forward Euler. Parameters â€”â€”â€”- x0 : np.ndarray Initial state t_span : tuple (t_start, t_end) dt : float Time step controller : object, optional Controller for closed-loop simulation Returns â€”â€”- dict { â€˜tâ€™: time vector, â€˜xâ€™: state history, â€˜uâ€™: control history (if controller provided) } â€œâ€â€ t_start, t_end = t_span t = np.arange(t_start, t_end + dt, dt) n_steps = len(t) x = np.zeros((n_steps, len(x0))) x[0] = x0 if controller: u = np.zeros(n_steps - 1) for i in range(n_steps - 1): if controller: result = controller.compute_control(x[i], {}, {}) u[i] = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, 0.0)) x_dot = self.dynamics.dynamics(x[i], u[i]) else: x_dot = self.dynamics.dynamics(x[i], 0.0) x[i+1] = x[i] + dt * x_dot result = {â€˜tâ€™: t, â€˜xâ€™: x} if controller: result[â€˜uâ€™] = u return result class RK4Integrator: â€œâ€â€Fourth-order Runge-Kutta integration. Fourth-order accurate: O(hâ´) â€œâ€â€ def <strong>init</strong>(self, dynamics): self.dynamics = dynamics def integrate(self, x0: np.ndarray, t_span: tuple, dt: float, controller: Optional[Any] = None) -&gt; dict: â€œâ€â€Integrate using RK4 method.â€â€â€ t_start, t_end = t_span t = np.arange(t_start, t_end + dt, dt) n_steps = len(t) x = np.zeros((n_steps, len(x0))) x[0] = x0 if controller: u = np.zeros(n_steps - 1) for i in range(n_steps - 1): if controller: result = controller.compute_control(x[i], {}, {}) u[i] = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, 0.0)) u_current = u[i] else: u_current = 0.0 # RK4 stages k1 = self.dynamics.dynamics(x[i], u_current) k2 = self.dynamics.dynamics(x[i] + 0.5<em>dt</em>k1, u_current) k3 = self.dynamics.dynamics(x[i] + 0.5<em>dt</em>k2, u_current) k4 = self.dynamics.dynamics(x[i] + dt<em>k3, u_current) x[i+1] = x[i] + (dt/6) * (k1 + 2</em>k2 + 2*k3 + k4) result = {â€˜tâ€™: t, â€˜xâ€™: x} if controller: result[â€˜uâ€™] = u return result class AdaptiveRK45Integrator: â€œâ€â€Adaptive Runge-Kutta 4-5 method (Dormand-Prince). Variable step size for error control. â€œâ€â€ def <strong>init</strong>(self, dynamics): self.dynamics = dynamics def integrate(self, x0: np.ndarray, t_span: tuple, rtol: float = 1e-6, atol: float = 1e-9, controller: Optional[Any] = None) -&gt; dict: â€œâ€â€Integrate using adaptive RK45.â€â€â€ from scipy.integrate import solve_ivp if controller: def dynamics_func(t, x): result = controller.compute_control(x, {}, {}) u = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, 0.0)) return self.dynamics.dynamics(x, u) else: def dynamics_func(t, x): return self.dynamics.dynamics(x, 0.0) sol = solve_ivp( dynamics_func, t_span, x0, method=â€™RK45â€™, rtol=rtol, atol=atol ) return { â€˜tâ€™: sol.t, â€˜xâ€™: sol.y.T }</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#runnable-false-benchmarks-analysis-accuracy-metrics-py-def-compute-energy-conservation-t-np-ndarray-x-np-ndarray-physics-params-dict-dict-analyze-energy-conservation-for-hamiltonian-systems-parameters-t-np-ndarray-time-vector-x-np-ndarray-state-trajectories-physics-params-dict-physics-parameters-returns-dict-initial-energy-float-final-energy-float-max-drift-float-relative-drift-float-def-compute-energy-state-kinetic-energy-x-dot-theta1-dot-theta2-dot-state-3-state-4-state-5-ke-0-5-physics-params-m-x-dot-2-cart-pendulum-kinetic-energy-potential-energy-theta1-theta2-state-1-state-2-pe-physics-params-m1-physics-params-g-physics-params-l1-1-np-cos-theta1-second-pendulum-pe-return-ke-pe-energies-np-array-compute-energy-state-for-state-in-x-initial-energy-energies-0-final-energy-energies-1-max-drift-np-max-np-abs-energies-initial-energy-relative-drift-max-drift-initial-energy-if-initial-energy-0-else-np-inf-return-initial-energy-float-initial-energy-final-energy-float-final-energy-max-drift-float-max-drift-relative-drift-float-relative-drift-energies-energies-def-estimate-convergence-order-integrator-x0-np-ndarray-t-span-tuple-dt-values-list-float-dict-estimate-numerical-convergence-order-uses-richardson-extrapolation-to-estimate-p-in-e-h-ch-p-parameters-integrator-object-integration-method-instance-x0-np-ndarray-initial-state-t-span-tuple-time-span-dt-values-list-of-float-decreasing-time-steps-for-convergence-analysis-returns-dict-convergence-order-float-errors-list-of-float-dt-values-list-of-float-get-reference-solution-finest-dt-ref-dt-min-dt-values-4-ref-result-integrator-integrate-x0-t-span-ref-dt-ref-x-final-ref-result-x-1-errors-for-dt-in-dt-values-result-integrator-integrate-x0-t-span-dt-x-final-result-x-1-error-np-linalg-norm-x-final-ref-x-final-errors-append-error-estimate-convergence-order-p-log-e-h1-e-h2-log-h1-h2-orders-for-i-in-range-len-errors-1-if-errors-i-1-0-order-np-log-errors-i-errors-i-1-np-log-dt-values-i-dt-values-i-1-orders-append-order-avg-order-np-mean-orders-if-orders-else-np-nan-return-convergence-order-float-avg-order-errors-float-e-for-e-in-errors-dt-values-dt-values">runnable: false # benchmarks/analysis/accuracy_metrics.py def compute_energy_conservation(t: np.ndarray, x: np.ndarray, physics_params: dict) -&gt; dict: â€œâ€â€Analyze energy conservation for Hamiltonian systems. Parameters â€”â€”â€”- t : np.ndarray Time vector x : np.ndarray State trajectories physics_params : dict Physics parameters Returns â€”â€”- dict { â€˜initial_energyâ€™: float, â€˜final_energyâ€™: float, â€˜max_driftâ€™: float, â€˜relative_driftâ€™: float } â€œâ€â€ def compute_energy(state): # Kinetic energy x_dot, theta1_dot, theta2_dot = state[3], state[4], state[5] KE = 0.5 * physics_params[â€˜Mâ€™] * x_dot**2 # Cart # â€¦ (pendulum kinetic energy) # Potential energy theta1, theta2 = state[1], state[2] PE = physics_params[â€˜m1â€™] * physics_params[â€˜gâ€™] * physics_params[â€˜L1â€™] * (1 - np.cos(theta1)) # â€¦ (second pendulum PE) return KE + PE energies = np.array([compute_energy(state) for state in x]) initial_energy = energies[0] final_energy = energies[-1] max_drift = np.max(np.abs(energies - initial_energy)) relative_drift = max_drift / initial_energy if initial_energy != 0 else np.inf return { â€˜initial_energyâ€™: float(initial_energy), â€˜final_energyâ€™: float(final_energy), â€˜max_driftâ€™: float(max_drift), â€˜relative_driftâ€™: float(relative_drift), â€˜energiesâ€™: energies } def estimate_convergence_order(integrator, x0: np.ndarray, t_span: tuple, dt_values: List[float]) -&gt; dict: â€œâ€â€Estimate numerical convergence order. Uses Richardson extrapolation to estimate p in: e_h = CÂ·h^p Parameters â€”â€”â€”- integrator : object Integration method instance x0 : np.ndarray Initial state t_span : tuple Time span dt_values : list of float Decreasing time steps for convergence analysis Returns â€”â€”- dict { â€˜convergence_orderâ€™: float, â€˜errorsâ€™: list of float, â€˜dt_valuesâ€™: list of float } â€œâ€â€ # Get reference solution (finest dt) ref_dt = min(dt_values) / 4 ref_result = integrator.integrate(x0, t_span, ref_dt) ref_x_final = ref_result[â€˜xâ€™][-1] errors = [] for dt in dt_values: result = integrator.integrate(x0, t_span, dt) x_final = result[â€˜xâ€™][-1] error = np.linalg.norm(x_final - ref_x_final) errors.append(error) # Estimate convergence order: p = log(e_h1/e_h2) / log(h1/h2) orders = [] for i in range(len(errors) - 1): if errors[i+1] &gt; 0: order = np.log(errors[i] / errors[i+1]) / np.log(dt_values[i] / dt_values[i+1]) orders.append(order) avg_order = np.mean(orders) if orders else np.nan return { â€˜convergence_orderâ€™: float(avg_order), â€˜errorsâ€™: [float(e) for e in errors], â€˜dt_valuesâ€™: dt_values }</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#benchmarks-comparison-method-comparison-py-class-integrationmethodcomparator-systematic-comparison-of-integration-methods-def-init-self-dynamics-physics-params-dict-self-dynamics-dynamics-self-physics-params-physics-params-def-compare-methods-self-methods-list-str-x0-np-ndarray-t-span-tuple-dt-values-list-float-dict-compare-multiple-integration-methods-parameters-methods-list-of-str-method-names-euler-rk4-rk45-x0-np-ndarray-initial-state-t-span-tuple-time-span-dt-values-list-of-float-time-steps-to-test-returns-dict-comparison-results-for-all-methods-from-benchmarks-integration-import-eulerintegrator-rk4integrator-adaptiverk45integrator-from-benchmarks-analysis-import-compute-energy-conservation-estimate-convergence-order-integrators-euler-eulerintegrator-self-dynamics-rk4-rk4integrator-self-dynamics-rk45-adaptiverk45integrator-self-dynamics-results-for-method-name-in-methods-integrator-integrators-method-name-convergence-analysis-convergence-estimate-convergence-order-integrator-x0-t-span-dt-values-energy-conservation-for-frictionless-system-result-integrator-integrate-x0-t-span-dt-min-dt-values-energy-analysis-compute-energy-conservation-result-t-result-x-self-physics-params-performance-measurement-import-time-start-time-time-integrator-integrate-x0-t-span-dt-min-dt-values-elapsed-time-time-start-results-method-name-convergence-order-convergence-convergence-order-energy-drift-energy-analysis-relative-drift-computation-time-elapsed-errors-convergence-errors-return-results">benchmarks/comparison/method_comparison.py class IntegrationMethodComparator: â€œâ€â€Systematic comparison of integration methods.â€â€â€ def <strong>init</strong>(self, dynamics, physics_params: dict): self.dynamics = dynamics self.physics_params = physics_params def compare_methods(self, methods: List[str], x0: np.ndarray, t_span: tuple, dt_values: List[float]) -&gt; dict: â€œâ€â€Compare multiple integration methods. Parameters â€”â€”â€”- methods : list of str Method names: [â€˜Eulerâ€™, â€˜RK4â€™, â€˜RK45â€™] x0 : np.ndarray Initial state t_span : tuple Time span dt_values : list of float Time steps to test Returns â€”â€”- dict Comparison results for all methods â€œâ€â€ from benchmarks.integration import EulerIntegrator, RK4Integrator, AdaptiveRK45Integrator from benchmarks.analysis import compute_energy_conservation, estimate_convergence_order integrators = { â€˜Eulerâ€™: EulerIntegrator(self.dynamics), â€˜RK4â€™: RK4Integrator(self.dynamics), â€˜RK45â€™: AdaptiveRK45Integrator(self.dynamics) } results = {} for method_name in methods: integrator = integrators[method_name] # Convergence analysis convergence = estimate_convergence_order(integrator, x0, t_span, dt_values) # Energy conservation (for frictionless system) result = integrator.integrate(x0, t_span, dt=min(dt_values)) energy_analysis = compute_energy_conservation( result[â€˜tâ€™], result[â€˜xâ€™], self.physics_params ) # Performance measurement import time start = time.time() _ = integrator.integrate(x0, t_span, dt=min(dt_values)) elapsed = time.time() - start results[method_name] = { â€˜convergence_orderâ€™: convergence[â€˜convergence_orderâ€™], â€˜energy_driftâ€™: energy_analysis[â€˜relative_driftâ€™], â€˜computation_timeâ€™: elapsed, â€˜errorsâ€™: convergence[â€˜errorsâ€™] } return results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#config-yaml-benchmark-configuration-benchmarks-statistical-n-trials-30-clt-compliance-confidence-level-0-95-95-ci-seed-42-reproducibility-physics-uncertainty-enabled-true-n-scenarios-10-variations-cart-mass-0-05-5-pendulum1-mass-0-10-10-pendulum2-mass-0-10-10-pendulum1-length-0-05-5-pendulum2-length-0-05-5-friction-cart-0-20-20-sensor-noise-enabled-false-std-position-0-001-1mm-std-angle-0-001-0-06-integration-methods-euler-rk4-rk45-dt-values-0-05-0-01-0-005-0-001-convergence-analysis-true-energy-conservation-check-true-performance-regression-threshold-0-05-5-slowdown-alert-baseline-file-benchmarks-baseline-json">config.yaml - Benchmark configuration benchmarks: statistical: n_trials: 30 # CLT compliance confidence_level: 0.95 # 95% CI seed: 42 # Reproducibility physics_uncertainty: enabled: true n_scenarios: 10 variations: cart_mass: 0.05 # Â±5% pendulum1_mass: 0.10 # Â±10% pendulum2_mass: 0.10 # Â±10% pendulum1_length: 0.05 # Â±5% pendulum2_length: 0.05 # Â±5% friction_cart: 0.20 # Â±20% sensor_noise: enabled: false std_position: 0.001 # 1mm std_angle: 0.001 # ~0.06Â° integration: methods: [â€˜Eulerâ€™, â€˜RK4â€™, â€˜RK45â€™] dt_values: [0.05, 0.01, 0.005, 0.001] convergence_analysis: true energy_conservation_check: true performance: regression_threshold: 0.05 # 5% slowdown alert baseline_file: â€˜benchmarks/baseline.jsonâ€™</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/validation_methodology_guide.html">Validation Methodology Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/theory/lyapunov_stability_testing.html">Lyapunov Stability Testing Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/theory/smc_validation_mathematics.html">SMC Validation Mathematics <strong>Status:</strong> Integrated into validation framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/theory/smc_validation_mathematics.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/theory/smc_validation_mathematics.html#runnable-false-def-monte-carlo-validation-controller-n-trials-1000-statistical-validation-of-controller-performance-settling-times-overshoot-values-for-in-range-n-trials-x0-random-initial-condition-result-simulate-controller-x0-duration-10-0-settling-times-append-compute-settling-time-result-overshoot-values-append-compute-overshoot-result-statistical-acceptance-criteria-assert-np-mean-settling-times-3-0-assert-np-percentile-settling-times-95-5-0-assert-np-mean-overshoot-values-0-1">runnable: false def monte_carlo_validation(controller, n_trials=1000): â€œâ€â€Statistical validation of controller performance.â€â€â€ settling_times = [] overshoot_values = [] for _ in range(n_trials): x0 = random_initial_condition() result = simulate(controller, x0, duration=10.0) settling_times.append(compute_settling_time(result)) overshoot_values.append(compute_overshoot(result)) # Statistical acceptance criteria assert np.mean(settling_times) &lt; 3.0 assert np.percentile(settling_times, 95) &lt; 5.0 assert np.mean(overshoot_values) &lt; 0.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/executive/executive_summary.html">Executive Test Summary Report <strong>Date</strong>: 2025-09-30 06:03</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/test_failure_analysis.html">Test Failure Analysis Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/failure_breakdown.html">Failure Resolution Tracking Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/pso_convergence_analysis.html">PSO Convergence Analysis - September 30, 2025</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/pso_fitness_investigation.html">PSO Fitness Function Investigation - cost=0.0 Root Cause Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/technical_analysis.html">Technical Deep-Dive: Pytest Failure Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/technical/control_theory_analysis.html">Control Theory Technical Analysis Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/technical/resolution_roadmap.html">Technical Resolution Roadmap <strong>Date</strong>: 2025-09-30 06:03</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/standards/testing_standards.html">Testing Standards and Guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/accessibility_checklist.html">WCAG 2.1 AA Accessibility Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/navigation_index.html">Testing Documentation Navigation Index</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../theory/index.html">Theoretical Foundations ```{toctree}</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html">Particle Swarm Optimization Algorithm Mathematical Foundations <strong>Authors:</strong> Documentation Expert Agent</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#result-simulate-pso-particle-trajectory">result = simulate_pso_particle_trajectory(</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#initial-position-np-array-5-0-5-0">initial_position=np.array([5.0, 5.0]),</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#initial-velocity-np-array-0-0-0-0">initial_velocity=np.array([0.0, 0.0]),</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#personal-best-np-array-3-0-3-0">personal_best=np.array([3.0, 3.0]),</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#global-best-np-array-0-0-0-0">global_best=np.array([0.0, 0.0]),</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#w-0-7-c1-2-0-c2-2-0-n-iterations-50">w=0.7, c1=2.0, c2=2.0, n_iterations=50</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#id1">)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#expected-converged-true-convergence-rate-0-final-distance-1e-3">Expected: converged=True, convergence_rate &gt; 0, final_distance &lt; 1e-3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#result1-analyze-pso-stability-w-0-7-c1-2-0-c2-2-0">result1 = analyze_pso_stability(w=0.7, c1=2.0, c2=2.0)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#expected-stable-empirical-false-oscillatory-stable-theoretical-false">Expected: stable_empirical=False (oscillatory), stable_theoretical=False</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#id2"></a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#result2-analyze-pso-stability-w-0-5-c1-1-5-c2-1-5">result2 = analyze_pso_stability(w=0.5, c1=1.5, c2=1.5)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#expected-stable-empirical-true-stable-theoretical-true">Expected: stable_empirical=True, stable_theoretical=True</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#convergence-rate-decreases-as-kappa-increases">- Convergence rate decreases as kappa increases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#well-conditioned-kappa-1-rate-0-1-0-2">- Well-conditioned (kappa=1): rate ~ 0.1-0.2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory/pso_algorithm_foundations.html#ill-conditioned-kappa-10000-rate-0-001-0-01">- Ill-conditioned (kappa=10000): rate ~ 0.001-0.01</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory_overview.html">Theory Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../use_cases.html">4. Use Cases &amp; Operating Modes</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../validation/index.html">Validation &amp; Verification</a><input aria-label="Toggle navigation of Validation &amp; Verification" class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_workflow.html">Validation Workflow Guide &gt; <strong>Coming Soon:</strong> validation workflow documentation. ## Current Resources For validation guidance, see: - <strong><span class="xref myst">Validation Examples</span></strong> - Practical validation examples and patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_validation_guide.html">Simulation Validation Guide &gt; <strong>Note:</strong> Simulation validation is covered in multiple guides. ## Quick Links - <strong><span class="xref myst">Validation Examples</span></strong> - Practical validation patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html">Simulation Result Validation Methodology <strong>Document Status:</strong> Phase 3.3 Completion - Monte Carlo and Statistical Testing Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html#controller-adapts-on-t0-t1">- Controller adapts on [tâ‚€, tâ‚]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html#performance-evaluated-on-t1-gap-t2">- Performance evaluated on [tâ‚+gap, tâ‚‚]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html#runnable-false-monte-carlo-cross-validation-statistical-tests">runnable: false # Monte Carlo + Cross-Validation + Statistical Tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html#if-diverge-investigate-why">If diverge â†’ investigate why</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html">Validation Examples: Practical Implementation Guide <strong>Document Status:</strong> Phase 3.3 Completion - Executable Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#runnable-false">runnable: false â€œâ€â€</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#conservative-20-uncertainty">Conservative (Â±20% uncertainty)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#pso-hyperparameter-selection-via-cross-validation-1-configuration-number-of-scenarios-100-pso-configurations-to-compare-4-1-small-explorative-pop-20-w-0-9-c1-2-0-c2-1-0-2-standard-pop-30-w-0-7-c1-1-5-c2-1-5-3-large-exploitative-pop-50-w-0-4-c1-1-0-c2-2-0-4-adaptive-pop-30-w-0-5-c1-1-8-c2-1-2-2-cross-validation-setup-method-monte-carlo-repetitions-50-train-test-split-80-20-3-running-cross-validation-this-may-take-several-minutes-4-results-cross-validation-scores-small-explorative-mean-cv-score-2-134-std-cv-score-0-312-median-cv-score-2-098-95-ci-2-223-2-045-standard-mean-cv-score-1-987-std-cv-score-0-267-median-cv-score-1-963-95-ci-2-062-1-912-large-exploitative-mean-cv-score-2-056-std-cv-score-0-298-median-cv-score-2-031-95-ci-2-138-1-974-adaptive-mean-cv-score-1-923-std-cv-score-0-245-median-cv-score-1-904-95-ci-1-992-1-854-5-statistical-comparison-pairwise-tests-after-multiple-comparison-correction-model-0-vs-model-3-model-3-is-significantly-better-p-0-0023-0-211-model-1-vs-model-3-model-3-is-significantly-better-p-0-0412-0-064-overall-ranking-1-adaptive-score-1-923-2-standard-score-1-987-3-large-exploitative-score-2-056-4-small-explorative-score-2-134-6-bias-variance-analysis-small-explorative-bias2-0-123456-variance-0-098234-high-bias-underfitting-consider-larger-population-standard-bias2-0-087654-variance-0-071234-good-balance-large-exploitative-bias2-0-091234-variance-0-089012-good-balance-adaptive-bias2-0-076543-variance-0-060123-good-balance-recommendation-recommended-pso-configuration-adaptive-parameters-population-size-30-inertia-weight-w-0-5-cognitive-coeff-c1-1-8-social-coeff-c2-1-2-mean-cv-score-1-923-this-configuration-showed-best-generalization-across-50-random-splits">======================================================================
PSO Hyperparameter Selection via Cross-Validation
====================================================================== 1. Configuration: Number of scenarios: 100 PSO configurations to compare: 4 1. Small-Explorative: pop=20, w=0.9, c1=2.0, c2=1.0 2. Standard: pop=30, w=0.7, c1=1.5, c2=1.5 3. Large-Exploitative: pop=50, w=0.4, c1=1.0, c2=2.0 4. Adaptive: pop=30, w=0.5, c1=1.8, c2=1.2 2. Cross-Validation Setup: Method: monte_carlo Repetitions: 50 Train-test split: 80%-20% 3. Running cross-validationâ€¦ (This may take several minutesâ€¦) 4. Results:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Cross-Validation Scores: Small-Explorative: Mean CV score: -2.134 Std CV score: 0.312 Median CV score: -2.098 95% CI: [-2.223, -2.045] Standard: Mean CV score: -1.987 Std CV score: 0.267 Median CV score: -1.963 95% CI: [-2.062, -1.912] Large-Exploitative: Mean CV score: -2.056 Std CV score: 0.298 Median CV score: -2.031 95% CI: [-2.138, -1.974] Adaptive: Mean CV score: -1.923 Std CV score: 0.245 Median CV score: -1.904 95% CI: [-1.992, -1.854] 5. Statistical Comparison: Pairwise Tests (after multiple comparison correction): model_0_vs_model_3: model_3 is significantly better (p=0.0023, Î”=0.211) model_1_vs_model_3: model_3 is significantly better (p=0.0412, Î”=0.064) Overall Ranking: 1. Adaptive (score: -1.923) 2. Standard (score: -1.987) 3. Large-Exploitative (score: -2.056) 4. Small-Explorative (score: -2.134) 6. Bias-Variance Analysis: Small-Explorative: BiasÂ²: 0.123456 Variance: 0.098234 âš  High bias - underfitting (consider larger population) Standard: BiasÂ²: 0.087654 Variance: 0.071234 âœ“ Good balance Large-Exploitative: BiasÂ²: 0.091234 Variance: 0.089012 âœ“ Good balance Adaptive: BiasÂ²: 0.076543 Variance: 0.060123 âœ“ Good balance ======================================================================
RECOMMENDATION: âœ“ RECOMMENDED PSO Configuration: Adaptive Parameters: - Population size: 30 - Inertia weight (w): 0.5 - Cognitive coeff (c1): 1.8 - Social coeff (c2): 1.2 Mean CV score: -1.923 This configuration showed best generalization across 50 random splits.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#statistical-comparison-of-controller-performance-1-experimental-setup-controllers-classical-smc-super-twisting-smc-adaptive-smc-trials-per-controller-30-significance-level-0-05-metric-settling-time-seconds-2-collecting-performance-data-3-descriptive-statistics-classical-smc-mean-2-487-s-std-0-398-s-median-2-465-s-min-1-823-s-max-3-312-s-cv-16-0-super-twisting-smc-mean-1-789-s-std-0-246-s-median-1-776-s-min-1-312-s-max-2-345-s-cv-13-8-adaptive-smc-mean-2-098-s-std-0-489-s-median-2-073-s-min-1-234-s-max-3-145-s-cv-23-3-4-assumption-testing-normality-tests-shapiro-wilk-classical-smc-w-0-9821-p-0-8734-normal-super-twisting-smc-w-0-9765-p-0-7231-normal-adaptive-smc-w-0-9798-p-0-8123-normal-homogeneity-of-variance-levene-s-test-f-3-2145-p-0-0456-unequal-variances-will-use-welch-s-test-5-pairwise-comparisons-multiple-comparison-correction-bonferroni-corrected-significance-level-0-0167-classical-smc-vs-super-twisting-smc-welch-s-t-test-t-7-8234-p-0-0001-significant-p-0-0167-mann-whitney-u-test-non-parametric-u-123-0-p-0-0002-effect-size-cohen-s-d-d-2-013-large-mean-difference-0-698-s-95-ci-for-difference-0-512-0-884-s-classical-smc-vs-adaptive-smc-welch-s-t-test-t-3-4567-p-0-0012-significant-p-0-0167-mann-whitney-u-test-non-parametric-u-287-0-p-0-0018-effect-size-cohen-s-d-d-0-891-large-mean-difference-0-389-s-95-ci-for-difference-0-167-0-611-s-super-twisting-smc-vs-adaptive-smc-welch-s-t-test-t-2-8901-p-0-0056-significant-p-0-0167-mann-whitney-u-test-non-parametric-u-234-0-p-0-0071-effect-size-cohen-s-d-d-0-743-medium-mean-difference-0-309-s-95-ci-for-difference-0-521-0-097-s-6-omnibus-test-one-way-anova-f-26-7891-p-0-000001-significant-at-least-one-controller-differs-kruskal-wallis-test-non-parametric-h-25-3456-p-0-000003-7-power-analysis-classical-smc-vs-super-twisting-smc-effect-size-d-2-013-sample-size-n-30-power-0-998-99-8-adequate-power-80-classical-smc-vs-adaptive-smc-effect-size-d-0-891-sample-size-n-30-power-0-865-86-5-adequate-power-80-super-twisting-smc-vs-adaptive-smc-effect-size-d-0-743-sample-size-n-30-power-0-752-75-2-low-power-recommend-n-36-for-80-power-conclusions-1-statistical-significance-significant-differences-found-0-0167-classical-smc-vs-super-twisting-smc-classical-smc-vs-adaptive-smc-super-twisting-smc-vs-adaptive-smc-2-effect-sizes-classical-smc-vs-super-twisting-smc-cohen-s-d-2-013-large-classical-smc-vs-adaptive-smc-cohen-s-d-0-891-large-super-twisting-smc-vs-adaptive-smc-cohen-s-d-0-743-medium-3-practical-recommendations-performance-ranking-by-mean-settling-time-1-super-twisting-smc-1-789-s-2-adaptive-smc-2-098-s-3-classical-smc-2-487-s-recommended-super-twisting-smc-fastest-mean-settling-time-significantly-better-than-classical-smc-p-0-0001-d-2-013-significantly-better-than-adaptive-smc-p-0-0056-d-0-743">======================================================================
Statistical Comparison of Controller Performance
====================================================================== 1. Experimental Setup: Controllers: Classical SMC, Super-Twisting SMC, Adaptive SMC Trials per controller: 30 Significance level: 0.05 Metric: Settling time (seconds) 2. Collecting performance dataâ€¦ 3. Descriptive Statistics:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Classical SMC: Mean: 2.487 s Std: 0.398 s Median: 2.465 s Min: 1.823 s Max: 3.312 s CV: 16.0% Super-Twisting SMC: Mean: 1.789 s Std: 0.246 s Median: 1.776 s Min: 1.312 s Max: 2.345 s CV: 13.8% Adaptive SMC: Mean: 2.098 s Std: 0.489 s Median: 2.073 s Min: 1.234 s Max: 3.145 s CV: 23.3% 4. Assumption Testing:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Normality Tests (Shapiro-Wilk): Classical SMC : W=0.9821, p=0.8734 âœ“ Normal Super-Twisting SMC : W=0.9765, p=0.7231 âœ“ Normal Adaptive SMC : W=0.9798, p=0.8123 âœ“ Normal Homogeneity of Variance (Leveneâ€™s test): F=3.2145, p=0.0456 âš  Unequal variances - will use Welchâ€™s test 5. Pairwise Comparisons:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Multiple comparison correction: Bonferroni Corrected significance level: Î±=0.0167 Classical SMC vs Super-Twisting SMC: Welchâ€™s t-test: t=7.8234, p=0.0001 âœ“ SIGNIFICANT (p &lt; 0.0167) Mann-Whitney U test (non-parametric): U=123.0, p=0.0002 Effect Size (Cohenâ€™s d): d=2.013 (large) Mean difference: 0.698 s 95% CI for difference: [0.512, 0.884] s Classical SMC vs Adaptive SMC: Welchâ€™s t-test: t=3.4567, p=0.0012 âœ“ SIGNIFICANT (p &lt; 0.0167) Mann-Whitney U test (non-parametric): U=287.0, p=0.0018 Effect Size (Cohenâ€™s d): d=0.891 (large) Mean difference: 0.389 s 95% CI for difference: [0.167, 0.611] s Super-Twisting SMC vs Adaptive SMC: Welchâ€™s t-test: t=-2.8901, p=0.0056 âœ“ SIGNIFICANT (p &lt; 0.0167) Mann-Whitney U test (non-parametric): U=234.0, p=0.0071 Effect Size (Cohenâ€™s d): d=-0.743 (medium) Mean difference: -0.309 s 95% CI for difference: [-0.521, -0.097] s 6. Omnibus Test (One-Way ANOVA):
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- F=26.7891, p=0.000001 âœ“ SIGNIFICANT: At least one controller differs Kruskal-Wallis test (non-parametric): H=25.3456, p=0.000003 7. Power Analysis:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Classical SMC vs Super-Twisting SMC: Effect size (d): 2.013 Sample size (n): 30 Power: 0.998 (99.8%) âœ“ Adequate power (â‰¥80%) Classical SMC vs Adaptive SMC: Effect size (d): 0.891 Sample size (n): 30 Power: 0.865 (86.5%) âœ“ Adequate power (â‰¥80%) Super-Twisting SMC vs Adaptive SMC: Effect size (d): 0.743 Sample size (n): 30 Power: 0.752 (75.2%) âš  Low power - recommend n=36 for 80% power ======================================================================
CONCLUSIONS:
====================================================================== 1. Statistical Significance: Significant differences found (Î±=0.0167): - Classical SMC vs Super-Twisting SMC - Classical SMC vs Adaptive SMC - Super-Twisting SMC vs Adaptive SMC 2. Effect Sizes: Classical SMC vs Super-Twisting SMC: Cohenâ€™s d = 2.013 (large) Classical SMC vs Adaptive SMC: Cohenâ€™s d = 0.891 (large) Super-Twisting SMC vs Adaptive SMC: Cohenâ€™s d = -0.743 (medium) 3. Practical Recommendations: Performance ranking (by mean settling time): 1. Super-Twisting SMC : 1.789 s 2. Adaptive SMC : 2.098 s 3. Classical SMC : 2.487 s âœ“ RECOMMENDED: Super-Twisting SMC - Fastest mean settling time - Significantly better than Classical SMC (p=0.0001, d=2.013) - Significantly better than Adaptive SMC (p=0.0056, d=0.743)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#uncertainty-quantification-for-settling-time-1-safety-requirement-settling-time-must-be-3-0s-with-99-confidence-2-collecting-experimental-data-number-of-test-runs-200-3-descriptive-statistics-mean-2-123-s-std-0-687-s-median-1-983-s-min-0-987-s-max-4-823-s-range-3-836-s-percentiles-5-1-234-s-25-1-653-s-50-1-983-s-75-2-456-s-95-3-567-s-99-4-234-s-4-bootstrap-confidence-intervals-bootstrap-iterations-10000-confidence-level-95-mean-settling-time-point-estimate-2-123-s-95-ci-2-026-2-223-s-ci-width-0-197-s-median-settling-time-point-estimate-1-983-s-95-ci-1-876-2-087-s-95th-percentile-point-estimate-3-567-s-95-ci-3-289-3-891-s-5-distribution-fitting-normal-k-s-statistic-0-0867-p-value-0-0234-aic-412-34-reject-poor-fit-lognormal-k-s-statistic-0-0421-p-value-0-6523-aic-387-12-cannot-reject-good-fit-gamma-k-s-statistic-0-0534-p-value-0-3421-aic-391-67-cannot-reject-good-fit-exponential-k-s-statistic-0-1234-p-value-0-0001-aic-445-89-reject-poor-fit-best-fit-lowest-aic-lognormal-aic-387-12-6-risk-analysis-value-at-risk-var-var-1-3-892-s-top-1-worst-cases-var-5-3-567-s-top-5-worst-cases-var-10-3-234-s-top-10-worst-cases-conditional-value-at-risk-cvar-expected-shortfall-cvar-1-4-123-s-avg-of-worst-1-cvar-5-3-789-s-avg-of-worst-5-cvar-10-3-456-s-avg-of-worst-10-7-safety-validation-empirical-analysis-samples-exceeding-3-0s-18-200-empirical-p-t-3-0s-0-0900-9-00-95-ci-for-p-t-3-0s-0-0523-0-1342-fitted-lognormal-distribution-p-t-3-0s-0-0823-8-23-p-t-3-0s-0-9177-91-77-fails-safety-requirement-91-8-99-0-to-meet-99-confidence-target-99-percentile-4-521-s-required-4-521s-3-0s-need-to-improve-99-percentile-by-1-521s-8-extreme-value-analysis-block-maxima-method-block-size-20-number-of-blocks-10-gev-parameters-0-234-3-876-0-456-return-levels-10-run-worst-case-4-876-s-50-run-worst-case-5-432-s-100-run-worst-case-5-687-s-uncertainty-quantification-summary-1-point-estimates-mean-2-123-s-95th-percentile-3-567-s-99th-percentile-4-234-s-2-uncertainty-95-ci-mean-2-026-2-223-s-95th-percentile-3-289-3-891-s-3-distributional-model-best-fit-lognormal-goodness-of-fit-p-value-0-6523-4-safety-assessment-threshold-3-0s-required-confidence-99-fails-only-91-8-of-scenarios-meet-requirement-5-recommendations-further-controller-improvement-needed-option-1-tune-controller-for-better-worst-case-performance-option-2-increase-safety-threshold-option-3-accept-lower-confidence-level-if-acceptable">======================================================================
Uncertainty Quantification for Settling Time
====================================================================== 1. Safety Requirement: Settling time must be &lt; 3.0s with 99% confidence 2. Collecting experimental dataâ€¦ Number of test runs: 200 3. Descriptive Statistics:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Mean: 2.123 s Std: 0.687 s Median: 1.983 s Min: 0.987 s Max: 4.823 s Range: 3.836 s Percentiles: 5%: 1.234 s 25%: 1.653 s 50%: 1.983 s 75%: 2.456 s 95%: 3.567 s 99%: 4.234 s 4. Bootstrap Confidence Intervals:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Bootstrap iterations: 10000 Confidence level: 95% Mean settling time: Point estimate: 2.123 s 95% CI: [2.026, 2.223] s CI width: 0.197 s Median settling time: Point estimate: 1.983 s 95% CI: [1.876, 2.087] s 95th percentile: Point estimate: 3.567 s 95% CI: [3.289, 3.891] s 5. Distribution Fitting:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Normal: K-S statistic: 0.0867 p-value: 0.0234 AIC: 412.34 âœ— Reject (poor fit) Lognormal: K-S statistic: 0.0421 p-value: 0.6523 AIC: 387.12 âœ“ Cannot reject (good fit) Gamma: K-S statistic: 0.0534 p-value: 0.3421 AIC: 391.67 âœ“ Cannot reject (good fit) Exponential: K-S statistic: 0.1234 p-value: 0.0001 AIC: 445.89 âœ— Reject (poor fit) Best fit (lowest AIC): Lognormal AIC = 387.12 6. Risk Analysis:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Value at Risk (VaR): VaR(1%): 3.892 s (top 1% worst cases) VaR(5%): 3.567 s (top 5% worst cases) VaR(10%): 3.234 s (top 10% worst cases) Conditional Value at Risk (CVaR / Expected Shortfall): CVaR(1%): 4.123 s (avg of worst 1%) CVaR(5%): 3.789 s (avg of worst 5%) CVaR(10%): 3.456 s (avg of worst 10%) 7. Safety Validation:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Empirical Analysis: Samples exceeding 3.0s: 18/200 Empirical P(T &gt; 3.0s) = 0.0900 (9.00%) 95% CI for P(T &gt; 3.0s): [0.0523, 0.1342] Fitted Lognormal Distribution: P(T &gt; 3.0s) = 0.0823 (8.23%) P(T â‰¤ 3.0s) = 0.9177 (91.77%) âœ— FAILS safety requirement (91.8% &lt; 99.0%) To meet 99% confidence: Target: 99% percentile = 4.521 s Required: 4.521s &lt; 3.0s âš  Need to improve 99% percentile by 1.521s 8. Extreme Value Analysis:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Block Maxima Method: Block size: 20 Number of blocks: 10 GEV parameters: Î¾=-0.234, Î¼=3.876, Ïƒ=0.456 Return Levels: 10-run worst-case: 4.876 s 50-run worst-case: 5.432 s 100-run worst-case: 5.687 s ======================================================================
UNCERTAINTY QUANTIFICATION SUMMARY:
====================================================================== 1. Point Estimates: Mean: 2.123 s 95th percentile: 3.567 s 99th percentile: 4.234 s 2. Uncertainty (95% CI): Mean: [2.026, 2.223] s 95th percentile: [3.289, 3.891] s 3. Distributional Model: Best fit: Lognormal Goodness-of-fit p-value: 0.6523 4. Safety Assessment: Threshold: 3.0s Required confidence: 99% âœ— FAILS: Only 91.8% of scenarios meet requirement 5. Recommendations: âœ— Further controller improvement needed â–¡ Option 1: Tune controller for better worst-case performance â–¡ Option 2: Increase safety threshold â–¡ Option 3: Accept lower confidence level (if acceptable)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/api_reference.html">Validation API Reference &gt; <strong>Coming Soon:</strong> validation API documentation. ## Current Resources For validation APIs, see: - <strong><span class="xref myst">Analysis Validation</span></strong> - Validation metrics API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/statistical_reference_tables.html">Statistical Reference Tables &gt; <strong>Coming Soon:</strong> statistical reference tables for validation. ## Current Resources For statistical validation, see: - <strong><span class="xref myst">Statistical Tests</span></strong> - Statistical test implementations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/phase_3_3_completion_report.html">Phase 3.3 Completion Report: Simulation Result Validation Documentation <strong>Completion Date:</strong> 2025-10-07</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../versioning_guide.html">Documentation Versioning Guide</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../workflows/index.html">Workflows &amp; Integration Guides</a><input aria-label="Toggle navigation of Workflows &amp; Integration Guides" class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html">Complete Integration Workflow Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#test-each-controller-individually">Test each controller individually</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#use-pre-optimized-gains-for-immediate-results">Use pre-optimized gains for immediate results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#launch-interactive-web-interface">Launch interactive web interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#select-controller-adjust-parameters-run-simulations">Select controller, adjust parameters, run simulations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#optimize-classical-smc-gains">Optimize classical SMC gains</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#optimize-adaptive-smc-with-uncertainty">Optimize adaptive SMC with uncertainty</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#optimize-sta-smc-for-finite-time-performance">Optimize STA SMC for finite-time performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#optimize-hybrid-smc-most-sophisticated">Optimize hybrid SMC (most sophisticated)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#optimize-all-controllers-in-sequence">Optimize all controllers in sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#runnable-false-scripts-custom-batch-optimization-py">runnable: false # scripts/custom_batch_optimization.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#multi-objective-optimization-for-competing-requirements">Multi-objective optimization for competing requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#runnable-false-adaptive-pso-with-time-varying-parameters">runnable: false # Adaptive PSO with time-varying parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#run-hil-simulation">Run HIL simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#real-time-monitoring-setup">Real-time monitoring setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#distributed-control-system">Distributed control system</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#adaptive-controller-selection-based-on-performance">Adaptive controller selection based on performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#diagnose-controller-performance-problems">Diagnose controller performance problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#debug-pso-optimization-problems">Debug PSO optimization problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#continuous-system-health-monitoring">Continuous system health monitoring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/pytest_testing_workflow.html">Quick Start Guide for Running Tests <strong>Document Version</strong>: 1.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/pytest_testing_workflow.html#run-all-tests-basic-command">1. Run all tests (basic command)</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="../_sources/api/simulation_engine_api_reference.md.txt" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div>
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section class="tex2jax_ignore mathjax_ignore" id="simulation-engine-api-reference-project-double-inverted-pendulum-smc-control-system">
<h1>Simulation Engine API Reference <strong>Project:</strong> Double-Inverted Pendulum SMC Control System<a class="headerlink" href="#simulation-engine-api-reference-project-double-inverted-pendulum-smc-control-system" title="Link to this heading">Â¶</a></h1>
<p><strong>Module:</strong> <code class="docutils literal notranslate"><span class="pre">src.simulation</span></code>
<strong>Version:</strong> 1.0
<strong>Date:</strong> 2025-10-07
<strong>Status:</strong> Production-Ready</p>
<hr class="docutils" />
<section id="table-of-contents-1-overview-architecture">
<h2>Table of Contents 1. <a class="reference internal" href="#1-overview--architecture"><span class="xref myst">Overview &amp; Architecture</span></a><a class="headerlink" href="#table-of-contents-1-overview-architecture" title="Link to this heading">Â¶</a></h2>
<ol class="arabic simple" start="2">
<li><p><a class="reference internal" href="#2-core-simulation-engine-api"><span class="xref myst">Core Simulation Engine API</span></a></p></li>
<li><p><a class="reference internal" href="#3-dynamics-model-api"><span class="xref myst">Dynamics Model API</span></a></p></li>
<li><p><a class="reference internal" href="#4-orchestrator-system-api"><span class="xref myst">Orchestrator System API</span></a></p></li>
<li><p><a class="reference internal" href="#5-integrator-system-api"><span class="xref myst">Integrator System API</span></a></p></li>
<li><p><a class="reference internal" href="#6-result-container-api"><span class="xref myst">Result Container API</span></a></p></li>
<li><p><a class="reference internal" href="#7-safety--monitoring-api"><span class="xref myst">Safety &amp; Monitoring API</span></a></p></li>
<li><p><a class="reference internal" href="#8-complete-code-examples"><span class="xref myst">Complete Code Examples</span></a></p></li>
<li><p><a class="reference internal" href="#9-integration-patterns"><span class="xref myst">Integration Patterns</span></a></p></li>
<li><p><a class="reference internal" href="#10-theory-cross-references--performance"><span class="xref myst">Theory Cross-References &amp; Performance</span></a></p></li>
</ol>
</section>
<hr class="docutils" />
<section id="overview-architecture-1-1-introduction-the-simulation-engine-is-the-core-execution-framework-for-the-double-inverted-pendulum-control-system-it-provides-flexible-simulation-execution-strategies-sequential-batch-parallel-real-time">
<h2>1. Overview &amp; Architecture ### 1.1 Introduction The <strong>Simulation Engine</strong> is the core execution framework for the Double-Inverted Pendulum control system. It provides: - <strong>Flexible simulation execution</strong> strategies (sequential, batch, parallel, real-time)<a class="headerlink" href="#overview-architecture-1-1-introduction-the-simulation-engine-is-the-core-execution-framework-for-the-double-inverted-pendulum-control-system-it-provides-flexible-simulation-execution-strategies-sequential-batch-parallel-real-time" title="Link to this heading">Â¶</a></h2>
<ul class="simple">
<li><p><strong>Multiple numerical integration</strong> methods (Euler, RK4, adaptive Runge-Kutta)</p></li>
<li><p><strong>dynamics models</strong> (simplified, full nonlinear, linearized)</p></li>
<li><p><strong>Safety monitoring</strong> and constraint enforcement</p></li>
<li><p><strong>Professional result management</strong> with export features - <strong>PSO optimization integration</strong> through batch execution</p></li>
<li><p><strong>Hardware-in-loop (HIL)</strong> real-time simulation support <strong>Key Features:</strong></p></li>
<li><p>âœ… 45 Python modules providing complete simulation framework</p></li>
<li><p>âœ… Backward-compatible with legacy <code class="docutils literal notranslate"><span class="pre">simulation_runner.py</span></code> interface</p></li>
<li><p>âœ… Extensible architecture for research and production use</p></li>
<li><p>âœ… Type-safe interfaces with protocols</p></li>
<li><p>âœ… Production-grade error handling and monitoring</p></li>
<li><p>âœ… Memory-optimized for long-running simulations ### 1.2 System Architecture ```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SIMULATION ENGINE SYSTEM â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Controller â”‚â”€â”€â”€â”€â–¶â”‚ Simulation â”‚â”€â”€â”€â”€â–¶â”‚ Dynamics â”‚ â”‚
â”‚ â”‚ Factory â”‚ â”‚ Runner â”‚ â”‚ Model â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ â”‚ â”‚ â”‚ â”‚
â”‚ â”‚ â–¼ â”‚ â”‚
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚ â”‚ â”‚ Orchestrator â”‚ â”‚ â”‚
â”‚ â”‚ â”‚ Strategy â”‚ â”‚ â”‚
â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚ â”‚ â”‚ â”‚ â”‚
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚ â”‚ â–¼ â–¼ â”‚ â”‚
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚ â”‚ â”‚Sequential â”‚ â”‚ Batch â”‚ â”‚ â”‚
â”‚ â”‚ â”‚Orchestr. â”‚ â”‚Orchestr. â”‚ â”‚ â”‚
â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚ â”‚ â”‚ â”‚ â”‚ â”‚
â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚ â”‚ â–¼ â”‚ â”‚
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚ â”‚ â”‚ Integrator â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ â”‚ â”‚ Factory â”‚ â”‚
â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ â”‚ â”‚ â”‚
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ â–¼ â–¼ â”‚
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ â”‚ Euler â”‚ â”‚ RK4 â”‚ â”‚
â”‚ â”‚ â”‚ (1st ord) â”‚ â”‚ (4th ord) â”‚ â”‚
â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ â”‚ â”‚ â”‚ â”‚
â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ â”‚ â–¼ â”‚
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ â”‚ Safety â”‚ â”‚
â”‚ â”‚ â”‚ Guards â”‚ â”‚
â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ â”‚ â”‚
â”‚ â–¼ â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ PSO â”‚ â”‚
â”‚ â”‚Optimization â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ â”‚ â”‚
â”‚ â–¼ â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Results â”‚ â”‚
â”‚ â”‚ Container â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</p></li>
</ul>
<div class="highlight-### notranslate"><div class="highlight"><pre><span></span>- **`simulation_runner.py`** - Main simulation loop and legacy compatibility
- **`simulation_context.py`** - Configuration management and orchestrator selection
- **`interfaces.py`** - Protocol definitions for extensibility **Execution Strategies (Orchestrators):**
- **`orchestrators/sequential.py`** - Single-threaded step-by-step execution
- **`orchestrators/batch.py`** - Vectorized multi-simulation execution
- **`orchestrators/parallel.py`** - Multi-threaded parallel execution
- **`orchestrators/real_time.py`** - Real-time constraint enforcement for HIL **Numerical Integration:**
- **`integrators/factory.py`** - Integrator creation and registry
- **`integrators/fixed_step/euler.py`** - 1st-order Euler method
- **`integrators/fixed_step/runge_kutta.py`** - 2nd and 4th-order Runge-Kutta
- **`integrators/adaptive/runge_kutta.py`** - Adaptive step size with error control
- **`integrators/discrete/zero_order_hold.py`** - Discrete-time control **Plant Dynamics:**
- **`plant/models/base/dynamics_interface.py`** - DynamicsModel protocol
- **`plant/models/lowrank/dynamics.py`** - Simplified DIP dynamics
- **`plant/models/full/dynamics.py`** - Full nonlinear DIP dynamics
- **`plant/models/simplified/dynamics.py`** - Educational simplified model **Results &amp; Safety:**
- **`results/containers.py`** - StandardResultContainer, BatchResultContainer
- **`results/exporters.py`** - CSV, HDF5 export functionality
- **`safety/guards.py`** - NaN/Inf detection, energy bounds, state validation
- **`safety/monitors.py`** - Performance monitoring and statistics ### 1.4 Data Flow Diagram #### Simulation Loop Execution Flow ```
START â”‚ â”œâ”€â–¶ Initialize state (x0) â”‚ â”œâ”€â–¶ Initialize controller (state_vars, history) â”‚ â”œâ”€â–¶ FOR each timestep i = 0 to N-1: â”‚ â”‚ â”‚ â”œâ”€â–¶ Measure control computation time (start timer) â”‚ â”‚ â”‚ â”œâ”€â–¶ Compute control: u = controller(t, x) â”‚ â”‚ â”‚ â”‚ â”‚ â”œâ”€â–¶ [Has compute_control] â†’ u, state_vars, history â”‚ â”‚ â””â”€â–¶ [Has __call__] â†’ u = controller(t, x) â”‚ â”‚ â”‚ â”œâ”€â–¶ Check latency (end timer) â”‚ â”‚ â”‚ â”‚ â”‚ â””â”€â–¶ [Exceeds dt AND fallback available] â†’ use fallback_controller â”‚ â”‚ â”‚ â”œâ”€â–¶ Apply control saturation: u = clip(u, -u_max, u_max) â”‚ â”‚ â”‚ â”œâ”€â–¶ Apply safety guards (NaN/Inf/Bounds checks) â”‚ â”‚ â”‚ â”‚ â”‚ â””â”€â–¶ [FAIL] â†’ Truncate trajectory and return â”‚ â”‚ â”‚ â”œâ”€â–¶ Propagate dynamics: x_next = dynamics.step(x, u, dt) â”‚ â”‚ â”‚ â”‚ â”‚ â””â”€â–¶ [Exception or NaN/Inf] â†’ Truncate and return â”‚ â”‚ â”‚ â”œâ”€â–¶ Validate result: np.isfinite(x_next) â”‚ â”‚ â”‚ â”‚ â”‚ â”œâ”€â–¶ [PASS] â†’ Continue â”‚ â”‚ â””â”€â–¶ [FAIL] â†’ Truncate and return â”‚ â”‚ â”‚ â””â”€â–¶ Store trajectory: (t[i+1], x[i+1], u[i]) â”‚ â””â”€â–¶ Attach final history to controller (if available) â”‚ â””â”€â–¶ Return: (t_arr, x_arr, u_arr)
``` #### Batch Simulation for PSO ```

PSO Tuner â”‚ â”œâ”€â–¶ Generate N particles (gain sets) â”‚ â”œâ”€â–¶ Create controller factory: functools.partial(create_controller, ...) â”‚ â”œâ”€â–¶ FOR each particle p: â”‚ â”‚ â”‚ â”œâ”€â–¶ Instantiate controller: ctrl = factory(gains=particle_p) â”‚ â”‚ â”‚ â”œâ”€â–¶ BatchOrchestrator.execute() â”‚ â”‚ â”‚ â”‚ â”‚ â”œâ”€â–¶ Initialize batch_size trajectories â”‚ â”‚ â”‚ â”‚ â”‚ â”œâ”€â–¶ FOR each step: â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”œâ”€â–¶ Vectorized control computation (batch_size x) â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”œâ”€â–¶ Safety guard check (each trajectory) â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”œâ”€â–¶ Dynamics step (each trajectory) â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â””â”€â–¶ Collect results â”‚ â”‚ â”‚ â”‚ â”‚ â””â”€â–¶ Return BatchResultContainer â”‚ â”‚ â”‚ â”œâ”€â–¶ Compute fitness metrics: â”‚ â”‚ â”‚ â”‚ â”‚ â”œâ”€â–¶ Settling time (2% threshold) â”‚ â”‚ â”œâ”€â–¶ Overshoot (peak deviation) â”‚ â”‚ â”œâ”€â–¶ ISE (Integral Squared Error) â”‚ â”‚ â””â”€â–¶ Control effort (sum |u|) â”‚ â”‚ â”‚ â””â”€â–¶ Store fitness[p] = combined_cost â”‚ â””â”€â–¶ PSO iteration: Update velocities and positions â”‚ â”œâ”€â–¶ Convergence check (EnhancedConvergenceAnalyzer) â”‚ â”‚ â”‚ â”œâ”€â–¶ Population diversity &lt; threshold â”‚ â”œâ”€â–¶ Fitness stagnation &gt; N iterations â”‚ â””â”€â–¶ Velocity convergence &lt; threshold â”‚ â””â”€â–¶ [Converged] â†’ Return optimal gains [Not converged] â†’ Continue PSO iteration
``` ### 1.5 Key Design Patterns #### 1.5.1 Protocol-Based Interfaces All major components define protocols for extensibility: ```python
# example-metadata:
# runnable: false from typing import Protocol class DynamicsModel(Protocol): &quot;&quot;&quot;Protocol for plant dynamics models.&quot;&quot;&quot; def compute_dynamics(self, state, control_input, time=0.0, **kwargs) -&gt; DynamicsResult: ... def get_physics_matrices(self, state) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]: ... def validate_state(self, state) -&gt; bool: ...
``` This allows:

- âœ… Duck-typed dynamics models (no inheritance required)
- âœ… Easy integration of custom dynamics
- âœ… Type checker validation (mypy, pyright) #### 1.5.2 Factory Pattern Integrator and orchestrator creation uses factory pattern: ```python
from src.simulation.integrators import IntegratorFactory integrator = IntegratorFactory.create_integrator(&#39;rk4&#39;, dt=0.01)
``` Benefits:
- âœ… Centralized integrator registry
- âœ… Consistent initialization
- âœ… Easy addition of new integrators
- âœ… Type safety and validation #### 1.5.3 Strategy Pattern Execution strategies encapsulated in orchestrators: ```python
# Sequential execution
seq_orchestrator = SequentialOrchestrator(dynamics, integrator)
result = seq_orchestrator.execute(initial_state, controls, dt, horizon) # Batch execution
batch_orchestrator = BatchOrchestrator(dynamics, integrator)
result = batch_orchestrator.execute(batch_initial_states, controls, dt, horizon)
``` Advantages:

- âœ… Swappable execution strategies
- âœ… Common interface for all orchestrators
- âœ… Performance optimization per strategy ### 1.6 Backward Compatibility **Legacy Interface Support:** The simulation engine maintains 100% backward compatibility with the original `simulation_runner.py`: ```python
# example-metadata:

# runnable: false # Legacy imports work unchanged

from src.simulation import run_simulation, step, get_step_fn, simulate # Original function signatures preserved
t, x, u = run_simulation(controller=..., dynamics_model=..., sim_time=5.0, dt=0.01, ...) # Legacy step function
x_next = step(x_current, u_current, dt)
``` **Migration Path:** New code can use modern orchestrator interface: ```python
from src.simulation import SequentialOrchestrator, IntegratorFactory # Modern interface
orchestrator = SequentialOrchestrator(dynamics, integrator)
result = orchestrator.execute(initial_state, controls, dt, horizon)
``` Both interfaces coexist seamlessly for gradual migration. ### 1.7 Performance Characteristics | Execution Strategy | Single Sim | Batch (10x) | Batch (100x) | Use Case |

|-------------------|------------|-------------|--------------|----------|
| Sequential | Baseline | 9.8x slower | 98x slower | Single trajectory, debugging |
| Batch | N/A | Baseline | 9.5x faster | PSO optimization, Monte Carlo |
| Parallel (4 cores) | N/A | 3.2x faster | 24x faster | Large parameter sweeps |
| Real-Time | Baseline | N/A | N/A | Hardware-in-loop, real systems | **Memory Footprint:**
- Sequential: ~5 MB per 10s simulation (6 states, 1000 steps)
- Batch (10x): ~50 MB (scales linearly)
- Batch (100x): ~500 MB (requires sufficient RAM) **Optimization Notes:**
- Use `BatchOrchestrator` for PSO fitness evaluation (10-30x speedup)
- Use `ForwardEuler` for fast prototyping (5x faster than RK4)
- Use `DormandPrince45` for high-accuracy requirements (adaptive step size)
- use `ParallelOrchestrator` for large-scale parameter studies

---

## 2. Core Simulation Engine API ### 2.1 `run_simulation()` Function **File:** `src/simulation/engines/simulation_runner.py:109` The main simulation function providing backward-compatible interface for controller-dynamics integration. #### 2.1.1 Function Signature ```python

# example-metadata:

# runnable: false def run_simulation( *, controller: Any, dynamics_model: Any, sim_time: float, dt: float, initial_state: Any, u_max: Optional[float] = None, seed: Optional[int] = None, rng: Optional[np.random.Generator] = None, latency_margin: Optional[float] = None, fallback_controller: Optional[Callable[[float, np.ndarray], float]] = None, **_kwargs: Any,

) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]: &quot;&quot;&quot;Simulate a single controller trajectory using explicit Euler method.&quot;&quot;&quot;
``` #### 2.1.2 Parameters | Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `controller` | Any | âœ… Yes | - | Controller object with `__call__(t, x)` or `compute_control(x, state, hist)` |
| `dynamics_model` | Any | âœ… Yes | - | Dynamics object with `step(state, u, dt)` method |
| `sim_time` | float | âœ… Yes | - | Total simulation time horizon (seconds) |
| `dt` | float | âœ… Yes | - | Integration timestep (seconds), must be &gt; 0 |
| `initial_state` | array-like | âœ… Yes | - | Initial state vector (flattened to 1D) |
| `u_max` | float | âŒ No | None | Control saturation limit; if None, uses `controller.max_force` |
| `seed` | int | âŒ No | None | (Deprecated) Random seed; use `rng` instead |
| `rng` | np.random.Generator | âŒ No | None | Random number generator for stochastic controllers |
| `latency_margin` | float | âŒ No | None | (Unused) Reserved for future latency control |
| `fallback_controller` | Callable | âŒ No | None | Fallback controller invoked after deadline miss |
| `**_kwargs` | dict | âŒ No | - | Additional kwargs ignored (backward compatibility) | #### 2.1.3 Return Values ```python
Tuple[np.ndarray, np.ndarray, np.ndarray] t_arr : np.ndarray # Time vector (n_steps+1,) x_arr : np.ndarray # State trajectory (n_steps+1, state_dim) u_arr : np.ndarray # Control sequence (n_steps,)
``` **Notes:**

- If simulation fails or is truncated, arrays are trimmed to valid length
- `t_arr[0] = 0.0`, `t_arr[-1] = n_steps * dt` where `n_steps = int(round(sim_time / dt))`
- `x_arr[0]` contains `initial_state`, `x_arr[i+1]` contains state after step `i`
- `u_arr[i]` contains control applied at step `i` #### 2.1.4 Controller Interface Requirements Controllers must implement **one** of these interfaces: **Option 1: Callable Interface**
```python
class MyController: def __call__(self, t: float, x: np.ndarray) -&gt; float: &quot;&quot;&quot;Compute control given time and state.&quot;&quot;&quot; return control_value
``` **Option 2: compute_control Interface** (Preferred for stateful controllers)

```python
class StatefulController: def compute_control(self, x: np.ndarray, state_vars: Any, history: Any): &quot;&quot;&quot;Compute control with state tracking.&quot;&quot;&quot; return control_value, updated_state, updated_history
``` **Optional Hooks:**

```python
def initialize_state(self) -&gt; Any: &quot;&quot;&quot;Initialize internal state variables (called once at start).&quot;&quot;&quot; return initial_state_vars def initialize_history(self) -&gt; Any: &quot;&quot;&quot;Initialize history buffer (called once at start).&quot;&quot;&quot; return initial_history
``` #### 2.1.5 Dynamics Model Interface Requirements Dynamics models must provide: ```python

class MyDynamics: def step(self, state: np.ndarray, u: float, dt: float) -&gt; np.ndarray: &quot;&quot;&quot;Integrate dynamics forward one timestep.&quot;&quot;&quot; return next_state
``` **Contract:**
- Input: `state` (n-dimensional), `u` (scalar or 1D array), `dt` (float)
- Output: `next_state` (n-dimensional, same shape as input state)
- Must handle exceptions gracefully (return NaN/Inf triggers truncation) #### 2.1.6 Control Saturation Logic ```python
# example-metadata:
# runnable: false # Priority hierarchy:
# 1. Explicit u_max parameter
if u_max is not None: u_limit = float(u_max)
# 2. Controller&#39;s max_force attribute
elif hasattr(controller, &#39;max_force&#39;): u_limit = float(controller.max_force)
# 3. No saturation
else: u_limit = None # Apply saturation
if u_limit is not None: u = np.clip(u, -u_limit, u_limit)
``` #### 2.1.7 Latency Monitoring and Fallback **Behavior:**

- Measures control computation time using `time.perf_counter()`
- If computation time exceeds `dt` on any step: - Engages `fallback_controller` for all subsequent steps - Logs latency violation (if logging enabled) **Example Use Case:**
```python
# example-metadata:
# runnable: false # Simple PD fallback controller
def pd_fallback(t, x): return -10 * x[0] - 5 * x[3] # -Kp*x - Kd*x_dot t, x, u = run_simulation( controller=complex_mpc_controller, dynamics_model=dynamics, sim_time=5.0, dt=0.01, initial_state=x0, fallback_controller=pd_fallback # Engage if MPC exceeds 10ms
)
``` #### 2.1.8 Early Termination Conditions Simulation terminates early if: 1. **Control computation fails:** ```python try: u = controller(t, x) except Exception: # Truncate and return ``` 2. **Dynamics propagation fails:** ```python try: x_next = dynamics.step(x, u, dt) except Exception: # Truncate and return ``` 3. **Invalid state detected:** ```python if not np.all(np.isfinite(x_next)): # Truncate and return (NaN or Inf detected) ``` **Truncated Return Behavior:**

- Arrays trimmed to last valid step
- `t_arr` length: `i+1` (0 to current step)
- `x_arr` length: `i+1` (includes current state)
- `u_arr` length: `i` (excludes failed control) #### 2.1.9 Memory Optimization **Key Optimization (Line 202, 249, 309):**
```python
# MEMORY OPTIMIZATION: asarray creates view when input is already ndarray
x0 = np.asarray(initial_state, dtype=float).reshape(-1) # View, not copy
x_curr = x0 # View, immediately overwritten at line 323
x_next = np.asarray(x_next, dtype=float).reshape(-1) # View when possible
``` **Impact:**

- Eliminates ~423 unnecessary array copies in typical 5s simulation
- Reduces memory allocations by 30-40%
- No performance degradation (validated by benchmarks) **Safety:**
- Guaranteed safe because: - `x_curr` immediately overwritten before first use - `x_next` from dynamics is copied into `x_arr` before view reassignment #### 2.1.10 Complete Usage Example ```python
from src.simulation import run_simulation
from src.controllers import create_controller
from src.plant.models import LowRankDIPDynamics
from src.config import load_config # Load configuration
config = load_config(&#39;config.yaml&#39;) # Create controller
controller = create_controller( &#39;classical_smc&#39;, config=config, gains=[10.0, 8.0, 15.0, 12.0, 50.0, 5.0]
) # Create dynamics model
dynamics = LowRankDIPDynamics(config.plant) # Run simulation
t, x, u = run_simulation( controller=controller, dynamics_model=dynamics, sim_time=5.0, dt=0.01, initial_state=[0, 0.1, 0.1, 0, 0, 0], # Small perturbation u_max=100.0, # Saturation limit seed=42 # Reproducibility
) # Analyze results
print(f&quot;Simulation steps: {len(t)-1}&quot;)
print(f&quot;Final state: {x[-1]}&quot;)
print(f&quot;Max control: {np.max(np.abs(u)):.2f} N&quot;)
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="simulationrunner-class-file-src-simulation-engines-simulation-runner-py-333-object-oriented-wrapper-around-run-simulation-providing-state-tracking-and-compatibility-with-test-cases-2-2-1-class-definition-python">
<h2>2.2 <code class="docutils literal notranslate"><span class="pre">SimulationRunner</span></code> Class <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/engines/simulation_runner.py:333</span></code> Object-oriented wrapper around <code class="docutils literal notranslate"><span class="pre">run_simulation()</span></code> providing state tracking and compatibility with test cases. #### 2.2.1 Class Definition ```python<a class="headerlink" href="#simulationrunner-class-file-src-simulation-engines-simulation-runner-py-333-object-oriented-wrapper-around-run-simulation-providing-state-tracking-and-compatibility-with-test-cases-2-2-1-class-definition-python" title="Link to this heading">Â¶</a></h2>
<p>class SimulationRunner: â€œâ€â€Object-oriented wrapper around run_simulation function.â€â€â€ def <strong>init</strong>(self, dynamics_model: Any, dt: float = 0.01, max_time: float = 10.0): â€œâ€â€Initialize simulation runner.â€â€â€</p>
<div class="highlight-#### notranslate"><div class="highlight"><pre><span></span>
|-----------|------|---------|-------------|
| `dynamics_model` | Any | required | Object with `step(state, u, dt)` method |
| `dt` | float | 0.01 | Integration timestep (seconds) |
| `max_time` | float | 10.0 | Maximum simulation time (seconds) | #### 2.2.3 Attributes ```python
self.dynamics_model: Any # Dynamics model instance
self.dt: float # Integration timestep
self.max_time: float # Maximum simulation time
self.current_time: float # Current simulation time (updated after run)
self.step_count: int # Number of steps executed (updated after run)
self.simulation_history: List[dict] # History of all simulation runs
``` #### 2.2.4 `run_simulation()` Method ```python
def run_simulation( self, initial_state: np.ndarray, controller: Optional[Any] = None, reference: Optional[np.ndarray] = None, **kwargs: Any
) -&gt; dict[str, Any]: &quot;&quot;&quot;Run simulation using functional API.&quot;&quot;&quot;
``` **Returns:**

```python
{ &#39;success&#39;: bool, # Whether simulation completed without error &#39;states&#39;: np.ndarray, # State trajectory (n_steps+1, state_dim) &#39;controls&#39;: np.ndarray, # Control sequence (n_steps,) &#39;time&#39;: np.ndarray, # Time vector (n_steps+1,) &#39;final_state&#39;: np.ndarray, # Final state (state_dim,) &#39;step_count&#39;: int, # Number of steps executed &#39;error&#39;: str # Error message (only if success=False)
}
``` #### 2.2.5 Usage Example ```python

from src.simulation import SimulationRunner
from src.plant.models import LowRankDIPDynamics # Create runner
dynamics = LowRankDIPDynamics(config.plant)
runner = SimulationRunner(dynamics, dt=0.01, max_time=10.0) # Run simulation
result = runner.run_simulation( initial_state=np.array([0, 0.1, 0.1, 0, 0, 0]), controller=controller, sim_time=5.0
) # Check result
if result[&#39;success&#39;]: print(f&quot;Simulation completed: {result[&#39;step_count&#39;]} steps&quot;) print(f&quot;Final state: {result[&#39;final_state&#39;]}&quot;)
else: print(f&quot;Simulation failed: {result[&#39;error&#39;]}&quot;) # Access history
for i, run in enumerate(runner.simulation_history): print(f&quot;Run {i}: {run[&#39;time&#39;].shape[0]} steps&quot;)
</pre></div>
</div>
<hr class="docutils" />
<section id="legacy-compatibility-functions-2-3-1-step-function-file-src-simulation-engines-simulation-runner-py-87-python">
<h3>2.3 Legacy Compatibility Functions #### 2.3.1 <code class="docutils literal notranslate"><span class="pre">step()</span></code> Function <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/engines/simulation_runner.py:87</span></code> ```python<a class="headerlink" href="#legacy-compatibility-functions-2-3-1-step-function-file-src-simulation-engines-simulation-runner-py-87-python" title="Link to this heading">Â¶</a></h3>
<p>def step(x, u, dt): â€œâ€â€Unified simulation step entry point.â€â€â€</p>
<div class="highlight-Dispatches notranslate"><div class="highlight"><pre><span></span>
```python
from src.simulation import step # Single dynamics step
x_next = step(x_current, u_current, dt=0.01)
``` #### 2.3.2 `get_step_fn()` Function **File:** `src/simulation/engines/simulation_runner.py:75` ```python

def get_step_fn(): &quot;&quot;&quot;Return appropriate step function based on configuration.&quot;&quot;&quot;
``` Returns either `src.plant.models.dip_full.step` or `src.plant.models.dip_lowrank.step` based on `config.simulation.use_full_dynamics`. **Usage:**
```python

from src.simulation import get_step_fn # Get configured step function
step_fn = get_step_fn()
x_next = step_fn(x, u, dt)
</pre></div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="dynamics-model-api-3-1-dynamicsmodel-protocol-file-src-plant-models-base-dynamics-interface-py-65-protocol-defining-the-interface-all-dynamics-models-must-implement-3-1-1-protocol-definition-python">
<h2>3. Dynamics Model API ### 3.1 <code class="docutils literal notranslate"><span class="pre">DynamicsModel</span></code> Protocol <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/plant/models/base/dynamics_interface.py:65</span></code> Protocol defining the interface all dynamics models must implement. #### 3.1.1 Protocol Definition ```python<a class="headerlink" href="#dynamics-model-api-3-1-dynamicsmodel-protocol-file-src-plant-models-base-dynamics-interface-py-65-protocol-defining-the-interface-all-dynamics-models-must-implement-3-1-1-protocol-definition-python" title="Link to this heading">Â¶</a></h2>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="example-metadata">
<h1>example-metadata:<a class="headerlink" href="#example-metadata" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-class-dynamicsmodel-protocol-protocol-for-plant-dynamics-models-def-compute-dynamics-self-state-np-ndarray-control-input-np-ndarray-time-float-0-0-kwargs-any-dynamicsresult-compute-system-dynamics-at-given-state-and-input-def-get-physics-matrices-self-state-np-ndarray-tuple-np-ndarray-np-ndarray-np-ndarray-get-physics-matrices-m-c-g-at-current-state-def-validate-state-self-state-np-ndarray-bool-validate-state-vector-format-and-bounds-def-get-state-dimension-self-int-get-dimension-of-state-vector-def-get-control-dimension-self-int-get-dimension-of-control-input-vector">
<h1>runnable: false class DynamicsModel(Protocol): â€œâ€â€Protocol for plant dynamics models.â€â€â€ def compute_dynamics( self, state: np.ndarray, control_input: np.ndarray, time: float = 0.0, **kwargs: Any ) -&gt; DynamicsResult: â€œâ€â€Compute system dynamics at given state and input.â€â€â€ â€¦ def get_physics_matrices( self, state: np.ndarray ) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]: â€œâ€â€Get physics matrices M, C, G at current state.â€â€â€ â€¦ def validate_state(self, state: np.ndarray) -&gt; bool: â€œâ€â€Validate state vector format and bounds.â€â€â€ â€¦ def get_state_dimension(self) -&gt; int: â€œâ€â€Get dimension of state vector.â€â€â€ â€¦ def get_control_dimension(self) -&gt; int: â€œâ€â€Get dimension of control input vector.â€â€â€ â€¦<a class="headerlink" href="#runnable-false-class-dynamicsmodel-protocol-protocol-for-plant-dynamics-models-def-compute-dynamics-self-state-np-ndarray-control-input-np-ndarray-time-float-0-0-kwargs-any-dynamicsresult-compute-system-dynamics-at-given-state-and-input-def-get-physics-matrices-self-state-np-ndarray-tuple-np-ndarray-np-ndarray-np-ndarray-get-physics-matrices-m-c-g-at-current-state-def-validate-state-self-state-np-ndarray-bool-validate-state-vector-format-and-bounds-def-get-state-dimension-self-int-get-dimension-of-state-vector-def-get-control-dimension-self-int-get-dimension-of-control-input-vector" title="Link to this heading">Â¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">####</span> <span class="pre">3.1.2</span> <span class="pre">`DynamicsResult`</span> <span class="pre">NamedTuple</span></code>python</p>
<p>class DynamicsResult(NamedTuple): â€œâ€â€Result of dynamics computation.â€â€â€ state_derivative: np.ndarray # dx/dt vector success: bool # Whether computation succeeded info: Dict[str, Any] # Additional diagnostic information</p>
<div class="highlight-**Factory notranslate"><div class="highlight"><pre><span></span>```python
# example-metadata:

# runnable: false # Create successful result

result = DynamicsResult.success_result( state_derivative=dx_dt, time=t, energy=total_energy
) # Create failure result
result = DynamicsResult.failure_result( reason=&quot;Singular matrix detected&quot;, condition_number=1e15
)
</pre></div>
</div>
<hr class="docutils" />
<section id="basedynamicsmodel-abstract-class-file-src-plant-models-base-dynamics-interface-py-130-abstract-base-class-providing-common-functionality-for-concrete-dynamics-implementations-3-2-1-class-definition-python">
<h2>3.2 <code class="docutils literal notranslate"><span class="pre">BaseDynamicsModel</span></code> Abstract Class <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/plant/models/base/dynamics_interface.py:130</span></code> Abstract base class providing common functionality for concrete dynamics implementations. #### 3.2.1 Class Definition ```python<a class="headerlink" href="#basedynamicsmodel-abstract-class-file-src-plant-models-base-dynamics-interface-py-130-abstract-base-class-providing-common-functionality-for-concrete-dynamics-implementations-3-2-1-class-definition-python" title="Link to this heading">Â¶</a></h2>
<p>class BaseDynamicsModel(ABC): â€œâ€â€Abstract base class for dynamics models.â€â€â€ def <strong>init</strong>(self, parameters: Any): â€œâ€â€Initialize dynamics model.â€â€â€ self.parameters = parameters self._setup_validation() self._setup_monitoring()
<code class="docutils literal notranslate"><span class="pre">####</span> <span class="pre">3.2.2</span> <span class="pre">Abstract</span> <span class="pre">Methods</span> <span class="pre">(Must</span> <span class="pre">Implement)</span></code>python</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1>example-metadata:<a class="headerlink" href="#id1" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-abstractmethod">
<h1>runnable: false &#64;abstractmethod<a class="headerlink" href="#runnable-false-abstractmethod" title="Link to this heading">Â¶</a></h1>
<p>def compute_dynamics( self, state: np.ndarray, control_input: np.ndarray, time: float = 0.0, **kwargs: Any
) -&gt; DynamicsResult: â€œâ€â€Compute system dynamics (must be implemented by subclasses).â€â€â€ pass &#64;abstractmethod
def get_physics_matrices( self, state: np.ndarray
) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]: â€œâ€â€Get physics matrices (must be implemented by subclasses).â€â€â€ pass &#64;abstractmethod
def _setup_validation(self) -&gt; None: â€œâ€â€Setup state validation (must be implemented by subclasses).â€â€â€ pass</p>
<div class="highlight-#### notranslate"><div class="highlight"><pre><span></span>```python
# example-metadata:

# runnable: false def validate_state(self, state: np.ndarray) -&gt; bool: &quot;&quot;&quot;Validate state vector using configured validator.&quot;&quot;&quot; if hasattr(self, &#39;_state_validator&#39;): return self._state_validator.validate_state(state) return self._basic_state_validation(state) def sanitize_state(self, state: np.ndarray) -&gt; np.ndarray: &quot;&quot;&quot;Sanitize state vector if validator supports it.&quot;&quot;&quot; if hasattr(self, &#39;_state_validator&#39;): return self._state_validator.sanitize_state(state) return state

``` **Dimension Accessors:**
```python

def get_state_dimension(self) -&gt; int: &quot;&quot;&quot;Get state vector dimension (default: 6 for DIP).&quot;&quot;&quot; return 6 def get_control_dimension(self) -&gt; int: &quot;&quot;&quot;Get control input dimension (default: 1 for DIP).&quot;&quot;&quot; return 1
``` **Monitoring:**
```python
# example-metadata:

# runnable: false def reset_monitoring(self) -&gt; None: &quot;&quot;&quot;Reset monitoring statistics.&quot;&quot;&quot; if hasattr(self, &#39;_stability_monitor&#39;): self._stability_monitor.reset_statistics() def get_monitoring_stats(self) -&gt; Dict[str, Any]: &quot;&quot;&quot;Get monitoring statistics.&quot;&quot;&quot; stats = {} if hasattr(self, &#39;_stability_monitor&#39;): stats[&#39;numerical_stability&#39;] = self._stability_monitor.get_statistics() return stats

</pre></div>
</div>
<hr class="docutils" />
<section id="lowrankdipdynamics-implementation-file-src-plant-models-lowrank-dynamics-py-27-simplified-double-inverted-pendulum-dynamics-optimized-for-computational-efficiency-3-3-1-class-definition-python">
<h2>3.3 <code class="docutils literal notranslate"><span class="pre">LowRankDIPDynamics</span></code> Implementation <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/plant/models/lowrank/dynamics.py:27</span></code> Simplified double-inverted pendulum dynamics optimized for computational efficiency. #### 3.3.1 Class Definition ```python<a class="headerlink" href="#lowrankdipdynamics-implementation-file-src-plant-models-lowrank-dynamics-py-27-simplified-double-inverted-pendulum-dynamics-optimized-for-computational-efficiency-3-3-1-class-definition-python" title="Link to this heading">Â¶</a></h2>
<p>class LowRankDIPDynamics(BaseDynamicsModel): â€œâ€â€Low-rank Double Inverted Pendulum Dynamics Model.â€â€â€ def <strong>init</strong>( self, config: Union[LowRankDIPConfig, Dict[str, Any]], enable_monitoring: bool = False, enable_validation: bool = True ): â€œâ€â€Initialize low-rank DIP dynamics.â€â€â€</p>
<div class="highlight-#### notranslate"><div class="highlight"><pre><span></span>
- âœ… **Essential dynamics preservation** (qualitatively similar to full model)
- âœ… **Optional linearization** for stability analysis
- âœ… **Small-angle approximations** for efficiency
- âœ… **Educational clarity** with simplified physics #### 3.3.3 Configuration ```python
from src.plant.models.lowrank import LowRankDIPConfig, LowRankDIPDynamics # Create default configuration
config = LowRankDIPConfig.create_default() # Or load from dictionary
config = LowRankDIPConfig.from_dict({ &#39;cart_mass&#39;: 1.0, &#39;pole1_mass&#39;: 0.1, &#39;pole2_mass&#39;: 0.1, &#39;pole1_length&#39;: 0.5, &#39;pole2_length&#39;: 0.5, &#39;gravity&#39;: 9.81, &#39;damping_cart&#39;: 0.01, &#39;damping_pole1&#39;: 0.001, &#39;damping_pole2&#39;: 0.001
}) # Initialize dynamics
dynamics = LowRankDIPDynamics( config=config, enable_monitoring=True, # Track performance statistics enable_validation=True # state validation
)
``` #### 3.3.4 Physics Computation **State Vector:**
</pre></div>
</div>
<p>x = [x, Î¸â‚, Î¸â‚‚, áº‹, Î¸Ì‡â‚, Î¸Ì‡â‚‚]áµ€ where: x - cart position Î¸â‚ - pole 1 angle (from vertical) Î¸â‚‚ - pole 2 angle (from vertical) áº‹ - cart velocity Î¸Ì‡â‚ - pole 1 angular velocity Î¸Ì‡â‚‚ - pole 2 angular velocity
<code class="docutils literal notranslate"><span class="pre">**Dynamics</span> <span class="pre">Equations</span> <span class="pre">(Low-Rank</span> <span class="pre">Approximation):**</span> <span class="pre">The</span> <span class="pre">low-rank</span> <span class="pre">model</span> <span class="pre">simplifies</span> <span class="pre">the</span> <span class="pre">full</span> <span class="pre">nonlinear</span> <span class="pre">dynamics</span> <span class="pre">using</span> <span class="pre">small-angle</span> <span class="pre">approximations:</span></code>
sin(Î¸áµ¢) â‰ˆ Î¸áµ¢
cos(Î¸áµ¢) â‰ˆ 1
<code class="docutils literal notranslate"><span class="pre">This</span> <span class="pre">yields</span> <span class="pre">linearized</span> <span class="pre">equations</span> <span class="pre">of</span> <span class="pre">motion</span> <span class="pre">suitable</span> <span class="pre">for</span> <span class="pre">fast</span> <span class="pre">computation:</span></code></p>
<p>M(x) qÌˆ = -C(x, áº‹) áº‹ - G(x) + Bu where: M = Simplified mass matrix (3x3) C = Simplified Coriolis/damping matrix G = Simplified gravity vector B = Input matrix [1, 0, 0]áµ€ u = Control force
<code class="docutils literal notranslate"><span class="pre">####</span> <span class="pre">3.3.5</span> <span class="pre">Method:</span> <span class="pre">`compute_dynamics()`</span></code>python
def compute_dynamics( self, state: np.ndarray, control_input: np.ndarray, time: float = 0.0, **kwargs: Any
) -&gt; DynamicsResult: â€œâ€â€Compute low-rank DIP dynamics.â€â€â€</p>
<div class="highlight-**Returns notranslate"><div class="highlight"><pre><span></span>
- `state_derivative`: 6-dimensional dx/dt vector
- `success`: True if computation succeeded
- `info`: Dictionary with diagnostics (energy, conditioning, etc.) #### 3.3.6 Method: `get_physics_matrices()` ```python
def get_physics_matrices( self, state: np.ndarray
) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]: &quot;&quot;&quot;Get simplified physics matrices M, C, G.&quot;&quot;&quot;
``` **Returns:**
- `M`: Mass/inertia matrix (3x3)
- `C`: Coriolis/damping matrix (3x3)
- `G`: Gravity vector (3,)

---

### 3.4 `LinearDynamicsModel` Base Class **File:** `src/plant/models/base/dynamics_interface.py:252` Base class for linear system dynamics: `áº‹ = Ax + Bu + f(t)` #### 3.4.1 Class Definition ```python
class LinearDynamicsModel(BaseDynamicsModel): &quot;&quot;&quot;Base class for linear dynamics models.&quot;&quot;&quot; def __init__(self, A: np.ndarray, B: np.ndarray, parameters: Any): &quot;&quot;&quot;Initialize linear dynamics model.&quot;&quot;&quot; super().__init__(parameters) self.A = A # System matrix self.B = B # Input matrix self._validate_matrices()
``` #### 3.4.2 Linear Dynamics Computation ```python
# example-metadata:

# runnable: false def compute_dynamics( self, state: np.ndarray, control_input: np.ndarray, time: float = 0.0, **kwargs: Any

) -&gt; DynamicsResult: &quot;&quot;&quot;Compute linear dynamics: áº‹ = Ax + Bu&quot;&quot;&quot; state_derivative = self.A @ state + self.B @ control_input # Optional time-varying disturbance if hasattr(self, &#39;_compute_time_varying_terms&#39;): disturbance = self._compute_time_varying_terms(time, state) state_derivative += disturbance return DynamicsResult.success_result(state_derivative, time=time)
``` #### 3.4.3 Usage Example ```python
import numpy as np
from src.plant.models.base import LinearDynamicsModel # Define linearized DIP system
A = np.array([ [0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1], [0, 14.7, 14.7, -0.1, 0, 0], [0, -29.4, 14.7, 0, -0.01, 0], [0, 14.7, -44.1, 0, 0, -0.01]
]) B = np.array([[0], [0], [0], [1], [0], [0]]) # Create linear dynamics
linear_dynamics = LinearDynamicsModel(A, B, parameters=config.plant) # Use with simulation
t, x, u = run_simulation( controller=linear_controller, dynamics_model=linear_dynamics, sim_time=5.0, dt=0.01, initial_state=[0, 0.1, 0.1, 0, 0, 0]
)
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="orchestrator-system-api-4-1-orchestrator-base-interface-file-src-simulation-core-interfaces-py-85-base-interface-defining-execution-strategy-protocol-python">
<h2>4. Orchestrator System API ### 4.1 <code class="docutils literal notranslate"><span class="pre">Orchestrator</span></code> Base Interface <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/core/interfaces.py:85</span></code> Base interface defining execution strategy protocol. ```python<a class="headerlink" href="#orchestrator-system-api-4-1-orchestrator-base-interface-file-src-simulation-core-interfaces-py-85-base-interface-defining-execution-strategy-protocol-python" title="Link to this heading">Â¶</a></h2>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id2">
<h1>example-metadata:<a class="headerlink" href="#id2" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-class-orchestrator-abc-base-interface-for-simulation-execution-strategies-abstractmethod-def-execute-self-initial-state-np-ndarray-control-inputs-np-ndarray-dt-float-horizon-int-kwargs-resultcontainer-execute-simulation-with-specified-strategy-pass">
<h1>runnable: false class Orchestrator(ABC): â€œâ€â€Base interface for simulation execution strategies.â€â€â€ &#64;abstractmethod def execute( self, initial_state: np.ndarray, control_inputs: np.ndarray, dt: float, horizon: int, **kwargs ) -&gt; ResultContainer: â€œâ€â€Execute simulation with specified strategy.â€â€â€ pass<a class="headerlink" href="#runnable-false-class-orchestrator-abc-base-interface-for-simulation-execution-strategies-abstractmethod-def-execute-self-initial-state-np-ndarray-control-inputs-np-ndarray-dt-float-horizon-int-kwargs-resultcontainer-execute-simulation-with-specified-strategy-pass" title="Link to this heading">Â¶</a></h1>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
---

## 4.2 `SequentialOrchestrator` **File:** `src/simulation/orchestrators/sequential.py:18` Single-threaded step-by-step execution for standard simulations. #### 4.2.1 Class Definition ```python
# example-metadata:
# runnable: false class SequentialOrchestrator(BaseOrchestrator): &quot;&quot;&quot;Sequential simulation orchestrator for single-threaded execution.&quot;&quot;&quot; def execute( self, initial_state: np.ndarray, control_inputs: np.ndarray, dt: float, horizon: int, **kwargs ) -&gt; ResultContainer: &quot;&quot;&quot;Execute sequential simulation.&quot;&quot;&quot;
``` #### 4.2.2 Parameters | Parameter | Type | Shape | Description |

|-----------|------|-------|-------------|
| `initial_state` | np.ndarray | (n,) | Initial state vector |
| `control_inputs` | np.ndarray | (horizon,) or (horizon, m) | Control sequence |
| `dt` | float | scalar | Time step |
| `horizon` | int | scalar | Number of simulation steps |
| `**kwargs` | dict | - | Additional options | **Optional Kwargs:**
- `safety_guards` (bool): safety checking (default: True)
- `stop_fn` (Callable): Custom stop condition function
- `t0` (float): Initial time (default: 0.0) #### 4.2.3 Features - âœ… **Step-by-step execution** with full state tracking
- âœ… **Safety guard integration** (NaN/Inf detection)
- âœ… **Early termination** on stop condition
- âœ… **Trajectory truncation** on failure
- âœ… **Compatible with all integrators** #### 4.2.4 Usage Example ```python
from src.simulation.orchestrators import SequentialOrchestrator
from src.simulation.integrators import IntegratorFactory # Create orchestrator
integrator = IntegratorFactory.create_integrator(&#39;rk4&#39;, dt=0.01)
orchestrator = SequentialOrchestrator(dynamics, integrator) # Execute simulation
initial_state = np.array([0, 0.1, 0.1, 0, 0, 0])
controls = controller_sequence # (horizon,) array
result = orchestrator.execute( initial_state=initial_state, control_inputs=controls, dt=0.01, horizon=500, safety_guards=True
) # Access results
states = result.get_states() # (horizon+1, 6)
times = result.get_times() # (horizon+1,)
</pre></div>
</div>
<hr class="docutils" />
<section id="batchorchestrator-file-src-simulation-orchestrators-batch-py-18-vectorized-execution-for-multiple-simultaneous-simulations-pso-optimization-monte-carlo-4-3-1-class-definition-python">
<h2>4.3 <code class="docutils literal notranslate"><span class="pre">BatchOrchestrator</span></code> <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/orchestrators/batch.py:18</span></code> Vectorized execution for multiple simultaneous simulations (PSO optimization, Monte Carlo). #### 4.3.1 Class Definition ```python<a class="headerlink" href="#batchorchestrator-file-src-simulation-orchestrators-batch-py-18-vectorized-execution-for-multiple-simultaneous-simulations-pso-optimization-monte-carlo-4-3-1-class-definition-python" title="Link to this heading">Â¶</a></h2>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id3">
<h1>example-metadata:<a class="headerlink" href="#id3" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-class-batchorchestrator-baseorchestrator-batch-simulation-orchestrator-for-vectorized-execution-def-execute-self-initial-state-np-ndarray-control-inputs-np-ndarray-dt-float-horizon-int-kwargs-resultcontainer-execute-batch-simulation">
<h1>runnable: false class BatchOrchestrator(BaseOrchestrator): â€œâ€â€Batch simulation orchestrator for vectorized execution.â€â€â€ def execute( self, initial_state: np.ndarray, control_inputs: np.ndarray, dt: float, horizon: int, **kwargs ) -&gt; ResultContainer: â€œâ€â€Execute batch simulation.â€â€â€<a class="headerlink" href="#runnable-false-class-batchorchestrator-baseorchestrator-batch-simulation-orchestrator-for-vectorized-execution-def-execute-self-initial-state-np-ndarray-control-inputs-np-ndarray-dt-float-horizon-int-kwargs-resultcontainer-execute-batch-simulation" title="Link to this heading">Â¶</a></h1>
<div class="highlight-#### notranslate"><div class="highlight"><pre><span></span>
|-----------|------|-------|-------------|
| `initial_state` | np.ndarray | (n,) or (batch_size, n) | Initial states |
| `control_inputs` | np.ndarray | (horizon,) or (batch_size, horizon, m) | Control sequences |
| `dt` | float | scalar | Time step |
| `horizon` | int | scalar | Number of simulation steps |
| `**kwargs` | dict | - | Additional options | **Batch Size Handling:**
- If `initial_state.shape == (n,)`: Single simulation (batch_size=1)
- If `initial_state.shape == (B, n)`: Batch of B simulations #### 4.3.3 Features - âœ… **Vectorized execution** for multiple trajectories
- âœ… **Active mask management** (track which sims are active)
- âœ… **Per-trajectory safety guards**
- âœ… **Independent truncation** (failures don&#39;t affect other trajectories)
- âœ… **Batch result aggregation** in BatchResultContainer #### 4.3.4 Performance Characteristics | Batch Size | Speedup vs Sequential | Memory Overhead |
|------------|----------------------|-----------------|
| 10x | 9.5x faster | 10x memory |
| 100x | 95x faster | 100x memory |
| 1000x | 850x faster | 1000x memory (may require RAM upgrade) | **Optimal Batch Sizes:**
- PSO optimization: 20-50 particles
- Monte Carlo: 100-1000 trials
- Parameter sweeps: 100-500 combinations #### 4.3.5 Usage Example: PSO Optimization ```python
from src.simulation.orchestrators import BatchOrchestrator
from src.optimization import PSOTuner
import functools # Create batch orchestrator
orchestrator = BatchOrchestrator(dynamics, integrator) # Define fitness function using batch execution
def fitness_function(gains): # Create controller with candidate gains controller = create_controller(&#39;classical_smc&#39;, config, gains=gains) # Batch initial conditions (10 perturbations) batch_initial = np.random.randn(10, 6) * 0.1 # Generate control inputs controls = np.zeros((10, 500)) # (batch_size, horizon) for i in range(10): for t in range(500): controls[i, t] = controller(t * 0.01, batch_initial[i]) # Batch execution result = orchestrator.execute( initial_state=batch_initial, control_inputs=controls, dt=0.01, horizon=500 ) # Compute fitness (aggregate over 10 trials) all_states = result.get_states() # (10, 501, 6) settling_times = compute_settling_times(all_states) return np.mean(settling_times) # Use with PSO
tuner = PSOTuner(fitness_fn=fitness_function, bounds=[(1,50)]*6)
result = tuner.optimise()
</pre></div>
</div>
<hr class="docutils" />
<section id="parallelorchestrator-file-src-simulation-orchestrators-parallel-py-multi-threaded-execution-for-large-scale-parameter-studies-4-4-1-features-thread-pool-management-configurable-pool-size">
<h2>4.4 <code class="docutils literal notranslate"><span class="pre">ParallelOrchestrator</span></code> <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/orchestrators/parallel.py</span></code> Multi-threaded execution for large-scale parameter studies. #### 4.4.1 Features - âœ… <strong>Thread pool management</strong> (configurable pool size)<a class="headerlink" href="#parallelorchestrator-file-src-simulation-orchestrators-parallel-py-multi-threaded-execution-for-large-scale-parameter-studies-4-4-1-features-thread-pool-management-configurable-pool-size" title="Link to this heading">Â¶</a></h2>
<ul class="simple">
<li><p>âœ… <strong>Result synchronization</strong> across threads</p></li>
<li><p>âœ… <strong>Load balancing</strong> for uneven workloads</p></li>
<li><p>âœ… <strong>Exception handling</strong> per thread #### 4.4.2 Usage Example ```python
from src.simulation.orchestrators import ParallelOrchestrator # Create parallel orchestrator (4 worker threads)
orchestrator = ParallelOrchestrator( dynamics=dynamics, integrator=integrator, num_workers=4
) # Execute parameter sweep
param_grid = generate_parameter_combinations() # (1000, n_params)
results = orchestrator.execute_parameter_sweep(param_grid)</p></li>
</ul>
<div class="highlight-**Note:** notranslate"><div class="highlight"><pre><span></span>
---

## 4.5 `RealTimeOrchestrator` **File:** `src/simulation/orchestrators/real_time.py` Real-time constraint enforcement for hardware-in-loop (HIL) applications. #### 4.5.1 Features - âœ… **Real-time timing** synchronized with wall clock

- âœ… **Deadline monitoring** with configurable tolerance
- âœ… **Late execution detection** and logging
- âœ… **Compatible with HIL interfaces** #### 4.5.2 Usage Example ```python
from src.simulation.orchestrators import RealTimeOrchestrator
from src.interfaces.hil import PlantServer # Create real-time orchestrator
orchestrator = RealTimeOrchestrator( dynamics=hardware_interface, integrator=integrator, real_time_factor=1.0, # Real-time (use 0.5 for slow-motion, 2.0 for fast) deadline_tolerance=0.001 # 1ms tolerance
) # Execute HIL simulation
result = orchestrator.execute( initial_state=x0, control_inputs=None, # Generated dynamically dt=0.01, horizon=1000, controller=controller
) # Check timing statistics
stats = orchestrator.get_timing_stats()
print(f&quot;Deadline misses: {stats[&#39;deadline_misses&#39;]}&quot;)
print(f&quot;Average execution time: {stats[&#39;mean_exec_time&#39;]:.3f}ms&quot;)
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="integrator-system-api-5-1-integratorfactory-file-src-simulation-integrators-factory-py-22-factory-pattern-for-creating-numerical-integrator-instances-with-validation-and-consistency-checking-5-1-1-integrator-registry-the-factory-maintains-a-registry-of-7-integrator-types-type-class-order-adaptive-description">
<h2>5. Integrator System API ### 5.1 <code class="docutils literal notranslate"><span class="pre">IntegratorFactory</span></code> <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/integrators/factory.py:22</span></code> Factory pattern for creating numerical integrator instances with validation and consistency checking. #### 5.1.1 Integrator Registry The factory maintains a registry of 7 integrator types: | Type | Class | Order | Adaptive | Description |<a class="headerlink" href="#integrator-system-api-5-1-integratorfactory-file-src-simulation-integrators-factory-py-22-factory-pattern-for-creating-numerical-integrator-instances-with-validation-and-consistency-checking-5-1-1-integrator-registry-the-factory-maintains-a-registry-of-7-integrator-types-type-class-order-adaptive-description" title="Link to this heading">Â¶</a></h2>
<p>|â€”â€”|â€”â€”-|â€”â€”-|â€”â€”â€”-|â€”â€”â€”â€”-|
| <code class="docutils literal notranslate"><span class="pre">'euler'</span></code> | ForwardEuler | 1st | No | Simple forward Euler |
| <code class="docutils literal notranslate"><span class="pre">'forward_euler'</span></code> | ForwardEuler | 1st | No | Alias for euler |
| <code class="docutils literal notranslate"><span class="pre">'backward_euler'</span></code> | BackwardEuler | 1st | No | Implicit backward Euler |
| <code class="docutils literal notranslate"><span class="pre">'rk2'</span></code> | RungeKutta2 | 2nd | No | Midpoint method |
| <code class="docutils literal notranslate"><span class="pre">'rk4'</span></code> | RungeKutta4 | 4th | No | Classic 4th-order RK |
| <code class="docutils literal notranslate"><span class="pre">'runge_kutta_4'</span></code> | RungeKutta4 | 4th | No | Alias for rk4 |
| <code class="docutils literal notranslate"><span class="pre">'adaptive_rk'</span></code> | AdaptiveRungeKutta | 4th/5th | Yes | Variable step size |
| <code class="docutils literal notranslate"><span class="pre">'dormand_prince'</span></code> | DormandPrince45 | 4th/5th | Yes | DP45 adaptive method |
| <code class="docutils literal notranslate"><span class="pre">'dp45'</span></code> | DormandPrince45 | 4th/5th | Yes | Alias for dormand_prince |
| <code class="docutils literal notranslate"><span class="pre">'zoh'</span></code> | ZeroOrderHold | 1st | No | Discrete-time control |
| <code class="docutils literal notranslate"><span class="pre">'zero_order_hold'</span></code> | ZeroOrderHold | 1st | No | Alias for zoh | #### 5.1.2 <code class="docutils literal notranslate"><span class="pre">create_integrator()</span></code> Method ```python
&#64;classmethod
def create_integrator( cls, integrator_type: str, dt: float = 0.01, **kwargs: Any
) -&gt; BaseIntegrator: â€œâ€â€Create integrator instance of specified type.â€â€â€</p>
<div class="highlight-**Parameters:** notranslate"><div class="highlight"><pre><span></span>
- `integrator_type` (str): Type identifier (case-insensitive, dash/space normalized)
- `dt` (float): Default integration timestep (stored as `integrator.default_dt`)
- `**kwargs`: Integrator-specific parameters **Returns:** Configured BaseIntegrator instance **Raises:** ValueError if integrator_type not recognized **Example:**
```python
from src.simulation.integrators import IntegratorFactory # Create RK4 integrator
rk4 = IntegratorFactory.create_integrator(&#39;rk4&#39;, dt=0.01) # Create adaptive integrator with error tolerances
dp45 = IntegratorFactory.create_integrator( &#39;dormand_prince&#39;, dt=0.01, atol=1e-6, rtol=1e-3
) # Use with orchestrator
from src.simulation.orchestrators import SequentialOrchestrator
orchestrator = SequentialOrchestrator(dynamics, rk4)
``` #### 5.1.3 Utility Methods **list_available_integrators()**

```python
# example-metadata:
# runnable: false IntegratorFactory.list_available_integrators()
# Returns: [&#39;euler&#39;, &#39;forward_euler&#39;, &#39;backward_euler&#39;, &#39;rk2&#39;, &#39;rk4&#39;, ...]
``` **get_integrator_info()**

```python
info = IntegratorFactory.get_integrator_info(&#39;rk4&#39;)
# Returns:
# {
# &#39;class_name&#39;: &#39;RungeKutta4&#39;,
# &#39;module&#39;: &#39;src.simulation.integrators.fixed_step.runge_kutta&#39;,
# &#39;order&#39;: 4,
# &#39;adaptive&#39;: False,
# &#39;description&#39;: &#39;Classic 4th-order Runge-Kutta method&#39;
# }
``` **register_integrator()** (Advanced)

```python
# example-metadata:
# runnable: false from src.simulation.integrators.base import BaseIntegrator class MyCustomIntegrator(BaseIntegrator): &quot;&quot;&quot;Custom integration method.&quot;&quot;&quot; ORDER = 3 ADAPTIVE = False # ... implement integrate() method ... # Register custom integrator
IntegratorFactory.register_integrator(&#39;my_custom&#39;, MyCustomIntegrator)
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="fixed-step-integrators-5-2-1-forwardeuler-file-src-simulation-integrators-fixed-step-euler-py-first-order-explicit-euler-method-x-n-1-x-n-dt-f-x-n-u-n-t-n-properties">
<h2>5.2 Fixed-Step Integrators #### 5.2.1 <code class="docutils literal notranslate"><span class="pre">ForwardEuler</span></code> <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/integrators/fixed_step/euler.py</span></code> First-order explicit Euler method: <code class="docutils literal notranslate"><span class="pre">x_{n+1}</span> <span class="pre">=</span> <span class="pre">x_n</span> <span class="pre">+</span> <span class="pre">dt</span> <span class="pre">*</span> <span class="pre">f(x_n,</span> <span class="pre">u_n,</span> <span class="pre">t_n)</span></code> <strong>Properties:</strong><a class="headerlink" href="#fixed-step-integrators-5-2-1-forwardeuler-file-src-simulation-integrators-fixed-step-euler-py-first-order-explicit-euler-method-x-n-1-x-n-dt-f-x-n-u-n-t-n-properties" title="Link to this heading">Â¶</a></h2>
<ul class="simple">
<li><p>Order: 1</p></li>
<li><p>Stability: Conditionally stable (small dt required)</p></li>
<li><p>Performance: Fastest (5x faster than RK4)</p></li>
<li><p>Accuracy: Low (O(dtÂ²) global error) <strong>Use Cases:</strong></p></li>
<li><p>Fast prototyping</p></li>
<li><p>Non-stiff systems with small dt</p></li>
<li><p>Real-time applications with tight timing constraints <strong>Example:</strong></p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">euler</span> <span class="o">=</span> <span class="n">IntegratorFactory</span><span class="o">.</span><span class="n">create_integrator</span><span class="p">(</span><span class="s1">&#39;euler&#39;</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span> <span class="c1"># Small dt for stability</span>
<span class="err">```</span> <span class="c1">#### 5.2.2 `RungeKutta2` **File:** `src/simulation/integrators/fixed_step/runge_kutta.py` Second-order midpoint method (improved Euler). **Properties:**</span>

<span class="o">-</span> <span class="n">Order</span><span class="p">:</span> <span class="mi">2</span>
<span class="o">-</span> <span class="n">Stability</span><span class="p">:</span> <span class="n">Better</span> <span class="n">than</span> <span class="n">Euler</span>
<span class="o">-</span> <span class="n">Performance</span><span class="p">:</span> <span class="mi">2</span><span class="n">x</span> <span class="n">slower</span> <span class="n">than</span> <span class="n">Euler</span>
<span class="o">-</span> <span class="n">Accuracy</span><span class="p">:</span> <span class="n">Moderate</span> <span class="p">(</span><span class="n">O</span><span class="p">(</span><span class="n">dt</span><span class="err">Â³</span><span class="p">)</span> <span class="k">global</span> <span class="n">error</span><span class="p">)</span> <span class="o">**</span><span class="n">Use</span> <span class="n">Cases</span><span class="p">:</span><span class="o">**</span>
<span class="o">-</span> <span class="n">Balance</span> <span class="n">between</span> <span class="n">speed</span> <span class="ow">and</span> <span class="n">accuracy</span>
<span class="o">-</span> <span class="n">Educational</span> <span class="n">demonstrations</span> <span class="c1">#### 5.2.3 `RungeKutta4` **File:** `src/simulation/integrators/fixed_step/runge_kutta.py` Classic 4th-order Runge-Kutta method (RK4) - **Recommended default**. **Properties:**</span>
<span class="o">-</span> <span class="n">Order</span><span class="p">:</span> <span class="mi">4</span>
<span class="o">-</span> <span class="n">Stability</span><span class="p">:</span> <span class="k">for</span> <span class="n">non</span><span class="o">-</span><span class="n">stiff</span> <span class="n">systems</span>
<span class="o">-</span> <span class="n">Performance</span><span class="p">:</span> <span class="n">Baseline</span> <span class="n">reference</span>
<span class="o">-</span> <span class="n">Accuracy</span><span class="p">:</span> <span class="n">High</span> <span class="p">(</span><span class="n">O</span><span class="p">(</span><span class="n">dt</span><span class="err">âµ</span><span class="p">)</span> <span class="k">global</span> <span class="n">error</span><span class="p">)</span> <span class="o">**</span><span class="n">Algorithm</span><span class="p">:</span><span class="o">**</span>
<span class="err">```</span><span class="n">python</span>
<span class="n">k1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x_n</span><span class="p">,</span> <span class="n">u_n</span><span class="p">,</span> <span class="n">t_n</span><span class="p">)</span>
<span class="n">k2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x_n</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k1</span><span class="p">,</span> <span class="n">u_n</span><span class="p">,</span> <span class="n">t_n</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="n">k3</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x_n</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k2</span><span class="p">,</span> <span class="n">u_n</span><span class="p">,</span> <span class="n">t_n</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="n">k4</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x_n</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">k3</span><span class="p">,</span> <span class="n">u_n</span><span class="p">,</span> <span class="n">t_n</span> <span class="o">+</span> <span class="n">dt</span><span class="p">)</span>
<span class="n">x_</span><span class="p">{</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">}</span> <span class="o">=</span> <span class="n">x_n</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mi">6</span> <span class="o">*</span> <span class="p">(</span><span class="n">k1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">k2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">k3</span> <span class="o">+</span> <span class="n">k4</span><span class="p">)</span>
<span class="err">```</span> <span class="o">**</span><span class="n">Use</span> <span class="n">Cases</span><span class="p">:</span><span class="o">**</span>

<span class="o">-</span> <span class="n">Standard</span> <span class="n">choice</span> <span class="k">for</span> <span class="n">most</span> <span class="n">simulations</span>
<span class="o">-</span> <span class="n">Good</span> <span class="n">accuracy</span> <span class="k">with</span> <span class="n">reasonable</span> <span class="n">performance</span>
<span class="o">-</span> <span class="n">DIP</span> <span class="n">control</span> <span class="n">system</span> <span class="n">simulations</span> <span class="p">(</span><span class="n">dt</span><span class="o">=</span><span class="mf">0.01</span><span class="n">s</span> <span class="n">typical</span><span class="p">)</span> <span class="o">**</span><span class="n">Example</span><span class="p">:</span><span class="o">**</span>
<span class="err">```</span><span class="n">python</span>
<span class="n">rk4</span> <span class="o">=</span> <span class="n">IntegratorFactory</span><span class="o">.</span><span class="n">create_integrator</span><span class="p">(</span><span class="s1">&#39;rk4&#39;</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
</pre></div>
</div>
<hr class="docutils" />
<section id="adaptive-integrators-5-3-1-dormandprince45-file-src-simulation-integrators-adaptive-runge-kutta-py-dormand-prince-4th-5th-order-adaptive-runge-kutta-method-dp45-recommended-for-high-accuracy-requirements-properties">
<h3>5.3 Adaptive Integrators #### 5.3.1 <code class="docutils literal notranslate"><span class="pre">DormandPrince45</span></code> <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/integrators/adaptive/runge_kutta.py</span></code> Dormand-Prince 4th/5th order adaptive Runge-Kutta method (DP45) - <strong>Recommended for high-accuracy requirements</strong>. <strong>Properties:</strong><a class="headerlink" href="#adaptive-integrators-5-3-1-dormandprince45-file-src-simulation-integrators-adaptive-runge-kutta-py-dormand-prince-4th-5th-order-adaptive-runge-kutta-method-dp45-recommended-for-high-accuracy-requirements-properties" title="Link to this heading">Â¶</a></h3>
<ul class="simple">
<li><p>Order: 4th-order accurate, 5th-order error estimate</p></li>
<li><p>Adaptive: Yes (automatic step size adjustment)</p></li>
<li><p>Performance: 2-5x slower than RK4 (depending on error tolerance)</p></li>
<li><p>Accuracy: (user-controlled via tolerances) <strong>Configuration:</strong></p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dp45</span> <span class="o">=</span> <span class="n">IntegratorFactory</span><span class="o">.</span><span class="n">create_integrator</span><span class="p">(</span> <span class="s1">&#39;dormand_prince&#39;</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="c1"># Initial step size atol=1e-6, # Absolute error tolerance rtol=1e-3, # Relative error tolerance min_step=1e-6, # Minimum allowed step size max_step=0.1, # Maximum allowed step size safety_factor=0.9 # Step size adjustment factor</span>
<span class="p">)</span>
<span class="err">```</span> <span class="o">**</span><span class="n">Error</span> <span class="n">Control</span><span class="p">:</span><span class="o">**</span>

<span class="o">-</span> <span class="n">Computes</span> <span class="n">error</span> <span class="n">estimate</span><span class="p">:</span> <span class="err">`</span><span class="n">err</span> <span class="o">=</span> <span class="o">||</span><span class="n">x_5</span> <span class="o">-</span> <span class="n">x_4</span><span class="o">||</span> <span class="o">/</span> <span class="p">(</span><span class="n">atol</span> <span class="o">+</span> <span class="n">rtol</span> <span class="o">*</span> <span class="o">||</span><span class="n">x</span><span class="o">||</span><span class="p">)</span><span class="err">`</span>
<span class="o">-</span> <span class="n">Accepts</span> <span class="n">step</span> <span class="k">if</span> <span class="err">`</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="err">`</span>
<span class="o">-</span> <span class="n">Adjusts</span> <span class="nb">next</span> <span class="n">step</span><span class="p">:</span> <span class="err">`</span><span class="n">dt_next</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">safety_factor</span> <span class="o">*</span> <span class="n">err</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="err">`</span> <span class="o">**</span><span class="n">Use</span> <span class="n">Cases</span><span class="p">:</span><span class="o">**</span>
<span class="o">-</span> <span class="n">High</span><span class="o">-</span><span class="n">accuracy</span> <span class="n">simulations</span>
<span class="o">-</span> <span class="n">Stiff</span> <span class="n">dynamics</span> <span class="p">(</span><span class="k">with</span> <span class="n">small</span> <span class="n">initial</span> <span class="n">dt</span><span class="p">)</span>
<span class="o">-</span> <span class="n">Variable</span> <span class="n">dynamics</span> <span class="p">(</span><span class="n">rapidly</span> <span class="n">changing</span> <span class="n">time</span> <span class="n">constants</span><span class="p">)</span>
<span class="o">-</span> <span class="n">Scientific</span> <span class="n">validation</span> <span class="ow">and</span> <span class="n">benchmarking</span> <span class="o">**</span><span class="n">Example</span><span class="p">:</span><span class="o">**</span>
<span class="err">```</span><span class="n">python</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.simulation.integrators</span><span class="w"> </span><span class="kn">import</span> <span class="n">IntegratorFactory</span> <span class="c1"># High-accuracy integration</span>
<span class="n">dp45</span> <span class="o">=</span> <span class="n">IntegratorFactory</span><span class="o">.</span><span class="n">create_integrator</span><span class="p">(</span> <span class="s1">&#39;dp45&#39;</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="c1"># Tight tolerance rtol=1e-6</span>
<span class="p">)</span> <span class="c1"># Use with orchestrator</span>
<span class="n">orchestrator</span> <span class="o">=</span> <span class="n">SequentialOrchestrator</span><span class="p">(</span><span class="n">dynamics</span><span class="p">,</span> <span class="n">dp45</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">orchestrator</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span> <span class="n">initial_state</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">control_inputs</span><span class="o">=</span><span class="n">controls</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="c1"># Initial dt (will adapt) horizon=1000</span>
<span class="p">)</span> <span class="c1"># Check integration statistics</span>
<span class="n">stats</span> <span class="o">=</span> <span class="n">dp45</span><span class="o">.</span><span class="n">get_statistics</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Accepted steps: </span><span class="si">{</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;accepted_steps&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Rejected steps: </span><span class="si">{</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;rejected_steps&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Average step size: </span><span class="si">{</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;mean_step_size&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
<span class="err">```</span> <span class="c1">#### 5.3.2 `AdaptiveRungeKutta` **File:** `src/simulation/integrators/adaptive/runge_kutta.py` Generic adaptive RK integrator with configurable Butcher tableau. **Use Cases:**</span>

<span class="o">-</span> <span class="n">Research</span> <span class="ow">and</span> <span class="n">experimentation</span> <span class="k">with</span> <span class="n">custom</span> <span class="n">RK</span> <span class="n">methods</span>
<span class="o">-</span> <span class="n">Implementing</span> <span class="n">specialized</span> <span class="n">adaptive</span> <span class="n">methods</span>

<span class="o">---</span>

<span class="c1">### 5.4 Discrete Integrators #### 5.4.1 `ZeroOrderHold` **File:** `src/simulation/integrators/discrete/zero_order_hold.py` Zero-order hold (ZOH) for discrete-time control systems. **Properties:**</span>

<span class="o">-</span> <span class="n">Order</span><span class="p">:</span> <span class="mi">1</span> <span class="p">(</span><span class="n">equivalent</span> <span class="n">to</span> <span class="n">Euler</span> <span class="k">with</span> <span class="n">ZOH</span> <span class="n">control</span><span class="p">)</span>
<span class="o">-</span> <span class="n">Discrete</span><span class="p">:</span> <span class="n">Control</span> <span class="n">held</span> <span class="n">constant</span> <span class="n">over</span> <span class="n">interval</span>
<span class="o">-</span> <span class="n">Performance</span><span class="p">:</span> <span class="n">Fast</span> <span class="p">(</span><span class="n">similar</span> <span class="n">to</span> <span class="n">Euler</span><span class="p">)</span> <span class="o">**</span><span class="n">Behavior</span><span class="p">:</span><span class="o">**</span>
<span class="err">```</span><span class="n">python</span>
<span class="n">u_held</span> <span class="o">=</span> <span class="n">u_n</span> <span class="c1"># Control held constant</span>
<span class="n">x_</span><span class="p">{</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">}</span> <span class="o">=</span> <span class="n">x_n</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">x_n</span><span class="p">,</span> <span class="n">u_held</span><span class="p">,</span> <span class="n">t_n</span><span class="p">)</span> <span class="c1"># Euler step with held control</span>
<span class="err">```</span> <span class="o">**</span><span class="n">Use</span> <span class="n">Cases</span><span class="p">:</span><span class="o">**</span>

<span class="o">-</span> <span class="n">Discrete</span><span class="o">-</span><span class="n">time</span> <span class="n">controller</span> <span class="n">testing</span>
<span class="o">-</span> <span class="n">Sampled</span><span class="o">-</span><span class="n">data</span> <span class="n">systems</span>
<span class="o">-</span> <span class="n">Hardware</span><span class="o">-</span><span class="ow">in</span><span class="o">-</span><span class="n">loop</span> <span class="k">with</span> <span class="n">discrete</span> <span class="n">actuators</span> <span class="o">**</span><span class="n">Example</span><span class="p">:</span><span class="o">**</span>
<span class="err">```</span><span class="n">python</span>
<span class="n">zoh</span> <span class="o">=</span> <span class="n">IntegratorFactory</span><span class="o">.</span><span class="n">create_integrator</span><span class="p">(</span><span class="s1">&#39;zoh&#39;</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span> <span class="c1"># Typical use with discrete controller</span>
<span class="n">orchestrator</span> <span class="o">=</span> <span class="n">SequentialOrchestrator</span><span class="p">(</span><span class="n">dynamics</span><span class="p">,</span> <span class="n">zoh</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">orchestrator</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span> <span class="n">initial_state</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">control_inputs</span><span class="o">=</span><span class="n">discrete_controls</span><span class="p">,</span> <span class="c1"># Piecewise constant dt=0.01, horizon=500</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="integrator-selection-guide-5-5-1-decision-tree">
<h3>5.5 Integrator Selection Guide #### 5.5.1 Decision Tree ```<a class="headerlink" href="#integrator-selection-guide-5-5-1-decision-tree" title="Link to this heading">Â¶</a></h3>
<p>Need adaptive step size?
â”œâ”€ YES â†’ DormandPrince45 (atol=1e-6, rtol=1e-3)
â”‚ Use for: High accuracy, stiff systems, variable dynamics
â”‚
â””â”€ NO â†’ Need high accuracy? â”œâ”€ YES â†’ RungeKutta4 (dt=0.001-0.01) â”‚ Use for: Standard simulations, balance speed/accuracy â”‚ â””â”€ NO â†’ Need maximum speed? â”œâ”€ YES â†’ ForwardEuler (dt=0.0001-0.001) â”‚ Use for: Fast prototyping, real-time constraints â”‚ â””â”€ Discrete control? â†’ ZeroOrderHold (dt=sampling period) Use for: Discrete-time, HIL, sampled-data</p>
<div class="highlight-#### notranslate"><div class="highlight"><pre><span></span>|------------|---------------|----------|--------|---------------|----------|
| ForwardEuler | 5.0x | â˜…â˜†â˜†â˜†â˜† | 1x | 0.0001s | Fast prototyping |
| RungeKutta2 | 2.5x | â˜…â˜…â˜†â˜†â˜† | 1x | 0.001s | Educational |
| RungeKutta4 | 1.0x (baseline) | â˜…â˜…â˜…â˜…â˜† | 1x | 0.01s | **Standard choice** |
| DormandPrince45 | 0.2-0.5x | â˜…â˜…â˜…â˜…â˜… | 2x | Adaptive | High-accuracy |
| ZeroOrderHold | 4.5x | â˜…â˜†â˜†â˜†â˜† | 1x | Variable | Discrete control | **Benchmark:** 1000-step DIP simulation on Intel i7-9700K #### 5.5.3 Accuracy vs. Performance Trade-off ```
High Accuracy (atol &lt; 1e-6) â†‘ â”‚ DP45 (adaptive) â”‚ â˜… â”‚ â”‚ RK4 (dt=0.001) â”‚ â˜… â”‚ â”‚ RK4 (dt=0.01) â”‚ â˜… â”‚ â”‚ Euler (dt=0.0001) â”‚ â˜… â”‚
Low Accuracy Euler (dt=0.01) â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â˜…â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Slow Fast Performance
``` #### 5.5.4 Recommendation by Application | Application | Recommended Integrator | Configuration |

|-------------|----------------------|---------------|
| **Standard DIP simulation** | RungeKutta4 | `dt=0.01` |
| **PSO optimization** | RungeKutta4 | `dt=0.01` (speed matters) |
| **Scientific validation** | DormandPrince45 | `atol=1e-8, rtol=1e-6` |
| **Real-time HIL** | ForwardEuler or ZOH | `dt=0.001` (timing critical) |
| **Parameter studies** | RungeKutta4 | `dt=0.01` (batch execution) |
| **Educational demos** | RungeKutta2 or RK4 | `dt=0.01` |

---

## 6. Result Container API ### 6.1 `ResultContainer` Base Interface **File:** `src/simulation/core/interfaces.py:174` Abstract base class defining result storage protocol. ```python

# example-metadata:

# runnable: false class ResultContainer(ABC): &quot;&quot;&quot;Base interface for simulation result containers.&quot;&quot;&quot; @abstractmethod def add_trajectory(self, states: np.ndarray, times: np.ndarray, **metadata) -&gt; None: &quot;&quot;&quot;Add a simulation trajectory to results.&quot;&quot;&quot; @abstractmethod def get_states(self) -&gt; np.ndarray: &quot;&quot;&quot;Get state trajectories.&quot;&quot;&quot; @abstractmethod def get_times(self) -&gt; np.ndarray: &quot;&quot;&quot;Get time vectors.&quot;&quot;&quot; @abstractmethod def export(self, format_type: str, filepath: str) -&gt; None: &quot;&quot;&quot;Export results to specified format.&quot;&quot;&quot;

</pre></div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="standardresultcontainer-file-src-simulation-results-containers-py-15-container-for-single-simulation-results-6-2-1-attributes-python">
<h2>6.2 <code class="docutils literal notranslate"><span class="pre">StandardResultContainer</span></code> <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/results/containers.py:15</span></code> Container for single simulation results. #### 6.2.1 Attributes ```python<a class="headerlink" href="#standardresultcontainer-file-src-simulation-results-containers-py-15-container-for-single-simulation-results-6-2-1-attributes-python" title="Link to this heading">Â¶</a></h2>
<p>self.states: Optional[np.ndarray] # State trajectory (n_steps+1, state_dim)
self.times: Optional[np.ndarray] # Time vector (n_steps+1,)
self.controls: Optional[np.ndarray] # Control sequence (n_steps,)
self.metadata: Dict[str, Any] # Additional data</p>
<div class="highlight-#### notranslate"><div class="highlight"><pre><span></span>
```python
def add_trajectory(self, states: np.ndarray, times: np.ndarray, **metadata) -&gt; None: &quot;&quot;&quot;Add trajectory data to container.&quot;&quot;&quot;
``` Stores states, times, and optional controls/metadata. **get_states()**

```python
def get_states(self) -&gt; np.ndarray: &quot;&quot;&quot;Get state trajectories.&quot;&quot;&quot;
``` Returns: State array (n_steps+1, state_dim) or empty array if no data. **get_times()**

```python
def get_times(self) -&gt; np.ndarray: &quot;&quot;&quot;Get time vectors.&quot;&quot;&quot;
``` Returns: Time array (n_steps+1,) or empty array if no data. **export()**

```python
def export(self, format_type: str, filepath: str) -&gt; None: &quot;&quot;&quot;Export results to specified format.&quot;&quot;&quot;
``` Supported formats: `&#39;csv&#39;`, `&#39;hdf5&#39;` #### 6.2.3 Usage Example ```python

from src.simulation.results import StandardResultContainer # Create container
result = StandardResultContainer() # Add simulation data
result.add_trajectory( states=x_arr, times=t_arr, controls=u_arr, controller_type=&#39;classical_smc&#39;, initial_state=x0
) # Access data
states = result.get_states() # (n_steps+1, 6)
times = result.get_times() # (n_steps+1,) # Export
result.export(&#39;csv&#39;, &#39;results/simulation_001.csv&#39;)
result.export(&#39;hdf5&#39;, &#39;results/simulation_001.h5&#39;)
</pre></div>
</div>
<hr class="docutils" />
<section id="batchresultcontainer-file-src-simulation-results-containers-py-59-container-for-multiple-simulation-results-batch-execution-6-3-1-attributes-python">
<h3>6.3 <code class="docutils literal notranslate"><span class="pre">BatchResultContainer</span></code> <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/results/containers.py:59</span></code> Container for multiple simulation results (batch execution). #### 6.3.1 Attributes ```python<a class="headerlink" href="#batchresultcontainer-file-src-simulation-results-containers-py-59-container-for-multiple-simulation-results-batch-execution-6-3-1-attributes-python" title="Link to this heading">Â¶</a></h3>
<p>self.batch_data: Dict[int, Dict[str, Any]] # Indexed simulation data
self.metadata: Dict[str, Any] # Global metadata</p>
<div class="highlight-**Structure:** notranslate"><div class="highlight"><pre><span></span>
```python
# example-metadata:
# runnable: false { 0: { &#39;states&#39;: np.ndarray (n_steps+1, state_dim), &#39;times&#39;: np.ndarray (n_steps+1,), &#39;controls&#39;: np.ndarray (n_steps,), &#39;metadata&#39;: {...} }, 1: {...}, ...
}
``` #### 6.3.2 Methods **add_trajectory()**

```python
def add_trajectory(self, states: np.ndarray, times: np.ndarray, **metadata) -&gt; None: &quot;&quot;&quot;Add trajectory data to batch container.&quot;&quot;&quot;
``` Automatically assigns `batch_index` if not provided in metadata. **get_states()**

```python
def get_states(self, batch_index: Optional[int] = None) -&gt; np.ndarray: &quot;&quot;&quot;Get state trajectories for specific batch or all batches.&quot;&quot;&quot;
``` Returns:

- If `batch_index` specified: (n_steps+1, state_dim)
- If `batch_index=None`: (batch_size, n_steps+1, state_dim) **get_times()**
```python
def get_times(self, batch_index: Optional[int] = None) -&gt; np.ndarray: &quot;&quot;&quot;Get time vectors for specific batch or all batches.&quot;&quot;&quot;
``` Returns:

- If `batch_index` specified: (n_steps+1,)
- If `batch_index=None`: (n_steps+1,) (assumes all batches have same times) #### 6.3.3 Usage Example ```python
from src.simulation.results import BatchResultContainer # Create batch container
batch_result = BatchResultContainer() # Add multiple trajectories
for i in range(10): batch_result.add_trajectory( states=x_arr_list[i], times=t_arr, controls=u_arr_list[i], batch_index=i, initial_condition=ic_list[i] ) # Access specific trajectory
states_3 = batch_result.get_states(batch_index=3) # (n_steps+1, 6) # Access all trajectories
all_states = batch_result.get_states() # (10, n_steps+1, 6) # Compute aggregate statistics
settling_times = []
for i in range(10): states_i = batch_result.get_states(batch_index=i) settling_times.append(compute_settling_time(states_i)) mean_settling = np.mean(settling_times)
</pre></div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="result-exporters-6-4-1-csv-exporter-file-src-simulation-results-exporters-py-exports-results-to-csv-format-human-readable-spreadsheet-compatible-format">
<h2>6.4 Result Exporters #### 6.4.1 CSV Exporter <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/results/exporters.py</span></code> Exports results to CSV format (human-readable, spreadsheet-compatible). <strong>Format:</strong><a class="headerlink" href="#result-exporters-6-4-1-csv-exporter-file-src-simulation-results-exporters-py-exports-results-to-csv-format-human-readable-spreadsheet-compatible-format" title="Link to this heading">Â¶</a></h2>
<div class="highlight-csv notranslate"><div class="highlight"><pre><span></span>
time,x,theta1,theta2,x_dot,theta1_dot,theta2_dot,control
0.00,0.000,0.100,0.100,0.000,0.000,0.000,
0.01,0.000,0.099,0.098,0.001,0.012,0.015,12.5
0.02,0.000,0.096,0.094,0.002,0.024,0.030,15.2
...
``` **Usage:**
```python

result.export(&#39;csv&#39;, &#39;results/sim_001.csv&#39;)
``` #### 6.4.2 HDF5 Exporter **File:** `src/simulation/results/exporters.py` Exports results to HDF5 format (binary, efficient, hierarchical). **Structure:**
</pre></div>
</div>
<p>simulation_001.h5
â”œâ”€â”€ /states (dataset: n_steps+1 x 6)
â”œâ”€â”€ /times (dataset: n_steps+1)
â”œâ”€â”€ /controls (dataset: n_steps)
â””â”€â”€ /metadata (attributes)</p>
<div class="highlight-**Usage:** notranslate"><div class="highlight"><pre><span></span>```python

result.export(&#39;hdf5&#39;, &#39;results/sim_001.h5&#39;) # Load with h5py
import h5py
with h5py.File(&#39;results/sim_001.h5&#39;, &#39;r&#39;) as f: states = f[&#39;states&#39;][:] times = f[&#39;times&#39;][:] metadata = dict(f.attrs)
``` **Advantages:**
- âœ… Fast read/write (10-100x faster than CSV for large datasets)
- âœ… Compression support (50-90% size reduction)
- âœ… Hierarchical structure (organize multiple simulations)
- âœ… Metadata storage (preserve all simulation parameters)

---

## 7. Safety &amp; Monitoring API ### 7.1 Safety Guards **File:** `src/simulation/safety/guards.py` #### 7.1.1 `apply_safety_guards()` ```python
def apply_safety_guards(state: np.ndarray, step_idx: int, config: Any) -&gt; None: &quot;&quot;&quot;Apply safety constraints to simulation state.&quot;&quot;&quot;
``` Performs three checks:

1. **NaN/Inf Detection** - `_guard_no_nan(state)`
2. **Energy Bounds** - `_guard_energy(state, config)`
3. **State Bounds** - `_guard_bounds(state, config)` **Raises:** `SafetyViolationError` if any guard fails **Example:**
```python
from src.simulation.safety import apply_safety_guards, SafetyViolationError try: apply_safety_guards(x_current, step_idx, config)
except SafetyViolationError as e: print(f&quot;Safety violation at step {step_idx}: {e}&quot;) # Truncate simulation
``` #### 7.1.2 Individual Guards **_guard_no_nan()**

```python
def _guard_no_nan(state: np.ndarray) -&gt; None: &quot;&quot;&quot;Check for NaN or Inf values.&quot;&quot;&quot; if not np.all(np.isfinite(state)): raise SafetyViolationError(&quot;State contains NaN or Inf&quot;)
``` **_guard_energy()**

```python
def _guard_energy(state: np.ndarray, config: Any) -&gt; None: &quot;&quot;&quot;Check total energy within bounds.&quot;&quot;&quot; E_kinetic = 0.5 * m * (x_dot**2 + theta1_dot**2 + theta2_dot**2) E_potential = m * g * (L1 * cos(theta1) + L2 * cos(theta2)) E_total = E_kinetic + E_potential if E_total &gt; config.safety.max_energy: raise SafetyViolationError(f&quot;Energy {E_total:.2f}J exceeds {config.safety.max_energy}J&quot;)
``` **_guard_bounds()**

```python
# example-metadata:
# runnable: false def _guard_bounds(state: np.ndarray, config: Any) -&gt; None: &quot;&quot;&quot;Check state within configured bounds.&quot;&quot;&quot; bounds = config.safety.state_bounds # [x_min, x_max, theta_min, theta_max, ...] for i, (val, (min_val, max_val)) in enumerate(zip(state, bounds)): if not (min_val &lt;= val &lt;= max_val): raise SafetyViolationError( f&quot;State[{i}] = {val:.3f} outside bounds [{min_val}, {max_val}]&quot; )
``` #### 7.1.3 Configuration ```yaml
# config.yaml

safety: max_energy: 100.0 # Joules state_bounds: x: [-2.0, 2.0] # Cart position (m) theta1: [-1.57, 1.57] # Pole 1 angle (rad, Â±Ï€/2) theta2: [-1.57, 1.57] # Pole 2 angle (rad, Â±Ï€/2) x_dot: [-10.0, 10.0] # Cart velocity (m/s) theta1_dot: [-20.0, 20.0] # Pole 1 angular velocity (rad/s) theta2_dot: [-20.0, 20.0] # Pole 2 angular velocity (rad/s)
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="performance-monitoring-file-src-simulation-safety-monitors-py-7-2-1-performancemonitor-tracks-execution-time-and-throughput-for-orchestrators-and-integrators-methods">
<h2>7.2 Performance Monitoring <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/safety/monitors.py</span></code> #### 7.2.1 <code class="docutils literal notranslate"><span class="pre">PerformanceMonitor</span></code> Tracks execution time and throughput for orchestrators and integrators. <strong>Methods:</strong><a class="headerlink" href="#performance-monitoring-file-src-simulation-safety-monitors-py-7-2-1-performancemonitor-tracks-execution-time-and-throughput-for-orchestrators-and-integrators-methods" title="Link to this heading">Â¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false monitor = PerformanceMonitor() monitor.start_timing(&#39;simulation&#39;)</span>

<span class="c1"># ... run simulation ...</span>

<span class="n">elapsed</span> <span class="o">=</span> <span class="n">monitor</span><span class="o">.</span><span class="n">end_timing</span><span class="p">(</span><span class="s1">&#39;simulation&#39;</span><span class="p">)</span> <span class="n">stats</span> <span class="o">=</span> <span class="n">monitor</span><span class="o">.</span><span class="n">get_statistics</span><span class="p">()</span>
<span class="c1"># Returns:</span>

<span class="c1"># {</span>

<span class="c1"># &#39;simulation&#39;: {</span>

<span class="c1"># &#39;count&#39;: 100,</span>

<span class="c1"># &#39;total_time&#39;: 12.5,</span>

<span class="c1"># &#39;mean_time&#39;: 0.125,</span>

<span class="c1"># &#39;std_time&#39;: 0.015,</span>

<span class="c1"># &#39;min_time&#39;: 0.110,</span>

<span class="c1"># &#39;max_time&#39;: 0.180</span>

<span class="c1"># }</span>

<span class="c1"># }</span>

<span class="err">```</span> <span class="o">**</span><span class="n">Usage</span> <span class="ow">in</span> <span class="n">Orchestrator</span><span class="p">:</span><span class="o">**</span>
<span class="err">```</span><span class="n">python</span>
<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false class SequentialOrchestrator(BaseOrchestrator): def execute(self, ...): self.monitor.start_timing(&#39;orchestrator_execute&#39;) # ... simulation loop ... elapsed = self.monitor.end_timing(&#39;orchestrator_execute&#39;) return result</span>

</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="complete-code-examples-8-1-example-1-basic-simulation-objective-run-a-single-simulation-with-classical-smc-controller-and-plot-results-python">
<h2>8. Complete Code Examples ### 8.1 Example 1: Basic Simulation <strong>Objective:</strong> Run a single simulation with classical SMC controller and plot results. ```python<a class="headerlink" href="#complete-code-examples-8-1-example-1-basic-simulation-objective-run-a-single-simulation-with-classical-smc-controller-and-plot-results-python" title="Link to this heading">Â¶</a></h2>
<p>â€œâ€â€
Example 1: Basic DIP Simulation
Demonstrates standard workflow: load config â†’ create controller â†’ create dynamics â†’ simulate â†’ plot
â€œâ€â€ import numpy as np
import matplotlib.pyplot as plt
from src.config import load_config
from src.controllers import create_controller
from src.plant.models import LowRankDIPDynamics
from src.simulation import run_simulation # ============================================================================</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="step-1-load-configuration">
<h1>STEP 1: Load Configuration<a class="headerlink" href="#step-1-load-configuration" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id4">
<h1>============================================================================<a class="headerlink" href="#id4" title="Link to this heading">Â¶</a></h1>
<p>config = load_config(â€˜config.yamlâ€™) # ============================================================================</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="step-2-create-controller">
<h1>STEP 2: Create Controller<a class="headerlink" href="#step-2-create-controller" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id5">
<h1>============================================================================<a class="headerlink" href="#id5" title="Link to this heading">Â¶</a></h1>
<p>controller = create_controller( â€˜classical_smcâ€™, config=config, gains=[10.0, 8.0, 15.0, 12.0, 50.0, 5.0] # [k1, k2, Î»1, Î»2, K, kd]
) # ============================================================================</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="step-3-create-dynamics-model">
<h1>STEP 3: Create Dynamics Model<a class="headerlink" href="#step-3-create-dynamics-model" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id6">
<h1>============================================================================<a class="headerlink" href="#id6" title="Link to this heading">Â¶</a></h1>
<p>dynamics = LowRankDIPDynamics( config=config.plant, enable_monitoring=True, enable_validation=True
) # ============================================================================</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="step-4-run-simulation">
<h1>STEP 4: Run Simulation<a class="headerlink" href="#step-4-run-simulation" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id7">
<h1>============================================================================<a class="headerlink" href="#id7" title="Link to this heading">Â¶</a></h1>
<p>initial_state = np.array([ 0.0, # x: cart position 0.1, # theta1: pole 1 angle (small perturbation) 0.1, # theta2: pole 2 angle (small perturbation) 0.0, # x_dot: cart velocity 0.0, # theta1_dot: pole 1 angular velocity 0.0 # theta2_dot: pole 2 angular velocity
]) t, x, u = run_simulation( controller=controller, dynamics_model=dynamics, sim_time=5.0, # 5 seconds dt=0.01, # 10ms timestep initial_state=initial_state, u_max=100.0, # 100N force limit seed=42 # Reproducibility
) # ============================================================================</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="step-5-analyze-results">
<h1>STEP 5: Analyze Results<a class="headerlink" href="#step-5-analyze-results" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id8">
<h1>============================================================================<a class="headerlink" href="#id8" title="Link to this heading">Â¶</a></h1>
<p>print(â€œ=â€ * 70)
print(â€œSIMULATION RESULTSâ€)
print(â€œ=â€ * 70)
print(fâ€Simulation steps: {len(t)-1}â€)
print(fâ€Final time: {t[-1]:.2f}sâ€)
print(fâ€Final state: {x[-1]}â€)
print(fâ€Max control: {np.max(np.abs(u)):.2f}Nâ€)
print(fâ€Mean |control|: {np.mean(np.abs(u)):.2f}Nâ€) # Compute performance metrics
settling_time_idx = np.where(np.all(np.abs(x[:, :3]) &lt; 0.02, axis=1))[0]
if len(settling_time_idx) &gt; 0: settling_time = t[settling_time_idx[0]] print(fâ€Settling time (2% threshold): {settling_time:.3f}sâ€) # ============================================================================</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="step-6-plot-results">
<h1>STEP 6: Plot Results<a class="headerlink" href="#step-6-plot-results" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id9">
<h1>============================================================================<a class="headerlink" href="#id9" title="Link to this heading">Â¶</a></h1>
<p>fig, axes = plt.subplots(4, 1, figsize=(10, 10)) # Cart position
axes[0].plot(t, x[:, 0], â€˜b-â€™, linewidth=2)
axes[0].set_ylabel(â€˜Cart Position (m)â€™, fontsize=12)
axes[0].grid(True, alpha=0.3)
axes[0].axhline(0, color=â€™râ€™, linestyle=â€™â€“â€™, alpha=0.5) # Pole angles
axes[1].plot(t, x[:, 1] * 180/np.pi, â€˜r-â€™, linewidth=2, label=â€™Pole 1â€™)
axes[1].plot(t, x[:, 2] * 180/np.pi, â€˜g-â€™, linewidth=2, label=â€™Pole 2â€™)
axes[1].set_ylabel(â€˜Angles (deg)â€™, fontsize=12)
axes[1].grid(True, alpha=0.3)
axes[1].legend(loc=â€™upper rightâ€™)
axes[1].axhline(0, color=â€™kâ€™, linestyle=â€™â€“â€™, alpha=0.5) # Velocities
axes[2].plot(t, x[:, 3], â€˜b-â€™, linewidth=2, label=â€™Cartâ€™)
axes[2].plot(t, x[:, 4], â€˜r-â€™, linewidth=2, label=â€™Pole 1â€™)
axes[2].plot(t, x[:, 5], â€˜g-â€™, linewidth=2, label=â€™Pole 2â€™)
axes[2].set_ylabel(â€˜Velocitiesâ€™, fontsize=12)
axes[2].grid(True, alpha=0.3)
axes[2].legend(loc=â€™upper rightâ€™) # Control input
axes[3].plot(t[:-1], u, â€˜m-â€™, linewidth=2)
axes[3].set_xlabel(â€˜Time (s)â€™, fontsize=12)
axes[3].set_ylabel(â€˜Control Force (N)â€™, fontsize=12)
axes[3].grid(True, alpha=0.3)
axes[3].axhline(100, color=â€™râ€™, linestyle=â€™â€“â€™, alpha=0.5, label=â€™Limitâ€™)
axes[3].axhline(-100, color=â€™râ€™, linestyle=â€™â€“â€™, alpha=0.5)
axes[3].legend(loc=â€™upper rightâ€™) plt.tight_layout()
plt.savefig(â€˜results/basic_simulation.pngâ€™, dpi=150)
plt.show() print(â€œ\nPlot saved to: results/basic_simulation.pngâ€)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="o">---</span>

<span class="c1">## 8.2 Example 2: Batch Simulation for PSO **Objective:** Use batch orchestrator for PSO fitness evaluation with vectorized execution. ```python</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Example 2: Batch Simulation for PSO Optimization</span>
<span class="sd">Demonstrates vectorized batch execution for parameter optimization</span>
<span class="sd">&quot;&quot;&quot;</span> <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.config</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_config</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.controllers</span><span class="w"> </span><span class="kn">import</span> <span class="n">create_controller</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.plant.models</span><span class="w"> </span><span class="kn">import</span> <span class="n">LowRankDIPDynamics</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.simulation.orchestrators</span><span class="w"> </span><span class="kn">import</span> <span class="n">BatchOrchestrator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.simulation.integrators</span><span class="w"> </span><span class="kn">import</span> <span class="n">IntegratorFactory</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.optimization</span><span class="w"> </span><span class="kn">import</span> <span class="n">PSOTuner</span> <span class="c1"># ============================================================================</span>
<span class="c1"># STEP 1: Configuration and Setup</span>

<span class="c1"># ============================================================================</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">load_config</span><span class="p">(</span><span class="s1">&#39;config.yaml&#39;</span><span class="p">)</span>
<span class="n">dynamics</span> <span class="o">=</span> <span class="n">LowRankDIPDynamics</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">plant</span><span class="p">)</span>
<span class="n">integrator</span> <span class="o">=</span> <span class="n">IntegratorFactory</span><span class="o">.</span><span class="n">create_integrator</span><span class="p">(</span><span class="s1">&#39;rk4&#39;</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span> <span class="c1"># ============================================================================</span>
<span class="c1"># STEP 2: Define Controller Factory for PSO</span>

<span class="c1"># ============================================================================</span>

<span class="k">def</span><span class="w"> </span><span class="nf">controller_factory</span><span class="p">(</span><span class="n">gains</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot;Create controller instance with candidate gains.&quot;&quot;&quot;</span> <span class="k">return</span> <span class="n">create_controller</span><span class="p">(</span> <span class="s1">&#39;classical_smc&#39;</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">,</span> <span class="n">gains</span><span class="o">=</span><span class="n">gains</span> <span class="c1"># [k1, k2, Î»1, Î»2, K, kd] ) # ============================================================================</span>
<span class="c1"># STEP 3: Define Fitness Function with Batch Execution</span>

<span class="c1"># ============================================================================</span>

<span class="k">def</span><span class="w"> </span><span class="nf">fitness_function</span><span class="p">(</span><span class="n">gains</span><span class="p">,</span> <span class="n">n_trials</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot; Evaluate controller gains using batch simulation. Args: gains: Controller gains to evaluate n_trials: Number of Monte Carlo trials (different ICs) Returns: Fitness value (lower is better) &quot;&quot;&quot;</span> <span class="c1"># Create controller controller = controller_factory(gains) # Generate batch of initial conditions (small perturbations) np.random.seed(42) # Reproducibility batch_initial = np.zeros((n_trials, 6)) batch_initial[:, 1] = np.random.uniform(0.05, 0.15, n_trials) # theta1 batch_initial[:, 2] = np.random.uniform(0.05, 0.15, n_trials) # theta2 # Precompute control sequence for all trials horizon = 500 dt = 0.01 controls = np.zeros((n_trials, horizon)) # Temporary: compute control for each initial condition # (In practice, use controller in orchestrator loop) for i in range(n_trials): x_temp = batch_initial[i] for j in range(horizon): controls[i, j] = controller(j * dt, x_temp) # Simple Euler prediction for next control (approximation) x_temp = x_temp + dt * np.array([ x_temp[3], x_temp[4], x_temp[5], 0, 0, 0 ]) # Execute batch simulation orchestrator = BatchOrchestrator(dynamics, integrator) result = orchestrator.execute( initial_state=batch_initial, control_inputs=controls, dt=dt, horizon=horizon, safety_guards=True ) # Compute fitness metrics all_states = result.get_states() # (n_trials, horizon+1, 6) fitness_values = [] for i in range(n_trials): states_i = all_states[i] # (horizon+1, 6) # Metric 1: Settling time (2% threshold) settled_mask = np.all(np.abs(states_i[:, :3]) &lt; 0.02, axis=1) if np.any(settled_mask): settling_idx = np.where(settled_mask)[0][0] settling_time = settling_idx * dt else: settling_time = 5.0 # Penalty if never settled # Metric 2: Peak overshoot peak_overshoot = np.max(np.abs(states_i[:, :3])) # Metric 3: Integral squared error ise = np.sum(np.sum(states_i[:, :3]**2, axis=1)) * dt # Combined fitness (weighted sum) fitness_i = ( 2.0 * settling_time + # Weight settling time heavily 5.0 * peak_overshoot + # Penalize overshoot 0.1 * ise # Penalize tracking error ) fitness_values.append(fitness_i) # Return mean fitness over all trials return np.mean(fitness_values) # ============================================================================</span>
<span class="c1"># STEP 4: Configure and Run PSO Optimization</span>

<span class="c1"># ============================================================================</span>

<span class="c1"># Define gain bounds for classical SMC</span>

<span class="c1"># [k1, k2, Î»1, Î»2, K, kd]</span>

<span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">50.0</span><span class="p">),</span> <span class="c1"># k1: position gain (1.0, 40.0), # k2: position damping (1.0, 50.0), # Î»1: angle gain 1 (1.0, 40.0), # Î»2: angle gain 2 (10.0, 100.0), # K: switching gain (0.1, 10.0) # kd: derivative gain</span>
<span class="p">]</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">70</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PSO OPTIMIZATION WITH BATCH SIMULATION&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">70</span><span class="p">)</span> <span class="c1"># Create PSO tuner</span>
<span class="n">tuner</span> <span class="o">=</span> <span class="n">PSOTuner</span><span class="p">(</span> <span class="n">fitness_fn</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="n">fitness_function</span><span class="p">,</span> <span class="n">n_trials</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">swarm_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span> <span class="c1"># Run optimization</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">tuner</span><span class="o">.</span><span class="n">optimise</span><span class="p">()</span> <span class="c1"># ============================================================================</span>
<span class="c1"># STEP 5: Display Results</span>

<span class="c1"># ============================================================================</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">70</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;OPTIMIZATION RESULTS&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">70</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Best fitness: </span><span class="si">{</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;best_fitness&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Best gains: </span><span class="si">{</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;best_gains&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Convergence iteration: </span><span class="si">{</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;convergence_iter&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="c1"># ============================================================================</span>
<span class="c1"># STEP 6: Validate Optimal Gains</span>

<span class="c1"># ============================================================================</span>

<span class="n">optimal_controller</span> <span class="o">=</span> <span class="n">controller_factory</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;best_gains&#39;</span><span class="p">])</span> <span class="kn">from</span><span class="w"> </span><span class="nn">src.simulation</span><span class="w"> </span><span class="kn">import</span> <span class="n">run_simulation</span> <span class="n">t_val</span><span class="p">,</span> <span class="n">x_val</span><span class="p">,</span> <span class="n">u_val</span> <span class="o">=</span> <span class="n">run_simulation</span><span class="p">(</span> <span class="n">controller</span><span class="o">=</span><span class="n">optimal_controller</span><span class="p">,</span> <span class="n">dynamics_model</span><span class="o">=</span><span class="n">dynamics</span><span class="p">,</span> <span class="n">sim_time</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">initial_state</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">u_max</span><span class="o">=</span><span class="mf">100.0</span>
<span class="p">)</span> <span class="c1"># Plot validation</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_val</span><span class="p">,</span> <span class="n">x_val</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Pole 1&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_val</span><span class="p">,</span> <span class="n">x_val</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="s1">&#39;g-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Pole 2&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Angles (deg)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Optimal Controller Performance&#39;</span><span class="p">)</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_val</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">u_val</span><span class="p">,</span> <span class="s1">&#39;m-&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Control (N)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;results/pso_batch_simulation.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Validation plot saved to: results/pso_batch_simulation.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
<hr class="docutils" />
<p>(Continuing with Examples 3-5, Sections 9-10, and completion reportâ€¦)</p>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="performance_benchmarks.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Performance Benchmarks Reference <strong>Status:</strong> ğŸš§ Under Construction This document will contain performance benchmarking documentation including: ## Planned Content ### Benchmark Methodology</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="pso_optimization.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">PSO Optimization Guide <strong>Status:</strong> ğŸš§ Under Construction This document will contain PSO optimization documentation including: ## Planned Content ### PSO Algorithm Fundamentals</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Research Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Simulation Engine API Reference <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a><ul>
<li><a class="reference internal" href="#table-of-contents-1-overview-architecture">Table of Contents 1. <span class="xref myst">Overview &amp; Architecture</span></a></li>
<li><a class="reference internal" href="#overview-architecture-1-1-introduction-the-simulation-engine-is-the-core-execution-framework-for-the-double-inverted-pendulum-control-system-it-provides-flexible-simulation-execution-strategies-sequential-batch-parallel-real-time">1. Overview &amp; Architecture ### 1.1 Introduction The <strong>Simulation Engine</strong> is the core execution framework for the Double-Inverted Pendulum control system. It provides: - <strong>Flexible simulation execution</strong> strategies (sequential, batch, parallel, real-time)</a></li>
<li><a class="reference internal" href="#simulationrunner-class-file-src-simulation-engines-simulation-runner-py-333-object-oriented-wrapper-around-run-simulation-providing-state-tracking-and-compatibility-with-test-cases-2-2-1-class-definition-python">2.2 <code class="docutils literal notranslate"><span class="pre">SimulationRunner</span></code> Class <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/engines/simulation_runner.py:333</span></code> Object-oriented wrapper around <code class="docutils literal notranslate"><span class="pre">run_simulation()</span></code> providing state tracking and compatibility with test cases. #### 2.2.1 Class Definition ```python</a><ul>
<li><a class="reference internal" href="#legacy-compatibility-functions-2-3-1-step-function-file-src-simulation-engines-simulation-runner-py-87-python">2.3 Legacy Compatibility Functions #### 2.3.1 <code class="docutils literal notranslate"><span class="pre">step()</span></code> Function <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/engines/simulation_runner.py:87</span></code> ```python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dynamics-model-api-3-1-dynamicsmodel-protocol-file-src-plant-models-base-dynamics-interface-py-65-protocol-defining-the-interface-all-dynamics-models-must-implement-3-1-1-protocol-definition-python">3. Dynamics Model API ### 3.1 <code class="docutils literal notranslate"><span class="pre">DynamicsModel</span></code> Protocol <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/plant/models/base/dynamics_interface.py:65</span></code> Protocol defining the interface all dynamics models must implement. #### 3.1.1 Protocol Definition ```python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-metadata">example-metadata:</a></li>
<li><a class="reference internal" href="#runnable-false-class-dynamicsmodel-protocol-protocol-for-plant-dynamics-models-def-compute-dynamics-self-state-np-ndarray-control-input-np-ndarray-time-float-0-0-kwargs-any-dynamicsresult-compute-system-dynamics-at-given-state-and-input-def-get-physics-matrices-self-state-np-ndarray-tuple-np-ndarray-np-ndarray-np-ndarray-get-physics-matrices-m-c-g-at-current-state-def-validate-state-self-state-np-ndarray-bool-validate-state-vector-format-and-bounds-def-get-state-dimension-self-int-get-dimension-of-state-vector-def-get-control-dimension-self-int-get-dimension-of-control-input-vector">runnable: false class DynamicsModel(Protocol): â€œâ€â€Protocol for plant dynamics models.â€â€â€ def compute_dynamics( self, state: np.ndarray, control_input: np.ndarray, time: float = 0.0, **kwargs: Any ) -&gt; DynamicsResult: â€œâ€â€Compute system dynamics at given state and input.â€â€â€ â€¦ def get_physics_matrices( self, state: np.ndarray ) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]: â€œâ€â€Get physics matrices M, C, G at current state.â€â€â€ â€¦ def validate_state(self, state: np.ndarray) -&gt; bool: â€œâ€â€Validate state vector format and bounds.â€â€â€ â€¦ def get_state_dimension(self) -&gt; int: â€œâ€â€Get dimension of state vector.â€â€â€ â€¦ def get_control_dimension(self) -&gt; int: â€œâ€â€Get dimension of control input vector.â€â€â€ â€¦</a><ul>
<li><a class="reference internal" href="#basedynamicsmodel-abstract-class-file-src-plant-models-base-dynamics-interface-py-130-abstract-base-class-providing-common-functionality-for-concrete-dynamics-implementations-3-2-1-class-definition-python">3.2 <code class="docutils literal notranslate"><span class="pre">BaseDynamicsModel</span></code> Abstract Class <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/plant/models/base/dynamics_interface.py:130</span></code> Abstract base class providing common functionality for concrete dynamics implementations. #### 3.2.1 Class Definition ```python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id1">example-metadata:</a></li>
<li><a class="reference internal" href="#runnable-false-abstractmethod">runnable: false &#64;abstractmethod</a><ul>
<li><a class="reference internal" href="#lowrankdipdynamics-implementation-file-src-plant-models-lowrank-dynamics-py-27-simplified-double-inverted-pendulum-dynamics-optimized-for-computational-efficiency-3-3-1-class-definition-python">3.3 <code class="docutils literal notranslate"><span class="pre">LowRankDIPDynamics</span></code> Implementation <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/plant/models/lowrank/dynamics.py:27</span></code> Simplified double-inverted pendulum dynamics optimized for computational efficiency. #### 3.3.1 Class Definition ```python</a></li>
<li><a class="reference internal" href="#orchestrator-system-api-4-1-orchestrator-base-interface-file-src-simulation-core-interfaces-py-85-base-interface-defining-execution-strategy-protocol-python">4. Orchestrator System API ### 4.1 <code class="docutils literal notranslate"><span class="pre">Orchestrator</span></code> Base Interface <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/core/interfaces.py:85</span></code> Base interface defining execution strategy protocol. ```python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id2">example-metadata:</a></li>
<li><a class="reference internal" href="#runnable-false-class-orchestrator-abc-base-interface-for-simulation-execution-strategies-abstractmethod-def-execute-self-initial-state-np-ndarray-control-inputs-np-ndarray-dt-float-horizon-int-kwargs-resultcontainer-execute-simulation-with-specified-strategy-pass">runnable: false class Orchestrator(ABC): â€œâ€â€Base interface for simulation execution strategies.â€â€â€ &#64;abstractmethod def execute( self, initial_state: np.ndarray, control_inputs: np.ndarray, dt: float, horizon: int, **kwargs ) -&gt; ResultContainer: â€œâ€â€Execute simulation with specified strategy.â€â€â€ pass</a><ul>
<li><a class="reference internal" href="#batchorchestrator-file-src-simulation-orchestrators-batch-py-18-vectorized-execution-for-multiple-simultaneous-simulations-pso-optimization-monte-carlo-4-3-1-class-definition-python">4.3 <code class="docutils literal notranslate"><span class="pre">BatchOrchestrator</span></code> <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/orchestrators/batch.py:18</span></code> Vectorized execution for multiple simultaneous simulations (PSO optimization, Monte Carlo). #### 4.3.1 Class Definition ```python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id3">example-metadata:</a></li>
<li><a class="reference internal" href="#runnable-false-class-batchorchestrator-baseorchestrator-batch-simulation-orchestrator-for-vectorized-execution-def-execute-self-initial-state-np-ndarray-control-inputs-np-ndarray-dt-float-horizon-int-kwargs-resultcontainer-execute-batch-simulation">runnable: false class BatchOrchestrator(BaseOrchestrator): â€œâ€â€Batch simulation orchestrator for vectorized execution.â€â€â€ def execute( self, initial_state: np.ndarray, control_inputs: np.ndarray, dt: float, horizon: int, **kwargs ) -&gt; ResultContainer: â€œâ€â€Execute batch simulation.â€â€â€</a><ul>
<li><a class="reference internal" href="#parallelorchestrator-file-src-simulation-orchestrators-parallel-py-multi-threaded-execution-for-large-scale-parameter-studies-4-4-1-features-thread-pool-management-configurable-pool-size">4.4 <code class="docutils literal notranslate"><span class="pre">ParallelOrchestrator</span></code> <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/orchestrators/parallel.py</span></code> Multi-threaded execution for large-scale parameter studies. #### 4.4.1 Features - âœ… <strong>Thread pool management</strong> (configurable pool size)</a></li>
<li><a class="reference internal" href="#integrator-system-api-5-1-integratorfactory-file-src-simulation-integrators-factory-py-22-factory-pattern-for-creating-numerical-integrator-instances-with-validation-and-consistency-checking-5-1-1-integrator-registry-the-factory-maintains-a-registry-of-7-integrator-types-type-class-order-adaptive-description">5. Integrator System API ### 5.1 <code class="docutils literal notranslate"><span class="pre">IntegratorFactory</span></code> <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/integrators/factory.py:22</span></code> Factory pattern for creating numerical integrator instances with validation and consistency checking. #### 5.1.1 Integrator Registry The factory maintains a registry of 7 integrator types: | Type | Class | Order | Adaptive | Description |</a></li>
<li><a class="reference internal" href="#fixed-step-integrators-5-2-1-forwardeuler-file-src-simulation-integrators-fixed-step-euler-py-first-order-explicit-euler-method-x-n-1-x-n-dt-f-x-n-u-n-t-n-properties">5.2 Fixed-Step Integrators #### 5.2.1 <code class="docutils literal notranslate"><span class="pre">ForwardEuler</span></code> <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/integrators/fixed_step/euler.py</span></code> First-order explicit Euler method: <code class="docutils literal notranslate"><span class="pre">x_{n+1}</span> <span class="pre">=</span> <span class="pre">x_n</span> <span class="pre">+</span> <span class="pre">dt</span> <span class="pre">*</span> <span class="pre">f(x_n,</span> <span class="pre">u_n,</span> <span class="pre">t_n)</span></code> <strong>Properties:</strong></a><ul>
<li><a class="reference internal" href="#adaptive-integrators-5-3-1-dormandprince45-file-src-simulation-integrators-adaptive-runge-kutta-py-dormand-prince-4th-5th-order-adaptive-runge-kutta-method-dp45-recommended-for-high-accuracy-requirements-properties">5.3 Adaptive Integrators #### 5.3.1 <code class="docutils literal notranslate"><span class="pre">DormandPrince45</span></code> <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/integrators/adaptive/runge_kutta.py</span></code> Dormand-Prince 4th/5th order adaptive Runge-Kutta method (DP45) - <strong>Recommended for high-accuracy requirements</strong>. <strong>Properties:</strong></a></li>
<li><a class="reference internal" href="#integrator-selection-guide-5-5-1-decision-tree">5.5 Integrator Selection Guide #### 5.5.1 Decision Tree ```</a></li>
</ul>
</li>
<li><a class="reference internal" href="#standardresultcontainer-file-src-simulation-results-containers-py-15-container-for-single-simulation-results-6-2-1-attributes-python">6.2 <code class="docutils literal notranslate"><span class="pre">StandardResultContainer</span></code> <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/results/containers.py:15</span></code> Container for single simulation results. #### 6.2.1 Attributes ```python</a><ul>
<li><a class="reference internal" href="#batchresultcontainer-file-src-simulation-results-containers-py-59-container-for-multiple-simulation-results-batch-execution-6-3-1-attributes-python">6.3 <code class="docutils literal notranslate"><span class="pre">BatchResultContainer</span></code> <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/results/containers.py:59</span></code> Container for multiple simulation results (batch execution). #### 6.3.1 Attributes ```python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#result-exporters-6-4-1-csv-exporter-file-src-simulation-results-exporters-py-exports-results-to-csv-format-human-readable-spreadsheet-compatible-format">6.4 Result Exporters #### 6.4.1 CSV Exporter <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/results/exporters.py</span></code> Exports results to CSV format (human-readable, spreadsheet-compatible). <strong>Format:</strong></a></li>
<li><a class="reference internal" href="#performance-monitoring-file-src-simulation-safety-monitors-py-7-2-1-performancemonitor-tracks-execution-time-and-throughput-for-orchestrators-and-integrators-methods">7.2 Performance Monitoring <strong>File:</strong> <code class="docutils literal notranslate"><span class="pre">src/simulation/safety/monitors.py</span></code> #### 7.2.1 <code class="docutils literal notranslate"><span class="pre">PerformanceMonitor</span></code> Tracks execution time and throughput for orchestrators and integrators. <strong>Methods:</strong></a></li>
<li><a class="reference internal" href="#complete-code-examples-8-1-example-1-basic-simulation-objective-run-a-single-simulation-with-classical-smc-controller-and-plot-results-python">8. Complete Code Examples ### 8.1 Example 1: Basic Simulation <strong>Objective:</strong> Run a single simulation with classical SMC controller and plot results. ```python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#step-1-load-configuration">STEP 1: Load Configuration</a></li>
<li><a class="reference internal" href="#id4">============================================================================</a></li>
<li><a class="reference internal" href="#step-2-create-controller">STEP 2: Create Controller</a></li>
<li><a class="reference internal" href="#id5">============================================================================</a></li>
<li><a class="reference internal" href="#step-3-create-dynamics-model">STEP 3: Create Dynamics Model</a></li>
<li><a class="reference internal" href="#id6">============================================================================</a></li>
<li><a class="reference internal" href="#step-4-run-simulation">STEP 4: Run Simulation</a></li>
<li><a class="reference internal" href="#id7">============================================================================</a></li>
<li><a class="reference internal" href="#step-5-analyze-results">STEP 5: Analyze Results</a></li>
<li><a class="reference internal" href="#id8">============================================================================</a></li>
<li><a class="reference internal" href="#step-6-plot-results">STEP 6: Plot Results</a></li>
<li><a class="reference internal" href="#id9">============================================================================</a></li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=8d563738"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=46bd48cc"></script>
    </body>
</html>