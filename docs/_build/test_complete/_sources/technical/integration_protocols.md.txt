# Integration Protocols and Cross-Domain Specifications ## Overview This document defines the integration protocols and cross-domain specifications for the controller factory within the double-inverted pendulum sliding mode control (DIP-SMC) ecosystem. These protocols ensure communication and data exchange between controllers, plant models, optimization algorithms, simulation engines, and hardware-in-the-loop (HIL) systems. ## Table of Contents 1. [System Architecture Overview](#system-architecture-overview)

2. [Controller-Plant Integration Protocol](#controller-plant-integration-protocol)
3. [Optimization-Factory Integration](#optimization-factory-integration)
4. [Simulation Engine Integration](#simulation-engine-integration)
5. [HIL System Integration](#hil-system-integration)
6. [Configuration Management Protocol](#configuration-management-protocol)
7. [Data Flow Specifications](#data-flow-specifications)
8. [Interface Contracts](#interface-contracts)

---

## System Architecture Overview ### Multi-Domain Integration Framework The controller factory operates at the center of a multi-domain integration ecosystem: ```mermaid

graph TB CF[Controller Factory] --> C[Controllers] CF --> PM[Plant Models] CF --> OPT[Optimization] CF --> SIM[Simulation] CF --> HIL[HIL Systems] CF --> CFG[Configuration] C --> SMC[SMC Variants] PM --> DYN[Dynamics Models] OPT --> PSO[PSO Algorithms] SIM --> VEC[Vector Simulation] HIL --> RT[Real-Time Systems] CFG --> VAL[Validation] subgraph "Cross-Domain Protocols" CP[Controller Protocol] PP[Plant Protocol] OP[Optimization Protocol] SP[Simulation Protocol] HP[HIL Protocol] end
``` ### Integration Principles 1. **Unified Interfaces**: All domains expose consistent API patterns
2. **Type Safety**: Strong typing across all integration points
3. **Error Resilience**: Graceful handling of cross-domain failures
4. **Performance Optimization**: Minimal overhead for real-time operations
5. **Extensibility**: Support for adding new domains without breaking existing integrations

---

## Controller-Plant Integration Protocol ### Plant Model Interface Specification All plant models must implement the `PlantModelInterface`: ```python
from abc import ABC, abstractmethod
from typing import Tuple, Optional
import numpy as np class PlantModelInterface(ABC): """Standard interface for plant models in the factory ecosystem.""" @abstractmethod def compute_dynamics( self, state: np.ndarray, control: float, disturbances: Optional[np.ndarray] = None ) -> np.ndarray: """ Compute system dynamics: dx/dt = f(x, u, d) Parameters ---------- state : np.ndarray, shape (6,) Current system state [θ₁, θ₂, x, θ̇₁, θ̇₂, ẋ] control : float Control input (cart force) disturbances : np.ndarray, optional External disturbances Returns ------- np.ndarray, shape (6,) State derivative vector """ pass @abstractmethod def get_linearization( self, state: np.ndarray, control: float ) -> Tuple[np.ndarray, np.ndarray]: """ Get linearized dynamics around operating point. Returns ------- A : np.ndarray, shape (6, 6) State matrix B : np.ndarray, shape (6, 1) Input matrix """ pass @abstractmethod def validate_state(self, state: np.ndarray) -> bool: """Validate if state is within acceptable bounds.""" pass @property @abstractmethod def state_dimension(self) -> int: """Return the state space dimension.""" pass @property @abstractmethod def control_dimension(self) -> int: """Return the control input dimension.""" pass
``` ### Plant Model Registration The factory supports dynamic plant model registration: ```python
# example-metadata:

# runnable: false class PlantModelRegistry: """Registry for plant models with validation.""" _models = {} @classmethod def register(cls, name: str, model_class: type): """Register a new plant model.""" if not issubclass(model_class, PlantModelInterface): raise TypeError("Model must implement PlantModelInterface") cls._models[name] = model_class @classmethod def create_model(cls, name: str, config: dict) -> PlantModelInterface: """Create plant model instance.""" if name not in cls._models: raise ValueError(f"Unknown plant model: {name}") model_class = cls._models[name] return model_class(config) @classmethod def list_models(cls) -> List[str]: """List available plant models.""" return list(cls._models.keys()) # Register built-in models

PlantModelRegistry.register('simplified_dip', SimplifiedDIPDynamics)
PlantModelRegistry.register('full_dip', FullDIPDynamics)
PlantModelRegistry.register('low_rank_dip', LowRankDIPDynamics)
``` ### Controller-Plant Communication Protocol ```python
# example-metadata:
# runnable: false class ControllerPlantBridge: """Bridge for controller-plant communication.""" def __init__(self, controller, plant_model): self.controller = controller self.plant_model = plant_model self._validate_compatibility() def _validate_compatibility(self): """Validate controller-plant compatibility.""" # Check state dimensions controller_states = getattr(self.controller, 'expected_states', 6) plant_states = self.plant_model.state_dimension if controller_states != plant_states: raise ValueError( f"State dimension mismatch: controller expects {controller_states}, " f"plant provides {plant_states}" ) # Check control dimensions controller_controls = getattr(self.controller, 'control_dimension', 1) plant_controls = self.plant_model.control_dimension if controller_controls != plant_controls: raise ValueError( f"Control dimension mismatch: controller outputs {controller_controls}, " f"plant expects {plant_controls}" ) def step(self, state: np.ndarray, dt: float) -> Tuple[np.ndarray, dict]: """Execute one control-plant step.""" # Validate state if not self.plant_model.validate_state(state): raise ValueError("Invalid state for plant model") # Compute control control_result = self.controller.compute_control(state, (), {}) u = control_result.u if hasattr(control_result, 'u') else control_result # Apply control to plant state_derivative = self.plant_model.compute_dynamics(state, u) # Integrate (simple Euler for demonstration) next_state = state + dt * state_derivative # Collect metadata metadata = { 'control_value': u, 'sliding_surface': getattr(control_result, 'sliding_surface', None), 'plant_model': type(self.plant_model).__name__, 'controller_type': type(self.controller).__name__ } return next_state, metadata
```

---

## Optimization-Factory Integration ### PSO Integration Architecture The PSO integration provides optimization of controller parameters: ```python

# example-metadata:

# runnable: false class PSOFactoryIntegration: """PSO-Factory integration layer.""" def __init__(self, controller_type: str, plant_model_config: dict): self.controller_type = controller_type self.plant_config = plant_model_config self.gain_bounds = self._get_theoretical_bounds() def create_optimization_objective( self, performance_metrics: List[str], weights: Optional[List[float]] = None ) -> Callable: """Create PSO optimization objective function.""" def objective_function(gains: np.ndarray) -> float: try: # Create controller with proposed gains controller = create_controller( self.controller_type, gains=gains.tolist() ) # Create plant model plant_model = PlantModelRegistry.create_model( 'simplified_dip', self.plant_config ) # Create bridge bridge = ControllerPlantBridge(controller, plant_model) # Run simulation performance = self._evaluate_performance( bridge, performance_metrics ) # Compute weighted cost if weights is None: weights = [1.0] * len(performance_metrics) total_cost = sum(w * p for w, p in zip(weights, performance)) return total_cost except Exception as e: # Return high cost for invalid configurations return 1e6 return objective_function def _evaluate_performance( self, bridge: ControllerPlantBridge, metrics: List[str] ) -> List[float]: """Evaluate controller performance metrics.""" # Standard test scenario initial_state = np.array([0.1, 0.05, 0.0, 0.0, 0.0, 0.0]) # Small perturbation dt = 0.001 t_final = 10.0 steps = int(t_final / dt) # Simulation state = initial_state.copy() states = [state.copy()] controls = [] for _ in range(steps): state, metadata = bridge.step(state, dt) states.append(state.copy()) controls.append(metadata['control_value']) states = np.array(states) controls = np.array(controls) # Compute metrics results = [] for metric in metrics: if metric == 'settling_time': results.append(self._compute_settling_time(states, dt)) elif metric == 'overshoot': results.append(self._compute_overshoot(states)) elif metric == 'control_effort': results.append(self._compute_control_effort(controls)) elif metric == 'steady_state_error': results.append(self._compute_steady_state_error(states)) else: raise ValueError(f"Unknown metric: {metric}") return results def _get_theoretical_bounds(self) -> Tuple[List[float], List[float]]: """Get theoretical bounds for optimization.""" return get_gain_bounds_for_pso(SMCType(self.controller_type))

``` ### Multi-Objective Optimization Support ```python
# example-metadata:
# runnable: false class MultiObjectivePSOIntegration: """Multi-objective PSO integration for controller optimization.""" def __init__(self, controller_type: str, objectives: List[str]): self.controller_type = controller_type self.objectives = objectives def create_pareto_optimizer(self) -> Callable: """Create Pareto-optimal PSO optimizer.""" def pareto_objective(gains: np.ndarray) -> List[float]: """Multi-objective function returning Pareto front.""" controller = create_controller(self.controller_type, gains=gains.tolist()) objectives_values = [] for obj in self.objectives: value = self._evaluate_single_objective(controller, obj) objectives_values.append(value) return objectives_values return pareto_objective def _evaluate_single_objective(self, controller, objective: str) -> float: """Evaluate a single objective function.""" # Implementation specific to each objective pass
```

---

## Simulation Engine Integration ### Vector Simulation Protocol The factory integrates with high-performance vector simulation engines: ```python

# example-metadata:

# runnable: false class VectorSimulationIntegration: """Integration with vectorized simulation engines.""" def __init__(self, controller_factory_config: dict): self.factory_config = controller_factory_config def create_batch_simulation( self, controller_types: List[str], gain_sets: List[List[float]], initial_conditions: List[np.ndarray] ) -> Dict[str, np.ndarray]: """Create batch simulation for multiple configurations.""" # Validate inputs assert len(controller_types) == len(gain_sets) assert len(controller_types) == len(initial_conditions) # Create controllers controllers = [] for ctrl_type, gains in zip(controller_types, gain_sets): controller = create_controller(ctrl_type, gains=gains) controllers.append(controller) # Prepare simulation data simulation_config = { 'controllers': controllers, 'initial_conditions': np.array(initial_conditions), 'dt': self.factory_config.get('dt', 0.001), 't_final': self.factory_config.get('t_final', 10.0) } # Run vectorized simulation results = run_vectorized_simulation(simulation_config) return results def create_parameter_sweep( self, controller_type: str, parameter_ranges: Dict[str, Tuple[float, float]], n_samples: int ) -> Dict[str, Any]: """Create parameter sweep simulation.""" # Generate parameter combinations parameter_combinations = self._generate_parameter_combinations( parameter_ranges, n_samples ) # Create controllers for each combination controllers = [] for params in parameter_combinations: controller = create_controller(controller_type, gains=params) controllers.append(controller) # Run batch simulation results = self.create_batch_simulation( [controller_type] * len(controllers), parameter_combinations, [np.zeros(6)] * len(controllers) # Standard initial condition ) return { 'parameters': parameter_combinations, 'results': results, 'analysis': self._analyze_parameter_sweep(results) }

``` ### Real-Time Simulation Support ```python
# example-metadata:
# runnable: false class RealTimeSimulationBridge: """Bridge for real-time simulation integration.""" def __init__(self, controller, dt: float = 0.001): self.controller = controller self.dt = dt self.last_control = 0.0 self.control_history = {} def real_time_step(self, state: np.ndarray, timestamp: float) -> float: """Execute real-time control step.""" try: # Compute control with timing constraints start_time = time.perf_counter() control_result = self.controller.compute_control( state, self.last_control, self.control_history ) computation_time = time.perf_counter() - start_time # Extract control value u = control_result.u if hasattr(control_result, 'u') else control_result # Update state self.last_control = u self.control_history[timestamp] = { 'control': u, 'computation_time': computation_time, 'state': state.copy() } # Validate real-time constraints if computation_time > self.dt: logger.warning( f"Control computation time {computation_time:.6f}s " f"exceeds timestep {self.dt:.6f}s" ) return u except Exception as e: logger.error(f"Real-time control step failed: {e}") return self.last_control # Use last valid control
```

---

## HIL System Integration ### Hardware Interface Protocol ```python

# example-metadata:

# runnable: false class HILIntegrationProtocol: """Hardware-in-the-loop integration protocol.""" def __init__(self, controller_factory, communication_config: dict): self.factory = controller_factory self.comm_config = communication_config self.safety_limits = self._get_safety_limits() def create_hil_controller( self, controller_type: str, gains: List[float], safety_config: dict ) -> 'HILController': """Create HIL-compatible controller with safety features.""" # Create base controller base_controller = create_controller(controller_type, gains=gains) # Wrap with HIL safety layer hil_controller = HILSafetyWrapper( base_controller, safety_config, self.safety_limits ) return hil_controller def _get_safety_limits(self) -> dict: """Get hardware safety limits.""" return { 'max_force': 50.0, # Reduced for hardware safety 'max_angle': np.pi / 6, # 30 degrees maximum 'max_velocity': 10.0, # rad/s 'emergency_stop_conditions': [ 'angle_limit_exceeded', 'velocity_limit_exceeded', 'communication_failure' ] } class HILSafetyWrapper: """Safety wrapper for HIL controllers.""" def __init__(self, controller, safety_config: dict, limits: dict): self.controller = controller self.safety_config = safety_config self.limits = limits self.emergency_stop = False def compute_control(self, state: np.ndarray, *args, **kwargs) -> float: """Compute control with safety checks.""" # Pre-control safety checks if self._check_emergency_conditions(state): self.emergency_stop = True return 0.0 # Emergency stop if self.emergency_stop: return 0.0 # Maintain emergency stop # Compute control try: control_result = self.controller.compute_control(state, *args, **kwargs) u = control_result.u if hasattr(control_result, 'u') else control_result # Post-control safety checks u_safe = self._apply_safety_limits(u, state) return u_safe except Exception as e: logger.error(f"HIL control computation failed: {e}") self.emergency_stop = True return 0.0 def _check_emergency_conditions(self, state: np.ndarray) -> bool: """Check for emergency stop conditions.""" theta1, theta2, x, dtheta1, dtheta2, dx = state # Angle limits if abs(theta1) > self.limits['max_angle']: logger.warning("Pendulum 1 angle limit exceeded") return True if abs(theta2) > self.limits['max_angle']: logger.warning("Pendulum 2 angle limit exceeded") return True # Velocity limits if abs(dtheta1) > self.limits['max_velocity']: logger.warning("Pendulum 1 velocity limit exceeded") return True if abs(dtheta2) > self.limits['max_velocity']: logger.warning("Pendulum 2 velocity limit exceeded") return True return False def _apply_safety_limits(self, control: float, state: np.ndarray) -> float: """Apply safety limits to control signal.""" # Force magnitude limit u_limited = np.clip(control, -self.limits['max_force'], self.limits['max_force']) # Rate limiting (if previous control available) if hasattr(self, '_last_control'): max_rate = self.safety_config.get('max_control_rate', 100.0) # N/s dt = self.safety_config.get('dt', 0.001) max_change = max_rate * dt control_change = u_limited - self._last_control if abs(control_change) > max_change: u_limited = self._last_control + np.sign(control_change) * max_change self._last_control = u_limited return u_limited

```

---

## Configuration Management Protocol ### Unified Configuration Schema ```python
from pydantic import BaseModel, Field
from typing import Dict, Any, Optional, Union class IntegrationConfig(BaseModel): """Unified configuration for cross-domain integration.""" # Controller configuration controller: Dict[str, Any] = Field( description="Controller-specific configuration" ) # Plant model configuration plant_model: Dict[str, Any] = Field( description="Plant model configuration" ) # Simulation configuration simulation: Dict[str, Any] = Field( default_factory=dict, description="Simulation engine configuration" ) # Optimization configuration optimization: Optional[Dict[str, Any]] = Field( default=None, description="PSO optimization configuration" ) # HIL configuration hil: Optional[Dict[str, Any]] = Field( default=None, description="Hardware-in-the-loop configuration" ) # Integration settings integration: Dict[str, Any] = Field( default_factory=lambda: { 'real_time_mode': False, 'safety_enabled': True, 'logging_level': 'INFO' }, description="Integration protocol settings" ) class Config: schema_extra = { "example": { "controller": { "type": "classical_smc", "gains": [5.0, 5.0, 5.0, 0.5, 0.5, 0.5], "max_force": 150.0 }, "plant_model": { "type": "simplified_dip", "m1": 0.5, "m2": 0.5, "l1": 0.5, "l2": 0.5 }, "simulation": { "dt": 0.001, "t_final": 10.0, "integration_method": "rk4" }, "optimization": { "algorithm": "pso", "n_particles": 30, "n_iterations": 100 } } } class ConfigurationValidator: """Validator for integration configurations.""" @staticmethod def validate_integration_config(config: IntegrationConfig) -> bool: """Validate cross-domain configuration consistency.""" # Validate controller-plant compatibility controller_type = config.controller.get('type') plant_type = config.plant_model.get('type') if not ConfigurationValidator._check_controller_plant_compatibility( controller_type, plant_type ): raise ValueError( f"Controller {controller_type} not compatible with plant {plant_type}" ) # Validate real-time constraints if config.integration.get('real_time_mode', False): dt = config.simulation.get('dt', 0.001) if dt < 0.0001: # 100μs minimum for real-time raise ValueError("Real-time mode requires dt ≥ 100μs") # Validate HIL safety requirements if config.hil is not None: max_force = config.controller.get('max_force', 150.0) hil_max_force = config.hil.get('max_safe_force', 50.0) if max_force > hil_max_force: logger.warning( f"Controller max_force ({max_force}) exceeds HIL safety limit ({hil_max_force})" ) return True @staticmethod def _check_controller_plant_compatibility(controller_type: str, plant_type: str) -> bool: """Check if controller and plant types are compatible.""" # Define compatibility matrix compatibility_matrix = { 'classical_smc': ['simplified_dip', 'full_dip'], 'sta_smc': ['simplified_dip', 'full_dip', 'low_rank_dip'], 'adaptive_smc': ['simplified_dip', 'full_dip'], 'hybrid_adaptive_sta_smc': ['simplified_dip', 'full_dip'] } compatible_plants = compatibility_matrix.get(controller_type, []) return plant_type in compatible_plants
```

---

## Data Flow Specifications ### Standard Data Structures ```python

from dataclasses import dataclass
from typing import Optional, Dict, Any
import numpy as np @dataclass
class SystemState: """Standard system state representation.""" timestamp: float state_vector: np.ndarray # [θ₁, θ₂, x, θ̇₁, θ̇₂, ẋ] metadata: Optional[Dict[str, Any]] = None @dataclass
class ControlAction: """Standard control action representation.""" timestamp: float control_value: float controller_state: Optional[Dict[str, Any]] = None computation_time: Optional[float] = None @dataclass
class SimulationResult: """Standard simulation result representation.""" timestamps: np.ndarray states: np.ndarray controls: np.ndarray performance_metrics: Dict[str, float] metadata: Dict[str, Any] @dataclass
class OptimizationResult: """Standard optimization result representation.""" optimal_gains: List[float] optimal_cost: float convergence_history: List[float] optimization_metadata: Dict[str, Any]
``` ### Data Exchange Protocol ```python
# example-metadata:
# runnable: false class DataExchangeBus: """Central data exchange bus for cross-domain communication.""" def __init__(self): self._subscribers = {} self._message_queue = [] def subscribe(self, topic: str, callback: Callable): """Subscribe to data topic.""" if topic not in self._subscribers: self._subscribers[topic] = [] self._subscribers[topic].append(callback) def publish(self, topic: str, data: Any): """Publish data to topic.""" if topic in self._subscribers: for callback in self._subscribers[topic]: try: callback(data) except Exception as e: logger.error(f"Subscriber callback failed: {e}") def get_data_schema(self, topic: str) -> Dict[str, Any]: """Get data schema for topic.""" schemas = { 'system_state': SystemState.__annotations__, 'control_action': ControlAction.__annotations__, 'simulation_result': SimulationResult.__annotations__, 'optimization_result': OptimizationResult.__annotations__ } return schemas.get(topic, {}) # Global data exchange bus instance
data_bus = DataExchangeBus()
```

---

## Interface Contracts ### Contract Validation Framework ```python

# example-metadata:

# runnable: false class InterfaceContract: """Interface contract specification and validation.""" def __init__(self, interface_name: str, requirements: Dict[str, Any]): self.interface_name = interface_name self.requirements = requirements def validate_implementation(self, implementation: Any) -> bool: """Validate that implementation satisfies contract.""" try: for requirement, spec in self.requirements.items(): if requirement == 'methods': self._validate_methods(implementation, spec) elif requirement == 'properties': self._validate_properties(implementation, spec) elif requirement == 'types': self._validate_types(implementation, spec) return True except Exception as e: logger.error(f"Contract validation failed for {self.interface_name}: {e}") return False def _validate_methods(self, implementation: Any, method_specs: Dict[str, Dict]): """Validate required methods.""" for method_name, spec in method_specs.items(): if not hasattr(implementation, method_name): raise AttributeError(f"Missing required method: {method_name}") method = getattr(implementation, method_name) if not callable(method): raise TypeError(f"Attribute {method_name} is not callable") # Validate method signature if specified if 'signature' in spec: self._validate_method_signature(method, spec['signature']) # Define standard contracts

CONTROLLER_CONTRACT = InterfaceContract( 'ControllerInterface', { 'methods': { 'compute_control': { 'signature': { 'args': ['state', 'last_control', 'history'], 'return_type': 'ControlResult' } } }, 'properties': { 'max_force': 'float', 'controller_type': 'str' } }
) PLANT_MODEL_CONTRACT = InterfaceContract( 'PlantModelInterface', { 'methods': { 'compute_dynamics': { 'signature': { 'args': ['state', 'control', 'disturbances'], 'return_type': 'np.ndarray' } }, 'get_linearization': { 'signature': { 'args': ['state', 'control'], 'return_type': 'Tuple[np.ndarray, np.ndarray]' } } }, 'properties': { 'state_dimension': 'int', 'control_dimension': 'int' } }
)
``` ### Contract Testing Framework ```python
# example-metadata:
# runnable: false class ContractTester: """Automated testing framework for interface contracts.""" def __init__(self, contract: InterfaceContract): self.contract = contract def test_implementation(self, implementation: Any) -> Dict[str, bool]: """Test implementation against contract.""" test_results = {} # Test method existence and signatures for method_name in self.contract.requirements.get('methods', {}): test_results[f'method_{method_name}'] = self._test_method( implementation, method_name ) # Test property existence and types for prop_name in self.contract.requirements.get('properties', {}): test_results[f'property_{prop_name}'] = self._test_property( implementation, prop_name ) # Test behavioral requirements test_results['behavioral'] = self._test_behavioral_requirements(implementation) return test_results def _test_behavioral_requirements(self, implementation: Any) -> bool: """Test behavioral requirements specific to interface.""" if self.contract.interface_name == 'ControllerInterface': return self._test_controller_behavior(implementation) elif self.contract.interface_name == 'PlantModelInterface': return self._test_plant_model_behavior(implementation) return True def _test_controller_behavior(self, controller: Any) -> bool: """Test controller-specific behavioral requirements.""" try: # Test with standard state test_state = np.array([0.1, 0.05, 0.0, 0.0, 0.0, 0.0]) result = controller.compute_control(test_state, 0.0, {}) # Validate result structure if hasattr(result, 'u'): control_value = result.u else: control_value = result # Check control bounds max_force = getattr(controller, 'max_force', 150.0) if abs(control_value) > max_force: logger.warning("Control value exceeds max_force limit") return False return True except Exception as e: logger.error(f"Controller behavioral test failed: {e}") return False
```

---

## Conclusion The integration protocols and cross-domain specifications provide a framework for interaction between all components of the DIP-SMC system. These protocols ensure: 1. **Type Safety**: Strong typing and contract validation across all interfaces

2. **Error Resilience**: Graceful handling of failures in any domain
3. **Performance**: Optimized data flow for real-time operations
4. **Extensibility**: Support for adding new domains and components
5. **Safety**: Hardware protection through layered safety mechanisms The modular design enables independent development and testing of components while maintaining system-wide integration integrity. The formal contract system ensures that all components adhere to expected interfaces, reducing integration errors and improving system reliability.