<!doctype html>
<html class="no-js" lang="en" data-content_root="../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
.chartjs-container {
    margin: 1.5em auto;
    padding: 1em;
    background: #f8f9fa;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.chart-note {
    text-align: center;
    color: #6c757d;
    font-size: 0.9em;
    margin-top: 0.5em;
}
</style>
<link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" /><link rel="next" title="controllers.smc.init" href="smc___init__.html" /><link rel="prev" title="controllers.smc.hybrid_adaptive_sta_smc" href="smc_hybrid_adaptive_sta_smc.html" />

    <!-- Generated with Sphinx 7.4.7 and Furo 2024.08.06 -->
        <title>controllers.smc.sta_smc - DIP_SMC_PSO Documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=5349f25f" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?v=302659d7" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=f5a89ef9" />
    
    


<style>
  body {
    --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">DIP_SMC_PSO Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">DIP_SMC_PSO Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">📚 Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../README.html">Optimal Sliding Mode Control for a Double-Inverted Pendulum via PSO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../theory_overview.html">1. Theoretical Background â€” Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../architecture.html">3. System Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../plant_model.html">1.x Plant Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hil_quickstart.html">Hardware-in-the-Loop (HIL) Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../streamlit_dashboard_guide.html">Streamlit Dashboard User Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">🎮 Control Systems &amp; Optimization</span></p>
<ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="../../controllers/index.html">Controllers Module Documentation</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Controllers Module Documentation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../controllers/classical_smc_technical_guide.html">Classical Sliding Mode Control Technical Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../controllers/adaptive_smc_technical_guide.html">Adaptive Sliding Mode Control Technical Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../controllers/sta_smc_technical_guide.html">Super-Twisting Sliding Mode Control Technical Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../controllers/hybrid_smc_technical_guide.html">Hybrid Adaptive Super-Twisting SMC Technical Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../controllers/mpc_technical_guide.html">Model Predictive Control Technical Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../controllers/swing_up_smc_technical_guide.html">Swing-Up SMC Technical Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../controllers/swing_up_smc_technical_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../controllers/swing_up_smc_technical_guide.html#runnable-false">runnable: false</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../controllers/factory_system_guide.html">SMC Controller Factory System Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../controllers/control_primitives_reference.html">Control Primitives Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mathematical_foundations/smc_complete_theory.html">Complete Sliding Mode Control Mathematical Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mathematical_foundations/controller_comparison_theory.html">SMC Controller Comparison Theory</a></li>
<li class="toctree-l2 current has-children"><a class="reference internal" href="index.html">Controllers Module</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Controllers Module</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="adaptive_smc.html">controllers.adaptive_smc</a></li>
<li class="toctree-l3"><a class="reference internal" href="classic_smc.html">controllers.classic_smc</a></li>
<li class="toctree-l3"><a class="reference internal" href="factory.html">controllers.factory</a></li>
<li class="toctree-l3"><a class="reference internal" href="mpc_controller.html">controllers.mpc_controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="sta_smc.html">controllers.sta_smc</a></li>
<li class="toctree-l3"><a class="reference internal" href="swing_up_smc.html">controllers.swing_up_smc</a></li>
<li class="toctree-l3"><a class="reference internal" href="__init__.html">controllers.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="base_controller_interface.html">controllers.base.controller_interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="base_control_primitives.html">controllers.base.control_primitives</a></li>
<li class="toctree-l3"><a class="reference internal" href="base___init__.html">controllers.base.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="factory_deprecation.html">controllers.factory.deprecation</a></li>
<li class="toctree-l3"><a class="reference internal" href="factory_fallback_configs.html">controllers.factory.fallback_configs</a></li>
<li class="toctree-l3"><a class="reference internal" href="factory_legacy_factory.html">controllers.factory.legacy_factory</a></li>
<li class="toctree-l3"><a class="reference internal" href="factory_optimization.html">controllers.factory.optimization</a></li>
<li class="toctree-l3"><a class="reference internal" href="factory_pso_integration.html">controllers.factory.pso_integration</a></li>
<li class="toctree-l3"><a class="reference internal" href="factory_smc_factory.html">controllers.factory.smc_factory</a></li>
<li class="toctree-l3"><a class="reference internal" href="factory_thread_safety.html">controllers.factory.thread_safety</a></li>
<li class="toctree-l3"><a class="reference internal" href="factory___init__.html">controllers.factory.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="mpc_mpc_controller.html">controllers.mpc.mpc_controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="mpc___init__.html">controllers.mpc.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_adaptive_smc.html">controllers.smc.adaptive_smc</a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_classic_smc.html">controllers.smc.classic_smc</a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_hybrid_adaptive_sta_smc.html">controllers.smc.hybrid_adaptive_sta_smc</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">controllers.smc.sta_smc</a></li>
<li class="toctree-l3"><a class="reference internal" href="smc___init__.html">controllers.smc.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="specialized_swing_up_smc.html">controllers.specialized.swing_up_smc</a></li>
<li class="toctree-l3"><a class="reference internal" href="specialized___init__.html">controllers.specialized.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="factory_core_protocols.html">controllers.factory.core.protocols</a></li>
<li class="toctree-l3"><a class="reference internal" href="factory_core_registry.html">controllers.factory.core.registry</a></li>
<li class="toctree-l3"><a class="reference internal" href="factory_core_threading.html">controllers.factory.core.threading</a></li>
<li class="toctree-l3"><a class="reference internal" href="factory_core_validation.html">controllers.factory.core.validation</a></li>
<li class="toctree-l3"><a class="reference internal" href="factory_core___init__.html">controllers.factory.core.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_algorithms___init__.html">controllers.smc.algorithms.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_core_equivalent_control.html">controllers.smc.core.equivalent_control</a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_core_gain_validation.html">controllers.smc.core.gain_validation</a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_core_sliding_surface.html">controllers.smc.core.sliding_surface</a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_core_switching_functions.html">controllers.smc.core.switching_functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_core___init__.html">controllers.smc.core.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_algorithms_adaptive_adaptation_law.html">controllers.smc.algorithms.adaptive.adaptation_law</a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_algorithms_adaptive_config.html">controllers.smc.algorithms.adaptive.config</a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_algorithms_adaptive_controller.html">controllers.smc.algorithms.adaptive.controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_algorithms_adaptive_parameter_estimation.html">controllers.smc.algorithms.adaptive.parameter_estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_algorithms_adaptive___init__.html">controllers.smc.algorithms.adaptive.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_algorithms_classical_boundary_layer.html">controllers.smc.algorithms.classical.boundary_layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_algorithms_classical_config.html">controllers.smc.algorithms.classical.config</a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_algorithms_classical_controller.html">controllers.smc.algorithms.classical.controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_algorithms_classical___init__.html">controllers.smc.algorithms.classical.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_algorithms_hybrid_config.html">controllers.smc.algorithms.hybrid.config</a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_algorithms_hybrid_controller.html">controllers.smc.algorithms.hybrid.controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_algorithms_hybrid_switching_logic.html">controllers.smc.algorithms.hybrid.switching_logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_algorithms_hybrid___init__.html">controllers.smc.algorithms.hybrid.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_algorithms_super_twisting_config.html">controllers.smc.algorithms.super_twisting.config</a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_algorithms_super_twisting_controller.html">controllers.smc.algorithms.super_twisting.controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_algorithms_super_twisting_twisting_algorithm.html">controllers.smc.algorithms.super_twisting.twisting_algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="smc_algorithms_super_twisting___init__.html">controllers.smc.algorithms.super_twisting.<strong>init</strong></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../mathematical_foundations/index.html">Mathematical Foundations</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Mathematical Foundations</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../mathematical_foundations/smc_complete_theory.html">Complete Sliding Mode Control Mathematical Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../mathematical_foundations/controller_comparison_theory.html">SMC Controller Comparison Theory</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../plant/models_guide.html">Plant Models Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../optimization_simulation/guide.html">Optimization &amp; Simulation Guide</a></li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">Controllers Module</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of Controllers Module</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="adaptive_smc.html">controllers.adaptive_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="classic_smc.html">controllers.classic_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory.html">controllers.factory</a></li>
<li class="toctree-l2"><a class="reference internal" href="mpc_controller.html">controllers.mpc_controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="sta_smc.html">controllers.sta_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="swing_up_smc.html">controllers.swing_up_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="__init__.html">controllers.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="base_controller_interface.html">controllers.base.controller_interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="base_control_primitives.html">controllers.base.control_primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="base___init__.html">controllers.base.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_deprecation.html">controllers.factory.deprecation</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_fallback_configs.html">controllers.factory.fallback_configs</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_legacy_factory.html">controllers.factory.legacy_factory</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_optimization.html">controllers.factory.optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_pso_integration.html">controllers.factory.pso_integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_smc_factory.html">controllers.factory.smc_factory</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_thread_safety.html">controllers.factory.thread_safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory___init__.html">controllers.factory.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="mpc_mpc_controller.html">controllers.mpc.mpc_controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="mpc___init__.html">controllers.mpc.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_adaptive_smc.html">controllers.smc.adaptive_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_classic_smc.html">controllers.smc.classic_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_hybrid_adaptive_sta_smc.html">controllers.smc.hybrid_adaptive_sta_smc</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">controllers.smc.sta_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc___init__.html">controllers.smc.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="specialized_swing_up_smc.html">controllers.specialized.swing_up_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="specialized___init__.html">controllers.specialized.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_core_protocols.html">controllers.factory.core.protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_core_registry.html">controllers.factory.core.registry</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_core_threading.html">controllers.factory.core.threading</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_core_validation.html">controllers.factory.core.validation</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_core___init__.html">controllers.factory.core.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_algorithms___init__.html">controllers.smc.algorithms.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_core_equivalent_control.html">controllers.smc.core.equivalent_control</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_core_gain_validation.html">controllers.smc.core.gain_validation</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_core_sliding_surface.html">controllers.smc.core.sliding_surface</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_core_switching_functions.html">controllers.smc.core.switching_functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_core___init__.html">controllers.smc.core.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_algorithms_adaptive_adaptation_law.html">controllers.smc.algorithms.adaptive.adaptation_law</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_algorithms_adaptive_config.html">controllers.smc.algorithms.adaptive.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_algorithms_adaptive_controller.html">controllers.smc.algorithms.adaptive.controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_algorithms_adaptive_parameter_estimation.html">controllers.smc.algorithms.adaptive.parameter_estimation</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_algorithms_adaptive___init__.html">controllers.smc.algorithms.adaptive.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_algorithms_classical_boundary_layer.html">controllers.smc.algorithms.classical.boundary_layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_algorithms_classical_config.html">controllers.smc.algorithms.classical.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_algorithms_classical_controller.html">controllers.smc.algorithms.classical.controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_algorithms_classical___init__.html">controllers.smc.algorithms.classical.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_algorithms_hybrid_config.html">controllers.smc.algorithms.hybrid.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_algorithms_hybrid_controller.html">controllers.smc.algorithms.hybrid.controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_algorithms_hybrid_switching_logic.html">controllers.smc.algorithms.hybrid.switching_logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_algorithms_hybrid___init__.html">controllers.smc.algorithms.hybrid.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_algorithms_super_twisting_config.html">controllers.smc.algorithms.super_twisting.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_algorithms_super_twisting_controller.html">controllers.smc.algorithms.super_twisting.controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_algorithms_super_twisting_twisting_algorithm.html">controllers.smc.algorithms.super_twisting.twisting_algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="smc_algorithms_super_twisting___init__.html">controllers.smc.algorithms.super_twisting.<strong>init</strong></a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../optimizer/index.html">Optimizer Module</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of Optimizer Module</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../optimizer/pso_optimizer.html">optimizer.pso_optimizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../optimizer/__init__.html">optimizer.<strong>init</strong></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../analysis_plan.html">5. Analysis &amp; Verification Plan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../benchmarks_methodology.html">Benchmarks &amp; Methodology</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">🧪 Development &amp; Testing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../TESTING.html">Testing Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../test_protocols.html">5.x Test Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../use_cases.html">4. Use Cases &amp; Operating Modes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../context.html">2. Application Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fault_detection_guide.html">Fault Detection &amp; Isolation (FDI) Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">📊 Research &amp; Theory</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../presentation/index.html">Research Presentation Materials</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle navigation of Research Presentation Materials</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/introduction.html">Abstract</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/introduction.html#introduction-and-motivation">Introduction and Motivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/introduction.html#the-double-inverted-pendulum-as-a-canonical-control-problem">The Double Inverted Pendulum as a Canonical Control Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/introduction.html#the-primary-control-objectives-and-challenges">The Primary Control Objectives and Challenges</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/introduction.html#sliding-mode-control-as-a-robust-solution">Sliding Mode Control as a Robust Solution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/introduction.html#the-gain-tuning-dilemma-and-the-need-for-optimization">The Gain Tuning Dilemma and the Need for Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/introduction.html#particle-swarm-optimization-for-automated-design">Particle Swarm Optimization for Automated Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/introduction.html#synthesis-and-motivation">Synthesis and Motivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/introduction.html#references">References</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/problem-statement.html">Problem Statement for Double‑Inverted Pendulum (DIP) Control with SMC and PSO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/previous-works.html">Previous Work Before the Project</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/system-modeling.html"><strong>A Comprehensive Technical Report on the Modeling and Configuration of a Cart‑Based Double Inverted Pendulum System</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/smc-theory.html">Sliding Mode Control for a Double‑Inverted Pendulum: Bridging Theory and Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/chattering-mitigation.html">Abstract</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/chattering-mitigation.html#introduction">1 Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/chattering-mitigation.html#system-modelling-and-problem-formulation">2 System Modelling and Problem Formulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/chattering-mitigation.html#simulation-methodology">3 Simulation Methodology</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/chattering-mitigation.html#classic-sliding-mode-control">4 Classic Sliding Mode Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/chattering-mitigation.html#chattering-mitigation-strategy-i-boundary-layer-method">5 Chattering Mitigation Strategy I: Boundary Layer Method</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/chattering-mitigation.html#chattering-mitigation-strategy-ii-supertwisting-algorithm">6 Chattering Mitigation Strategy II: Super‑Twisting Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/chattering-mitigation.html#chattering-mitigation-strategy-iii-adaptive-sliding-mode-control">7 Chattering Mitigation Strategy III: Adaptive Sliding Mode Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/chattering-mitigation.html#chattering-mitigation-strategy-iv-hybrid-adaptivesta">8 Chattering Mitigation Strategy IV: Hybrid Adaptive–STA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/chattering-mitigation.html#synthesis-and-comparative-analysis">9 Synthesis and Comparative Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/chattering-mitigation.html#references">References</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/pso-optimization.html"><strong>Comprehensive Simulation Analysis and Enhancements for the Double Inverted Pendulum Control System</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/simulation-setup.html">Particle Swarm Optimization for Sliding‑Mode Controller Tuning of a Double Inverted Pendulum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/results-discussion.html">8 – Results and Discussion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../presentation/results-discussion.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/introduction.html">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/introduction.html#introduction-and-motivation">Introduction and Motivation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/introduction.html#the-double-inverted-pendulum-as-a-canonical-control-problem">The Double Inverted Pendulum as a Canonical Control Problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/introduction.html#the-primary-control-objectives-and-challenges">The Primary Control Objectives and Challenges</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/introduction.html#sliding-mode-control-as-a-robust-solution">Sliding Mode Control as a Robust Solution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/introduction.html#the-gain-tuning-dilemma-and-the-need-for-optimization">The Gain Tuning Dilemma and the Need for Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/introduction.html#particle-swarm-optimization-for-automated-design">Particle Swarm Optimization for Automated Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/introduction.html#synthesis-and-motivation">Synthesis and Motivation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/introduction.html#references">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/problem-statement.html">Problem Statement for Double‑Inverted Pendulum (DIP) Control with SMC and PSO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/previous-works.html">Previous Work Before the Project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/system-modeling.html"><strong>A Comprehensive Technical Report on the Modeling and Configuration of a Cart‑Based Double Inverted Pendulum System</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/smc-theory.html">Sliding Mode Control for a Double‑Inverted Pendulum: Bridging Theory and Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/chattering-mitigation.html">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/chattering-mitigation.html#introduction">1 Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/chattering-mitigation.html#system-modelling-and-problem-formulation">2 System Modelling and Problem Formulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/chattering-mitigation.html#simulation-methodology">3 Simulation Methodology</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/chattering-mitigation.html#classic-sliding-mode-control">4 Classic Sliding Mode Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/chattering-mitigation.html#chattering-mitigation-strategy-i-boundary-layer-method">5 Chattering Mitigation Strategy I: Boundary Layer Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/chattering-mitigation.html#chattering-mitigation-strategy-ii-supertwisting-algorithm">6 Chattering Mitigation Strategy II: Super‑Twisting Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/chattering-mitigation.html#chattering-mitigation-strategy-iii-adaptive-sliding-mode-control">7 Chattering Mitigation Strategy III: Adaptive Sliding Mode Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/chattering-mitigation.html#chattering-mitigation-strategy-iv-hybrid-adaptivesta">8 Chattering Mitigation Strategy IV: Hybrid Adaptive–STA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/chattering-mitigation.html#synthesis-and-comparative-analysis">9 Synthesis and Comparative Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/chattering-mitigation.html#references">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/pso-optimization.html"><strong>Comprehensive Simulation Analysis and Enhancements for the Double Inverted Pendulum Control System</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/simulation-setup.html">Particle Swarm Optimization for Sliding‑Mode Controller Tuning of a Double Inverted Pendulum</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/results-discussion.html">8 – Results and Discussion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../presentation/results-discussion.html#references">References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">📖 API Reference &amp; Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">API Reference Documentation</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../examples/index.html">Examples</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle navigation of Examples</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../bibliography.html">Bibliography &amp; Academic References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">🔧 Project Management</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../CONTRIBUTING.html">Contributing – ResearchPlanSpec Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../RELEASE_CHECKLIST.html">Release Checklist</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CHANGELOG.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../symbols.html">Symbols &amp; Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../results_readme.html">Results &amp; Plots</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">📚 Citations &amp; Attribution</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../CITATIONS.html">Citations &amp; Academic Attribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CITATIONS_ACADEMIC.html">Academic Theory Citations &amp; References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../DEPENDENCIES.html">Software Dependencies &amp; Citations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PATTERNS.html">Software Design Patterns &amp; Architecture Attribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../LICENSES.html">License Compliance &amp; Attribution</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/blob/main/docs/reference/controllers/smc_sta_smc.md?plain=true" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div><div class="edit-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/edit/main/docs/reference/controllers/smc_sta_smc.md" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section class="tex2jax_ignore mathjax_ignore" id="controllers-smc-sta-smc">
<h1>controllers.smc.sta_smc<a class="headerlink" href="#controllers-smc-sta-smc" title="Link to this heading">¶</a></h1>
<p><strong>Source:</strong> <code class="docutils literal notranslate"><span class="pre">src\controllers\smc\sta_smc.py</span></code></p>
<section id="module-overview">
<h2>Module Overview<a class="headerlink" href="#module-overview" title="Link to this heading">¶</a></h2>
<p><em>No module docstring available.</em></p>
</section>
<section id="complete-source-code">
<h2>Complete Source Code<a class="headerlink" href="#complete-source-code" title="Link to this heading">¶</a></h2>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">  1</span><span class="c1">#======================================================================================\\\</span>
<span class="linenos">  2</span><span class="c1">#=========================== src/controllers/smc/sta_smc.py ===========================\\\</span>
<span class="linenos">  3</span><span class="c1">#======================================================================================\\\</span>
<span class="linenos">  4</span>
<span class="linenos">  5</span><span class="c1"># Changed: enforce strict positivity of algorithmic and sliding‑surface gains (K1, K2, k1, k2, λ1, λ2);</span>
<span class="linenos">  6</span><span class="c1"># added corresponding validation logic in __init__; updated the class docstring to include a</span>
<span class="linenos">  7</span><span class="c1"># gain‑positivity section citing super‑twisting literature; these changes address F‑4.SMCDesign.2 / RC‑04.</span>
<span class="linenos">  8</span><span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>
<span class="linenos">  9</span><span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="linenos"> 10</span><span class="kn">import</span><span class="w"> </span><span class="nn">weakref</span>
<span class="linenos"> 11</span><span class="c1"># ---------------------------------------------------------------------------</span>
<span class="linenos"> 12</span><span class="c1"># Optional numba import</span>
<span class="linenos"> 13</span><span class="c1">#</span>
<span class="linenos"> 14</span><span class="c1"># The super‑twisting SMC controller uses Numba to accelerate inner loops.</span>
<span class="linenos"> 15</span><span class="c1"># Provide a fallback implementation when Numba is unavailable so that this</span>
<span class="linenos"> 16</span><span class="c1"># module can be imported without raising a ModuleNotFoundError.  The dummy</span>
<span class="linenos"> 17</span><span class="c1"># object supplies an ``njit`` decorator that simply returns the original</span>
<span class="linenos"> 18</span><span class="c1"># function unchanged.</span>
<span class="linenos"> 19</span><span class="k">try</span><span class="p">:</span>
<span class="linenos"> 20</span>    <span class="kn">import</span><span class="w"> </span><span class="nn">numba</span>  <span class="c1"># type: ignore</span>
<span class="linenos"> 21</span><span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>  <span class="c1"># pragma: no cover - fallback when numba is missing</span>
<span class="linenos"> 22</span>    <span class="k">class</span><span class="w"> </span><span class="nc">_DummyNumba</span><span class="p">:</span>
<span class="linenos"> 23</span>        <span class="k">def</span><span class="w"> </span><span class="nf">njit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># type: ignore</span>
<span class="linenos"> 24</span>            <span class="k">def</span><span class="w"> </span><span class="nf">deco</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
<span class="linenos"> 25</span>                <span class="k">return</span> <span class="n">fn</span>
<span class="linenos"> 26</span>            <span class="k">return</span> <span class="n">deco</span>
<span class="linenos"> 27</span>    <span class="n">numba</span> <span class="o">=</span> <span class="n">_DummyNumba</span><span class="p">()</span>  <span class="c1"># type: ignore</span>
<span class="linenos"> 28</span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="linenos"> 29</span><span class="c1"># Import from new organized structure</span>
<span class="linenos"> 30</span><span class="kn">from</span><span class="w"> </span><span class="nn">...utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">saturate</span>
<span class="linenos"> 31</span><span class="kn">from</span><span class="w"> </span><span class="nn">...utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">STAOutput</span>
<span class="linenos"> 32</span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Union</span>
<span class="linenos"> 33</span>
<span class="linenos"> 34</span><span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="linenos"> 35</span><span class="k">def</span><span class="w"> </span><span class="nf">_sta_smc_control_numba</span><span class="p">(</span>
<span class="linenos"> 36</span>    <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span class="linenos"> 37</span>    <span class="n">z</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 38</span>    <span class="n">alg_gain_K1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">alg_gain_K2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">surf_gain_k1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">surf_gain_k2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">surf_lam1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">surf_lam2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 39</span>    <span class="n">damping_gain</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">max_force</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">boundary_layer</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 40</span>    <span class="n">u_eq</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="linenos"> 41</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="linenos"> 42</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos"> 43</span><span class="sd">    Numba‑accelerated core of the Super‑Twisting SMC.</span>
<span class="linenos"> 44</span>
<span class="linenos"> 45</span><span class="sd">    Uses a saturated sign function for sigma to maintain full control authority</span>
<span class="linenos"> 46</span><span class="sd">    outside the boundary layer and linear behavior inside it, which is required</span>
<span class="linenos"> 47</span><span class="sd">    for robust, finite‑time convergence of the super‑twisting algorithm.</span>
<span class="linenos"> 48</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 49</span>    <span class="n">_</span><span class="p">,</span> <span class="n">th1</span><span class="p">,</span> <span class="n">th2</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">th1dot</span><span class="p">,</span> <span class="n">th2dot</span> <span class="o">=</span> <span class="n">state</span>
<span class="linenos"> 50</span>
<span class="linenos"> 51</span>    <span class="c1"># Sliding surface: sigma = k1*(th1dot + lam1*th1) + k2*(th2dot + lam2*th2)</span>
<span class="linenos"> 52</span>    <span class="n">sigma</span> <span class="o">=</span> <span class="n">surf_gain_k1</span> <span class="o">*</span> <span class="p">(</span><span class="n">th1dot</span> <span class="o">+</span> <span class="n">surf_lam1</span> <span class="o">*</span> <span class="n">th1</span><span class="p">)</span> <span class="o">+</span> <span class="n">surf_gain_k2</span> <span class="o">*</span> <span class="p">(</span><span class="n">th2dot</span> <span class="o">+</span> <span class="n">surf_lam2</span> <span class="o">*</span> <span class="n">th2</span><span class="p">)</span>
<span class="linenos"> 53</span>
<span class="linenos"> 54</span>    <span class="c1"># ---- FIX CS‑01: robust saturation instead of &quot;sigma/(|sigma|+eps)&quot; ----</span>
<span class="linenos"> 55</span>    <span class="n">eps</span> <span class="o">=</span> <span class="n">boundary_layer</span>  <span class="c1"># guaranteed &gt; 0 by __init__</span>
<span class="linenos"> 56</span>    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">:</span>
<span class="linenos"> 57</span>        <span class="n">sgn_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>        <span class="c1"># full control authority</span>
<span class="linenos"> 58</span>    <span class="k">else</span><span class="p">:</span>
<span class="linenos"> 59</span>        <span class="n">sgn_sigma</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">/</span> <span class="n">eps</span>           <span class="c1"># linear inside boundary layer</span>
<span class="linenos"> 60</span>    <span class="c1"># -----------------------------------------------------------------------</span>
<span class="linenos"> 61</span>
<span class="linenos"> 62</span>    <span class="c1"># Super‑twisting continuous term and disturbance‑like internal state</span>
<span class="linenos"> 63</span>    <span class="n">u_cont</span> <span class="o">=</span> <span class="o">-</span><span class="n">alg_gain_K1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span> <span class="o">*</span> <span class="n">sgn_sigma</span>
<span class="linenos"> 64</span>    <span class="c1"># Use the previous z (integral state) for the disturbance term.  In the</span>
<span class="linenos"> 65</span>    <span class="c1"># continuous super‑twisting algorithm, the integral term z enters the</span>
<span class="linenos"> 66</span>    <span class="c1"># control law directly and is updated after computing the control.  The</span>
<span class="linenos"> 67</span>    <span class="c1"># earlier implementation incorrectly used the updated z in the same step.</span>
<span class="linenos"> 68</span>    <span class="n">u_dis</span> <span class="o">=</span> <span class="n">z</span>
<span class="linenos"> 69</span>    <span class="n">new_z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">alg_gain_K2</span> <span class="o">*</span> <span class="n">sgn_sigma</span> <span class="o">*</span> <span class="n">dt</span>
<span class="linenos"> 70</span>
<span class="linenos"> 71</span>    <span class="c1"># Damping on sigma (optional)</span>
<span class="linenos"> 72</span>    <span class="n">u</span> <span class="o">=</span> <span class="n">u_eq</span> <span class="o">+</span> <span class="n">u_cont</span> <span class="o">+</span> <span class="n">u_dis</span> <span class="o">-</span> <span class="n">damping_gain</span> <span class="o">*</span> <span class="n">sigma</span>
<span class="linenos"> 73</span>
<span class="linenos"> 74</span>    <span class="c1"># Saturate final outputs to actuator limits.  Numba cannot</span>
<span class="linenos"> 75</span>    <span class="c1"># compile np.clip on scalars when running in nopython mode.  Use</span>
<span class="linenos"> 76</span>    <span class="c1"># explicit conditional clamps instead.</span>
<span class="linenos"> 77</span>    <span class="k">if</span> <span class="n">u</span> <span class="o">&gt;</span> <span class="n">max_force</span><span class="p">:</span>
<span class="linenos"> 78</span>        <span class="n">u</span> <span class="o">=</span> <span class="n">max_force</span>
<span class="linenos"> 79</span>    <span class="k">elif</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">max_force</span><span class="p">:</span>
<span class="linenos"> 80</span>        <span class="n">u</span> <span class="o">=</span> <span class="o">-</span><span class="n">max_force</span>
<span class="linenos"> 81</span>    <span class="k">if</span> <span class="n">new_z</span> <span class="o">&gt;</span> <span class="n">max_force</span><span class="p">:</span>
<span class="linenos"> 82</span>        <span class="n">new_z</span> <span class="o">=</span> <span class="n">max_force</span>
<span class="linenos"> 83</span>    <span class="k">elif</span> <span class="n">new_z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">max_force</span><span class="p">:</span>
<span class="linenos"> 84</span>        <span class="n">new_z</span> <span class="o">=</span> <span class="o">-</span><span class="n">max_force</span>
<span class="linenos"> 85</span>    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">new_z</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
<span class="linenos"> 86</span>
<span class="linenos"> 87</span>
<span class="linenos"> 88</span><span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="linenos"> 89</span><span class="k">def</span><span class="w"> </span><span class="nf">_sta_smc_core</span><span class="p">(</span>
<span class="linenos"> 90</span>    <span class="n">z</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 91</span>    <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 92</span>    <span class="n">sgn_sigma</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 93</span>    <span class="n">alg_gain_K1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 94</span>    <span class="n">alg_gain_K2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 95</span>    <span class="n">damping_gain</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 96</span>    <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 97</span>    <span class="n">max_force</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 98</span>    <span class="n">u_eq</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span class="linenos"> 99</span>    <span class="n">Kaw</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span class="linenos">100</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="linenos">101</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Numba-accelerated core using precomputed sigma and its saturated sign.</span>
<span class="linenos">102</span>
<span class="linenos">103</span><span class="sd">    Includes anti-windup back‑calculation: the integrator state ``z`` is</span>
<span class="linenos">104</span><span class="sd">    updated using the difference between the saturated and unsaturated</span>
<span class="linenos">105</span><span class="sd">    control multiplied by ``Kaw``【789743582768797†L224-L249】.  Returns</span>
<span class="linenos">106</span><span class="sd">    ``(u_saturated, new_z, sigma)``.</span>
<span class="linenos">107</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">108</span>    <span class="c1"># Continuous term and disturbance‑like internal state</span>
<span class="linenos">109</span>    <span class="n">u_cont</span> <span class="o">=</span> <span class="o">-</span><span class="n">alg_gain_K1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span> <span class="o">*</span> <span class="n">sgn_sigma</span>
<span class="linenos">110</span>    <span class="n">u_dis</span> <span class="o">=</span> <span class="n">z</span>
<span class="linenos">111</span>    <span class="c1"># Compute unsaturated control</span>
<span class="linenos">112</span>    <span class="n">u_raw</span> <span class="o">=</span> <span class="n">u_eq</span> <span class="o">+</span> <span class="n">u_cont</span> <span class="o">+</span> <span class="n">u_dis</span> <span class="o">-</span> <span class="n">damping_gain</span> <span class="o">*</span> <span class="n">sigma</span>
<span class="linenos">113</span>    <span class="c1"># Saturate the control</span>
<span class="linenos">114</span>    <span class="n">u_sat</span> <span class="o">=</span> <span class="n">u_raw</span>
<span class="linenos">115</span>    <span class="k">if</span> <span class="n">u_sat</span> <span class="o">&gt;</span> <span class="n">max_force</span><span class="p">:</span>
<span class="linenos">116</span>        <span class="n">u_sat</span> <span class="o">=</span> <span class="n">max_force</span>
<span class="linenos">117</span>    <span class="k">elif</span> <span class="n">u_sat</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">max_force</span><span class="p">:</span>
<span class="linenos">118</span>        <span class="n">u_sat</span> <span class="o">=</span> <span class="o">-</span><span class="n">max_force</span>
<span class="linenos">119</span>    <span class="c1"># Anti-windup back‑calculation: adjust integrator when saturation occurs</span>
<span class="linenos">120</span>    <span class="n">new_z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">alg_gain_K2</span> <span class="o">*</span> <span class="n">sgn_sigma</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">+</span> <span class="n">Kaw</span> <span class="o">*</span> <span class="p">(</span><span class="n">u_sat</span> <span class="o">-</span> <span class="n">u_raw</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
<span class="linenos">121</span>    <span class="c1"># Saturate the integrator to maintain boundedness</span>
<span class="linenos">122</span>    <span class="k">if</span> <span class="n">new_z</span> <span class="o">&gt;</span> <span class="n">max_force</span><span class="p">:</span>
<span class="linenos">123</span>        <span class="n">new_z</span> <span class="o">=</span> <span class="n">max_force</span>
<span class="linenos">124</span>    <span class="k">elif</span> <span class="n">new_z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">max_force</span><span class="p">:</span>
<span class="linenos">125</span>        <span class="n">new_z</span> <span class="o">=</span> <span class="o">-</span><span class="n">max_force</span>
<span class="linenos">126</span>    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">u_sat</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">new_z</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
<span class="linenos">127</span> 
<span class="linenos">128</span>
<span class="linenos">129</span><span class="k">class</span><span class="w"> </span><span class="nc">SuperTwistingSMC</span><span class="p">:</span>
<span class="linenos">130</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">131</span><span class="sd">    Second‑order (super‑twisting) sliding‑mode controller for the double‑inverted pendulum.</span>
<span class="linenos">132</span>
<span class="linenos">133</span><span class="sd">    This controller implements the super‑twisting algorithm, a higher‑order</span>
<span class="linenos">134</span><span class="sd">    sliding‑mode technique that achieves finite‑time convergence without</span>
<span class="linenos">135</span><span class="sd">    requiring direct measurement of the sliding surface derivative.  Compared</span>
<span class="linenos">136</span><span class="sd">    with conventional (first‑order) sliding‑mode control, the super‑twisting</span>
<span class="linenos">137</span><span class="sd">    algorithm is known to mitigate chattering and reduce control effort,</span>
<span class="linenos">138</span><span class="sd">    offering improved tracking accuracy.  The</span>
<span class="linenos">139</span><span class="sd">    implementation uses a continuous saturation function within a boundary</span>
<span class="linenos">140</span><span class="sd">    layer ``ε`` to approximate the sign of the sliding variable σ,</span>
<span class="linenos">141</span><span class="sd">    consistent with the boundary‑layer approach for chattering reduction</span>
<span class="linenos">142</span><span class="sd">   .  The size of ``ε`` therefore controls</span>
<span class="linenos">143</span><span class="sd">    the trade‑off between chattering attenuation and steady‑state accuracy</span>
<span class="linenos">144</span><span class="sd">   .</span>
<span class="linenos">145</span>
<span class="linenos">146</span><span class="sd">    **Gains:**</span>
<span class="linenos">147</span>
<span class="linenos">148</span><span class="sd">      - If a 2‑element sequence ``[K1, K2]`` is provided, the sliding‑surface</span>
<span class="linenos">149</span><span class="sd">        gains and poles ``(k1, k2, λ1, λ2)`` are set to default values.</span>
<span class="linenos">150</span><span class="sd">      - A 6‑element sequence ``[K1, K2, k1, k2, λ1, λ2]`` specifies all</span>
<span class="linenos">151</span><span class="sd">        super‑twisting and surface parameters explicitly.</span>
<span class="linenos">152</span>
<span class="linenos">153</span><span class="sd">    **Sliding surface:**</span>
<span class="linenos">154</span>
<span class="linenos">155</span><span class="sd">    .. math::</span>
<span class="linenos">156</span><span class="sd">        \\sigma = k_1\\,(\\dot{\\theta}_1 + \\lambda_1\\,\\theta_1) + k_2\\,(\\dot{\\theta}_2 + \\lambda_2\\,\\theta_2).</span>
<span class="linenos">157</span>
<span class="linenos">158</span><span class="sd">    **Discrete‑time control law:**</span>
<span class="linenos">159</span>
<span class="linenos">160</span><span class="sd">    .. math::</span>
<span class="linenos">161</span><span class="sd">        \\begin{aligned}</span>
<span class="linenos">162</span><span class="sd">        u &amp;= u_{\\\\text{eq}} - K_1 \\\\sqrt{|\\\\sigma|}\\\\,\\\\operatorname{sat}\\\\left( \\\\frac{\\\\sigma}{\\\\epsilon} \\\\right) + z - d\\\\,\\\\sigma,\\\\\\\\</span>
<span class="linenos">163</span><span class="sd">        z^+ &amp;= z - K_2\\\\,\\\\operatorname{sat}\\\\left( \\\\frac{\\\\sigma}{\\\\epsilon} \\\\right)\\\\,dt,</span>
<span class="linenos">164</span><span class="sd">        \\end{aligned}</span>
<span class="linenos">165</span>
<span class="linenos">166</span><span class="sd">    where ``sat`` is a continuous approximation of ``sign`` (either linear or</span>
<span class="linenos">167</span><span class="sd">    hyperbolic tangent), ``d`` is the optional damping gain and ``u_eq`` is</span>
<span class="linenos">168</span><span class="sd">    the equivalent control derived from the dynamics model.  The final output</span>
<span class="linenos">169</span><span class="sd">    ``u`` and the disturbance‑like internal state ``z`` are both saturated</span>
<span class="linenos">170</span><span class="sd">    to lie within the actuator limits.</span>
<span class="linenos">171</span>
<span class="linenos">172</span><span class="sd">    The boundary layer ε (&gt; 0) is validated at construction time to avoid</span>
<span class="linenos">173</span><span class="sd">    division by zero in the saturated sign computation.  A well‑chosen ε</span>
<span class="linenos">174</span><span class="sd">    ensures finite‑time convergence and reduces chattering.</span>
<span class="linenos">175</span>
<span class="linenos">176</span><span class="sd">    **Gain positivity (F‑4.SMCDesign.2 / RC‑04)**:  For finite‑time convergence of</span>
<span class="linenos">177</span><span class="sd">    the super‑twisting algorithm the algorithmic gains ``K1`` and ``K2`` must</span>
<span class="linenos">178</span><span class="sd">    be strictly positive and the sliding‑surface gains ``k1`` and ``k2`` together</span>
<span class="linenos">179</span><span class="sd">    with the slope parameters ``λ1`` and ``λ2`` must also be strictly positive.</span>
<span class="linenos">180</span><span class="sd">    Super‑twisting literature emphasises that positive constants are required to</span>
<span class="linenos">181</span><span class="sd">    ensure robust finite‑time stability【MorenoOsorio2012†L27-L40】 and positive</span>
<span class="linenos">182</span><span class="sd">    sliding‑surface coefficients guarantee that the error terms combine with</span>
<span class="linenos">183</span><span class="sd">    positive weights【OkstateThesis2013†L1415-L1419】.  The constructor therefore</span>
<span class="linenos">184</span><span class="sd">    validates all gains using ``require_positive`` and raises a ``ValueError``</span>
<span class="linenos">185</span><span class="sd">    when any gain is non‑positive.</span>
<span class="linenos">186</span>
<span class="linenos">187</span><span class="sd">    Returns</span>
<span class="linenos">188</span><span class="sd">    -------</span>
<span class="linenos">189</span><span class="sd">    tuple</span>
<span class="linenos">190</span><span class="sd">        A triple ``(u, (z, σ), history)`` containing the saturated control</span>
<span class="linenos">191</span><span class="sd">        signal ``u``, the updated internal state and sliding surface value,</span>
<span class="linenos">192</span><span class="sd">        and a history dictionary (empty for this controller).</span>
<span class="linenos">193</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">194</span>
<span class="linenos">195</span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
<span class="linenos">196</span>        <span class="bp">self</span><span class="p">,</span>
<span class="linenos">197</span>        <span class="n">gains</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span>
<span class="linenos">198</span>        <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos">199</span>        <span class="n">max_force</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">150.0</span><span class="p">,</span>
<span class="linenos">200</span>        <span class="n">damping_gain</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span class="linenos">201</span>        <span class="n">boundary_layer</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
<span class="linenos">202</span>        <span class="n">dynamics_model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos">203</span>        <span class="n">switch_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
<span class="linenos">204</span>        <span class="n">regularization</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">,</span>
<span class="linenos">205</span>        <span class="n">anti_windup_gain</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span class="linenos">206</span>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">207</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">208</span><span class="sd">        Initialize a Super‑Twisting Sliding Mode Controller.</span>
<span class="linenos">209</span>
<span class="linenos">210</span><span class="sd">        Parameters</span>
<span class="linenos">211</span><span class="sd">        ----------</span>
<span class="linenos">212</span><span class="sd">        gains : array‑like of length 2 or 6</span>
<span class="linenos">213</span><span class="sd">            Controller gains.  A 2‑vector supplies algorithmic gains</span>
<span class="linenos">214</span><span class="sd">            ``[K1, K2]`` and defaults sliding surface parameters.  A 6‑vector</span>
<span class="linenos">215</span><span class="sd">            supplies ``[K1, K2, k1, k2, λ1, λ2]`` explicitly.</span>
<span class="linenos">216</span><span class="sd">        dt : float</span>
<span class="linenos">217</span><span class="sd">            Integration time step (seconds). Must be &gt; 0.</span>
<span class="linenos">218</span><span class="sd">        max_force : float, optional</span>
<span class="linenos">219</span><span class="sd">            Actuator saturation limit.  Defaults to ``150.0``.  The control</span>
<span class="linenos">220</span><span class="sd">            output will be clipped to ``[-max_force, max_force]``.</span>
<span class="linenos">221</span><span class="sd">        damping_gain : float, optional</span>
<span class="linenos">222</span><span class="sd">            Linear damping term multiplied by the sliding surface σ.  Defaults to</span>
<span class="linenos">223</span><span class="sd">            ``0.0``.</span>
<span class="linenos">224</span><span class="sd">        boundary_layer : float, optional</span>
<span class="linenos">225</span><span class="sd">            Positive width of the boundary layer used to regularize the sign</span>
<span class="linenos">226</span><span class="sd">            function.  Defaults to ``0.01``.  A non‑zero value is required to</span>
<span class="linenos">227</span><span class="sd">            avoid division by zero and to guarantee finite‑time convergence in</span>
<span class="linenos">228</span><span class="sd">            the discrete super‑twisting algorithm. **Raises `ValueError` if ≤ 0.**</span>
<span class="linenos">229</span><span class="sd">        switch_method : {&quot;linear&quot;,&quot;tanh&quot;}, optional</span>
<span class="linenos">230</span><span class="sd">            Method for saturated sign of σ. Defaults to &quot;linear&quot;.</span>
<span class="linenos">231</span><span class="sd">        dynamics_model : object, optional</span>
<span class="linenos">232</span><span class="sd">            Dynamics model used to compute the equivalent control.  If ``None``,</span>
<span class="linenos">233</span><span class="sd">            the equivalent control will be zero.</span>
<span class="linenos">234</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">235</span>        <span class="c1"># Gain initialization</span>
<span class="linenos">236</span>        <span class="c1"># Store a private copy of the provided gains for external</span>
<span class="linenos">237</span>        <span class="c1"># introspection via the ``gains`` property.  Accept both 2‑ and 6‑</span>
<span class="linenos">238</span>        <span class="c1"># element sequences.  Only the relevant elements are used for</span>
<span class="linenos">239</span>        <span class="c1"># internal parameters; extra values are ignored.</span>
<span class="linenos">240</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_gains</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gains</span><span class="p">)</span>
<span class="linenos">241</span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gains</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
<span class="linenos">242</span>            <span class="bp">self</span><span class="o">.</span><span class="n">alg_gain_K1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alg_gain_K2</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">gains</span><span class="p">)</span>
<span class="linenos">243</span>            <span class="c1"># Default surface gains (positive constants).  Choosing conservative</span>
<span class="linenos">244</span>            <span class="c1"># defaults ensures the sliding surface has a positive slope and</span>
<span class="linenos">245</span>            <span class="c1"># finite‑time convergence properties【MorenoOsorio2012†L27-L40】.</span>
<span class="linenos">246</span>            <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_lam1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_lam2</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span>
<span class="linenos">247</span>        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">gains</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
<span class="linenos">248</span>            <span class="bp">self</span><span class="o">.</span><span class="n">alg_gain_K1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alg_gain_K2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_lam1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_lam2</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">gains</span><span class="p">[:</span><span class="mi">6</span><span class="p">])</span>
<span class="linenos">249</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">250</span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;SuperTwistingSMC requires 2 or 6 gains&quot;</span><span class="p">)</span>
<span class="linenos">251</span>
<span class="linenos">252</span>
<span class="linenos">253</span>        <span class="c1"># Store parameters from arguments using weakref to break circular references</span>
<span class="linenos">254</span>        <span class="k">if</span> <span class="n">dynamics_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">255</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_dynamics_ref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">dynamics_model</span><span class="p">)</span>
<span class="linenos">256</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">257</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_dynamics_ref</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="kc">None</span>
<span class="linenos">258</span>        <span class="c1"># Validate core parameters using the shared utility.  These</span>
<span class="linenos">259</span>        <span class="c1"># validations enforce positivity or non‑negativity with</span>
<span class="linenos">260</span>        <span class="c1"># consistent error messages across controllers.  See</span>
<span class="linenos">261</span>        <span class="c1"># `src/utils/control_primitives.require_positive` for details.</span>
<span class="linenos">262</span>        <span class="c1"># Import from new modular utils structure</span>
<span class="linenos">263</span>        <span class="k">try</span><span class="p">:</span>
<span class="linenos">264</span>            <span class="kn">from</span><span class="w"> </span><span class="nn">src.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">require_positive</span>  <span class="c1"># when repo root on sys.path</span>
<span class="linenos">265</span>        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
<span class="linenos">266</span>            <span class="k">try</span><span class="p">:</span>
<span class="linenos">267</span>                <span class="kn">from</span><span class="w"> </span><span class="nn">...utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">require_positive</span>  <span class="c1"># when importing as src.controllers.*</span>
<span class="linenos">268</span>            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
<span class="linenos">269</span>                <span class="kn">from</span><span class="w"> </span><span class="nn">utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">require_positive</span>    <span class="c1"># when src itself on sys.path</span>
<span class="linenos">270</span>
<span class="linenos">271</span>        <span class="c1"># Integration step must be strictly positive to avoid division by</span>
<span class="linenos">272</span>        <span class="c1"># zero in discrete‑time updates.</span>
<span class="linenos">273</span>        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;dt&quot;</span><span class="p">)</span>
<span class="linenos">274</span>
<span class="linenos">275</span>        <span class="c1"># Saturation limit must be strictly positive; if zero the</span>
<span class="linenos">276</span>        <span class="c1"># controller could never exert any force and would be ineffective.</span>
<span class="linenos">277</span>        <span class="bp">self</span><span class="o">.</span><span class="n">max_force</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="n">max_force</span><span class="p">,</span> <span class="s2">&quot;max_force&quot;</span><span class="p">)</span>
<span class="linenos">278</span>
<span class="linenos">279</span>        <span class="c1"># Damping gain is a free parameter; allow any finite float</span>
<span class="linenos">280</span>        <span class="c1"># (positive, zero or negative) without validation here.  The</span>
<span class="linenos">281</span>        <span class="c1"># smoothing effect of the damping term is documented in the</span>
<span class="linenos">282</span>        <span class="c1"># class docstring.</span>
<span class="linenos">283</span>        <span class="bp">self</span><span class="o">.</span><span class="n">damping_gain</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">damping_gain</span><span class="p">)</span>
<span class="linenos">284</span>
<span class="linenos">285</span>        <span class="c1"># Boundary layer width epsilon must be strictly positive to</span>
<span class="linenos">286</span>        <span class="c1"># avoid division by zero in the saturated sign function.  Use</span>
<span class="linenos">287</span>        <span class="c1"># `require_positive` to centralise this check and unify error</span>
<span class="linenos">288</span>        <span class="c1"># messages across controllers.</span>
<span class="linenos">289</span>        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_layer</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="n">boundary_layer</span><span class="p">,</span> <span class="s2">&quot;boundary_layer&quot;</span><span class="p">)</span>
<span class="linenos">290</span>
<span class="linenos">291</span>        <span class="c1"># ---- Additional validation of STA gains (F‑4.SMCDesign.2 / RC‑04) ----</span>
<span class="linenos">292</span>        <span class="c1"># Enforce positivity of algorithmic gains K1, K2 and sliding‑surface</span>
<span class="linenos">293</span>        <span class="c1"># parameters k1, k2, λ1, λ2.  Positive constants ensure finite‑time</span>
<span class="linenos">294</span>        <span class="c1"># stability and well‑posed Lyapunov surfaces【MorenoOsorio2012†L27-L40】.</span>
<span class="linenos">295</span>        <span class="bp">self</span><span class="o">.</span><span class="n">alg_gain_K1</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alg_gain_K1</span><span class="p">,</span> <span class="s2">&quot;K1&quot;</span><span class="p">)</span>
<span class="linenos">296</span>        <span class="bp">self</span><span class="o">.</span><span class="n">alg_gain_K2</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alg_gain_K2</span><span class="p">,</span> <span class="s2">&quot;K2&quot;</span><span class="p">)</span>
<span class="linenos">297</span>        <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k1</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k1</span><span class="p">,</span> <span class="s2">&quot;k1&quot;</span><span class="p">)</span>
<span class="linenos">298</span>        <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k2</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k2</span><span class="p">,</span> <span class="s2">&quot;k2&quot;</span><span class="p">)</span>
<span class="linenos">299</span>        <span class="bp">self</span><span class="o">.</span><span class="n">surf_lam1</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surf_lam1</span><span class="p">,</span> <span class="s2">&quot;lam1&quot;</span><span class="p">)</span>
<span class="linenos">300</span>        <span class="bp">self</span><span class="o">.</span><span class="n">surf_lam2</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surf_lam2</span><span class="p">,</span> <span class="s2">&quot;lam2&quot;</span><span class="p">)</span>
<span class="linenos">301</span>        <span class="n">sm</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">switch_method</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="linenos">302</span>        <span class="k">if</span> <span class="n">sm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;tanh&quot;</span><span class="p">):</span>
<span class="linenos">303</span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;switch_method must be &#39;linear&#39; or &#39;tanh&#39;&quot;</span><span class="p">)</span>
<span class="linenos">304</span>        <span class="bp">self</span><span class="o">.</span><span class="n">switch_method</span> <span class="o">=</span> <span class="n">sm</span>
<span class="linenos">305</span>
<span class="linenos">306</span>        <span class="c1"># Placeholders for optional equivalent control</span>
<span class="linenos">307</span>        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="linenos">308</span>        <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="linenos">309</span>
<span class="linenos">310</span>        <span class="c1"># Logger</span>
<span class="linenos">311</span>        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
<span class="linenos">312</span>
<span class="linenos">313</span>        <span class="c1"># Regularisation constant used in the equivalent control term.  A</span>
<span class="linenos">314</span>        <span class="c1"># small positive diagonal added to the inertia matrix improves</span>
<span class="linenos">315</span>        <span class="c1"># conditioning and ensures the matrix is invertible.</span>
<span class="linenos">316</span>        <span class="bp">self</span><span class="o">.</span><span class="n">regularization</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">regularization</span><span class="p">)</span>
<span class="linenos">317</span>
<span class="linenos">318</span>        <span class="c1"># Anti‑windup gain used in back‑calculation.  When non‑zero, the</span>
<span class="linenos">319</span>        <span class="c1"># integrator state z is updated using the difference between the</span>
<span class="linenos">320</span>        <span class="c1"># saturated and unsaturated control to prevent integrator wind‑up</span>
<span class="linenos">321</span>        <span class="c1"># under actuator saturation【789743582768797†L224-L249】.</span>
<span class="linenos">322</span>        <span class="bp">self</span><span class="o">.</span><span class="n">anti_windup_gain</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">anti_windup_gain</span><span class="p">)</span>
<span class="linenos">323</span>
<span class="linenos">324</span>        <span class="c1"># Expose the expected length of the gain vector to external tools.</span>
<span class="linenos">325</span>        <span class="c1"># When a 2‑element gain vector is supplied the remaining surface</span>
<span class="linenos">326</span>        <span class="c1"># parameters default to conservative values; however PSO and other</span>
<span class="linenos">327</span>        <span class="c1"># tuners should explore the full six‑dimensional space.  Declare</span>
<span class="linenos">328</span>        <span class="c1"># six as the nominal dimension so that vector bounds reflect this</span>
<span class="linenos">329</span>        <span class="c1"># maximum length.  See design review section 5 (PSO integration).</span>
<span class="linenos">330</span>        <span class="bp">self</span><span class="o">.</span><span class="n">n_gains</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span>
<span class="linenos">331</span>
<span class="linenos">332</span>    <span class="c1"># ---------------- Controller state/history API ----------------</span>
<span class="linenos">333</span>
<span class="linenos">334</span>    <span class="k">def</span><span class="w"> </span><span class="nf">initialize_state</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="linenos">335</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Return (z, sigma) initial internal state.&quot;&quot;&quot;</span>
<span class="linenos">336</span>        <span class="k">return</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="linenos">337</span>
<span class="linenos">338</span>    <span class="k">def</span><span class="w"> </span><span class="nf">initialize_history</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="linenos">339</span>        <span class="k">return</span> <span class="p">{}</span>
<span class="linenos">340</span>
<span class="linenos">341</span>    <span class="c1"># ---------------- Main control computation -------------------</span>
<span class="linenos">342</span>
<span class="linenos">343</span>    <span class="k">def</span><span class="w"> </span><span class="nf">compute_control</span><span class="p">(</span>
<span class="linenos">344</span>        <span class="bp">self</span><span class="p">,</span>
<span class="linenos">345</span>        <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span class="linenos">346</span>        <span class="n">state_vars</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
<span class="linenos">347</span>        <span class="n">history</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
<span class="linenos">348</span>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">STAOutput</span><span class="p">:</span>
<span class="linenos">349</span>        <span class="c1"># State variables may be provided either as a tuple of (z, sigma)</span>
<span class="linenos">350</span>        <span class="c1"># or as a single scalar (legacy usage).  Accept both forms.</span>
<span class="linenos">351</span>        <span class="k">try</span><span class="p">:</span>
<span class="linenos">352</span>            <span class="c1"># Unpack z and ignore provided sigma; the sliding surface will</span>
<span class="linenos">353</span>            <span class="c1"># be recomputed below.</span>
<span class="linenos">354</span>            <span class="n">z</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">state_vars</span>
<span class="linenos">355</span>        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="linenos">356</span>            <span class="c1"># Non‑iterable (e.g., float) provided: treat as z and</span>
<span class="linenos">357</span>            <span class="c1"># initialize sigma to zero.  Cast to float to avoid</span>
<span class="linenos">358</span>            <span class="c1"># unexpected types (e.g., numpy scalars).</span>
<span class="linenos">359</span>            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;State unpacking failed (non-iterable), treating as scalar: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="linenos">360</span>            <span class="n">z</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">state_vars</span><span class="p">)</span> <span class="k">if</span> <span class="n">state_vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">0.0</span>  <span class="c1"># OK: Legacy input format</span>
<span class="linenos">361</span>
<span class="linenos">362</span>        <span class="n">u_eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_equivalent_control</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="linenos">363</span>
<span class="linenos">364</span>        <span class="c1"># Compute sliding surface and its saturated sign using shared utility</span>
<span class="linenos">365</span>        <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_sliding_surface</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="linenos">366</span>        <span class="n">sgn_sigma</span> <span class="o">=</span> <span class="n">saturate</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_layer</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">switch_method</span><span class="p">)</span>
<span class="linenos">367</span>
<span class="linenos">368</span>        <span class="c1"># Use numba core with precomputed sigma and sgn_sigma</span>
<span class="linenos">369</span>        <span class="n">u</span><span class="p">,</span> <span class="n">new_z</span><span class="p">,</span> <span class="n">sigma_val</span> <span class="o">=</span> <span class="n">_sta_smc_core</span><span class="p">(</span>
<span class="linenos">370</span>            <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span>
<span class="linenos">371</span>            <span class="n">sigma</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">),</span>
<span class="linenos">372</span>            <span class="n">sgn_sigma</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">sgn_sigma</span><span class="p">),</span>
<span class="linenos">373</span>            <span class="n">alg_gain_K1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alg_gain_K1</span><span class="p">,</span>
<span class="linenos">374</span>            <span class="n">alg_gain_K2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alg_gain_K2</span><span class="p">,</span>
<span class="linenos">375</span>            <span class="n">damping_gain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">damping_gain</span><span class="p">,</span>
<span class="linenos">376</span>            <span class="n">dt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span>
<span class="linenos">377</span>            <span class="n">max_force</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_force</span><span class="p">,</span>
<span class="linenos">378</span>            <span class="n">u_eq</span><span class="o">=</span><span class="n">u_eq</span><span class="p">,</span>
<span class="linenos">379</span>            <span class="n">Kaw</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">anti_windup_gain</span><span class="p">,</span>
<span class="linenos">380</span>        <span class="p">)</span>
<span class="linenos">381</span>        <span class="c1"># Telemetry: append key signals to history (in-place)</span>
<span class="linenos">382</span>        <span class="n">hist</span> <span class="o">=</span> <span class="n">history</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">history</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="p">{}</span>
<span class="linenos">383</span>        <span class="n">hist</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;sigma&#39;</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span>
<span class="linenos">384</span>        <span class="n">hist</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">new_z</span><span class="p">))</span>
<span class="linenos">385</span>        <span class="n">hist</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
<span class="linenos">386</span>        <span class="n">hist</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;u_eq&#39;</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">u_eq</span><span class="p">))</span>
<span class="linenos">387</span>
<span class="linenos">388</span>        <span class="c1"># Package results into a named tuple. The internal state carries</span>
<span class="linenos">389</span>        <span class="c1"># the updated z and latest sliding surface value. Sigma is also</span>
<span class="linenos">390</span>        <span class="c1"># returned separately for batch simulation and Lyapunov validation.</span>
<span class="linenos">391</span>        <span class="k">return</span> <span class="n">STAOutput</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="n">new_z</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">)),</span> <span class="n">hist</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span>
<span class="linenos">392</span>
<span class="linenos">393</span>    <span class="k">def</span><span class="w"> </span><span class="nf">validate_gains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gains_b</span><span class="p">:</span> <span class="s2">&quot;np.ndarray&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;np.ndarray&quot;</span><span class="p">:</span>
<span class="linenos">394</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">395</span><span class="sd">        Vectorized feasibility check for super‑twisting SMC gains.</span>
<span class="linenos">396</span>
<span class="linenos">397</span><span class="sd">        The algorithmic gains ``K1`` and ``K2`` must be strictly positive to</span>
<span class="linenos">398</span><span class="sd">        ensure finite‑time convergence of the super‑twisting algorithm. Additionally,</span>
<span class="linenos">399</span><span class="sd">        for stability, K1 &gt; K2 is required per super-twisting theory. When</span>
<span class="linenos">400</span><span class="sd">        a six‑element gain vector is provided the sliding‑surface gains</span>
<span class="linenos">401</span><span class="sd">        ``k1``, ``k2`` and the lambda parameters ``lam1``, ``lam2`` must also</span>
<span class="linenos">402</span><span class="sd">        be positive.  Positive sliding‑surface coefficients are required</span>
<span class="linenos">403</span><span class="sd">        because the sliding surface is a linear combination of state</span>
<span class="linenos">404</span><span class="sd">        variables with positive weights.</span>
<span class="linenos">405</span>
<span class="linenos">406</span><span class="sd">        Parameters</span>
<span class="linenos">407</span><span class="sd">        ----------</span>
<span class="linenos">408</span><span class="sd">        gains_b : np.ndarray</span>
<span class="linenos">409</span><span class="sd">            Array of shape (B, D) containing candidate gain vectors.  The</span>
<span class="linenos">410</span><span class="sd">            first two columns correspond to ``K1`` and ``K2``; if ``D`` ≥ 6</span>
<span class="linenos">411</span><span class="sd">            then columns 3–6 correspond to ``k1``, ``k2``, ``lam1`` and</span>
<span class="linenos">412</span><span class="sd">            ``lam2`` respectively.</span>
<span class="linenos">413</span>
<span class="linenos">414</span><span class="sd">        Returns</span>
<span class="linenos">415</span><span class="sd">        -------</span>
<span class="linenos">416</span><span class="sd">        np.ndarray</span>
<span class="linenos">417</span><span class="sd">            Boolean mask of shape (B,) indicating which rows satisfy the</span>
<span class="linenos">418</span><span class="sd">            positivity and stability constraints.</span>
<span class="linenos">419</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">420</span>        <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_np</span>
<span class="linenos">421</span>        <span class="k">if</span> <span class="n">gains_b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">gains_b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
<span class="linenos">422</span>            <span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">gains_b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="linenos">423</span>        <span class="c1"># Always require K1 and K2 to be positive AND K1 &gt; K2 for stability</span>
<span class="linenos">424</span>        <span class="n">k1</span> <span class="o">=</span> <span class="n">gains_b</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span class="linenos">425</span>        <span class="n">k2</span> <span class="o">=</span> <span class="n">gains_b</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span class="linenos">426</span>        <span class="n">valid</span> <span class="o">=</span> <span class="p">(</span><span class="n">k1</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k2</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k1</span> <span class="o">&gt;</span> <span class="n">k2</span><span class="p">)</span>
<span class="linenos">427</span>        <span class="c1"># If sliding surface parameters are provided, require them to be positive</span>
<span class="linenos">428</span>        <span class="k">if</span> <span class="n">gains_b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">:</span>
<span class="linenos">429</span>            <span class="n">surf_k1</span> <span class="o">=</span> <span class="n">gains_b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span class="linenos">430</span>            <span class="n">surf_k2</span> <span class="o">=</span> <span class="n">gains_b</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span class="linenos">431</span>            <span class="n">lam1</span> <span class="o">=</span> <span class="n">gains_b</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span class="linenos">432</span>            <span class="n">lam2</span> <span class="o">=</span> <span class="n">gains_b</span><span class="p">[:,</span> <span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span class="linenos">433</span>            <span class="n">valid</span> <span class="o">=</span> <span class="n">valid</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">surf_k1</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">surf_k2</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">lam1</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">lam2</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="linenos">434</span>        <span class="k">return</span> <span class="n">valid</span>
<span class="linenos">435</span>
<span class="linenos">436</span>    <span class="c1"># ------------------------------------------------------------------</span>
<span class="linenos">437</span>    <span class="c1"># Properties</span>
<span class="linenos">438</span>    <span class="c1"># ------------------------------------------------------------------</span>
<span class="linenos">439</span>    <span class="nd">@property</span>
<span class="linenos">440</span>    <span class="k">def</span><span class="w"> </span><span class="nf">gains</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="linenos">441</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a copy of the gains used to configure this controller.</span>
<span class="linenos">442</span>
<span class="linenos">443</span><span class="sd">        The returned list includes all elements supplied to the constructor,</span>
<span class="linenos">444</span><span class="sd">        whether 2 or 6 gains.  This enables external code (and tests) to</span>
<span class="linenos">445</span><span class="sd">        inspect the algorithmic and sliding‑surface gains after</span>
<span class="linenos">446</span><span class="sd">        instantiation without risk of mutating the internal state.</span>
<span class="linenos">447</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">448</span>        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gains</span><span class="p">)</span>
<span class="linenos">449</span>
<span class="linenos">450</span>    <span class="nd">@property</span>
<span class="linenos">451</span>    <span class="k">def</span><span class="w"> </span><span class="nf">dyn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">452</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Access dynamics model via weakref.&quot;&quot;&quot;</span>
<span class="linenos">453</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamics_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">454</span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamics_ref</span><span class="p">()</span>
<span class="linenos">455</span>        <span class="k">return</span> <span class="kc">None</span>
<span class="linenos">456</span>
<span class="linenos">457</span>    <span class="nd">@dyn</span><span class="o">.</span><span class="n">setter</span>
<span class="linenos">458</span>    <span class="k">def</span><span class="w"> </span><span class="nf">dyn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="linenos">459</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Set dynamics model using weakref.&quot;&quot;&quot;</span>
<span class="linenos">460</span>        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">461</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_dynamics_ref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="linenos">462</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">463</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_dynamics_ref</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="kc">None</span>
<span class="linenos">464</span>
<span class="linenos">465</span>    <span class="nd">@property</span>
<span class="linenos">466</span>    <span class="k">def</span><span class="w"> </span><span class="nf">dynamics_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">467</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Alias for dyn property (for batch simulation compatibility).&quot;&quot;&quot;</span>
<span class="linenos">468</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn</span>
<span class="linenos">469</span>
<span class="linenos">470</span>    <span class="nd">@dynamics_model</span><span class="o">.</span><span class="n">setter</span>
<span class="linenos">471</span>    <span class="k">def</span><span class="w"> </span><span class="nf">dynamics_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="linenos">472</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Alias for dyn setter (for batch simulation compatibility).&quot;&quot;&quot;</span>
<span class="linenos">473</span>        <span class="bp">self</span><span class="o">.</span><span class="n">dyn</span> <span class="o">=</span> <span class="n">value</span>
<span class="linenos">474</span>
<span class="linenos">475</span>    <span class="c1"># ---------------- Utilities -------------------</span>
<span class="linenos">476</span>
<span class="linenos">477</span>    <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">478</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset STA-SMC controller state.</span>
<span class="linenos">479</span>
<span class="linenos">480</span><span class="sd">        Resets internal state variables to initial conditions:</span>
<span class="linenos">481</span><span class="sd">        - Clears the integral state z</span>
<span class="linenos">482</span><span class="sd">        - Resets the last surface value</span>
<span class="linenos">483</span><span class="sd">        - Reinitializes any internal tracking variables</span>
<span class="linenos">484</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">485</span>        <span class="c1"># Reset integral state (z) to zero</span>
<span class="linenos">486</span>        <span class="c1"># This is the main internal state for the super-twisting algorithm</span>
<span class="linenos">487</span>        <span class="k">pass</span>  <span class="c1"># The controller gets z from state_vars parameter, no persistent internal state</span>
<span class="linenos">488</span>
<span class="linenos">489</span>    <span class="k">def</span><span class="w"> </span><span class="nf">cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">490</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Clean up controller resources (Issue #15).</span>
<span class="linenos">491</span>
<span class="linenos">492</span><span class="sd">        Explicitly releases references to dynamics model and clears</span>
<span class="linenos">493</span><span class="sd">        any cached data to facilitate garbage collection and prevent</span>
<span class="linenos">494</span><span class="sd">        memory leaks during repeated controller instantiation.</span>
<span class="linenos">495</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">496</span>        <span class="c1"># Nullify dynamics reference</span>
<span class="linenos">497</span>        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_dynamics_ref&#39;</span><span class="p">):</span>
<span class="linenos">498</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_dynamics_ref</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="kc">None</span>
<span class="linenos">499</span>
<span class="linenos">500</span>        <span class="c1"># Clear cached vectors</span>
<span class="linenos">501</span>        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">):</span>
<span class="linenos">502</span>            <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="kc">None</span>
<span class="linenos">503</span>        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">):</span>
<span class="linenos">504</span>            <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="kc">None</span>
<span class="linenos">505</span>
<span class="linenos">506</span>    <span class="k">def</span><span class="w"> </span><span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">507</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Destructor for automatic cleanup.</span>
<span class="linenos">508</span>
<span class="linenos">509</span><span class="sd">        Ensures cleanup is called when the controller is garbage collected.</span>
<span class="linenos">510</span><span class="sd">        Catches all exceptions to prevent errors during finalization.</span>
<span class="linenos">511</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">512</span>        <span class="k">try</span><span class="p">:</span>
<span class="linenos">513</span>            <span class="bp">self</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
<span class="linenos">514</span>        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
<span class="linenos">515</span>            <span class="k">pass</span>  <span class="c1"># Prevent exceptions during cleanup</span>
<span class="linenos">516</span>
<span class="linenos">517</span>    <span class="k">def</span><span class="w"> </span><span class="nf">set_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dynamics_model</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">518</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Attach dynamics model if available (used by u_eq if implemented).&quot;&quot;&quot;</span>
<span class="linenos">519</span>        <span class="bp">self</span><span class="o">.</span><span class="n">dyn</span> <span class="o">=</span> <span class="n">dynamics_model</span>
<span class="linenos">520</span>
<span class="linenos">521</span>    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_sliding_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="linenos">522</span>        <span class="n">_</span><span class="p">,</span> <span class="n">th1</span><span class="p">,</span> <span class="n">th2</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">th1dot</span><span class="p">,</span> <span class="n">th2dot</span> <span class="o">=</span> <span class="n">state</span>
<span class="linenos">523</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k1</span> <span class="o">*</span> <span class="p">(</span><span class="n">th1dot</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_lam1</span> <span class="o">*</span> <span class="n">th1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k2</span> <span class="o">*</span> <span class="p">(</span><span class="n">th2dot</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_lam2</span> <span class="o">*</span> <span class="n">th2</span><span class="p">)</span>
<span class="linenos">524</span>
<span class="linenos">525</span>    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_equivalent_control</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="linenos">526</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the model‑based equivalent control ``u_eq`` using Tikhonov regularisation.</span>
<span class="linenos">527</span>
<span class="linenos">528</span><span class="sd">        The original implementation used an SVD‑based condition estimate and a</span>
<span class="linenos">529</span><span class="sd">        pseudo‑inverse to invert the inertia matrix.  This version instead</span>
<span class="linenos">530</span><span class="sd">        applies a small diagonal regularisation and solves the resulting</span>
<span class="linenos">531</span><span class="sd">        linear systems directly, reducing computational overhead and</span>
<span class="linenos">532</span><span class="sd">        eliminating the need for a full SVD.  Adding a small constant to</span>
<span class="linenos">533</span><span class="sd">        the diagonal of a symmetric indefinite matrix makes it positive</span>
<span class="linenos">534</span><span class="sd">        definite and invertible, a standard technique in control</span>
<span class="linenos">535</span><span class="sd">        literature.</span>
<span class="linenos">536</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">537</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">538</span>            <span class="k">return</span> <span class="mf">0.0</span>
<span class="linenos">539</span>
<span class="linenos">540</span>        <span class="n">q_dot</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
<span class="linenos">541</span>        <span class="k">try</span><span class="p">:</span>
<span class="linenos">542</span>            <span class="n">M</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn</span><span class="o">.</span><span class="n">_compute_physics_matrices</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="linenos">543</span>        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="linenos">544</span>            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Physics matrix computation failed, returning safe zero control: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="linenos">545</span>            <span class="k">return</span> <span class="mf">0.0</span>  <span class="c1"># OK: Safe fallback when dynamics unavailable</span>
<span class="linenos">546</span>
<span class="linenos">547</span>        <span class="c1"># Regularise the inertia matrix using the configurable constant.  A</span>
<span class="linenos">548</span>        <span class="c1"># small diagonal offset guarantees invertibility of symmetric</span>
<span class="linenos">549</span>        <span class="c1"># matrices.</span>
<span class="linenos">550</span>        <span class="n">M_reg</span> <span class="o">=</span> <span class="n">M</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regularization</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="linenos">551</span>        <span class="k">try</span><span class="p">:</span>
<span class="linenos">552</span>            <span class="c1"># Compute controllability scalar L M^-1 B.  Use the boundary layer</span>
<span class="linenos">553</span>            <span class="c1"># thickness as a threshold for ill‑conditioned feedforward terms.</span>
<span class="linenos">554</span>            <span class="n">Minv_B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M_reg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">)</span>
<span class="linenos">555</span>            <span class="n">L_Minv_B</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">@</span> <span class="n">Minv_B</span><span class="p">)</span>
<span class="linenos">556</span>            <span class="c1"># If the equivalent control would divide by a very small number,</span>
<span class="linenos">557</span>            <span class="c1"># return zero.  The threshold equals the boundary layer epsilon</span>
<span class="linenos">558</span>            <span class="c1"># such that the same tuning parameter governs both chattering</span>
<span class="linenos">559</span>            <span class="c1"># mitigation and model invertibility.</span>
<span class="linenos">560</span>            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">L_Minv_B</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_layer</span><span class="p">:</span>
<span class="linenos">561</span>                <span class="k">return</span> <span class="mf">0.0</span>
<span class="linenos">562</span>
<span class="linenos">563</span>            <span class="c1"># Compute rhs = C q_dot + G.  Support both matrix and vector forms.</span>
<span class="linenos">564</span>            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s2">&quot;ndim&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
<span class="linenos">565</span>                <span class="n">rhs</span> <span class="o">=</span> <span class="n">C</span> <span class="o">@</span> <span class="n">q_dot</span> <span class="o">+</span> <span class="n">G</span>
<span class="linenos">566</span>            <span class="k">else</span><span class="p">:</span>
<span class="linenos">567</span>                <span class="n">rhs</span> <span class="o">=</span> <span class="n">C</span> <span class="o">+</span> <span class="n">G</span>
<span class="linenos">568</span>            <span class="n">Minv_rhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M_reg</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
<span class="linenos">569</span>            <span class="n">num</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">@</span> <span class="n">Minv_rhs</span><span class="p">)</span>
<span class="linenos">570</span>            <span class="c1"># Equivalent control is the feedforward term minus the damping</span>
<span class="linenos">571</span>            <span class="c1"># portion from the sliding surface definition.  Following</span>
<span class="linenos">572</span>            <span class="c1"># conventional SMC, subtract the inner product of the surface</span>
<span class="linenos">573</span>            <span class="c1"># gains with the joint velocities.  Note the sign convention</span>
<span class="linenos">574</span>            <span class="c1"># matches the one used in ClassicalSMC.</span>
<span class="linenos">575</span>            <span class="n">u_eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_lam1</span> <span class="o">*</span> <span class="n">q_dot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
<span class="linenos">576</span>                           <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_lam2</span> <span class="o">*</span> <span class="n">q_dot</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">/</span> <span class="n">L_Minv_B</span>
<span class="linenos">577</span>        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
<span class="linenos">578</span>            <span class="c1"># Singular matrix despite regularisation; disable equivalent control</span>
<span class="linenos">579</span>            <span class="k">return</span> <span class="mf">0.0</span>
<span class="linenos">580</span>
<span class="linenos">581</span>        <span class="c1"># Do not apply additional clamping here.  The final saturation in</span>
<span class="linenos">582</span>        <span class="c1"># ``compute_control`` will bound the control effort.  Returning the</span>
<span class="linenos">583</span>        <span class="c1"># raw equivalent control maintains transparency and avoids</span>
<span class="linenos">584</span>        <span class="c1"># inadvertently biasing the controller output.</span>
<span class="linenos">585</span>        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">u_eq</span><span class="p">)</span>
<span class="linenos">586</span><span class="c1">#========================================================================================================\\\</span>
</pre></div>
</div>
</section>
<hr class="docutils" />
<section id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Link to this heading">¶</a></h2>
<section id="supertwistingsmc">
<h3><code class="docutils literal notranslate"><span class="pre">SuperTwistingSMC</span></code><a class="headerlink" href="#supertwistingsmc" title="Link to this heading">¶</a></h3>
<p>Second‑order (super‑twisting) sliding‑mode controller for the double‑inverted pendulum.</p>
<p>This controller implements the super‑twisting algorithm, a higher‑order
sliding‑mode technique that achieves finite‑time convergence without
requiring direct measurement of the sliding surface derivative.  Compared
with conventional (first‑order) sliding‑mode control, the super‑twisting
algorithm is known to mitigate chattering and reduce control effort,
offering improved tracking accuracy.  The
implementation uses a continuous saturation function within a boundary
layer <code class="docutils literal notranslate"><span class="pre">ε</span></code> to approximate the sign of the sliding variable σ,
consistent with the boundary‑layer approach for chattering reduction
.  The size of <code class="docutils literal notranslate"><span class="pre">ε</span></code> therefore controls
the trade‑off between chattering attenuation and steady‑state accuracy
.</p>
<p><strong>Gains:</strong></p>
<ul class="simple">
<li><p>If a 2‑element sequence <code class="docutils literal notranslate"><span class="pre">[K1,</span> <span class="pre">K2]</span></code> is provided, the sliding‑surface
gains and poles <code class="docutils literal notranslate"><span class="pre">(k1,</span> <span class="pre">k2,</span> <span class="pre">λ1,</span> <span class="pre">λ2)</span></code> are set to default values.</p></li>
<li><p>A 6‑element sequence <code class="docutils literal notranslate"><span class="pre">[K1,</span> <span class="pre">K2,</span> <span class="pre">k1,</span> <span class="pre">k2,</span> <span class="pre">λ1,</span> <span class="pre">λ2]</span></code> specifies all
super‑twisting and surface parameters explicitly.</p></li>
</ul>
<p><strong>Sliding surface:</strong></p>
<p>.. math::
\sigma = k_1,(\dot{\theta}_1 + \lambda_1,\theta_1) + k_2,(\dot{\theta}_2 + \lambda_2,\theta_2).</p>
<p><strong>Discrete‑time control law:</strong></p>
<p>.. math::
\begin{aligned}
u &amp;= u_{\text{eq}} - K_1 \sqrt{|\sigma|}\,\operatorname{sat}\left( \frac{\sigma}{\epsilon} \right) + z - d\,\sigma,\
z^+ &amp;= z - K_2\,\operatorname{sat}\left( \frac{\sigma}{\epsilon} \right)\,dt,
\end{aligned}</p>
<p>where <code class="docutils literal notranslate"><span class="pre">sat</span></code> is a continuous approximation of <code class="docutils literal notranslate"><span class="pre">sign</span></code> (either linear or
hyperbolic tangent), <code class="docutils literal notranslate"><span class="pre">d</span></code> is the optional damping gain and <code class="docutils literal notranslate"><span class="pre">u_eq</span></code> is
the equivalent control derived from the dynamics model.  The final output
<code class="docutils literal notranslate"><span class="pre">u</span></code> and the disturbance‑like internal state <code class="docutils literal notranslate"><span class="pre">z</span></code> are both saturated
to lie within the actuator limits.</p>
<p>The boundary layer ε (&gt; 0) is validated at construction time to avoid
division by zero in the saturated sign computation.  A well‑chosen ε
ensures finite‑time convergence and reduces chattering.</p>
<p><strong>Gain positivity (F‑4.SMCDesign.2 / RC‑04)</strong>:  For finite‑time convergence of
the super‑twisting algorithm the algorithmic gains <code class="docutils literal notranslate"><span class="pre">K1</span></code> and <code class="docutils literal notranslate"><span class="pre">K2</span></code> must
be strictly positive and the sliding‑surface gains <code class="docutils literal notranslate"><span class="pre">k1</span></code> and <code class="docutils literal notranslate"><span class="pre">k2</span></code> together
with the slope parameters <code class="docutils literal notranslate"><span class="pre">λ1</span></code> and <code class="docutils literal notranslate"><span class="pre">λ2</span></code> must also be strictly positive.
Super‑twisting literature emphasises that positive constants are required to
ensure robust finite‑time stability【MorenoOsorio2012†L27-L40】 and positive
sliding‑surface coefficients guarantee that the error terms combine with
positive weights【OkstateThesis2013†L1415-L1419】.  The constructor therefore
validates all gains using <code class="docutils literal notranslate"><span class="pre">require_positive</span></code> and raises a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>
when any gain is non‑positive.</p>
</section>
</section>
<section id="returns">
<h2>Returns<a class="headerlink" href="#returns" title="Link to this heading">¶</a></h2>
<p>tuple
A triple <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">(z,</span> <span class="pre">σ),</span> <span class="pre">history)</span></code> containing the saturated control
signal <code class="docutils literal notranslate"><span class="pre">u</span></code>, the updated internal state and sliding surface value,
and a history dictionary (empty for this controller).</p>
<section id="source-code">
<h3>Source Code<a class="headerlink" href="#source-code" title="Link to this heading">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos">  1</span><span class="k">class</span><span class="w"> </span><span class="nc">SuperTwistingSMC</span><span class="p">:</span>
<span class="linenos">  2</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">  3</span><span class="sd">    Second‑order (super‑twisting) sliding‑mode controller for the double‑inverted pendulum.</span>
<span class="linenos">  4</span>
<span class="linenos">  5</span><span class="sd">    This controller implements the super‑twisting algorithm, a higher‑order</span>
<span class="linenos">  6</span><span class="sd">    sliding‑mode technique that achieves finite‑time convergence without</span>
<span class="linenos">  7</span><span class="sd">    requiring direct measurement of the sliding surface derivative.  Compared</span>
<span class="linenos">  8</span><span class="sd">    with conventional (first‑order) sliding‑mode control, the super‑twisting</span>
<span class="linenos">  9</span><span class="sd">    algorithm is known to mitigate chattering and reduce control effort,</span>
<span class="linenos"> 10</span><span class="sd">    offering improved tracking accuracy.  The</span>
<span class="linenos"> 11</span><span class="sd">    implementation uses a continuous saturation function within a boundary</span>
<span class="linenos"> 12</span><span class="sd">    layer ``ε`` to approximate the sign of the sliding variable σ,</span>
<span class="linenos"> 13</span><span class="sd">    consistent with the boundary‑layer approach for chattering reduction</span>
<span class="linenos"> 14</span><span class="sd">   .  The size of ``ε`` therefore controls</span>
<span class="linenos"> 15</span><span class="sd">    the trade‑off between chattering attenuation and steady‑state accuracy</span>
<span class="linenos"> 16</span><span class="sd">   .</span>
<span class="linenos"> 17</span>
<span class="linenos"> 18</span><span class="sd">    **Gains:**</span>
<span class="linenos"> 19</span>
<span class="linenos"> 20</span><span class="sd">      - If a 2‑element sequence ``[K1, K2]`` is provided, the sliding‑surface</span>
<span class="linenos"> 21</span><span class="sd">        gains and poles ``(k1, k2, λ1, λ2)`` are set to default values.</span>
<span class="linenos"> 22</span><span class="sd">      - A 6‑element sequence ``[K1, K2, k1, k2, λ1, λ2]`` specifies all</span>
<span class="linenos"> 23</span><span class="sd">        super‑twisting and surface parameters explicitly.</span>
<span class="linenos"> 24</span>
<span class="linenos"> 25</span><span class="sd">    **Sliding surface:**</span>
<span class="linenos"> 26</span>
<span class="linenos"> 27</span><span class="sd">    .. math::</span>
<span class="linenos"> 28</span><span class="sd">        \\sigma = k_1\\,(\\dot{\\theta}_1 + \\lambda_1\\,\\theta_1) + k_2\\,(\\dot{\\theta}_2 + \\lambda_2\\,\\theta_2).</span>
<span class="linenos"> 29</span>
<span class="linenos"> 30</span><span class="sd">    **Discrete‑time control law:**</span>
<span class="linenos"> 31</span>
<span class="linenos"> 32</span><span class="sd">    .. math::</span>
<span class="linenos"> 33</span><span class="sd">        \\begin{aligned}</span>
<span class="linenos"> 34</span><span class="sd">        u &amp;= u_{\\\\text{eq}} - K_1 \\\\sqrt{|\\\\sigma|}\\\\,\\\\operatorname{sat}\\\\left( \\\\frac{\\\\sigma}{\\\\epsilon} \\\\right) + z - d\\\\,\\\\sigma,\\\\\\\\</span>
<span class="linenos"> 35</span><span class="sd">        z^+ &amp;= z - K_2\\\\,\\\\operatorname{sat}\\\\left( \\\\frac{\\\\sigma}{\\\\epsilon} \\\\right)\\\\,dt,</span>
<span class="linenos"> 36</span><span class="sd">        \\end{aligned}</span>
<span class="linenos"> 37</span>
<span class="linenos"> 38</span><span class="sd">    where ``sat`` is a continuous approximation of ``sign`` (either linear or</span>
<span class="linenos"> 39</span><span class="sd">    hyperbolic tangent), ``d`` is the optional damping gain and ``u_eq`` is</span>
<span class="linenos"> 40</span><span class="sd">    the equivalent control derived from the dynamics model.  The final output</span>
<span class="linenos"> 41</span><span class="sd">    ``u`` and the disturbance‑like internal state ``z`` are both saturated</span>
<span class="linenos"> 42</span><span class="sd">    to lie within the actuator limits.</span>
<span class="linenos"> 43</span>
<span class="linenos"> 44</span><span class="sd">    The boundary layer ε (&gt; 0) is validated at construction time to avoid</span>
<span class="linenos"> 45</span><span class="sd">    division by zero in the saturated sign computation.  A well‑chosen ε</span>
<span class="linenos"> 46</span><span class="sd">    ensures finite‑time convergence and reduces chattering.</span>
<span class="linenos"> 47</span>
<span class="linenos"> 48</span><span class="sd">    **Gain positivity (F‑4.SMCDesign.2 / RC‑04)**:  For finite‑time convergence of</span>
<span class="linenos"> 49</span><span class="sd">    the super‑twisting algorithm the algorithmic gains ``K1`` and ``K2`` must</span>
<span class="linenos"> 50</span><span class="sd">    be strictly positive and the sliding‑surface gains ``k1`` and ``k2`` together</span>
<span class="linenos"> 51</span><span class="sd">    with the slope parameters ``λ1`` and ``λ2`` must also be strictly positive.</span>
<span class="linenos"> 52</span><span class="sd">    Super‑twisting literature emphasises that positive constants are required to</span>
<span class="linenos"> 53</span><span class="sd">    ensure robust finite‑time stability【MorenoOsorio2012†L27-L40】 and positive</span>
<span class="linenos"> 54</span><span class="sd">    sliding‑surface coefficients guarantee that the error terms combine with</span>
<span class="linenos"> 55</span><span class="sd">    positive weights【OkstateThesis2013†L1415-L1419】.  The constructor therefore</span>
<span class="linenos"> 56</span><span class="sd">    validates all gains using ``require_positive`` and raises a ``ValueError``</span>
<span class="linenos"> 57</span><span class="sd">    when any gain is non‑positive.</span>
<span class="linenos"> 58</span>
<span class="linenos"> 59</span><span class="sd">    Returns</span>
<span class="linenos"> 60</span><span class="sd">    -------</span>
<span class="linenos"> 61</span><span class="sd">    tuple</span>
<span class="linenos"> 62</span><span class="sd">        A triple ``(u, (z, σ), history)`` containing the saturated control</span>
<span class="linenos"> 63</span><span class="sd">        signal ``u``, the updated internal state and sliding surface value,</span>
<span class="linenos"> 64</span><span class="sd">        and a history dictionary (empty for this controller).</span>
<span class="linenos"> 65</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos"> 66</span>
<span class="linenos"> 67</span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
<span class="linenos"> 68</span>        <span class="bp">self</span><span class="p">,</span>
<span class="linenos"> 69</span>        <span class="n">gains</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span>
<span class="linenos"> 70</span>        <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 71</span>        <span class="n">max_force</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">150.0</span><span class="p">,</span>
<span class="linenos"> 72</span>        <span class="n">damping_gain</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span class="linenos"> 73</span>        <span class="n">boundary_layer</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
<span class="linenos"> 74</span>        <span class="n">dynamics_model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="linenos"> 75</span>        <span class="n">switch_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
<span class="linenos"> 76</span>        <span class="n">regularization</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">,</span>
<span class="linenos"> 77</span>        <span class="n">anti_windup_gain</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span class="linenos"> 78</span>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos"> 79</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos"> 80</span><span class="sd">        Initialize a Super‑Twisting Sliding Mode Controller.</span>
<span class="linenos"> 81</span>
<span class="linenos"> 82</span><span class="sd">        Parameters</span>
<span class="linenos"> 83</span><span class="sd">        ----------</span>
<span class="linenos"> 84</span><span class="sd">        gains : array‑like of length 2 or 6</span>
<span class="linenos"> 85</span><span class="sd">            Controller gains.  A 2‑vector supplies algorithmic gains</span>
<span class="linenos"> 86</span><span class="sd">            ``[K1, K2]`` and defaults sliding surface parameters.  A 6‑vector</span>
<span class="linenos"> 87</span><span class="sd">            supplies ``[K1, K2, k1, k2, λ1, λ2]`` explicitly.</span>
<span class="linenos"> 88</span><span class="sd">        dt : float</span>
<span class="linenos"> 89</span><span class="sd">            Integration time step (seconds). Must be &gt; 0.</span>
<span class="linenos"> 90</span><span class="sd">        max_force : float, optional</span>
<span class="linenos"> 91</span><span class="sd">            Actuator saturation limit.  Defaults to ``150.0``.  The control</span>
<span class="linenos"> 92</span><span class="sd">            output will be clipped to ``[-max_force, max_force]``.</span>
<span class="linenos"> 93</span><span class="sd">        damping_gain : float, optional</span>
<span class="linenos"> 94</span><span class="sd">            Linear damping term multiplied by the sliding surface σ.  Defaults to</span>
<span class="linenos"> 95</span><span class="sd">            ``0.0``.</span>
<span class="linenos"> 96</span><span class="sd">        boundary_layer : float, optional</span>
<span class="linenos"> 97</span><span class="sd">            Positive width of the boundary layer used to regularize the sign</span>
<span class="linenos"> 98</span><span class="sd">            function.  Defaults to ``0.01``.  A non‑zero value is required to</span>
<span class="linenos"> 99</span><span class="sd">            avoid division by zero and to guarantee finite‑time convergence in</span>
<span class="linenos">100</span><span class="sd">            the discrete super‑twisting algorithm. **Raises `ValueError` if ≤ 0.**</span>
<span class="linenos">101</span><span class="sd">        switch_method : {&quot;linear&quot;,&quot;tanh&quot;}, optional</span>
<span class="linenos">102</span><span class="sd">            Method for saturated sign of σ. Defaults to &quot;linear&quot;.</span>
<span class="linenos">103</span><span class="sd">        dynamics_model : object, optional</span>
<span class="linenos">104</span><span class="sd">            Dynamics model used to compute the equivalent control.  If ``None``,</span>
<span class="linenos">105</span><span class="sd">            the equivalent control will be zero.</span>
<span class="linenos">106</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">107</span>        <span class="c1"># Gain initialization</span>
<span class="linenos">108</span>        <span class="c1"># Store a private copy of the provided gains for external</span>
<span class="linenos">109</span>        <span class="c1"># introspection via the ``gains`` property.  Accept both 2‑ and 6‑</span>
<span class="linenos">110</span>        <span class="c1"># element sequences.  Only the relevant elements are used for</span>
<span class="linenos">111</span>        <span class="c1"># internal parameters; extra values are ignored.</span>
<span class="linenos">112</span>        <span class="bp">self</span><span class="o">.</span><span class="n">_gains</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gains</span><span class="p">)</span>
<span class="linenos">113</span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gains</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
<span class="linenos">114</span>            <span class="bp">self</span><span class="o">.</span><span class="n">alg_gain_K1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alg_gain_K2</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">gains</span><span class="p">)</span>
<span class="linenos">115</span>            <span class="c1"># Default surface gains (positive constants).  Choosing conservative</span>
<span class="linenos">116</span>            <span class="c1"># defaults ensures the sliding surface has a positive slope and</span>
<span class="linenos">117</span>            <span class="c1"># finite‑time convergence properties【MorenoOsorio2012†L27-L40】.</span>
<span class="linenos">118</span>            <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_lam1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_lam2</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span>
<span class="linenos">119</span>        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">gains</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
<span class="linenos">120</span>            <span class="bp">self</span><span class="o">.</span><span class="n">alg_gain_K1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alg_gain_K2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_lam1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_lam2</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">gains</span><span class="p">[:</span><span class="mi">6</span><span class="p">])</span>
<span class="linenos">121</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">122</span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;SuperTwistingSMC requires 2 or 6 gains&quot;</span><span class="p">)</span>
<span class="linenos">123</span>
<span class="linenos">124</span>
<span class="linenos">125</span>        <span class="c1"># Store parameters from arguments using weakref to break circular references</span>
<span class="linenos">126</span>        <span class="k">if</span> <span class="n">dynamics_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">127</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_dynamics_ref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">dynamics_model</span><span class="p">)</span>
<span class="linenos">128</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">129</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_dynamics_ref</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="kc">None</span>
<span class="linenos">130</span>        <span class="c1"># Validate core parameters using the shared utility.  These</span>
<span class="linenos">131</span>        <span class="c1"># validations enforce positivity or non‑negativity with</span>
<span class="linenos">132</span>        <span class="c1"># consistent error messages across controllers.  See</span>
<span class="linenos">133</span>        <span class="c1"># `src/utils/control_primitives.require_positive` for details.</span>
<span class="linenos">134</span>        <span class="c1"># Import from new modular utils structure</span>
<span class="linenos">135</span>        <span class="k">try</span><span class="p">:</span>
<span class="linenos">136</span>            <span class="kn">from</span><span class="w"> </span><span class="nn">src.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">require_positive</span>  <span class="c1"># when repo root on sys.path</span>
<span class="linenos">137</span>        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
<span class="linenos">138</span>            <span class="k">try</span><span class="p">:</span>
<span class="linenos">139</span>                <span class="kn">from</span><span class="w"> </span><span class="nn">...utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">require_positive</span>  <span class="c1"># when importing as src.controllers.*</span>
<span class="linenos">140</span>            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
<span class="linenos">141</span>                <span class="kn">from</span><span class="w"> </span><span class="nn">utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">require_positive</span>    <span class="c1"># when src itself on sys.path</span>
<span class="linenos">142</span>
<span class="linenos">143</span>        <span class="c1"># Integration step must be strictly positive to avoid division by</span>
<span class="linenos">144</span>        <span class="c1"># zero in discrete‑time updates.</span>
<span class="linenos">145</span>        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="s2">&quot;dt&quot;</span><span class="p">)</span>
<span class="linenos">146</span>
<span class="linenos">147</span>        <span class="c1"># Saturation limit must be strictly positive; if zero the</span>
<span class="linenos">148</span>        <span class="c1"># controller could never exert any force and would be ineffective.</span>
<span class="linenos">149</span>        <span class="bp">self</span><span class="o">.</span><span class="n">max_force</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="n">max_force</span><span class="p">,</span> <span class="s2">&quot;max_force&quot;</span><span class="p">)</span>
<span class="linenos">150</span>
<span class="linenos">151</span>        <span class="c1"># Damping gain is a free parameter; allow any finite float</span>
<span class="linenos">152</span>        <span class="c1"># (positive, zero or negative) without validation here.  The</span>
<span class="linenos">153</span>        <span class="c1"># smoothing effect of the damping term is documented in the</span>
<span class="linenos">154</span>        <span class="c1"># class docstring.</span>
<span class="linenos">155</span>        <span class="bp">self</span><span class="o">.</span><span class="n">damping_gain</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">damping_gain</span><span class="p">)</span>
<span class="linenos">156</span>
<span class="linenos">157</span>        <span class="c1"># Boundary layer width epsilon must be strictly positive to</span>
<span class="linenos">158</span>        <span class="c1"># avoid division by zero in the saturated sign function.  Use</span>
<span class="linenos">159</span>        <span class="c1"># `require_positive` to centralise this check and unify error</span>
<span class="linenos">160</span>        <span class="c1"># messages across controllers.</span>
<span class="linenos">161</span>        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_layer</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="n">boundary_layer</span><span class="p">,</span> <span class="s2">&quot;boundary_layer&quot;</span><span class="p">)</span>
<span class="linenos">162</span>
<span class="linenos">163</span>        <span class="c1"># ---- Additional validation of STA gains (F‑4.SMCDesign.2 / RC‑04) ----</span>
<span class="linenos">164</span>        <span class="c1"># Enforce positivity of algorithmic gains K1, K2 and sliding‑surface</span>
<span class="linenos">165</span>        <span class="c1"># parameters k1, k2, λ1, λ2.  Positive constants ensure finite‑time</span>
<span class="linenos">166</span>        <span class="c1"># stability and well‑posed Lyapunov surfaces【MorenoOsorio2012†L27-L40】.</span>
<span class="linenos">167</span>        <span class="bp">self</span><span class="o">.</span><span class="n">alg_gain_K1</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alg_gain_K1</span><span class="p">,</span> <span class="s2">&quot;K1&quot;</span><span class="p">)</span>
<span class="linenos">168</span>        <span class="bp">self</span><span class="o">.</span><span class="n">alg_gain_K2</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alg_gain_K2</span><span class="p">,</span> <span class="s2">&quot;K2&quot;</span><span class="p">)</span>
<span class="linenos">169</span>        <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k1</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k1</span><span class="p">,</span> <span class="s2">&quot;k1&quot;</span><span class="p">)</span>
<span class="linenos">170</span>        <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k2</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k2</span><span class="p">,</span> <span class="s2">&quot;k2&quot;</span><span class="p">)</span>
<span class="linenos">171</span>        <span class="bp">self</span><span class="o">.</span><span class="n">surf_lam1</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surf_lam1</span><span class="p">,</span> <span class="s2">&quot;lam1&quot;</span><span class="p">)</span>
<span class="linenos">172</span>        <span class="bp">self</span><span class="o">.</span><span class="n">surf_lam2</span> <span class="o">=</span> <span class="n">require_positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surf_lam2</span><span class="p">,</span> <span class="s2">&quot;lam2&quot;</span><span class="p">)</span>
<span class="linenos">173</span>        <span class="n">sm</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">switch_method</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="linenos">174</span>        <span class="k">if</span> <span class="n">sm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;tanh&quot;</span><span class="p">):</span>
<span class="linenos">175</span>            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;switch_method must be &#39;linear&#39; or &#39;tanh&#39;&quot;</span><span class="p">)</span>
<span class="linenos">176</span>        <span class="bp">self</span><span class="o">.</span><span class="n">switch_method</span> <span class="o">=</span> <span class="n">sm</span>
<span class="linenos">177</span>
<span class="linenos">178</span>        <span class="c1"># Placeholders for optional equivalent control</span>
<span class="linenos">179</span>        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="linenos">180</span>        <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="linenos">181</span>
<span class="linenos">182</span>        <span class="c1"># Logger</span>
<span class="linenos">183</span>        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
<span class="linenos">184</span>
<span class="linenos">185</span>        <span class="c1"># Regularisation constant used in the equivalent control term.  A</span>
<span class="linenos">186</span>        <span class="c1"># small positive diagonal added to the inertia matrix improves</span>
<span class="linenos">187</span>        <span class="c1"># conditioning and ensures the matrix is invertible.</span>
<span class="linenos">188</span>        <span class="bp">self</span><span class="o">.</span><span class="n">regularization</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">regularization</span><span class="p">)</span>
<span class="linenos">189</span>
<span class="linenos">190</span>        <span class="c1"># Anti‑windup gain used in back‑calculation.  When non‑zero, the</span>
<span class="linenos">191</span>        <span class="c1"># integrator state z is updated using the difference between the</span>
<span class="linenos">192</span>        <span class="c1"># saturated and unsaturated control to prevent integrator wind‑up</span>
<span class="linenos">193</span>        <span class="c1"># under actuator saturation【789743582768797†L224-L249】.</span>
<span class="linenos">194</span>        <span class="bp">self</span><span class="o">.</span><span class="n">anti_windup_gain</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">anti_windup_gain</span><span class="p">)</span>
<span class="linenos">195</span>
<span class="linenos">196</span>        <span class="c1"># Expose the expected length of the gain vector to external tools.</span>
<span class="linenos">197</span>        <span class="c1"># When a 2‑element gain vector is supplied the remaining surface</span>
<span class="linenos">198</span>        <span class="c1"># parameters default to conservative values; however PSO and other</span>
<span class="linenos">199</span>        <span class="c1"># tuners should explore the full six‑dimensional space.  Declare</span>
<span class="linenos">200</span>        <span class="c1"># six as the nominal dimension so that vector bounds reflect this</span>
<span class="linenos">201</span>        <span class="c1"># maximum length.  See design review section 5 (PSO integration).</span>
<span class="linenos">202</span>        <span class="bp">self</span><span class="o">.</span><span class="n">n_gains</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span>
<span class="linenos">203</span>
<span class="linenos">204</span>    <span class="c1"># ---------------- Controller state/history API ----------------</span>
<span class="linenos">205</span>
<span class="linenos">206</span>    <span class="k">def</span><span class="w"> </span><span class="nf">initialize_state</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="linenos">207</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Return (z, sigma) initial internal state.&quot;&quot;&quot;</span>
<span class="linenos">208</span>        <span class="k">return</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="linenos">209</span>
<span class="linenos">210</span>    <span class="k">def</span><span class="w"> </span><span class="nf">initialize_history</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="linenos">211</span>        <span class="k">return</span> <span class="p">{}</span>
<span class="linenos">212</span>
<span class="linenos">213</span>    <span class="c1"># ---------------- Main control computation -------------------</span>
<span class="linenos">214</span>
<span class="linenos">215</span>    <span class="k">def</span><span class="w"> </span><span class="nf">compute_control</span><span class="p">(</span>
<span class="linenos">216</span>        <span class="bp">self</span><span class="p">,</span>
<span class="linenos">217</span>        <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span class="linenos">218</span>        <span class="n">state_vars</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
<span class="linenos">219</span>        <span class="n">history</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
<span class="linenos">220</span>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">STAOutput</span><span class="p">:</span>
<span class="linenos">221</span>        <span class="c1"># State variables may be provided either as a tuple of (z, sigma)</span>
<span class="linenos">222</span>        <span class="c1"># or as a single scalar (legacy usage).  Accept both forms.</span>
<span class="linenos">223</span>        <span class="k">try</span><span class="p">:</span>
<span class="linenos">224</span>            <span class="c1"># Unpack z and ignore provided sigma; the sliding surface will</span>
<span class="linenos">225</span>            <span class="c1"># be recomputed below.</span>
<span class="linenos">226</span>            <span class="n">z</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">state_vars</span>
<span class="linenos">227</span>        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="linenos">228</span>            <span class="c1"># Non‑iterable (e.g., float) provided: treat as z and</span>
<span class="linenos">229</span>            <span class="c1"># initialize sigma to zero.  Cast to float to avoid</span>
<span class="linenos">230</span>            <span class="c1"># unexpected types (e.g., numpy scalars).</span>
<span class="linenos">231</span>            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;State unpacking failed (non-iterable), treating as scalar: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="linenos">232</span>            <span class="n">z</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">state_vars</span><span class="p">)</span> <span class="k">if</span> <span class="n">state_vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">0.0</span>  <span class="c1"># OK: Legacy input format</span>
<span class="linenos">233</span>
<span class="linenos">234</span>        <span class="n">u_eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_equivalent_control</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="linenos">235</span>
<span class="linenos">236</span>        <span class="c1"># Compute sliding surface and its saturated sign using shared utility</span>
<span class="linenos">237</span>        <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_sliding_surface</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="linenos">238</span>        <span class="n">sgn_sigma</span> <span class="o">=</span> <span class="n">saturate</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_layer</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">switch_method</span><span class="p">)</span>
<span class="linenos">239</span>
<span class="linenos">240</span>        <span class="c1"># Use numba core with precomputed sigma and sgn_sigma</span>
<span class="linenos">241</span>        <span class="n">u</span><span class="p">,</span> <span class="n">new_z</span><span class="p">,</span> <span class="n">sigma_val</span> <span class="o">=</span> <span class="n">_sta_smc_core</span><span class="p">(</span>
<span class="linenos">242</span>            <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span>
<span class="linenos">243</span>            <span class="n">sigma</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">),</span>
<span class="linenos">244</span>            <span class="n">sgn_sigma</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">sgn_sigma</span><span class="p">),</span>
<span class="linenos">245</span>            <span class="n">alg_gain_K1</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alg_gain_K1</span><span class="p">,</span>
<span class="linenos">246</span>            <span class="n">alg_gain_K2</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alg_gain_K2</span><span class="p">,</span>
<span class="linenos">247</span>            <span class="n">damping_gain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">damping_gain</span><span class="p">,</span>
<span class="linenos">248</span>            <span class="n">dt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span>
<span class="linenos">249</span>            <span class="n">max_force</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_force</span><span class="p">,</span>
<span class="linenos">250</span>            <span class="n">u_eq</span><span class="o">=</span><span class="n">u_eq</span><span class="p">,</span>
<span class="linenos">251</span>            <span class="n">Kaw</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">anti_windup_gain</span><span class="p">,</span>
<span class="linenos">252</span>        <span class="p">)</span>
<span class="linenos">253</span>        <span class="c1"># Telemetry: append key signals to history (in-place)</span>
<span class="linenos">254</span>        <span class="n">hist</span> <span class="o">=</span> <span class="n">history</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">history</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="p">{}</span>
<span class="linenos">255</span>        <span class="n">hist</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;sigma&#39;</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span>
<span class="linenos">256</span>        <span class="n">hist</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">new_z</span><span class="p">))</span>
<span class="linenos">257</span>        <span class="n">hist</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
<span class="linenos">258</span>        <span class="n">hist</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;u_eq&#39;</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">u_eq</span><span class="p">))</span>
<span class="linenos">259</span>
<span class="linenos">260</span>        <span class="c1"># Package results into a named tuple. The internal state carries</span>
<span class="linenos">261</span>        <span class="c1"># the updated z and latest sliding surface value. Sigma is also</span>
<span class="linenos">262</span>        <span class="c1"># returned separately for batch simulation and Lyapunov validation.</span>
<span class="linenos">263</span>        <span class="k">return</span> <span class="n">STAOutput</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="n">new_z</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">)),</span> <span class="n">hist</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span>
<span class="linenos">264</span>
<span class="linenos">265</span>    <span class="k">def</span><span class="w"> </span><span class="nf">validate_gains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gains_b</span><span class="p">:</span> <span class="s2">&quot;np.ndarray&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;np.ndarray&quot;</span><span class="p">:</span>
<span class="linenos">266</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">267</span><span class="sd">        Vectorized feasibility check for super‑twisting SMC gains.</span>
<span class="linenos">268</span>
<span class="linenos">269</span><span class="sd">        The algorithmic gains ``K1`` and ``K2`` must be strictly positive to</span>
<span class="linenos">270</span><span class="sd">        ensure finite‑time convergence of the super‑twisting algorithm. Additionally,</span>
<span class="linenos">271</span><span class="sd">        for stability, K1 &gt; K2 is required per super-twisting theory. When</span>
<span class="linenos">272</span><span class="sd">        a six‑element gain vector is provided the sliding‑surface gains</span>
<span class="linenos">273</span><span class="sd">        ``k1``, ``k2`` and the lambda parameters ``lam1``, ``lam2`` must also</span>
<span class="linenos">274</span><span class="sd">        be positive.  Positive sliding‑surface coefficients are required</span>
<span class="linenos">275</span><span class="sd">        because the sliding surface is a linear combination of state</span>
<span class="linenos">276</span><span class="sd">        variables with positive weights.</span>
<span class="linenos">277</span>
<span class="linenos">278</span><span class="sd">        Parameters</span>
<span class="linenos">279</span><span class="sd">        ----------</span>
<span class="linenos">280</span><span class="sd">        gains_b : np.ndarray</span>
<span class="linenos">281</span><span class="sd">            Array of shape (B, D) containing candidate gain vectors.  The</span>
<span class="linenos">282</span><span class="sd">            first two columns correspond to ``K1`` and ``K2``; if ``D`` ≥ 6</span>
<span class="linenos">283</span><span class="sd">            then columns 3–6 correspond to ``k1``, ``k2``, ``lam1`` and</span>
<span class="linenos">284</span><span class="sd">            ``lam2`` respectively.</span>
<span class="linenos">285</span>
<span class="linenos">286</span><span class="sd">        Returns</span>
<span class="linenos">287</span><span class="sd">        -------</span>
<span class="linenos">288</span><span class="sd">        np.ndarray</span>
<span class="linenos">289</span><span class="sd">            Boolean mask of shape (B,) indicating which rows satisfy the</span>
<span class="linenos">290</span><span class="sd">            positivity and stability constraints.</span>
<span class="linenos">291</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">292</span>        <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_np</span>
<span class="linenos">293</span>        <span class="k">if</span> <span class="n">gains_b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">gains_b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
<span class="linenos">294</span>            <span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">gains_b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="linenos">295</span>        <span class="c1"># Always require K1 and K2 to be positive AND K1 &gt; K2 for stability</span>
<span class="linenos">296</span>        <span class="n">k1</span> <span class="o">=</span> <span class="n">gains_b</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span class="linenos">297</span>        <span class="n">k2</span> <span class="o">=</span> <span class="n">gains_b</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span class="linenos">298</span>        <span class="n">valid</span> <span class="o">=</span> <span class="p">(</span><span class="n">k1</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k2</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">k1</span> <span class="o">&gt;</span> <span class="n">k2</span><span class="p">)</span>
<span class="linenos">299</span>        <span class="c1"># If sliding surface parameters are provided, require them to be positive</span>
<span class="linenos">300</span>        <span class="k">if</span> <span class="n">gains_b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">:</span>
<span class="linenos">301</span>            <span class="n">surf_k1</span> <span class="o">=</span> <span class="n">gains_b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span class="linenos">302</span>            <span class="n">surf_k2</span> <span class="o">=</span> <span class="n">gains_b</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span class="linenos">303</span>            <span class="n">lam1</span> <span class="o">=</span> <span class="n">gains_b</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span class="linenos">304</span>            <span class="n">lam2</span> <span class="o">=</span> <span class="n">gains_b</span><span class="p">[:,</span> <span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span class="linenos">305</span>            <span class="n">valid</span> <span class="o">=</span> <span class="n">valid</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">surf_k1</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">surf_k2</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">lam1</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">lam2</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="linenos">306</span>        <span class="k">return</span> <span class="n">valid</span>
<span class="linenos">307</span>
<span class="linenos">308</span>    <span class="c1"># ------------------------------------------------------------------</span>
<span class="linenos">309</span>    <span class="c1"># Properties</span>
<span class="linenos">310</span>    <span class="c1"># ------------------------------------------------------------------</span>
<span class="linenos">311</span>    <span class="nd">@property</span>
<span class="linenos">312</span>    <span class="k">def</span><span class="w"> </span><span class="nf">gains</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="linenos">313</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a copy of the gains used to configure this controller.</span>
<span class="linenos">314</span>
<span class="linenos">315</span><span class="sd">        The returned list includes all elements supplied to the constructor,</span>
<span class="linenos">316</span><span class="sd">        whether 2 or 6 gains.  This enables external code (and tests) to</span>
<span class="linenos">317</span><span class="sd">        inspect the algorithmic and sliding‑surface gains after</span>
<span class="linenos">318</span><span class="sd">        instantiation without risk of mutating the internal state.</span>
<span class="linenos">319</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">320</span>        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gains</span><span class="p">)</span>
<span class="linenos">321</span>
<span class="linenos">322</span>    <span class="nd">@property</span>
<span class="linenos">323</span>    <span class="k">def</span><span class="w"> </span><span class="nf">dyn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">324</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Access dynamics model via weakref.&quot;&quot;&quot;</span>
<span class="linenos">325</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamics_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">326</span>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dynamics_ref</span><span class="p">()</span>
<span class="linenos">327</span>        <span class="k">return</span> <span class="kc">None</span>
<span class="linenos">328</span>
<span class="linenos">329</span>    <span class="nd">@dyn</span><span class="o">.</span><span class="n">setter</span>
<span class="linenos">330</span>    <span class="k">def</span><span class="w"> </span><span class="nf">dyn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="linenos">331</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Set dynamics model using weakref.&quot;&quot;&quot;</span>
<span class="linenos">332</span>        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">333</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_dynamics_ref</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="linenos">334</span>        <span class="k">else</span><span class="p">:</span>
<span class="linenos">335</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_dynamics_ref</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="kc">None</span>
<span class="linenos">336</span>
<span class="linenos">337</span>    <span class="nd">@property</span>
<span class="linenos">338</span>    <span class="k">def</span><span class="w"> </span><span class="nf">dynamics_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="linenos">339</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Alias for dyn property (for batch simulation compatibility).&quot;&quot;&quot;</span>
<span class="linenos">340</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn</span>
<span class="linenos">341</span>
<span class="linenos">342</span>    <span class="nd">@dynamics_model</span><span class="o">.</span><span class="n">setter</span>
<span class="linenos">343</span>    <span class="k">def</span><span class="w"> </span><span class="nf">dynamics_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="linenos">344</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Alias for dyn setter (for batch simulation compatibility).&quot;&quot;&quot;</span>
<span class="linenos">345</span>        <span class="bp">self</span><span class="o">.</span><span class="n">dyn</span> <span class="o">=</span> <span class="n">value</span>
<span class="linenos">346</span>
<span class="linenos">347</span>    <span class="c1"># ---------------- Utilities -------------------</span>
<span class="linenos">348</span>
<span class="linenos">349</span>    <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">350</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset STA-SMC controller state.</span>
<span class="linenos">351</span>
<span class="linenos">352</span><span class="sd">        Resets internal state variables to initial conditions:</span>
<span class="linenos">353</span><span class="sd">        - Clears the integral state z</span>
<span class="linenos">354</span><span class="sd">        - Resets the last surface value</span>
<span class="linenos">355</span><span class="sd">        - Reinitializes any internal tracking variables</span>
<span class="linenos">356</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">357</span>        <span class="c1"># Reset integral state (z) to zero</span>
<span class="linenos">358</span>        <span class="c1"># This is the main internal state for the super-twisting algorithm</span>
<span class="linenos">359</span>        <span class="k">pass</span>  <span class="c1"># The controller gets z from state_vars parameter, no persistent internal state</span>
<span class="linenos">360</span>
<span class="linenos">361</span>    <span class="k">def</span><span class="w"> </span><span class="nf">cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">362</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Clean up controller resources (Issue #15).</span>
<span class="linenos">363</span>
<span class="linenos">364</span><span class="sd">        Explicitly releases references to dynamics model and clears</span>
<span class="linenos">365</span><span class="sd">        any cached data to facilitate garbage collection and prevent</span>
<span class="linenos">366</span><span class="sd">        memory leaks during repeated controller instantiation.</span>
<span class="linenos">367</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">368</span>        <span class="c1"># Nullify dynamics reference</span>
<span class="linenos">369</span>        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_dynamics_ref&#39;</span><span class="p">):</span>
<span class="linenos">370</span>            <span class="bp">self</span><span class="o">.</span><span class="n">_dynamics_ref</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="kc">None</span>
<span class="linenos">371</span>
<span class="linenos">372</span>        <span class="c1"># Clear cached vectors</span>
<span class="linenos">373</span>        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">):</span>
<span class="linenos">374</span>            <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="kc">None</span>
<span class="linenos">375</span>        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">):</span>
<span class="linenos">376</span>            <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="kc">None</span>
<span class="linenos">377</span>
<span class="linenos">378</span>    <span class="k">def</span><span class="w"> </span><span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">379</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Destructor for automatic cleanup.</span>
<span class="linenos">380</span>
<span class="linenos">381</span><span class="sd">        Ensures cleanup is called when the controller is garbage collected.</span>
<span class="linenos">382</span><span class="sd">        Catches all exceptions to prevent errors during finalization.</span>
<span class="linenos">383</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">384</span>        <span class="k">try</span><span class="p">:</span>
<span class="linenos">385</span>            <span class="bp">self</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
<span class="linenos">386</span>        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
<span class="linenos">387</span>            <span class="k">pass</span>  <span class="c1"># Prevent exceptions during cleanup</span>
<span class="linenos">388</span>
<span class="linenos">389</span>    <span class="k">def</span><span class="w"> </span><span class="nf">set_dynamics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dynamics_model</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">390</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Attach dynamics model if available (used by u_eq if implemented).&quot;&quot;&quot;</span>
<span class="linenos">391</span>        <span class="bp">self</span><span class="o">.</span><span class="n">dyn</span> <span class="o">=</span> <span class="n">dynamics_model</span>
<span class="linenos">392</span>
<span class="linenos">393</span>    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_sliding_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="linenos">394</span>        <span class="n">_</span><span class="p">,</span> <span class="n">th1</span><span class="p">,</span> <span class="n">th2</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">th1dot</span><span class="p">,</span> <span class="n">th2dot</span> <span class="o">=</span> <span class="n">state</span>
<span class="linenos">395</span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k1</span> <span class="o">*</span> <span class="p">(</span><span class="n">th1dot</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_lam1</span> <span class="o">*</span> <span class="n">th1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k2</span> <span class="o">*</span> <span class="p">(</span><span class="n">th2dot</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_lam2</span> <span class="o">*</span> <span class="n">th2</span><span class="p">)</span>
<span class="linenos">396</span>
<span class="linenos">397</span>    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_equivalent_control</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="linenos">398</span><span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the model‑based equivalent control ``u_eq`` using Tikhonov regularisation.</span>
<span class="linenos">399</span>
<span class="linenos">400</span><span class="sd">        The original implementation used an SVD‑based condition estimate and a</span>
<span class="linenos">401</span><span class="sd">        pseudo‑inverse to invert the inertia matrix.  This version instead</span>
<span class="linenos">402</span><span class="sd">        applies a small diagonal regularisation and solves the resulting</span>
<span class="linenos">403</span><span class="sd">        linear systems directly, reducing computational overhead and</span>
<span class="linenos">404</span><span class="sd">        eliminating the need for a full SVD.  Adding a small constant to</span>
<span class="linenos">405</span><span class="sd">        the diagonal of a symmetric indefinite matrix makes it positive</span>
<span class="linenos">406</span><span class="sd">        definite and invertible, a standard technique in control</span>
<span class="linenos">407</span><span class="sd">        literature.</span>
<span class="linenos">408</span><span class="sd">        &quot;&quot;&quot;</span>
<span class="linenos">409</span>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="linenos">410</span>            <span class="k">return</span> <span class="mf">0.0</span>
<span class="linenos">411</span>
<span class="linenos">412</span>        <span class="n">q_dot</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
<span class="linenos">413</span>        <span class="k">try</span><span class="p">:</span>
<span class="linenos">414</span>            <span class="n">M</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dyn</span><span class="o">.</span><span class="n">_compute_physics_matrices</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="linenos">415</span>        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="linenos">416</span>            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Physics matrix computation failed, returning safe zero control: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="linenos">417</span>            <span class="k">return</span> <span class="mf">0.0</span>  <span class="c1"># OK: Safe fallback when dynamics unavailable</span>
<span class="linenos">418</span>
<span class="linenos">419</span>        <span class="c1"># Regularise the inertia matrix using the configurable constant.  A</span>
<span class="linenos">420</span>        <span class="c1"># small diagonal offset guarantees invertibility of symmetric</span>
<span class="linenos">421</span>        <span class="c1"># matrices.</span>
<span class="linenos">422</span>        <span class="n">M_reg</span> <span class="o">=</span> <span class="n">M</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regularization</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="linenos">423</span>        <span class="k">try</span><span class="p">:</span>
<span class="linenos">424</span>            <span class="c1"># Compute controllability scalar L M^-1 B.  Use the boundary layer</span>
<span class="linenos">425</span>            <span class="c1"># thickness as a threshold for ill‑conditioned feedforward terms.</span>
<span class="linenos">426</span>            <span class="n">Minv_B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M_reg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">)</span>
<span class="linenos">427</span>            <span class="n">L_Minv_B</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">@</span> <span class="n">Minv_B</span><span class="p">)</span>
<span class="linenos">428</span>            <span class="c1"># If the equivalent control would divide by a very small number,</span>
<span class="linenos">429</span>            <span class="c1"># return zero.  The threshold equals the boundary layer epsilon</span>
<span class="linenos">430</span>            <span class="c1"># such that the same tuning parameter governs both chattering</span>
<span class="linenos">431</span>            <span class="c1"># mitigation and model invertibility.</span>
<span class="linenos">432</span>            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">L_Minv_B</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_layer</span><span class="p">:</span>
<span class="linenos">433</span>                <span class="k">return</span> <span class="mf">0.0</span>
<span class="linenos">434</span>
<span class="linenos">435</span>            <span class="c1"># Compute rhs = C q_dot + G.  Support both matrix and vector forms.</span>
<span class="linenos">436</span>            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s2">&quot;ndim&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
<span class="linenos">437</span>                <span class="n">rhs</span> <span class="o">=</span> <span class="n">C</span> <span class="o">@</span> <span class="n">q_dot</span> <span class="o">+</span> <span class="n">G</span>
<span class="linenos">438</span>            <span class="k">else</span><span class="p">:</span>
<span class="linenos">439</span>                <span class="n">rhs</span> <span class="o">=</span> <span class="n">C</span> <span class="o">+</span> <span class="n">G</span>
<span class="linenos">440</span>            <span class="n">Minv_rhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">M_reg</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
<span class="linenos">441</span>            <span class="n">num</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">@</span> <span class="n">Minv_rhs</span><span class="p">)</span>
<span class="linenos">442</span>            <span class="c1"># Equivalent control is the feedforward term minus the damping</span>
<span class="linenos">443</span>            <span class="c1"># portion from the sliding surface definition.  Following</span>
<span class="linenos">444</span>            <span class="c1"># conventional SMC, subtract the inner product of the surface</span>
<span class="linenos">445</span>            <span class="c1"># gains with the joint velocities.  Note the sign convention</span>
<span class="linenos">446</span>            <span class="c1"># matches the one used in ClassicalSMC.</span>
<span class="linenos">447</span>            <span class="n">u_eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_lam1</span> <span class="o">*</span> <span class="n">q_dot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
<span class="linenos">448</span>                           <span class="bp">self</span><span class="o">.</span><span class="n">surf_gain_k2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">surf_lam2</span> <span class="o">*</span> <span class="n">q_dot</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">/</span> <span class="n">L_Minv_B</span>
<span class="linenos">449</span>        <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
<span class="linenos">450</span>            <span class="c1"># Singular matrix despite regularisation; disable equivalent control</span>
<span class="linenos">451</span>            <span class="k">return</span> <span class="mf">0.0</span>
<span class="linenos">452</span>
<span class="linenos">453</span>        <span class="c1"># Do not apply additional clamping here.  The final saturation in</span>
<span class="linenos">454</span>        <span class="c1"># ``compute_control`` will bound the control effort.  Returning the</span>
<span class="linenos">455</span>        <span class="c1"># raw equivalent control maintains transparency and avoids</span>
<span class="linenos">456</span>        <span class="c1"># inadvertently biasing the controller output.</span>
<span class="linenos">457</span>        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">u_eq</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="methods-14">
<h3>Methods (14)<a class="headerlink" href="#methods-14" title="Link to this heading">¶</a></h3>
<section id="init-self-gains-dt-max-force-damping-gain-boundary-layer-dynamics-model-switch-method-regularization-anti-windup-gain">
<h4><code class="docutils literal notranslate"><span class="pre">__init__(self,</span> <span class="pre">gains,</span> <span class="pre">dt,</span> <span class="pre">max_force,</span> <span class="pre">damping_gain,</span> <span class="pre">boundary_layer,</span> <span class="pre">dynamics_model,</span> <span class="pre">switch_method,</span> <span class="pre">regularization,</span> <span class="pre">anti_windup_gain)</span></code><a class="headerlink" href="#init-self-gains-dt-max-force-damping-gain-boundary-layer-dynamics-model-switch-method-regularization-anti-windup-gain" title="Link to this heading">¶</a></h4>
<p>Initialize a Super‑Twisting Sliding Mode Controller.</p>
<p><a class="reference internal" href="#method-supertwistingsmc-__init__"><span class="xref myst">View full source →</span></a></p>
</section>
<section id="initialize-state-self">
<h4><code class="docutils literal notranslate"><span class="pre">initialize_state(self)</span></code><a class="headerlink" href="#initialize-state-self" title="Link to this heading">¶</a></h4>
<p>Return (z, sigma) initial internal state.</p>
<p><a class="reference internal" href="#method-supertwistingsmc-initialize_state"><span class="xref myst">View full source →</span></a></p>
</section>
<section id="initialize-history-self">
<h4><code class="docutils literal notranslate"><span class="pre">initialize_history(self)</span></code><a class="headerlink" href="#initialize-history-self" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="#method-supertwistingsmc-initialize_history"><span class="xref myst">View full source →</span></a></p>
</section>
<section id="compute-control-self-state-state-vars-history">
<h4><code class="docutils literal notranslate"><span class="pre">compute_control(self,</span> <span class="pre">state,</span> <span class="pre">state_vars,</span> <span class="pre">history)</span></code><a class="headerlink" href="#compute-control-self-state-state-vars-history" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="#method-supertwistingsmc-compute_control"><span class="xref myst">View full source →</span></a></p>
</section>
<section id="validate-gains-self-gains-b">
<h4><code class="docutils literal notranslate"><span class="pre">validate_gains(self,</span> <span class="pre">gains_b)</span></code><a class="headerlink" href="#validate-gains-self-gains-b" title="Link to this heading">¶</a></h4>
<p>Vectorized feasibility check for super‑twisting SMC gains.</p>
<p><a class="reference internal" href="#method-supertwistingsmc-validate_gains"><span class="xref myst">View full source →</span></a></p>
</section>
<section id="gains-self">
<h4><code class="docutils literal notranslate"><span class="pre">gains(self)</span></code><a class="headerlink" href="#gains-self" title="Link to this heading">¶</a></h4>
<p>Return a copy of the gains used to configure this controller.</p>
<p><a class="reference internal" href="#method-supertwistingsmc-gains"><span class="xref myst">View full source →</span></a></p>
</section>
<section id="dyn-self">
<h4><code class="docutils literal notranslate"><span class="pre">dyn(self)</span></code><a class="headerlink" href="#dyn-self" title="Link to this heading">¶</a></h4>
<p>Access dynamics model via weakref.</p>
<p><a class="reference internal" href="#method-supertwistingsmc-dyn"><span class="xref myst">View full source →</span></a></p>
</section>
<section id="dyn-self-value">
<h4><code class="docutils literal notranslate"><span class="pre">dyn(self,</span> <span class="pre">value)</span></code><a class="headerlink" href="#dyn-self-value" title="Link to this heading">¶</a></h4>
<p>Set dynamics model using weakref.</p>
<p><a class="reference internal" href="#method-supertwistingsmc-dyn"><span class="xref myst">View full source →</span></a></p>
</section>
<section id="reset-self">
<h4><code class="docutils literal notranslate"><span class="pre">reset(self)</span></code><a class="headerlink" href="#reset-self" title="Link to this heading">¶</a></h4>
<p>Reset STA-SMC controller state.</p>
<p><a class="reference internal" href="#method-supertwistingsmc-reset"><span class="xref myst">View full source →</span></a></p>
</section>
<section id="cleanup-self">
<h4><code class="docutils literal notranslate"><span class="pre">cleanup(self)</span></code><a class="headerlink" href="#cleanup-self" title="Link to this heading">¶</a></h4>
<p>Clean up controller resources (Issue #15).</p>
<p><a class="reference internal" href="#method-supertwistingsmc-cleanup"><span class="xref myst">View full source →</span></a></p>
</section>
<section id="del-self">
<h4><code class="docutils literal notranslate"><span class="pre">__del__(self)</span></code><a class="headerlink" href="#del-self" title="Link to this heading">¶</a></h4>
<p>Destructor for automatic cleanup.</p>
<p><a class="reference internal" href="#method-supertwistingsmc-__del__"><span class="xref myst">View full source →</span></a></p>
</section>
<section id="set-dynamics-self-dynamics-model">
<h4><code class="docutils literal notranslate"><span class="pre">set_dynamics(self,</span> <span class="pre">dynamics_model)</span></code><a class="headerlink" href="#set-dynamics-self-dynamics-model" title="Link to this heading">¶</a></h4>
<p>Attach dynamics model if available (used by u_eq if implemented).</p>
<p><a class="reference internal" href="#method-supertwistingsmc-set_dynamics"><span class="xref myst">View full source →</span></a></p>
</section>
<section id="compute-sliding-surface-self-state">
<h4><code class="docutils literal notranslate"><span class="pre">_compute_sliding_surface(self,</span> <span class="pre">state)</span></code><a class="headerlink" href="#compute-sliding-surface-self-state" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="#method-supertwistingsmc-_compute_sliding_surface"><span class="xref myst">View full source →</span></a></p>
</section>
<section id="compute-equivalent-control-self-state">
<h4><code class="docutils literal notranslate"><span class="pre">_compute_equivalent_control(self,</span> <span class="pre">state)</span></code><a class="headerlink" href="#compute-equivalent-control-self-state" title="Link to this heading">¶</a></h4>
<p>Compute the model‑based equivalent control <code class="docutils literal notranslate"><span class="pre">u_eq</span></code> using Tikhonov regularisation.</p>
<p><a class="reference internal" href="#method-supertwistingsmc-_compute_equivalent_control"><span class="xref myst">View full source →</span></a></p>
</section>
</section>
</section>
<hr class="docutils" />
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Link to this heading">¶</a></h2>
<section id="sta-smc-control-numba-state-z-alg-gain-k1-alg-gain-k2-surf-gain-k1-surf-gain-k2-surf-lam1-surf-lam2-damping-gain-dt-max-force-boundary-layer-u-eq">
<h3><code class="docutils literal notranslate"><span class="pre">_sta_smc_control_numba(state,</span> <span class="pre">z,</span> <span class="pre">alg_gain_K1,</span> <span class="pre">alg_gain_K2,</span> <span class="pre">surf_gain_k1,</span> <span class="pre">surf_gain_k2,</span> <span class="pre">surf_lam1,</span> <span class="pre">surf_lam2,</span> <span class="pre">damping_gain,</span> <span class="pre">dt,</span> <span class="pre">max_force,</span> <span class="pre">boundary_layer,</span> <span class="pre">u_eq)</span></code><a class="headerlink" href="#sta-smc-control-numba-state-z-alg-gain-k1-alg-gain-k2-surf-gain-k1-surf-gain-k2-surf-lam1-surf-lam2-damping-gain-dt-max-force-boundary-layer-u-eq" title="Link to this heading">¶</a></h3>
<p><strong>Decorators:</strong> <code class="docutils literal notranslate"><span class="pre">&#64;numba.njit(cache=True)</span></code></p>
<p>Numba‑accelerated core of the Super‑Twisting SMC.</p>
<p>Uses a saturated sign function for sigma to maintain full control authority
outside the boundary layer and linear behavior inside it, which is required
for robust, finite‑time convergence of the super‑twisting algorithm.</p>
<section id="id1">
<h4>Source Code<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="linenos"> 2</span><span class="k">def</span><span class="w"> </span><span class="nf">_sta_smc_control_numba</span><span class="p">(</span>
<span class="linenos"> 3</span>    <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span class="linenos"> 4</span>    <span class="n">z</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 5</span>    <span class="n">alg_gain_K1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">alg_gain_K2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">surf_gain_k1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">surf_gain_k2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">surf_lam1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">surf_lam2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 6</span>    <span class="n">damping_gain</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">max_force</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">boundary_layer</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 7</span>    <span class="n">u_eq</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="linenos"> 8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="linenos"> 9</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="linenos">10</span><span class="sd">    Numba‑accelerated core of the Super‑Twisting SMC.</span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="sd">    Uses a saturated sign function for sigma to maintain full control authority</span>
<span class="linenos">13</span><span class="sd">    outside the boundary layer and linear behavior inside it, which is required</span>
<span class="linenos">14</span><span class="sd">    for robust, finite‑time convergence of the super‑twisting algorithm.</span>
<span class="linenos">15</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">16</span>    <span class="n">_</span><span class="p">,</span> <span class="n">th1</span><span class="p">,</span> <span class="n">th2</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">th1dot</span><span class="p">,</span> <span class="n">th2dot</span> <span class="o">=</span> <span class="n">state</span>
<span class="linenos">17</span>
<span class="linenos">18</span>    <span class="c1"># Sliding surface: sigma = k1*(th1dot + lam1*th1) + k2*(th2dot + lam2*th2)</span>
<span class="linenos">19</span>    <span class="n">sigma</span> <span class="o">=</span> <span class="n">surf_gain_k1</span> <span class="o">*</span> <span class="p">(</span><span class="n">th1dot</span> <span class="o">+</span> <span class="n">surf_lam1</span> <span class="o">*</span> <span class="n">th1</span><span class="p">)</span> <span class="o">+</span> <span class="n">surf_gain_k2</span> <span class="o">*</span> <span class="p">(</span><span class="n">th2dot</span> <span class="o">+</span> <span class="n">surf_lam2</span> <span class="o">*</span> <span class="n">th2</span><span class="p">)</span>
<span class="linenos">20</span>
<span class="linenos">21</span>    <span class="c1"># ---- FIX CS‑01: robust saturation instead of &quot;sigma/(|sigma|+eps)&quot; ----</span>
<span class="linenos">22</span>    <span class="n">eps</span> <span class="o">=</span> <span class="n">boundary_layer</span>  <span class="c1"># guaranteed &gt; 0 by __init__</span>
<span class="linenos">23</span>    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">:</span>
<span class="linenos">24</span>        <span class="n">sgn_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>        <span class="c1"># full control authority</span>
<span class="linenos">25</span>    <span class="k">else</span><span class="p">:</span>
<span class="linenos">26</span>        <span class="n">sgn_sigma</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">/</span> <span class="n">eps</span>           <span class="c1"># linear inside boundary layer</span>
<span class="linenos">27</span>    <span class="c1"># -----------------------------------------------------------------------</span>
<span class="linenos">28</span>
<span class="linenos">29</span>    <span class="c1"># Super‑twisting continuous term and disturbance‑like internal state</span>
<span class="linenos">30</span>    <span class="n">u_cont</span> <span class="o">=</span> <span class="o">-</span><span class="n">alg_gain_K1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span> <span class="o">*</span> <span class="n">sgn_sigma</span>
<span class="linenos">31</span>    <span class="c1"># Use the previous z (integral state) for the disturbance term.  In the</span>
<span class="linenos">32</span>    <span class="c1"># continuous super‑twisting algorithm, the integral term z enters the</span>
<span class="linenos">33</span>    <span class="c1"># control law directly and is updated after computing the control.  The</span>
<span class="linenos">34</span>    <span class="c1"># earlier implementation incorrectly used the updated z in the same step.</span>
<span class="linenos">35</span>    <span class="n">u_dis</span> <span class="o">=</span> <span class="n">z</span>
<span class="linenos">36</span>    <span class="n">new_z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">alg_gain_K2</span> <span class="o">*</span> <span class="n">sgn_sigma</span> <span class="o">*</span> <span class="n">dt</span>
<span class="linenos">37</span>
<span class="linenos">38</span>    <span class="c1"># Damping on sigma (optional)</span>
<span class="linenos">39</span>    <span class="n">u</span> <span class="o">=</span> <span class="n">u_eq</span> <span class="o">+</span> <span class="n">u_cont</span> <span class="o">+</span> <span class="n">u_dis</span> <span class="o">-</span> <span class="n">damping_gain</span> <span class="o">*</span> <span class="n">sigma</span>
<span class="linenos">40</span>
<span class="linenos">41</span>    <span class="c1"># Saturate final outputs to actuator limits.  Numba cannot</span>
<span class="linenos">42</span>    <span class="c1"># compile np.clip on scalars when running in nopython mode.  Use</span>
<span class="linenos">43</span>    <span class="c1"># explicit conditional clamps instead.</span>
<span class="linenos">44</span>    <span class="k">if</span> <span class="n">u</span> <span class="o">&gt;</span> <span class="n">max_force</span><span class="p">:</span>
<span class="linenos">45</span>        <span class="n">u</span> <span class="o">=</span> <span class="n">max_force</span>
<span class="linenos">46</span>    <span class="k">elif</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">max_force</span><span class="p">:</span>
<span class="linenos">47</span>        <span class="n">u</span> <span class="o">=</span> <span class="o">-</span><span class="n">max_force</span>
<span class="linenos">48</span>    <span class="k">if</span> <span class="n">new_z</span> <span class="o">&gt;</span> <span class="n">max_force</span><span class="p">:</span>
<span class="linenos">49</span>        <span class="n">new_z</span> <span class="o">=</span> <span class="n">max_force</span>
<span class="linenos">50</span>    <span class="k">elif</span> <span class="n">new_z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">max_force</span><span class="p">:</span>
<span class="linenos">51</span>        <span class="n">new_z</span> <span class="o">=</span> <span class="o">-</span><span class="n">max_force</span>
<span class="linenos">52</span>    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">new_z</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="sta-smc-core-z-sigma-sgn-sigma-alg-gain-k1-alg-gain-k2-damping-gain-dt-max-force-u-eq-kaw">
<h3><code class="docutils literal notranslate"><span class="pre">_sta_smc_core(z,</span> <span class="pre">sigma,</span> <span class="pre">sgn_sigma,</span> <span class="pre">alg_gain_K1,</span> <span class="pre">alg_gain_K2,</span> <span class="pre">damping_gain,</span> <span class="pre">dt,</span> <span class="pre">max_force,</span> <span class="pre">u_eq,</span> <span class="pre">Kaw)</span></code><a class="headerlink" href="#sta-smc-core-z-sigma-sgn-sigma-alg-gain-k1-alg-gain-k2-damping-gain-dt-max-force-u-eq-kaw" title="Link to this heading">¶</a></h3>
<p><strong>Decorators:</strong> <code class="docutils literal notranslate"><span class="pre">&#64;numba.njit(cache=True)</span></code></p>
<p>Numba-accelerated core using precomputed sigma and its saturated sign.</p>
<p>Includes anti-windup back‑calculation: the integrator state <code class="docutils literal notranslate"><span class="pre">z</span></code> is
updated using the difference between the saturated and unsaturated
control multiplied by <code class="docutils literal notranslate"><span class="pre">Kaw</span></code>【789743582768797†L224-L249】.  Returns
<code class="docutils literal notranslate"><span class="pre">(u_saturated,</span> <span class="pre">new_z,</span> <span class="pre">sigma)</span></code>.</p>
<section id="id2">
<h4>Source Code<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="linenos"> 2</span><span class="k">def</span><span class="w"> </span><span class="nf">_sta_smc_core</span><span class="p">(</span>
<span class="linenos"> 3</span>    <span class="n">z</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 4</span>    <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 5</span>    <span class="n">sgn_sigma</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 6</span>    <span class="n">alg_gain_K1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 7</span>    <span class="n">alg_gain_K2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 8</span>    <span class="n">damping_gain</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos"> 9</span>    <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos">10</span>    <span class="n">max_force</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="linenos">11</span>    <span class="n">u_eq</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span class="linenos">12</span>    <span class="n">Kaw</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
<span class="linenos">13</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="linenos">14</span><span class="w">    </span><span class="sd">&quot;&quot;&quot;Numba-accelerated core using precomputed sigma and its saturated sign.</span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="sd">    Includes anti-windup back‑calculation: the integrator state ``z`` is</span>
<span class="linenos">17</span><span class="sd">    updated using the difference between the saturated and unsaturated</span>
<span class="linenos">18</span><span class="sd">    control multiplied by ``Kaw``【789743582768797†L224-L249】.  Returns</span>
<span class="linenos">19</span><span class="sd">    ``(u_saturated, new_z, sigma)``.</span>
<span class="linenos">20</span><span class="sd">    &quot;&quot;&quot;</span>
<span class="linenos">21</span>    <span class="c1"># Continuous term and disturbance‑like internal state</span>
<span class="linenos">22</span>    <span class="n">u_cont</span> <span class="o">=</span> <span class="o">-</span><span class="n">alg_gain_K1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sigma</span><span class="p">))</span> <span class="o">*</span> <span class="n">sgn_sigma</span>
<span class="linenos">23</span>    <span class="n">u_dis</span> <span class="o">=</span> <span class="n">z</span>
<span class="linenos">24</span>    <span class="c1"># Compute unsaturated control</span>
<span class="linenos">25</span>    <span class="n">u_raw</span> <span class="o">=</span> <span class="n">u_eq</span> <span class="o">+</span> <span class="n">u_cont</span> <span class="o">+</span> <span class="n">u_dis</span> <span class="o">-</span> <span class="n">damping_gain</span> <span class="o">*</span> <span class="n">sigma</span>
<span class="linenos">26</span>    <span class="c1"># Saturate the control</span>
<span class="linenos">27</span>    <span class="n">u_sat</span> <span class="o">=</span> <span class="n">u_raw</span>
<span class="linenos">28</span>    <span class="k">if</span> <span class="n">u_sat</span> <span class="o">&gt;</span> <span class="n">max_force</span><span class="p">:</span>
<span class="linenos">29</span>        <span class="n">u_sat</span> <span class="o">=</span> <span class="n">max_force</span>
<span class="linenos">30</span>    <span class="k">elif</span> <span class="n">u_sat</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">max_force</span><span class="p">:</span>
<span class="linenos">31</span>        <span class="n">u_sat</span> <span class="o">=</span> <span class="o">-</span><span class="n">max_force</span>
<span class="linenos">32</span>    <span class="c1"># Anti-windup back‑calculation: adjust integrator when saturation occurs</span>
<span class="linenos">33</span>    <span class="n">new_z</span> <span class="o">=</span> <span class="n">z</span> <span class="o">-</span> <span class="n">alg_gain_K2</span> <span class="o">*</span> <span class="n">sgn_sigma</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">+</span> <span class="n">Kaw</span> <span class="o">*</span> <span class="p">(</span><span class="n">u_sat</span> <span class="o">-</span> <span class="n">u_raw</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
<span class="linenos">34</span>    <span class="c1"># Saturate the integrator to maintain boundedness</span>
<span class="linenos">35</span>    <span class="k">if</span> <span class="n">new_z</span> <span class="o">&gt;</span> <span class="n">max_force</span><span class="p">:</span>
<span class="linenos">36</span>        <span class="n">new_z</span> <span class="o">=</span> <span class="n">max_force</span>
<span class="linenos">37</span>    <span class="k">elif</span> <span class="n">new_z</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">max_force</span><span class="p">:</span>
<span class="linenos">38</span>        <span class="n">new_z</span> <span class="o">=</span> <span class="o">-</span><span class="n">max_force</span>
<span class="linenos">39</span>    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">u_sat</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">new_z</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
</section>
<hr class="docutils" />
<section id="dependencies">
<h2>Dependencies<a class="headerlink" href="#dependencies" title="Link to this heading">¶</a></h2>
<p>This module imports:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">annotations</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">logging</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">weakref</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">numpy</span> <span class="pre">as</span> <span class="pre">np</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...utils</span> <span class="pre">import</span> <span class="pre">saturate</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">...utils</span> <span class="pre">import</span> <span class="pre">STAOutput</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">typing</span> <span class="pre">import</span> <span class="pre">Optional,</span> <span class="pre">List,</span> <span class="pre">Tuple,</span> <span class="pre">Dict,</span> <span class="pre">Union</span></code></p></li>
</ul>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="smc___init__.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">controllers.smc.<strong>init</strong></div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="smc_hybrid_adaptive_sta_smc.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">controllers.smc.hybrid_adaptive_sta_smc</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Research Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on Oct 08, 2025</div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">controllers.smc.sta_smc</a><ul>
<li><a class="reference internal" href="#module-overview">Module Overview</a></li>
<li><a class="reference internal" href="#complete-source-code">Complete Source Code</a></li>
<li><a class="reference internal" href="#classes">Classes</a><ul>
<li><a class="reference internal" href="#supertwistingsmc"><code class="docutils literal notranslate"><span class="pre">SuperTwistingSMC</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#returns">Returns</a><ul>
<li><a class="reference internal" href="#source-code">Source Code</a></li>
<li><a class="reference internal" href="#methods-14">Methods (14)</a><ul>
<li><a class="reference internal" href="#init-self-gains-dt-max-force-damping-gain-boundary-layer-dynamics-model-switch-method-regularization-anti-windup-gain"><code class="docutils literal notranslate"><span class="pre">__init__(self,</span> <span class="pre">gains,</span> <span class="pre">dt,</span> <span class="pre">max_force,</span> <span class="pre">damping_gain,</span> <span class="pre">boundary_layer,</span> <span class="pre">dynamics_model,</span> <span class="pre">switch_method,</span> <span class="pre">regularization,</span> <span class="pre">anti_windup_gain)</span></code></a></li>
<li><a class="reference internal" href="#initialize-state-self"><code class="docutils literal notranslate"><span class="pre">initialize_state(self)</span></code></a></li>
<li><a class="reference internal" href="#initialize-history-self"><code class="docutils literal notranslate"><span class="pre">initialize_history(self)</span></code></a></li>
<li><a class="reference internal" href="#compute-control-self-state-state-vars-history"><code class="docutils literal notranslate"><span class="pre">compute_control(self,</span> <span class="pre">state,</span> <span class="pre">state_vars,</span> <span class="pre">history)</span></code></a></li>
<li><a class="reference internal" href="#validate-gains-self-gains-b"><code class="docutils literal notranslate"><span class="pre">validate_gains(self,</span> <span class="pre">gains_b)</span></code></a></li>
<li><a class="reference internal" href="#gains-self"><code class="docutils literal notranslate"><span class="pre">gains(self)</span></code></a></li>
<li><a class="reference internal" href="#dyn-self"><code class="docutils literal notranslate"><span class="pre">dyn(self)</span></code></a></li>
<li><a class="reference internal" href="#dyn-self-value"><code class="docutils literal notranslate"><span class="pre">dyn(self,</span> <span class="pre">value)</span></code></a></li>
<li><a class="reference internal" href="#reset-self"><code class="docutils literal notranslate"><span class="pre">reset(self)</span></code></a></li>
<li><a class="reference internal" href="#cleanup-self"><code class="docutils literal notranslate"><span class="pre">cleanup(self)</span></code></a></li>
<li><a class="reference internal" href="#del-self"><code class="docutils literal notranslate"><span class="pre">__del__(self)</span></code></a></li>
<li><a class="reference internal" href="#set-dynamics-self-dynamics-model"><code class="docutils literal notranslate"><span class="pre">set_dynamics(self,</span> <span class="pre">dynamics_model)</span></code></a></li>
<li><a class="reference internal" href="#compute-sliding-surface-self-state"><code class="docutils literal notranslate"><span class="pre">_compute_sliding_surface(self,</span> <span class="pre">state)</span></code></a></li>
<li><a class="reference internal" href="#compute-equivalent-control-self-state"><code class="docutils literal notranslate"><span class="pre">_compute_equivalent_control(self,</span> <span class="pre">state)</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#functions">Functions</a><ul>
<li><a class="reference internal" href="#sta-smc-control-numba-state-z-alg-gain-k1-alg-gain-k2-surf-gain-k1-surf-gain-k2-surf-lam1-surf-lam2-damping-gain-dt-max-force-boundary-layer-u-eq"><code class="docutils literal notranslate"><span class="pre">_sta_smc_control_numba(state,</span> <span class="pre">z,</span> <span class="pre">alg_gain_K1,</span> <span class="pre">alg_gain_K2,</span> <span class="pre">surf_gain_k1,</span> <span class="pre">surf_gain_k2,</span> <span class="pre">surf_lam1,</span> <span class="pre">surf_lam2,</span> <span class="pre">damping_gain,</span> <span class="pre">dt,</span> <span class="pre">max_force,</span> <span class="pre">boundary_layer,</span> <span class="pre">u_eq)</span></code></a><ul>
<li><a class="reference internal" href="#id1">Source Code</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sta-smc-core-z-sigma-sgn-sigma-alg-gain-k1-alg-gain-k2-damping-gain-dt-max-force-u-eq-kaw"><code class="docutils literal notranslate"><span class="pre">_sta_smc_core(z,</span> <span class="pre">sigma,</span> <span class="pre">sgn_sigma,</span> <span class="pre">alg_gain_K1,</span> <span class="pre">alg_gain_K2,</span> <span class="pre">damping_gain,</span> <span class="pre">dt,</span> <span class="pre">max_force,</span> <span class="pre">u_eq,</span> <span class="pre">Kaw)</span></code></a><ul>
<li><a class="reference internal" href="#id2">Source Code</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#dependencies">Dependencies</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../../_static/documentation_options.js?v=4ebf8126"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/furo.js?v=5fa4622c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=08e7b316"></script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../../_static/back-to-top.js?v=840797bb"></script>
    <script src="../../_static/lazy-load.js?v=dc25293c"></script>
    <script src="../../_static/dark-mode.js?v=bf328970"></script>
    </body>
</html>