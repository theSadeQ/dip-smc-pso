<!doctype html>
<html class="no-js" lang="en" data-content_root="./">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
.chartjs-container {
    margin: 1.5em auto;
    padding: 1em;
    background: #f8f9fa;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.chart-note {
    text-align: center;
    color: #6c757d;
    font-size: 0.9em;
    margin-top: 0.5em;
}
</style>
<link rel="index" title="Index" href="genindex.html"><link rel="search" title="Search" href="search.html">

    <!-- Generated with Sphinx 8.2.3 and Furo 2025.09.25 -->
        <title>1. Core Interface Contracts ### 1.1 Controller Factory Interface Function Signature: - DIP_SMC_PSO Documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=5349f25f" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?v=580074bf" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?v=8dab3a3b" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css?v=8a7e329d" />
    
    


<style>
  body {
    --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="index.html"><div class="brand">DIP_SMC_PSO Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="index.html">
  
  <span class="sidebar-brand-text">DIP_SMC_PSO Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">📚 Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="README.html">Optimal Sliding Mode Control for a Double-Inverted Pendulum via PSO  ## How to validate a ResearchPlan JSON Run the validator locally: ```bash</a></li>
<li class="toctree-l1"><a class="reference internal" href="theory_overview.html">Theory Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="architecture.html">3. System Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="plant_model.html">1.x Plant Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="hil_quickstart.html">Hardware-in-the-Loop (HIL) Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="streamlit_dashboard_guide.html">Streamlit Dashboard User Guide</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/blob/main/docs/controller_pso_interface_api_documentation.md?plain=true" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div><div class="edit-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/edit/main/docs/controller_pso_interface_api_documentation.md" rel="edit" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <p>#==========================================================================================\<br />
#============== docs/controller_pso_interface_api_documentation.md =================\<br />
#==========================================================================================\ # Controller-PSO Interface API Documentation
<strong>Double-Inverted Pendulum Sliding Mode Control System</strong> ## Executive Summary This document provides API documentation for the interface between Particle Swarm Optimization (PSO) and Sliding Mode Control (SMC) controllers within the Double-Inverted Pendulum system. The interface ensures integration between optimization algorithms and control implementations while maintaining type safety, performance, and mathematical rigor. <strong>API Status</strong>: ✅ <strong>PRODUCTION READY</strong> - All interfaces validated and operational
<strong>Type Safety</strong>: 100% type-annotated with runtime validation
<strong>Performance</strong>: Vectorized operations with sub-millisecond controller instantiation</p>
<hr class="docutils" />
<section id="core-interface-contracts-1-1-controller-factory-interface-function-signature">
<h1>1. Core Interface Contracts ### 1.1 Controller Factory Interface <strong>Function Signature:</strong><a class="headerlink" href="#core-interface-contracts-1-1-controller-factory-interface-function-signature" title="Link to this heading">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># example-metadata:</span>
<span class="c1"># runnable: false def controller_factory(gains: np.ndarray, **kwargs) -&gt; BaseController</span>
<span class="err">```</span> <span class="o">**</span><span class="n">Mathematical</span> <span class="n">Foundation</span><span class="p">:</span><span class="o">**</span>

<span class="n">The</span> <span class="n">factory</span> <span class="n">function</span> <span class="err">$</span>\<span class="n">mathcal</span><span class="p">{</span><span class="n">F</span><span class="p">}:</span> \<span class="n">mathbb</span><span class="p">{</span><span class="n">R</span><span class="p">}</span><span class="o">^</span><span class="n">n</span> \<span class="n">rightarrow</span> \<span class="n">mathcal</span><span class="p">{</span><span class="n">C</span><span class="p">}</span><span class="err">$</span> <span class="n">maps</span> <span class="n">gain</span> <span class="n">vectors</span> <span class="n">to</span> <span class="n">controller</span> <span class="n">instances</span><span class="p">:</span> <span class="err">$$</span>\<span class="n">mathcal</span><span class="p">{</span><span class="n">F</span><span class="p">}(</span>\<span class="n">mathbf</span><span class="p">{</span><span class="n">G</span><span class="p">})</span> <span class="o">=</span> \<span class="n">text</span><span class="p">{</span><span class="n">Controller</span><span class="p">}(</span>\<span class="n">mathbf</span><span class="p">{</span><span class="n">G</span><span class="p">},</span> \<span class="n">boldsymbol</span><span class="p">{</span>\<span class="n">theta</span><span class="p">})</span><span class="err">$$</span> <span class="n">where</span><span class="p">:</span>
<span class="o">-</span> <span class="err">$</span>\<span class="n">mathbf</span><span class="p">{</span><span class="n">G</span><span class="p">}</span> \<span class="ow">in</span> \<span class="n">mathbb</span><span class="p">{</span><span class="n">R</span><span class="p">}</span><span class="o">^</span><span class="n">n</span><span class="err">$</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">gain</span> <span class="n">vector</span> <span class="kn">from</span><span class="w"> </span><span class="nn">PSO</span> <span class="n">particles</span>
<span class="o">-</span> <span class="err">$</span>\<span class="n">boldsymbol</span><span class="p">{</span>\<span class="n">theta</span><span class="p">}</span><span class="err">$</span> <span class="n">represents</span> <span class="n">additional</span> <span class="n">controller</span> <span class="n">parameters</span>
<span class="o">-</span> <span class="err">$</span>\<span class="n">mathcal</span><span class="p">{</span><span class="n">C</span><span class="p">}</span><span class="err">$</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">space</span> <span class="n">of</span> <span class="n">valid</span> <span class="n">controller</span> <span class="n">instances</span> <span class="o">**</span><span class="n">Complete</span> <span class="n">Interface</span> <span class="n">Definition</span><span class="p">:</span><span class="o">**</span> <span class="err">```</span><span class="n">python</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Protocol</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Any</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span> <span class="k">class</span><span class="w"> </span><span class="nc">PSO_ControllerInterface</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot;PSO-compatible controller interface protocol.&quot;&quot;&quot;</span> <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gains</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;Initialize controller with PSO-optimized gains. Parameters ---------- gains : np.ndarray, shape (n,) Controller gain vector from PSO particle - Classical SMC: [c1, λ1, c2, λ2, K, kd] ∈ ℝ⁶ - STA-SMC: [K1, K2, k1, k2, λ1, λ2] ∈ ℝ⁶ - Adaptive SMC: [c1, λ1, c2, λ2, γ] ∈ ℝ⁵ - Hybrid Adaptive: [c1, λ1, c2, λ2] ∈ ℝ⁴ **kwargs Additional controller-specific parameters &quot;&quot;&quot;</span> <span class="nd">@property</span> <span class="k">def</span><span class="w"> </span><span class="nf">max_force</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;Actuator saturation limit [N]. Required for PSO simulation bounds. Typical range: [50.0, 200.0] N &quot;&quot;&quot;</span> <span class="k">def</span><span class="w"> </span><span class="nf">compute_control</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;Compute control command for current state. Parameters ---------- state : np.ndarray, shape (6,) System state [θ₁, θ₂, x, θ̇₁, θ̇₂, ẋ] dt : float, optional Sampling time [s] Returns ------- float Control command u(t) ∈ [-max_force, max_force] &quot;&quot;&quot;</span> <span class="k">def</span><span class="w"> </span><span class="nf">validate_gains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;Optional: Pre-filter invalid particles. Parameters ---------- particles : np.ndarray, shape (n_particles, n_gains) Swarm particle matrix Returns ------- np.ndarray, shape (n_particles,), dtype=bool Boolean mask indicating valid particles Notes ----- This method enables early rejection of unstable gain combinations before expensive simulation evaluation. &quot;&quot;&quot;</span>
<span class="err">```</span> <span class="c1">### 1.2 Controller Registration Protocol **Factory Registration System:**</span>
<span class="err">```</span><span class="n">python</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Callable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span> <span class="k">class</span><span class="w"> </span><span class="nc">ControllerFactory</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;Centralized controller factory with PSO integration.&quot;&quot;&quot;</span> <span class="n">_controller_registry</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span> <span class="nd">@classmethod</span> <span class="k">def</span><span class="w"> </span><span class="nf">register_controller</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">controller_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">PSO_ControllerInterface</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;Register controller class for PSO optimization. Parameters ---------- name : str Controller identifier (e.g., &#39;classical_smc&#39;) controller_class : Type[PSO_ControllerInterface] Controller class implementing required interface &quot;&quot;&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">controller_class</span><span class="p">,</span> <span class="s1">&#39;max_force&#39;</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Controller </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> missing required &#39;max_force&#39; property&quot;</span><span class="p">)</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_controller_registry</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">controller_class</span> <span class="nd">@classmethod</span> <span class="k">def</span><span class="w"> </span><span class="nf">create_controller</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">controller_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">gains</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PSO_ControllerInterface</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;Create controller instance from PSO gains. Parameters ---------- controller_type : str Registered controller name gains : np.ndarray PSO-optimized gain vector **kwargs Additional parameters Returns ------- PSO_ControllerInterface Configured controller instance &quot;&quot;&quot;</span> <span class="k">if</span> <span class="n">controller_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_controller_registry</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown controller type: </span><span class="si">{</span><span class="n">controller_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="n">controller_class</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_controller_registry</span><span class="p">[</span><span class="n">controller_type</span><span class="p">]</span> <span class="k">return</span> <span class="n">controller_class</span><span class="p">(</span><span class="n">gains</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<hr class="docutils" />
</section>
<section id="controller-specific-api-implementations-2-1-classical-smc-interface-gain-vector-specification">
<h1>2. Controller-Specific API Implementations ### 2.1 Classical SMC Interface <strong>Gain Vector Specification:</strong><a class="headerlink" href="#controller-specific-api-implementations-2-1-classical-smc-interface-gain-vector-specification" title="Link to this heading">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false # Classical SMC Gains: [c1, λ1, c2, λ2, K, kd] ∈ ℝ⁶</span>

<span class="n">CLASSICAL_SMC_GAINS</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;c1&#39;</span><span class="p">:</span> <span class="s1">&#39;Sliding surface gain for θ₁ error&#39;</span><span class="p">,</span> <span class="s1">&#39;lambda1&#39;</span><span class="p">:</span> <span class="s1">&#39;Sliding surface coefficient for θ₁&#39;</span><span class="p">,</span> <span class="s1">&#39;c2&#39;</span><span class="p">:</span> <span class="s1">&#39;Sliding surface gain for θ₂ error&#39;</span><span class="p">,</span> <span class="s1">&#39;lambda2&#39;</span><span class="p">:</span> <span class="s1">&#39;Sliding surface coefficient for θ₂&#39;</span><span class="p">,</span> <span class="s1">&#39;K&#39;</span><span class="p">:</span> <span class="s1">&#39;Control gain&#39;</span><span class="p">,</span> <span class="s1">&#39;kd&#39;</span><span class="p">:</span> <span class="s1">&#39;Derivative gain&#39;</span>
<span class="p">}</span> <span class="c1"># Typical bounds for PSO optimization:</span>
<span class="n">CLASSICAL_SMC_BOUNDS</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;lower&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">20.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">]</span>
<span class="p">}</span>
<span class="err">```</span> <span class="o">**</span><span class="n">Implementation</span><span class="p">:</span><span class="o">**</span>
<span class="err">```</span><span class="n">python</span>
<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false class ClassicalSMC(PSO_ControllerInterface): &quot;&quot;&quot;Classical Sliding Mode Controller with PSO interface.&quot;&quot;&quot; def __init__(self, gains: np.ndarray, **kwargs) -&gt; None: &quot;&quot;&quot;Initialize Classical SMC. Mathematical Model: Sliding surface: s = λ₁e₁ + λ₂e₂ + ė₁ + ė₂ Control law: u = -K·sign(s) - kd·ṡ Parameters ---------- gains : np.ndarray, shape (6,) [c1, λ1, c2, λ2, K, kd] &quot;&quot;&quot; if len(gains) != 6: raise ValueError(f&quot;Classical SMC requires 6 gains, got {len(gains)}&quot;) self.c1, self.lambda1, self.c2, self.lambda2, self.K, self.kd = gains self._max_force = kwargs.get(&#39;max_force&#39;, 150.0) self.boundary_layer = kwargs.get(&#39;boundary_layer&#39;, 0.02) # Validate stability conditions if self.lambda1 &lt;= 0 or self.lambda2 &lt;= 0: raise ValueError(&quot;Sliding surface coefficients must be positive&quot;) if self.K &lt;= 0: raise ValueError(&quot;Control gain must be positive&quot;) @property def max_force(self) -&gt; float: &quot;&quot;&quot;Actuator saturation limit.&quot;&quot;&quot; return self._max_force def compute_control(self, state: np.ndarray, dt: float = 0.001) -&gt; float: &quot;&quot;&quot;Compute classical SMC control. Mathematical Implementation: 1. Compute position errors: e₁ = θ₁, e₂ = θ₂ 2. Compute velocity errors: ė₁ = θ̇₁, ė₂ = θ̇₂ 3. Sliding surface: s = λ₁e₁ + λ₂e₂ + ė₁ + ė₂ 4. Control law: u = -K·sat(s/ε) - kd·ṡ &quot;&quot;&quot; theta1, theta2, x, theta1_dot, theta2_dot, x_dot = state # Position errors (target is upright: θ₁ = θ₂ = 0) e1 = theta1 e2 = theta2 # Velocity errors (target velocities are zero) e1_dot = theta1_dot e2_dot = theta2_dot # Sliding surface s = self.lambda1 * e1 + self.lambda2 * e2 + e1_dot + e2_dot # Boundary layer saturation function if abs(s) &lt;= self.boundary_layer: sat_s = s / self.boundary_layer else: sat_s = np.sign(s) # Control law u = -self.K * sat_s - self.kd * s # Apply actuator saturation return np.clip(u, -self.max_force, self.max_force) def validate_gains(self, particles: np.ndarray) -&gt; np.ndarray: &quot;&quot;&quot;Validate Classical SMC gain combinations. Stability Requirements: 1. λ₁, λ₂ &gt; 0 (sliding surface stability) 2. K &gt; 0 (control authority) 3. Reasonable gain ratios to prevent numerical issues &quot;&quot;&quot; n_particles = particles.shape[0] valid = np.ones(n_particles, dtype=bool) # Extract gain components c1, lambda1, c2, lambda2, K, kd = particles.T # Stability conditions valid &amp;= (lambda1 &gt; 0) &amp; (lambda2 &gt; 0) # Surface coefficients valid &amp;= (K &gt; 0) # Control gain valid &amp;= (kd &gt;= 0) # Derivative gain # Numerical stability bounds valid &amp;= (lambda1 &lt; 100) &amp; (lambda2 &lt; 100) # Prevent excessive stiffness valid &amp;= (K &lt; 1000) # Prevent actuator abuse return valid</span>

<span class="err">```</span> <span class="c1">### 2.2 Super-Twisting SMC Interface **Gain Vector Specification:**</span>
<span class="err">```</span><span class="n">python</span>
<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false # STA-SMC Gains: [K1, K2, k1, k2, λ1, λ2] ∈ ℝ⁶</span>

<span class="n">STA_SMC_GAINS</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;K1&#39;</span><span class="p">:</span> <span class="s1">&#39;First-order sliding mode gain&#39;</span><span class="p">,</span> <span class="s1">&#39;K2&#39;</span><span class="p">:</span> <span class="s1">&#39;Second-order sliding mode gain&#39;</span><span class="p">,</span> <span class="s1">&#39;k1&#39;</span><span class="p">:</span> <span class="s1">&#39;Surface gain for θ₁&#39;</span><span class="p">,</span> <span class="s1">&#39;k2&#39;</span><span class="p">:</span> <span class="s1">&#39;Surface gain for θ₂&#39;</span><span class="p">,</span> <span class="s1">&#39;lambda1&#39;</span><span class="p">:</span> <span class="s1">&#39;Surface coefficient for θ₁&#39;</span><span class="p">,</span> <span class="s1">&#39;lambda2&#39;</span><span class="p">:</span> <span class="s1">&#39;Surface coefficient for θ₂&#39;</span>
<span class="p">}</span> <span class="c1"># Optimized bounds from Issue #2 resolution:</span>
<span class="n">STA_SMC_BOUNDS</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;lower&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">20.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">]</span>
<span class="p">}</span>
<span class="err">```</span> <span class="o">**</span><span class="n">Implementation</span><span class="p">:</span><span class="o">**</span>
<span class="err">```</span><span class="n">python</span>
<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false class STASMC(PSO_ControllerInterface): &quot;&quot;&quot;Super-Twisting Algorithm Sliding Mode Controller.&quot;&quot;&quot; def __init__(self, gains: np.ndarray, **kwargs) -&gt; None: &quot;&quot;&quot;Initialize STA-SMC. Mathematical Model: Sliding surface: s = k₁θ₁ + k₂θ₂ + λ₁θ̇₁ + λ₂θ̇₂ Super-twisting control: u̇ = -K₂·sign(s) u = -K₁·|s|^(1/2)·sign(s) + ∫u̇dt Parameters ---------- gains : np.ndarray, shape (6,) [K1, K2, k1, k2, λ1, λ2] &quot;&quot;&quot; if len(gains) != 6: raise ValueError(f&quot;STA-SMC requires 6 gains, got {len(gains)}&quot;) self.K1, self.K2, self.k1, self.k2, self.lambda1, self.lambda2 = gains self._max_force = kwargs.get(&#39;max_force&#39;, 150.0) self.dt = kwargs.get(&#39;dt&#39;, 0.001) # Internal states for super-twisting algorithm self.u_integral = 0.0 self.boundary_layer = kwargs.get(&#39;boundary_layer&#39;, 0.05) # Validate super-twisting stability conditions if self.K1 &lt;= 0 or self.K2 &lt;= 0: raise ValueError(&quot;Super-twisting gains must be positive&quot;) if self.lambda1 &lt;= 0 or self.lambda2 &lt;= 0: raise ValueError(&quot;Surface coefficients must be positive&quot;) @property def max_force(self) -&gt; float: &quot;&quot;&quot;Actuator saturation limit.&quot;&quot;&quot; return self._max_force def compute_control(self, state: np.ndarray, dt: float = 0.001) -&gt; float: &quot;&quot;&quot;Compute super-twisting SMC control. Mathematical Implementation: 1. Sliding surface: s = k₁θ₁ + k₂θ₂ + λ₁θ̇₁ + λ₂θ̇₂ 2. First-order term: u₁ = -K₁·|s|^(1/2)·sign(s) 3. Second-order term: u̇₂ = -K₂·sign(s) 4. Total control: u = u₁ + u₂ &quot;&quot;&quot; theta1, theta2, x, theta1_dot, theta2_dot, x_dot = state # Sliding surface computation s = (self.k1 * theta1 + self.k2 * theta2 + self.lambda1 * theta1_dot + self.lambda2 * theta2_dot) # Super-twisting algorithm if abs(s) &lt;= self.boundary_layer: # Boundary layer approximation u1 = -self.K1 * (abs(s) / self.boundary_layer)**0.5 * s / self.boundary_layer u2_dot = -self.K2 * s / self.boundary_layer else: # Traditional super-twisting u1 = -self.K1 * np.sqrt(abs(s)) * np.sign(s) u2_dot = -self.K2 * np.sign(s) # Integrate second-order term self.u_integral += u2_dot * dt # Total control u = u1 + self.u_integral # Apply actuator saturation return np.clip(u, -self.max_force, self.max_force) def validate_gains(self, particles: np.ndarray) -&gt; np.ndarray: &quot;&quot;&quot;Validate STA-SMC gain combinations. Super-Twisting Stability Conditions: 1. K₁, K₂ &gt; 0 (algorithmic gains) 2. λ₁, λ₂ &gt; 0 (surface coefficients) 3. Sufficient condition: K₁ &gt; L, K₂ &gt; K₁·C (where L, C are bounds) &quot;&quot;&quot; n_particles = particles.shape[0] valid = np.ones(n_particles, dtype=bool) # Extract gains K1, K2, k1, k2, lambda1, lambda2 = particles.T # Basic positivity valid &amp;= (K1 &gt; 0) &amp; (K2 &gt; 0) valid &amp;= (k1 &gt; 0) &amp; (k2 &gt; 0) valid &amp;= (lambda1 &gt; 0) &amp; (lambda2 &gt; 0) # Super-twisting stability condition (simplified) valid &amp;= (K2 &gt; K1 * 0.5) # Simplified sufficient condition # Practical bounds to prevent excessive oscillations valid &amp;= (K1 &lt; 50) &amp; (K2 &lt; 50) valid &amp;= (lambda1 &lt; 20) &amp; (lambda2 &lt; 20) return valid</span>

<span class="err">```</span> <span class="c1">### 2.3 Adaptive SMC Interface **Gain Vector Specification:**</span>
<span class="err">```</span><span class="n">python</span>
<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false # Adaptive SMC Gains: [c1, λ1, c2, λ2, γ] ∈ ℝ⁵</span>

<span class="n">ADAPTIVE_SMC_GAINS</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;c1&#39;</span><span class="p">:</span> <span class="s1">&#39;Sliding surface gain for θ₁&#39;</span><span class="p">,</span> <span class="s1">&#39;lambda1&#39;</span><span class="p">:</span> <span class="s1">&#39;Sliding surface coefficient for θ₁&#39;</span><span class="p">,</span> <span class="s1">&#39;c2&#39;</span><span class="p">:</span> <span class="s1">&#39;Sliding surface gain for θ₂&#39;</span><span class="p">,</span> <span class="s1">&#39;lambda2&#39;</span><span class="p">:</span> <span class="s1">&#39;Sliding surface coefficient for θ₂&#39;</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="s1">&#39;Adaptation rate&#39;</span>
<span class="p">}</span> <span class="n">ADAPTIVE_SMC_BOUNDS</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;lower&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">],</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">20.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">]</span>
<span class="p">}</span>
<span class="err">```</span> <span class="o">**</span><span class="n">Implementation</span><span class="p">:</span><span class="o">**</span>
<span class="err">```</span><span class="n">python</span>
<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false class AdaptiveSMC(PSO_ControllerInterface): &quot;&quot;&quot;Adaptive Sliding Mode Controller with uncertainty estimation.&quot;&quot;&quot; def __init__(self, gains: np.ndarray, **kwargs) -&gt; None: &quot;&quot;&quot;Initialize Adaptive SMC. Mathematical Model: Sliding surface: s = λ₁e₁ + λ₂e₂ + ė₁ + ė₂ Adaptive control: u = -K̂(t)·sign(s) Adaptation law: K̇ = γ·|s| for |s| &gt; δ, 0 otherwise Parameters ---------- gains : np.ndarray, shape (5,) [c1, λ1, c2, λ2, γ] &quot;&quot;&quot; if len(gains) != 5: raise ValueError(f&quot;Adaptive SMC requires 5 gains, got {len(gains)}&quot;) self.c1, self.lambda1, self.c2, self.lambda2, self.gamma = gains self._max_force = kwargs.get(&#39;max_force&#39;, 150.0) # Adaptive gain initialization self.K_adaptive = kwargs.get(&#39;K_init&#39;, 1.0) self.K_min = kwargs.get(&#39;K_min&#39;, 0.1) self.K_max = kwargs.get(&#39;K_max&#39;, 100.0) self.dead_zone = kwargs.get(&#39;dead_zone&#39;, 0.05) # Validate adaptation parameters if self.gamma &lt;= 0: raise ValueError(&quot;Adaptation rate must be positive&quot;) if self.lambda1 &lt;= 0 or self.lambda2 &lt;= 0: raise ValueError(&quot;Surface coefficients must be positive&quot;) @property def max_force(self) -&gt; float: &quot;&quot;&quot;Actuator saturation limit.&quot;&quot;&quot; return self._max_force def compute_control(self, state: np.ndarray, dt: float = 0.001) -&gt; float: &quot;&quot;&quot;Compute adaptive SMC control. Mathematical Implementation: 1. Sliding surface: s = λ₁e₁ + λ₂e₂ + ė₁ + ė₂ 2. Adaptation law: K̇ = γ·|s| (outside dead zone) 3. Control law: u = -K̂(t)·sign(s) &quot;&quot;&quot; theta1, theta2, x, theta1_dot, theta2_dot, x_dot = state # Position and velocity errors e1, e2 = theta1, theta2 e1_dot, e2_dot = theta1_dot, theta2_dot # Sliding surface s = self.lambda1 * e1 + self.lambda2 * e2 + e1_dot + e2_dot # Adaptive gain update (outside dead zone) if abs(s) &gt; self.dead_zone: K_dot = self.gamma * abs(s) self.K_adaptive += K_dot * dt self.K_adaptive = np.clip(self.K_adaptive, self.K_min, self.K_max) # Control law if abs(s) &lt;= self.dead_zone: sat_s = s / self.dead_zone else: sat_s = np.sign(s) u = -self.K_adaptive * sat_s return np.clip(u, -self.max_force, self.max_force) def validate_gains(self, particles: np.ndarray) -&gt; np.ndarray: &quot;&quot;&quot;Validate Adaptive SMC parameters.&quot;&quot;&quot; n_particles = particles.shape[0] valid = np.ones(n_particles, dtype=bool) c1, lambda1, c2, lambda2, gamma = particles.T # Basic constraints valid &amp;= (lambda1 &gt; 0) &amp; (lambda2 &gt; 0) # Surface stability valid &amp;= (gamma &gt; 0) # Adaptation positivity valid &amp;= (c1 &gt; 0) &amp; (c2 &gt; 0) # Surface gains # Practical bounds valid &amp;= (gamma &lt; 10) # Prevent excessive adaptation speed valid &amp;= (lambda1 &lt; 50) &amp; (lambda2 &lt; 50) # Numerical stability return valid</span>

<span class="err">```</span> <span class="c1">### 2.4 Hybrid Adaptive STA-SMC Interface **Gain Vector Specification:**</span>
<span class="err">```</span><span class="n">python</span>
<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false # Hybrid Adaptive STA-SMC Gains: [c1, λ1, c2, λ2] ∈ ℝ⁴</span>

<span class="n">HYBRID_ADAPTIVE_STA_SMC_GAINS</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;c1&#39;</span><span class="p">:</span> <span class="s1">&#39;Proportional-like sliding surface gain&#39;</span><span class="p">,</span> <span class="s1">&#39;lambda1&#39;</span><span class="p">:</span> <span class="s1">&#39;Integral-like sliding surface coefficient&#39;</span><span class="p">,</span> <span class="s1">&#39;c2&#39;</span><span class="p">:</span> <span class="s1">&#39;Proportional-like sliding surface gain&#39;</span><span class="p">,</span> <span class="s1">&#39;lambda2&#39;</span><span class="p">:</span> <span class="s1">&#39;Integral-like sliding surface coefficient&#39;</span>
<span class="p">}</span> <span class="n">HYBRID_ADAPTIVE_STA_SMC_BOUNDS</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;lower&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">20.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">]</span>
<span class="p">}</span>
<span class="err">```</span> <span class="o">**</span><span class="n">Implementation</span><span class="p">:</span><span class="o">**</span>
<span class="err">```</span><span class="n">python</span>
<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false class HybridAdaptiveSTASMC(PSO_ControllerInterface): &quot;&quot;&quot;Hybrid Adaptive Super-Twisting SMC with dual adaptation.&quot;&quot;&quot; def __init__(self, gains: np.ndarray, **kwargs) -&gt; None: &quot;&quot;&quot;Initialize Hybrid Adaptive STA-SMC. Mathematical Model: Combines adaptive gain estimation with super-twisting algorithm. Sliding surface: s = c₁θ₁ + c₂θ₂ + λ₁∫θ₁dt + λ₂∫θ₂dt Adaptive STA: u = -k₁(t)·|s|^(1/2)·sign(s) + u₂ where k₁(t) adapts based on sliding surface magnitude. Parameters ---------- gains : np.ndarray, shape (4,) [c1, λ1, c2, λ2] &quot;&quot;&quot; if len(gains) != 4: raise ValueError(f&quot;Hybrid Adaptive STA-SMC requires 4 gains, got {len(gains)}&quot;) self.c1, self.lambda1, self.c2, self.lambda2 = gains self._max_force = kwargs.get(&#39;max_force&#39;, 150.0) # Adaptive parameters self.k1_adaptive = kwargs.get(&#39;k1_init&#39;, 4.0) self.k2_adaptive = kwargs.get(&#39;k2_init&#39;, 0.4) self.k1_adapt_rate = kwargs.get(&#39;k1_adapt_rate&#39;, 0.5) self.k2_adapt_rate = kwargs.get(&#39;k2_adapt_rate&#39;, 0.05) # Internal states self.theta1_integral = 0.0 self.theta2_integral = 0.0 self.u2_integral = 0.0 self.dt = kwargs.get(&#39;dt&#39;, 0.001) # Validation if any(g &lt;= 0 for g in gains): raise ValueError(&quot;All gains must be positive&quot;) @property def max_force(self) -&gt; float: &quot;&quot;&quot;Actuator saturation limit.&quot;&quot;&quot; return self._max_force def compute_control(self, state: np.ndarray, dt: float = 0.001) -&gt; float: &quot;&quot;&quot;Compute hybrid adaptive STA control. Mathematical Implementation: 1. Update integral terms 2. Compute sliding surface with integral action 3. Adapt gains based on sliding surface 4. Apply super-twisting algorithm &quot;&quot;&quot; theta1, theta2, x, theta1_dot, theta2_dot, x_dot = state # Update integral terms self.theta1_integral += theta1 * dt self.theta2_integral += theta2 * dt # Sliding surface with integral action s = (self.c1 * theta1 + self.c2 * theta2 + self.lambda1 * self.theta1_integral + self.lambda2 * self.theta2_integral) # Adaptive gain updates if abs(s) &gt; 0.01: # Dead zone self.k1_adaptive += self.k1_adapt_rate * abs(s) * dt self.k2_adaptive += self.k2_adapt_rate * abs(s) * dt # Bound adaptive gains self.k1_adaptive = np.clip(self.k1_adaptive, 0.1, 50.0) self.k2_adaptive = np.clip(self.k2_adaptive, 0.01, 5.0) # Super-twisting control u1 = -self.k1_adaptive * np.sqrt(abs(s)) * np.sign(s) u2_dot = -self.k2_adaptive * np.sign(s) self.u2_integral += u2_dot * dt u = u1 + self.u2_integral return np.clip(u, -self.max_force, self.max_force) def validate_gains(self, particles: np.ndarray) -&gt; np.ndarray: &quot;&quot;&quot;Validate Hybrid Adaptive STA-SMC gains.&quot;&quot;&quot; n_particles = particles.shape[0] valid = np.ones(n_particles, dtype=bool) c1, lambda1, c2, lambda2 = particles.T # All gains must be positive valid &amp;= (c1 &gt; 0) &amp; (lambda1 &gt; 0) &amp; (c2 &gt; 0) &amp; (lambda2 &gt; 0) # Practical bounds for stability valid &amp;= (c1 &lt; 100) &amp; (c2 &lt; 100) valid &amp;= (lambda1 &lt; 50) &amp; (lambda2 &lt; 50) return valid</span>

</pre></div>
</div>
<hr class="docutils" />
</section>
<section id="pso-integration-api-3-1-pso-tuner-interface-class-definition">
<h1>3. PSO Integration API ### 3.1 PSO Tuner Interface <strong>Class Definition:</strong><a class="headerlink" href="#pso-integration-api-3-1-pso-tuner-interface-class-definition" title="Link to this heading">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false class PSOTuner: &quot;&quot;&quot;High-performance PSO tuner for SMC controllers.&quot;&quot;&quot; def __init__(self, controller_factory: Callable[[np.ndarray], PSO_ControllerInterface], config: Union[ConfigSchema, str, Path], seed: Optional[int] = None, rng: Optional[np.random.Generator] = None, **kwargs) -&gt; None: &quot;&quot;&quot;Initialize PSO tuner with controller factory. Parameters ---------- controller_factory : Callable Function mapping gain vectors to controller instances. Must return objects implementing PSO_ControllerInterface. config : ConfigSchema or path System configuration with PSO parameters seed : int, optional Random seed for reproducibility rng : np.random.Generator, optional External random number generator **kwargs Additional PSO parameters &quot;&quot;&quot; def optimize(self, bounds: Optional[Tuple[np.ndarray, np.ndarray]] = None, n_particles: Optional[int] = None, n_iterations: Optional[int] = None, **kwargs) -&gt; Dict[str, Any]: &quot;&quot;&quot;Run PSO optimization. Parameters ---------- bounds : tuple of arrays, optional (lower_bounds, upper_bounds) for gain parameters n_particles : int, optional Number of particles in swarm n_iterations : int, optional Maximum optimization iterations **kwargs Additional PSO options Returns ------- Dict[str, Any] Optimization results with keys: - &#39;best_gains&#39;: Optimal gain vector - &#39;best_cost&#39;: Best fitness value - &#39;cost_history&#39;: Convergence history - &#39;success&#39;: Optimization success flag - &#39;message&#39;: Status message &quot;&quot;&quot;</span>

<span class="err">```</span> <span class="c1">### 3.2 Factory Integration API **Usage Example:**</span>
<span class="err">```</span><span class="n">python</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">src.controllers.factory</span><span class="w"> </span><span class="kn">import</span> <span class="n">ControllerFactory</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.optimization.algorithms.pso_optimizer</span><span class="w"> </span><span class="kn">import</span> <span class="n">PSOTuner</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.config</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_config</span> <span class="c1"># Load configuration</span>
<span class="n">config</span> <span class="o">=</span> <span class="n">load_config</span><span class="p">(</span><span class="s1">&#39;config.yaml&#39;</span><span class="p">)</span> <span class="c1"># Create controller factory for specific type</span>
<span class="k">def</span><span class="w"> </span><span class="nf">create_classical_smc</span><span class="p">(</span><span class="n">gains</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ClassicalSMC</span><span class="p">:</span> <span class="k">return</span> <span class="n">ControllerFactory</span><span class="o">.</span><span class="n">create_controller</span><span class="p">(</span><span class="s1">&#39;classical_smc&#39;</span><span class="p">,</span> <span class="n">gains</span><span class="p">)</span> <span class="c1"># Initialize PSO tuner</span>
<span class="n">pso_tuner</span> <span class="o">=</span> <span class="n">PSOTuner</span><span class="p">(</span> <span class="n">controller_factory</span><span class="o">=</span><span class="n">create_classical_smc</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">42</span>
<span class="p">)</span> <span class="c1"># Extract bounds from configuration</span>
<span class="n">bounds_config</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">pso</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">classical_smc</span>
<span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bounds_config</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span>
<span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bounds_config</span><span class="o">.</span><span class="n">upper</span><span class="p">)</span> <span class="c1"># Run optimization</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">pso_tuner</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">,</span> <span class="n">upper_bounds</span><span class="p">),</span> <span class="n">n_particles</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_iterations</span><span class="o">=</span><span class="mi">100</span>
<span class="p">)</span> <span class="c1"># Extract optimized gains</span>
<span class="n">optimal_gains</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;best_gains&#39;</span><span class="p">]</span>
<span class="n">optimal_controller</span> <span class="o">=</span> <span class="n">create_classical_smc</span><span class="p">(</span><span class="n">optimal_gains</span><span class="p">)</span>
</pre></div>
</div>
<hr class="docutils" />
</section>
<section id="error-handling-and-validation-4-1-parameter-validation-api-validation-framework">
<h1>4. Error Handling and Validation ### 4.1 Parameter Validation API <strong>Validation Framework:</strong><a class="headerlink" href="#error-handling-and-validation-4-1-parameter-validation-api-validation-framework" title="Link to this heading">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false from typing import List, Tuple</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span> <span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ValidationResult</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;Parameter validation result.&quot;&quot;&quot;</span> <span class="n">is_valid</span><span class="p">:</span> <span class="nb">bool</span> <span class="n">errors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="n">warnings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="k">class</span><span class="w"> </span><span class="nc">ParameterValidator</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;Controller parameter validation utilities.&quot;&quot;&quot;</span> <span class="nd">@staticmethod</span> <span class="k">def</span><span class="w"> </span><span class="nf">validate_gain_vector</span><span class="p">(</span><span class="n">gains</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">controller_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ValidationResult</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;Validate gain vector for specific controller type. Parameters ---------- gains : np.ndarray Controller gain vector controller_type : str Controller type identifier Returns ------- ValidationResult Validation outcome with error details &quot;&quot;&quot;</span> <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span> <span class="n">warnings</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Check dimensionality expected_dims = { &#39;classical_smc&#39;: 6, &#39;sta_smc&#39;: 6, &#39;adaptive_smc&#39;: 5, &#39;hybrid_adaptive_sta_smc&#39;: 4 } if controller_type not in expected_dims: errors.append(f&quot;Unknown controller type: {controller_type}&quot;) return ValidationResult(False, errors, warnings) expected_dim = expected_dims[controller_type] if len(gains) != expected_dim: errors.append(f&quot;Expected {expected_dim} gains, got {len(gains)}&quot;) # Check for NaN/Inf values if not np.all(np.isfinite(gains)): errors.append(&quot;Gains contain NaN or infinite values&quot;) # Controller-specific validation if controller_type == &#39;classical_smc&#39;: c1, lambda1, c2, lambda2, K, kd = gains if lambda1 &lt;= 0 or lambda2 &lt;= 0: errors.append(&quot;Sliding surface coefficients must be positive&quot;) if K &lt;= 0: errors.append(&quot;Control gain must be positive&quot;) if kd &lt; 0: warnings.append(&quot;Negative derivative gain may cause instability&quot;) # Add similar validation for other controller types... return ValidationResult(len(errors) == 0, errors, warnings)</span>
<span class="err">```</span> <span class="c1">### 4.2 Runtime Error Handling **Exception Hierarchy:**</span>
<span class="err">```</span><span class="n">python</span>
<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false class PSO_ControllerError(Exception): &quot;&quot;&quot;Base exception for PSO-controller interface errors.&quot;&quot;&quot; pass class InvalidGainsError(PSO_ControllerError): &quot;&quot;&quot;Raised when gain vector is invalid.&quot;&quot;&quot; def __init__(self, gains: np.ndarray, controller_type: str, reason: str): self.gains = gains self.controller_type = controller_type self.reason = reason super().__init__(f&quot;Invalid gains for {controller_type}: {reason}&quot;) class ControllerInstantiationError(PSO_ControllerError): &quot;&quot;&quot;Raised when controller creation fails.&quot;&quot;&quot; pass class SimulationError(PSO_ControllerError): &quot;&quot;&quot;Raised when control simulation fails.&quot;&quot;&quot; pass</span>

<span class="err">```</span> <span class="o">**</span><span class="n">Error</span> <span class="n">Recovery</span> <span class="n">Strategies</span><span class="p">:</span><span class="o">**</span>
<span class="err">```</span><span class="n">python</span>
<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false def robust_controller_factory(gains: np.ndarray, controller_type: str, fallback_gains: Optional[np.ndarray] = None) -&gt; PSO_ControllerInterface: &quot;&quot;&quot;Robust controller factory with error recovery. Parameters ---------- gains : np.ndarray Primary gain vector controller_type : str Controller type fallback_gains : np.ndarray, optional Fallback gains for error recovery Returns ------- PSO_ControllerInterface Controller instance (primary or fallback) Raises ------ ControllerInstantiationError If both primary and fallback creation fail &quot;&quot;&quot; try: # Validate gains first validation = ParameterValidator.validate_gain_vector(gains, controller_type) if not validation.is_valid: raise InvalidGainsError(gains, controller_type, &#39;; &#39;.join(validation.errors)) # Create controller return ControllerFactory.create_controller(controller_type, gains) except Exception as e: if fallback_gains is not None: try: return ControllerFactory.create_controller(controller_type, fallback_gains) except Exception: pass raise ControllerInstantiationError( f&quot;Failed to create {controller_type} controller: {str(e)}&quot; ) from e</span>

</pre></div>
</div>
<hr class="docutils" />
</section>
<section id="performance-api-and-benchmarking-5-1-performance-monitoring-performance-metrics-interface">
<h1>5. Performance API and Benchmarking ### 5.1 Performance Monitoring <strong>Performance Metrics Interface:</strong><a class="headerlink" href="#performance-api-and-benchmarking-5-1-performance-monitoring-performance-metrics-interface" title="Link to this heading">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
<span class="kn">from</span><span class="w"> </span><span class="nn">time</span><span class="w"> </span><span class="kn">import</span> <span class="n">perf_counter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span> <span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PerformanceMetrics</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;Controller performance metrics.&quot;&quot;&quot;</span> <span class="n">creation_time</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="n">control_computation_times</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span> <span class="n">memory_usage</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="n">cache_hits</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">cache_misses</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span> <span class="nd">@property</span> <span class="k">def</span><span class="w"> </span><span class="nf">mean_control_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;Mean control computation time.&quot;&quot;&quot;</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">control_computation_times</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_computation_times</span> <span class="k">else</span> <span class="mf">0.0</span> <span class="nd">@property</span> <span class="k">def</span><span class="w"> </span><span class="nf">max_control_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;Maximum control computation time.&quot;&quot;&quot;</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">control_computation_times</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_computation_times</span> <span class="k">else</span> <span class="mf">0.0</span> <span class="k">class</span><span class="w"> </span><span class="nc">PerformanceMonitoredController</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;Wrapper for performance monitoring.&quot;&quot;&quot;</span> <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">controller</span><span class="p">:</span> <span class="n">PSO_ControllerInterface</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">controller</span> <span class="o">=</span> <span class="n">controller</span> <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span> <span class="o">=</span> <span class="n">PerformanceMetrics</span><span class="p">()</span> <span class="bp">self</span><span class="o">.</span><span class="n">_creation_start</span> <span class="o">=</span> <span class="n">perf_counter</span><span class="p">()</span> <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot;Delegate attribute access to wrapped controller.&quot;&quot;&quot;</span> <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">controller</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">def</span><span class="w"> </span><span class="nf">compute_control</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;Timed control computation.&quot;&quot;&quot;</span> <span class="n">start_time</span> <span class="o">=</span> <span class="n">perf_counter</span><span class="p">()</span> <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">controller</span><span class="o">.</span><span class="n">compute_control</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="n">end_time</span> <span class="o">=</span> <span class="n">perf_counter</span><span class="p">()</span> <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span><span class="o">.</span><span class="n">control_computation_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span> <span class="k">return</span> <span class="n">result</span>
<span class="err">```</span> <span class="c1">### 5.2 Benchmarking API **Benchmark Suite:**</span>
<span class="err">```</span><span class="n">python</span>
<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false class ControllerBenchmark: &quot;&quot;&quot;Standardized controller benchmarking.&quot;&quot;&quot; @staticmethod def benchmark_creation(controller_factory: Callable, gain_samples: List[np.ndarray], n_runs: int = 100) -&gt; Dict[str, float]: &quot;&quot;&quot;Benchmark controller creation time. Parameters ---------- controller_factory : Callable Factory function to benchmark gain_samples : List[np.ndarray] Sample gain vectors for testing n_runs : int Number of benchmark runs Returns ------- Dict[str, float] Timing statistics &quot;&quot;&quot; creation_times = [] for _ in range(n_runs): gains = gain_samples[np.random.randint(len(gain_samples))] start_time = perf_counter() controller = controller_factory(gains) end_time = perf_counter() creation_times.append(end_time - start_time) return { &#39;mean_time&#39;: np.mean(creation_times), &#39;std_time&#39;: np.std(creation_times), &#39;min_time&#39;: np.min(creation_times), &#39;max_time&#39;: np.max(creation_times), &#39;p95_time&#39;: np.percentile(creation_times, 95) } @staticmethod def benchmark_control_computation(controller: PSO_ControllerInterface, state_samples: List[np.ndarray], n_runs: int = 1000) -&gt; Dict[str, float]: &quot;&quot;&quot;Benchmark control computation performance.&quot;&quot;&quot; computation_times = [] for _ in range(n_runs): state = state_samples[np.random.randint(len(state_samples))] start_time = perf_counter() control = controller.compute_control(state) end_time = perf_counter() computation_times.append(end_time - start_time) return { &#39;mean_time&#39;: np.mean(computation_times), &#39;std_time&#39;: np.std(computation_times), &#39;min_time&#39;: np.min(computation_times), &#39;max_time&#39;: np.max(computation_times), &#39;p95_time&#39;: np.percentile(computation_times, 95), &#39;p99_time&#39;: np.percentile(computation_times, 99) }</span>

</pre></div>
</div>
<hr class="docutils" />
</section>
<section id="testing-and-validation-api-6-1-interface-compliance-testing-protocol-compliance-tests">
<h1>6. Testing and Validation API ### 6.1 Interface Compliance Testing <strong>Protocol Compliance Tests:</strong><a class="headerlink" href="#testing-and-validation-api-6-1-interface-compliance-testing-protocol-compliance-tests" title="Link to this heading">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Type</span> <span class="k">def</span><span class="w"> </span><span class="nf">test_pso_controller_interface_compliance</span><span class="p">(</span><span class="n">controller_class</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">PSO_ControllerInterface</span><span class="p">],</span> <span class="n">sample_gains</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot;Test PSO controller interface compliance. Parameters ---------- controller_class : Type[PSO_ControllerInterface] Controller class to test sample_gains : np.ndarray Valid gain vector for testing &quot;&quot;&quot;</span> <span class="c1"># Test instantiation controller = controller_class(sample_gains) # Test required properties assert hasattr(controller, &#39;max_force&#39;), &quot;Controller missing max_force property&quot; assert isinstance(controller.max_force, (int, float)), &quot;max_force must be numeric&quot; assert controller.max_force &gt; 0, &quot;max_force must be positive&quot; # Test required methods assert hasattr(controller, &#39;compute_control&#39;), &quot;Controller missing compute_control method&quot; assert callable(controller.compute_control), &quot;compute_control must be callable&quot; # Test control computation test_state = np.array([0.1, 0.05, 0.0, 0.0, 0.0, 0.0]) control = controller.compute_control(test_state) assert isinstance(control, (int, float)), &quot;Control output must be numeric&quot; assert abs(control) &lt;= controller.max_force, &quot;Control must respect actuator limits&quot; # Test optional validate_gains method if hasattr(controller, &#39;validate_gains&#39;): test_particles = np.array([sample_gains, sample_gains]) mask = controller.validate_gains(test_particles) assert mask.shape == (2,), &quot;validate_gains must return boolean mask&quot; assert mask.dtype == bool, &quot;validate_gains must return boolean array&quot; def test_controller_factory_integration(controller_type: str, sample_gains: np.ndarray): &quot;&quot;&quot;Test controller factory integration.&quot;&quot;&quot; from src.controllers.factory import ControllerFactory # Test factory creation controller = ControllerFactory.create_controller(controller_type, sample_gains) # Verify interface compliance test_pso_controller_interface_compliance(type(controller), sample_gains) # Test multiple creations with same gains controller2 = ControllerFactory.create_controller(controller_type, sample_gains) assert type(controller) == type(controller2), &quot;Factory must return consistent types&quot;</span>
<span class="err">```</span> <span class="c1">### 6.2 Integration Testing Framework **End-to-End Testing:**</span>
<span class="err">```</span><span class="n">python</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_pso_optimization_integration</span><span class="p">(</span><span class="n">controller_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot;Test complete PSO optimization workflow.&quot;&quot;&quot;</span> <span class="kn">from</span><span class="w"> </span><span class="nn">src.config</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_config</span> <span class="kn">from</span><span class="w"> </span><span class="nn">src.optimization.algorithms.pso_optimizer</span><span class="w"> </span><span class="kn">import</span> <span class="n">PSOTuner</span> <span class="c1"># Load test configuration config = load_config(&#39;config.yaml&#39;) # Create controller factory def factory(gains: np.ndarray): return ControllerFactory.create_controller(controller_type, gains) # Initialize PSO tuner pso_tuner = PSOTuner( controller_factory=factory, config=config, seed=42 # Reproducible testing ) # Run short optimization bounds_config = getattr(config.pso.bounds, controller_type) lower_bounds = np.array(bounds_config.lower) upper_bounds = np.array(bounds_config.upper) results = pso_tuner.optimize( bounds=(lower_bounds, upper_bounds), n_particles=10, # Small for testing n_iterations=5 # Short for testing ) # Validate results assert &#39;best_gains&#39; in results, &quot;Results missing best_gains&quot; assert &#39;best_cost&#39; in results, &quot;Results missing best_cost&quot; assert &#39;success&#39; in results, &quot;Results missing success flag&quot; best_gains = results[&#39;best_gains&#39;] assert len(best_gains) == len(lower_bounds), &quot;Invalid best_gains dimension&quot; assert np.all(best_gains &gt;= lower_bounds), &quot;best_gains violate lower bounds&quot; assert np.all(best_gains &lt;= upper_bounds), &quot;best_gains violate upper bounds&quot; # Test optimized controller creation optimized_controller = factory(best_gains) test_state = np.zeros(6) control = optimized_controller.compute_control(test_state) assert np.isfinite(control), &quot;Optimized controller produces invalid control&quot;</span>
</pre></div>
</div>
<hr class="docutils" />
</section>
<section id="documentation-and-examples-7-1-usage-examples-basic-pso-optimization">
<h1>7. Documentation and Examples ### 7.1 Usage Examples <strong>Basic PSO Optimization:</strong><a class="headerlink" href="#documentation-and-examples-7-1-usage-examples-basic-pso-optimization" title="Link to this heading">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false #!/usr/bin/env python3</span>

<span class="sd">&quot;&quot;&quot;Example: PSO optimization for Classical SMC.&quot;&quot;&quot;</span> <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.controllers.factory</span><span class="w"> </span><span class="kn">import</span> <span class="n">ControllerFactory</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.optimization.algorithms.pso_optimizer</span><span class="w"> </span><span class="kn">import</span> <span class="n">PSOTuner</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.config</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_config</span> <span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">():</span> <span class="s2">&quot;&quot;&quot;Run PSO optimization example.&quot;&quot;&quot;</span> <span class="c1"># Load configuration config = load_config(&#39;config.yaml&#39;) # Define controller factory def create_classical_smc(gains: np.ndarray): return ControllerFactory.create_controller(&#39;classical_smc&#39;, gains) # Initialize PSO tuner pso_tuner = PSOTuner( controller_factory=create_classical_smc, config=config, seed=42 ) # Set optimization bounds lower_bounds = np.array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1]) upper_bounds = np.array([20.0, 20.0, 20.0, 20.0, 100.0, 10.0]) # Run optimization print(&quot;Starting PSO optimization...&quot;) results = pso_tuner.optimize( bounds=(lower_bounds, upper_bounds), n_particles=50, n_iterations=100, verbose=True ) # Display results if results[&#39;success&#39;]: print(f&quot;Optimization successful!&quot;) print(f&quot;Best gains: {results[&#39;best_gains&#39;]}&quot;) print(f&quot;Best cost: {results[&#39;best_cost&#39;]:.6f}&quot;) # Test optimized controller controller = create_classical_smc(results[&#39;best_gains&#39;]) test_state = np.array([0.1, 0.05, 0.0, 0.0, 0.0, 0.0]) control = controller.compute_control(test_state) print(f&quot;Test control output: {control:.3f} N&quot;) else: print(f&quot;Optimization failed: {results.get(&#39;message&#39;, &#39;Unknown error&#39;)}&quot;) if __name__ == &quot;__main__&quot;: main()</span>
<span class="err">```</span> <span class="o">**</span><span class="n">Custom</span> <span class="n">Controller</span> <span class="n">Integration</span><span class="p">:</span><span class="o">**</span>
<span class="err">```</span><span class="n">python</span>

<span class="sd">&quot;&quot;&quot;Example: Custom controller with PSO interface.&quot;&quot;&quot;</span> <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.optimization.algorithms.pso_optimizer</span><span class="w"> </span><span class="kn">import</span> <span class="n">PSOTuner</span> <span class="k">class</span><span class="w"> </span><span class="nc">CustomSMC</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;Custom SMC implementing PSO interface.&quot;&quot;&quot;</span> <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gains</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gains</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Custom SMC requires 3 gains&quot;</span><span class="p">)</span> <span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k3</span> <span class="o">=</span> <span class="n">gains</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_force</span> <span class="o">=</span> <span class="mf">100.0</span> <span class="nd">@property</span> <span class="k">def</span><span class="w"> </span><span class="nf">max_force</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_force</span> <span class="k">def</span><span class="w"> </span><span class="nf">compute_control</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span> <span class="n">theta1</span><span class="p">,</span> <span class="n">theta2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">theta1_dot</span><span class="p">,</span> <span class="n">theta2_dot</span><span class="p">,</span> <span class="n">x_dot</span> <span class="o">=</span> <span class="n">state</span> <span class="c1"># Custom control law u = -self.k1 * theta1 - self.k2 * theta2 - self.k3 * x return np.clip(u, -self.max_force, self.max_force) def validate_gains(self, particles: np.ndarray) -&gt; np.ndarray: # All gains must be positive return np.all(particles &gt; 0, axis=1) def optimize_custom_controller(): &quot;&quot;&quot;Optimize custom controller with PSO.&quot;&quot;&quot; # Create factory function def create_custom_smc(gains: np.ndarray) -&gt; CustomSMC: return CustomSMC(gains) # Mock configuration (normally loaded from YAML) class MockConfig: simulation = type(&#39;obj&#39;, (object,), {&#39;duration&#39;: 10.0, &#39;dt&#39;: 0.001}) cost_function = type(&#39;obj&#39;, (object,), { &#39;weights&#39;: type(&#39;obj&#39;, (object,), { &#39;state_error&#39;: 1.0, &#39;control_effort&#39;: 0.01, &#39;control_rate&#39;: 0.001, &#39;stability&#39;: 10.0 })() })() # Initialize PSO tuner pso_tuner = PSOTuner( controller_factory=create_custom_smc, config=MockConfig(), seed=42 ) # Optimize bounds = (np.array([0.1, 0.1, 0.1]), np.array([10.0, 10.0, 10.0])) results = pso_tuner.optimize(bounds=bounds, n_particles=20, n_iterations=50) return results</span>
</pre></div>
</div>
<hr class="docutils" />
</section>
<section id="api-migration-and-compatibility-8-1-legacy-interface-support-backward-compatibility-layer">
<h1>8. API Migration and Compatibility ### 8.1 Legacy Interface Support <strong>Backward Compatibility Layer:</strong><a class="headerlink" href="#api-migration-and-compatibility-8-1-legacy-interface-support-backward-compatibility-layer" title="Link to this heading">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false def legacy_controller_adapter(legacy_controller_class): &quot;&quot;&quot;Adapter for legacy controllers without PSO interface.&quot;&quot;&quot; class PSO_CompatibleAdapter(PSO_ControllerInterface): def __init__(self, gains: np.ndarray, **kwargs): # Convert gains to legacy format legacy_params = self._convert_gains_to_legacy(gains) self._legacy_controller = legacy_controller_class(**legacy_params) self._max_force = kwargs.get(&#39;max_force&#39;, 150.0) @property def max_force(self) -&gt; float: return self._max_force def compute_control(self, state: np.ndarray, **kwargs) -&gt; float: return self._legacy_controller.compute_control(state, **kwargs) def _convert_gains_to_legacy(self, gains: np.ndarray) -&gt; dict: # Implementation-specific conversion pass return PSO_CompatibleAdapter # Usage:</span>

<span class="c1"># PSO_CompatibleLegacyController = legacy_controller_adapter(LegacyControllerClass)</span>

<span class="err">```</span> <span class="c1">### 8.2 Version Migration Tools **API Version Checker:**</span>
<span class="err">```</span><span class="n">python</span>
<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false def check_controller_api_version(controller_class: Type) -&gt; str: &quot;&quot;&quot;Check controller API version compatibility.&quot;&quot;&quot; # Check for PSO interface compliance required_methods = [&#39;compute_control&#39;] required_properties = [&#39;max_force&#39;] optional_methods = [&#39;validate_gains&#39;] has_required = all(hasattr(controller_class, method) for method in required_methods) has_properties = all(hasattr(controller_class, prop) for prop in required_properties) has_optional = any(hasattr(controller_class, method) for method in optional_methods) if has_required and has_properties: if has_optional: return &quot;PSO_v2.0&quot; # Full PSO interface else: return &quot;PSO_v1.0&quot; # Basic PSO interface else: return &quot;Legacy&quot; # Requires adapter</span>

</pre></div>
</div>
<hr class="docutils" />
</section>
<section id="conclusion-the-controller-pso-interface-api-provides-a-comprehensive-type-safe-and-performant-framework-for-integrating-optimization-algorithms-with-sliding-mode-controllers-key-api-strengths-include-interface-design">
<h1>9. Conclusion The Controller-PSO Interface API provides a comprehensive, type-safe, and performant framework for integrating optimization algorithms with sliding mode controllers. Key API strengths include: <strong>Interface Design:</strong><a class="headerlink" href="#conclusion-the-controller-pso-interface-api-provides-a-comprehensive-type-safe-and-performant-framework-for-integrating-optimization-algorithms-with-sliding-mode-controllers-key-api-strengths-include-interface-design" title="Link to this heading">¶</a></h1>
<ul class="simple">
<li><p><strong>Standardized Contracts</strong>: Consistent interface across all controller types</p></li>
<li><p><strong>Type Safety</strong>: Full type annotation with runtime validation</p></li>
<li><p><strong>Performance</strong>: Vectorized operations with minimal overhead</p></li>
<li><p><strong>Extensibility</strong>: Plugin architecture for new controller types <strong>Integration Features:</strong></p></li>
<li><p><strong>Factory Pattern</strong>: Centralized controller creation and management</p></li>
<li><p><strong>Error Handling</strong>: validation and graceful error recovery</p></li>
<li><p><strong>Performance Monitoring</strong>: Built-in benchmarking and profiling features - <strong>Backward Compatibility</strong>: Migration tools for legacy controller integration <strong>Optimization Support:</strong></p></li>
<li><p><strong>PSO Integration</strong>: particle swarm optimization workflow</p></li>
<li><p><strong>Batch Operations</strong>: Efficient vectorized fitness evaluation</p></li>
<li><p><strong>Uncertainty Handling</strong>: Robust optimization under parameter uncertainty</p></li>
<li><p><strong>Real-time Constraints</strong>: Performance guarantees for control applications This API successfully resolves the interface requirements of GitHub Issue #4, providing a robust foundation for controller optimization workflows within the Double-Inverted Pendulum system.</p></li>
</ul>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Research Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on Oct 10, 2025</div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="_static/documentation_options.js?v=4ebf8126"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/scripts/furo.js?v=46bd48cc"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=08e7b316"></script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script src="_static/back-to-top.js?v=840797bb"></script>
    <script src="_static/lazy-load.js?v=dc25293c"></script>
    <script src="_static/dark-mode.js?v=bf328970"></script>
    </body>
</html>