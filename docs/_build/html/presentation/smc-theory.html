<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="Abstract" href="chattering-mitigation.html" /><link rel="prev" title="A Comprehensive Technical Report on the Modeling and Configuration of a Cart‑Based Double Inverted Pendulum System" href="system-modeling.html" />

    <!-- Generated with Sphinx 7.4.7 and Furo 2024.08.06 -->
        <title>Sliding Mode Control for a Double‑Inverted Pendulum: Bridging Theory and Implementation - DIP_SMC_PSO Documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5349f25f" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=302659d7" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=f5a89ef9" />
    
    


<style>
  body {
    --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">DIP_SMC_PSO Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">DIP_SMC_PSO Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">📚 Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Optimal Sliding Mode Control for a Double-Inverted Pendulum via PSO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory_overview.html">1. Theoretical Background â€” Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../architecture.html">3. System Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plant_model.html">1.x Plant Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hil_quickstart.html">Hardware-in-the-Loop (HIL) Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../streamlit_dashboard_guide.html">Streamlit Dashboard User Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">🎮 Control Systems &amp; Optimization</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../controllers/index.html">Controllers Module Documentation</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Controllers Module Documentation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../controllers/classical_smc_technical_guide.html">Classical Sliding Mode Control Technical Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../controllers/adaptive_smc_technical_guide.html">Adaptive Sliding Mode Control Technical Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../controllers/sta_smc_technical_guide.html">Super-Twisting Sliding Mode Control Technical Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../controllers/hybrid_smc_technical_guide.html">Hybrid Adaptive Super-Twisting SMC Technical Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../controllers/mpc_technical_guide.html">Model Predictive Control Technical Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../controllers/swing_up_smc_technical_guide.html">Swing-Up SMC Technical Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../controllers/factory_system_guide.html">SMC Controller Factory System Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../controllers/control_primitives_reference.html">Control Primitives Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/smc_complete_theory.html">Complete Sliding Mode Control Mathematical Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/controller_comparison_theory.html">SMC Controller Comparison Theory</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../reference/controllers/index.html">Controllers Module</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Controllers Module</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/adaptive_smc.html">controllers.adaptive_smc</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/classic_smc.html">controllers.classic_smc</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/factory.html">controllers.factory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/mpc_controller.html">controllers.mpc_controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/sta_smc.html">controllers.sta_smc</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/swing_up_smc.html">controllers.swing_up_smc</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/__init__.html">controllers.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/base_controller_interface.html">controllers.base.controller_interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/base_control_primitives.html">controllers.base.control_primitives</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/base___init__.html">controllers.base.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/factory_deprecation.html">controllers.factory.deprecation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/factory_fallback_configs.html">controllers.factory.fallback_configs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/factory_legacy_factory.html">controllers.factory.legacy_factory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/factory_optimization.html">controllers.factory.optimization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/factory_pso_integration.html">controllers.factory.pso_integration</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/factory_smc_factory.html">controllers.factory.smc_factory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/factory_thread_safety.html">controllers.factory.thread_safety</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/factory___init__.html">controllers.factory.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/mpc_mpc_controller.html">controllers.mpc.mpc_controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/mpc___init__.html">controllers.mpc.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_adaptive_smc.html">controllers.smc.adaptive_smc</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_classic_smc.html">controllers.smc.classic_smc</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_hybrid_adaptive_sta_smc.html">controllers.smc.hybrid_adaptive_sta_smc</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_sta_smc.html">controllers.smc.sta_smc</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc___init__.html">controllers.smc.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/specialized_swing_up_smc.html">controllers.specialized.swing_up_smc</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/specialized___init__.html">controllers.specialized.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/factory_core_protocols.html">controllers.factory.core.protocols</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/factory_core_registry.html">controllers.factory.core.registry</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/factory_core_threading.html">controllers.factory.core.threading</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/factory_core_validation.html">controllers.factory.core.validation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/factory_core___init__.html">controllers.factory.core.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_algorithms___init__.html">controllers.smc.algorithms.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_core_equivalent_control.html">controllers.smc.core.equivalent_control</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_core_gain_validation.html">controllers.smc.core.gain_validation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_core_sliding_surface.html">controllers.smc.core.sliding_surface</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_core_switching_functions.html">controllers.smc.core.switching_functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_core___init__.html">controllers.smc.core.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_algorithms_adaptive_adaptation_law.html">controllers.smc.algorithms.adaptive.adaptation_law</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_algorithms_adaptive_config.html">controllers.smc.algorithms.adaptive.config</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_algorithms_adaptive_controller.html">controllers.smc.algorithms.adaptive.controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_algorithms_adaptive_parameter_estimation.html">controllers.smc.algorithms.adaptive.parameter_estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_algorithms_adaptive___init__.html">controllers.smc.algorithms.adaptive.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_algorithms_classical_boundary_layer.html">controllers.smc.algorithms.classical.boundary_layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_algorithms_classical_config.html">controllers.smc.algorithms.classical.config</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_algorithms_classical_controller.html">controllers.smc.algorithms.classical.controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_algorithms_classical___init__.html">controllers.smc.algorithms.classical.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_algorithms_hybrid_config.html">controllers.smc.algorithms.hybrid.config</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_algorithms_hybrid_controller.html">controllers.smc.algorithms.hybrid.controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_algorithms_hybrid_switching_logic.html">controllers.smc.algorithms.hybrid.switching_logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_algorithms_hybrid___init__.html">controllers.smc.algorithms.hybrid.<strong>init</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_algorithms_super_twisting_config.html">controllers.smc.algorithms.super_twisting.config</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_algorithms_super_twisting_controller.html">controllers.smc.algorithms.super_twisting.controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_algorithms_super_twisting_twisting_algorithm.html">controllers.smc.algorithms.super_twisting.twisting_algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/controllers/smc_algorithms_super_twisting___init__.html">controllers.smc.algorithms.super_twisting.<strong>init</strong></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../mathematical_foundations/index.html">Mathematical Foundations</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Mathematical Foundations</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/smc_complete_theory.html">Complete Sliding Mode Control Mathematical Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/controller_comparison_theory.html">SMC Controller Comparison Theory</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../plant/models_guide.html">Plant Models Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../optimization_simulation/guide.html">Optimization &amp; Simulation Guide</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../reference/controllers/index.html">Controllers Module</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of Controllers Module</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/adaptive_smc.html">controllers.adaptive_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/classic_smc.html">controllers.classic_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory.html">controllers.factory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/mpc_controller.html">controllers.mpc_controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/sta_smc.html">controllers.sta_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/swing_up_smc.html">controllers.swing_up_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/__init__.html">controllers.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/base_controller_interface.html">controllers.base.controller_interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/base_control_primitives.html">controllers.base.control_primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/base___init__.html">controllers.base.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_deprecation.html">controllers.factory.deprecation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_fallback_configs.html">controllers.factory.fallback_configs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_legacy_factory.html">controllers.factory.legacy_factory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_optimization.html">controllers.factory.optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_pso_integration.html">controllers.factory.pso_integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_smc_factory.html">controllers.factory.smc_factory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_thread_safety.html">controllers.factory.thread_safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory___init__.html">controllers.factory.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/mpc_mpc_controller.html">controllers.mpc.mpc_controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/mpc___init__.html">controllers.mpc.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_adaptive_smc.html">controllers.smc.adaptive_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_classic_smc.html">controllers.smc.classic_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_hybrid_adaptive_sta_smc.html">controllers.smc.hybrid_adaptive_sta_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_sta_smc.html">controllers.smc.sta_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc___init__.html">controllers.smc.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/specialized_swing_up_smc.html">controllers.specialized.swing_up_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/specialized___init__.html">controllers.specialized.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_core_protocols.html">controllers.factory.core.protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_core_registry.html">controllers.factory.core.registry</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_core_threading.html">controllers.factory.core.threading</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_core_validation.html">controllers.factory.core.validation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_core___init__.html">controllers.factory.core.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms___init__.html">controllers.smc.algorithms.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_core_equivalent_control.html">controllers.smc.core.equivalent_control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_core_gain_validation.html">controllers.smc.core.gain_validation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_core_sliding_surface.html">controllers.smc.core.sliding_surface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_core_switching_functions.html">controllers.smc.core.switching_functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_core___init__.html">controllers.smc.core.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_adaptive_adaptation_law.html">controllers.smc.algorithms.adaptive.adaptation_law</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_adaptive_config.html">controllers.smc.algorithms.adaptive.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_adaptive_controller.html">controllers.smc.algorithms.adaptive.controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_adaptive_parameter_estimation.html">controllers.smc.algorithms.adaptive.parameter_estimation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_adaptive___init__.html">controllers.smc.algorithms.adaptive.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_classical_boundary_layer.html">controllers.smc.algorithms.classical.boundary_layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_classical_config.html">controllers.smc.algorithms.classical.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_classical_controller.html">controllers.smc.algorithms.classical.controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_classical___init__.html">controllers.smc.algorithms.classical.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_hybrid_config.html">controllers.smc.algorithms.hybrid.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_hybrid_controller.html">controllers.smc.algorithms.hybrid.controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_hybrid_switching_logic.html">controllers.smc.algorithms.hybrid.switching_logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_hybrid___init__.html">controllers.smc.algorithms.hybrid.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_super_twisting_config.html">controllers.smc.algorithms.super_twisting.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_super_twisting_controller.html">controllers.smc.algorithms.super_twisting.controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_super_twisting_twisting_algorithm.html">controllers.smc.algorithms.super_twisting.twisting_algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_super_twisting___init__.html">controllers.smc.algorithms.super_twisting.<strong>init</strong></a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../reference/optimizer/index.html">Optimizer Module</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of Optimizer Module</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimizer/pso_optimizer.html">optimizer.pso_optimizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimizer/__init__.html">optimizer.<strong>init</strong></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../analysis_plan.html">5. Analysis &amp; Verification Plan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html">Benchmarks &amp; Methodology</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">🧪 Development &amp; Testing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../TESTING.html">Testing Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_protocols.html">5.x Test Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="../use_cases.html">4. Use Cases &amp; Operating Modes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../context.html">2. Application Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault_detection_guide.html">Fault Detection &amp; Isolation (FDI) Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">📊 Research &amp; Theory</span></p>
<ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">Research Presentation Materials</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle navigation of Research Presentation Materials</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="introduction.html">Abstract</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html#introduction-and-motivation">Introduction and Motivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html#the-double-inverted-pendulum-as-a-canonical-control-problem">The Double Inverted Pendulum as a Canonical Control Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html#the-primary-control-objectives-and-challenges">The Primary Control Objectives and Challenges</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html#sliding-mode-control-as-a-robust-solution">Sliding Mode Control as a Robust Solution</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html#the-gain-tuning-dilemma-and-the-need-for-optimization">The Gain Tuning Dilemma and the Need for Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html#particle-swarm-optimization-for-automated-design">Particle Swarm Optimization for Automated Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html#synthesis-and-motivation">Synthesis and Motivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="introduction.html#references">References</a></li>
<li class="toctree-l2"><a class="reference internal" href="problem-statement.html">Problem Statement for Double‑Inverted Pendulum (DIP) Control with SMC and PSO</a></li>
<li class="toctree-l2"><a class="reference internal" href="previous-works.html">Previous Work Before the Project</a></li>
<li class="toctree-l2"><a class="reference internal" href="system-modeling.html"><strong>A Comprehensive Technical Report on the Modeling and Configuration of a Cart‑Based Double Inverted Pendulum System</strong></a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Sliding Mode Control for a Double‑Inverted Pendulum: Bridging Theory and Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="chattering-mitigation.html">Abstract</a></li>
<li class="toctree-l2"><a class="reference internal" href="chattering-mitigation.html#introduction">1 Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="chattering-mitigation.html#system-modelling-and-problem-formulation">2 System Modelling and Problem Formulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="chattering-mitigation.html#simulation-methodology">3 Simulation Methodology</a></li>
<li class="toctree-l2"><a class="reference internal" href="chattering-mitigation.html#classic-sliding-mode-control">4 Classic Sliding Mode Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="chattering-mitigation.html#chattering-mitigation-strategy-i-boundary-layer-method">5 Chattering Mitigation Strategy I: Boundary Layer Method</a></li>
<li class="toctree-l2"><a class="reference internal" href="chattering-mitigation.html#chattering-mitigation-strategy-ii-supertwisting-algorithm">6 Chattering Mitigation Strategy II: Super‑Twisting Algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="chattering-mitigation.html#chattering-mitigation-strategy-iii-adaptive-sliding-mode-control">7 Chattering Mitigation Strategy III: Adaptive Sliding Mode Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="chattering-mitigation.html#chattering-mitigation-strategy-iv-hybrid-adaptivesta">8 Chattering Mitigation Strategy IV: Hybrid Adaptive–STA</a></li>
<li class="toctree-l2"><a class="reference internal" href="chattering-mitigation.html#synthesis-and-comparative-analysis">9 Synthesis and Comparative Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="chattering-mitigation.html#references">References</a></li>
<li class="toctree-l2"><a class="reference internal" href="pso-optimization.html"><strong>Comprehensive Simulation Analysis and Enhancements for the Double Inverted Pendulum Control System</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation-setup.html">Particle Swarm Optimization for Sliding‑Mode Controller Tuning of a Double Inverted Pendulum</a></li>
<li class="toctree-l2"><a class="reference internal" href="results-discussion.html">8 – Results and Discussion</a></li>
<li class="toctree-l2"><a class="reference internal" href="results-discussion.html#references">References</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html#introduction-and-motivation">Introduction and Motivation</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html#the-double-inverted-pendulum-as-a-canonical-control-problem">The Double Inverted Pendulum as a Canonical Control Problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html#the-primary-control-objectives-and-challenges">The Primary Control Objectives and Challenges</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html#sliding-mode-control-as-a-robust-solution">Sliding Mode Control as a Robust Solution</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html#the-gain-tuning-dilemma-and-the-need-for-optimization">The Gain Tuning Dilemma and the Need for Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html#particle-swarm-optimization-for-automated-design">Particle Swarm Optimization for Automated Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html#synthesis-and-motivation">Synthesis and Motivation</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html#references">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="problem-statement.html">Problem Statement for Double‑Inverted Pendulum (DIP) Control with SMC and PSO</a></li>
<li class="toctree-l1"><a class="reference internal" href="previous-works.html">Previous Work Before the Project</a></li>
<li class="toctree-l1"><a class="reference internal" href="system-modeling.html"><strong>A Comprehensive Technical Report on the Modeling and Configuration of a Cart‑Based Double Inverted Pendulum System</strong></a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Sliding Mode Control for a Double‑Inverted Pendulum: Bridging Theory and Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="chattering-mitigation.html">Abstract</a></li>
<li class="toctree-l1"><a class="reference internal" href="chattering-mitigation.html#introduction">1 Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="chattering-mitigation.html#system-modelling-and-problem-formulation">2 System Modelling and Problem Formulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="chattering-mitigation.html#simulation-methodology">3 Simulation Methodology</a></li>
<li class="toctree-l1"><a class="reference internal" href="chattering-mitigation.html#classic-sliding-mode-control">4 Classic Sliding Mode Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="chattering-mitigation.html#chattering-mitigation-strategy-i-boundary-layer-method">5 Chattering Mitigation Strategy I: Boundary Layer Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="chattering-mitigation.html#chattering-mitigation-strategy-ii-supertwisting-algorithm">6 Chattering Mitigation Strategy II: Super‑Twisting Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="chattering-mitigation.html#chattering-mitigation-strategy-iii-adaptive-sliding-mode-control">7 Chattering Mitigation Strategy III: Adaptive Sliding Mode Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="chattering-mitigation.html#chattering-mitigation-strategy-iv-hybrid-adaptivesta">8 Chattering Mitigation Strategy IV: Hybrid Adaptive–STA</a></li>
<li class="toctree-l1"><a class="reference internal" href="chattering-mitigation.html#synthesis-and-comparative-analysis">9 Synthesis and Comparative Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="chattering-mitigation.html#references">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="pso-optimization.html"><strong>Comprehensive Simulation Analysis and Enhancements for the Double Inverted Pendulum Control System</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="simulation-setup.html">Particle Swarm Optimization for Sliding‑Mode Controller Tuning of a Double Inverted Pendulum</a></li>
<li class="toctree-l1"><a class="reference internal" href="results-discussion.html">8 – Results and Discussion</a></li>
<li class="toctree-l1"><a class="reference internal" href="results-discussion.html#references">References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">📖 API Reference &amp; Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API Reference Documentation</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../examples/index.html">Examples</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle navigation of Examples</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../bibliography.html">Bibliography &amp; Academic References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">🔧 Project Management</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../CONTRIBUTING.html">Contributing – ResearchPlanSpec Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../RELEASE_CHECKLIST.html">Release Checklist</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CHANGELOG.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symbols.html">Symbols &amp; Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../results_readme.html">Results &amp; Plots</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/blob/main/docs/presentation/smc-theory.md?plain=true" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div><div class="edit-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/edit/main/docs/presentation/smc-theory.md" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section class="tex2jax_ignore mathjax_ignore" id="sliding-mode-control-for-a-doubleinverted-pendulum-bridging-theory-and-implementation">
<h1>Sliding Mode Control for a Double‑Inverted Pendulum: Bridging Theory and Implementation<a class="headerlink" href="#sliding-mode-control-for-a-doubleinverted-pendulum-bridging-theory-and-implementation" title="Link to this heading">¶</a></h1>
<section id="introduction-why-sliding-mode-control">
<h2>Introduction – Why Sliding Mode Control?<a class="headerlink" href="#introduction-why-sliding-mode-control" title="Link to this heading">¶</a></h2>
<p>The double‑inverted pendulum (DIP) is widely recognised as a <strong>canonical benchmark</strong> for the study of nonlinear, under‑actuated control systems. Inverted‑pendulum experiments have been used for decades to teach and validate control techniques; variants such as the rotational single‑arm pendulum, the cart pendulum and the <strong>double inverted pendulum</strong> offer escalating control challenges, and the inverted pendulum is often described as the most fundamental benchmark for robotics and control education [1]. In the DIP, two pendula are attached in series to a horizontally moving cart and only the cart is actuated. Consequently the system has fewer actuators than degrees of freedom and is both <strong>under‑actuated</strong> and <strong>strongly nonlinear</strong> [2]. Conventional linear controllers struggle with large deflections, parameter variations and model uncertainty.</p>
<p>Sliding Mode Control (SMC) addresses these issues by forcing the system state onto a pre‑defined <strong>sliding manifold</strong>. When the state reaches this manifold, the resulting closed‑loop dynamics become insensitive to matched disturbances and uncertainties [3]. The control law compensates modelling errors through the control input channel so that the plant behaves according to the reduced‑order dynamics on the manifold [3]. This robustness and finite‑time convergence make SMC attractive for under‑actuated systems such as the DIP. However, the discontinuous switching law of classic SMC induces <strong>chattering</strong>, a high‑frequency oscillation caused by rapid control switching when the state crosses the sliding surface. Chattering increases control effort, excites unmodelled high‑frequency modes and can cause wear in actuators. Introducing a boundary layer around the sliding surface alleviates chattering but enlarges the tracking error and slows the response [4].</p>
<p>To explore different trade‑offs between robustness, smoothness and complexity, this project implements four SMC variants – <strong>classic (first‑order)</strong>, <strong>super‑twisting algorithm (STA)</strong>, <strong>adaptive SMC</strong>, and <strong>hybrid adaptive–STA</strong>. Each variant is implemented in the provided Python code (<code class="docutils literal notranslate"><span class="pre">classic_smc.py</span></code>, <code class="docutils literal notranslate"><span class="pre">sta_smc.py</span></code>, <code class="docutils literal notranslate"><span class="pre">adaptive_smc.py</span></code>, <code class="docutils literal notranslate"><span class="pre">hybrid_adaptive_sta_smc.py</span></code>), and the following sections link the theory to these implementations.</p>
<section id="structure-of-the-report">
<h3>Structure of the report<a class="headerlink" href="#structure-of-the-report" title="Link to this heading">¶</a></h3>
<p>The report is organised as follows. Each controller variant is presented with a concise theoretical background, a description of its implementation in the project, and an analysis of its practical implications. New sections map configuration parameters to mathematical symbols and discuss robustness issues such as singularity handling. A glossary of symbols and tables summarise the key results.</p>
</section>
</section>
<hr class="docutils" />
<section id="variant-i-classic-sliding-mode-control-smc">
<h2>Variant I: Classic Sliding Mode Control (SMC)<a class="headerlink" href="#variant-i-classic-sliding-mode-control-smc" title="Link to this heading">¶</a></h2>
<section id="principles-and-sliding-surface">
<h3>Principles and sliding surface<a class="headerlink" href="#principles-and-sliding-surface" title="Link to this heading">¶</a></h3>
<p>Classic SMC designs a linear <strong>sliding surface</strong> that combines position and velocity errors. For second‑order systems such as the DIP, the surface is typically a linear combination of the tracking error and its first derivative [5]. In this report the sliding surface is</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>\sigma = \lambda_{1}\,\theta_{1} + \lambda_{2}\,\theta_{2} + k_{1}\,\dot{\theta}_{1} + k_{2}\,\dot{\theta}_{2},
</pre></div>
</div>
<p>where (\theta_{i}) are the pendulum angles, (\dot{\theta}<em>{i}) their angular velocities, and (\lambda</em>{i}&gt;0) are design gains. The implementation computes the sliding variable in the <code class="docutils literal notranslate"><span class="pre">_compute_sliding_surface</span></code> method of <code class="docutils literal notranslate"><span class="pre">classic_smc.py</span></code>:</p>
<p><em>“sigma = self.lam1 * theta1 + self.lam2 * theta2 + self.k1 * dtheta1 + self.k2 * dtheta2”</em> (see <code class="docutils literal notranslate"><span class="pre">classic_smc.py</span></code>), directly matching the equation above.</p>
</section>
<section id="control-law-equivalent-and-switching-parts">
<h3>Control law: equivalent and switching parts<a class="headerlink" href="#control-law-equivalent-and-switching-parts" title="Link to this heading">¶</a></h3>
<p>The control input \u\ is decomposed into an <strong>equivalent control</strong> \u_{\mathrm{eq}} that cancels the nominal dynamics and a <strong>robust switching</strong> term \u_{\mathrm{sw}} that drives (\sigma) toward zero. This decomposition, often written as (u = u_{eq} + u_{sw}), is standard in sliding‑mode design [5]:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>u = u_{eq} - K\, sat\left( \frac{\sigma}{\epsilon} \right) - k_{d}\,\sigma.
</pre></div>
</div>
<section id="equivalent-control-computation">
<h4>Equivalent control computation<a class="headerlink" href="#equivalent-control-computation" title="Link to this heading">¶</a></h4>
<p>In <code class="docutils literal notranslate"><span class="pre">classic_smc.py</span></code> the <code class="docutils literal notranslate"><span class="pre">_compute_equivalent_control</span></code> method solves the dynamic equation of the DIP:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>M(q)\ddot{q} + C\left( q,\dot{q} \right)\dot{q} + G(q) = B\, u,
</pre></div>
</div>
<p>for the <strong>cart force</strong> \u\ required to satisfy (\dot{\sigma}=0). The inertia matrix \M(q)\ is computed from the physics parameters and then <strong>regularised</strong> by adding a small diagonal term. Before inversion the code checks the condition number of \M(q); if it is ill‑conditioned the method resorts to the pseudo‑inverse (<code class="docutils literal notranslate"><span class="pre">np.linalg.pinv</span></code>) to avoid numerical singularities. This careful handling prevents blow‑ups when the pendulum angles approach singular configurations. The resulting \u_{\mathrm{eq}} is limited by the <code class="docutils literal notranslate"><span class="pre">max_force</span></code> parameter in the configuration.</p>
</section>
<section id="boundary-layer-and-saturation">
<h4>Boundary layer and saturation<a class="headerlink" href="#boundary-layer-and-saturation" title="Link to this heading">¶</a></h4>
<p>The switching term uses a <strong>saturation function</strong> to approximate the discontinuous sign function within a small <strong>boundary layer</strong> of width (\epsilon). Such smoothing reduces the chattering inherent in the discontinuous sign function, but it comes at a cost: introducing a boundary layer increases the tracking error and slows the response [4]. In the code, the <code class="docutils literal notranslate"><span class="pre">saturate</span></code> utility implements two approximations—a hyperbolic tangent (<code class="docutils literal notranslate"><span class="pre">method='tanh'</span></code>) and a linear clipping (<code class="docutils literal notranslate"><span class="pre">method='linear</span></code>)—that smooth the sign function. Figure 1 plots the ideal sign function alongside these saturations. Notice how both approximations approach the discontinuous sign outside the boundary layer and produce smoother transitions inside.</p>
<p>Saturation function approximations</p>
<p><em>Figure 1 – Approximation of the sign function by the hyperbolic‑tangent and linear saturation methods. The boundary layer width (\epsilon) determines where the output transitions between −1 and 1.</em></p>
</section>
</section>
<section id="numerical-robustness">
<h3>Numerical robustness<a class="headerlink" href="#numerical-robustness" title="Link to this heading">¶</a></h3>
<p>The classic controller includes several robustness enhancements:</p>
<ul class="simple">
<li><p><strong>Condition‑number checking and regularisation:</strong> The inertia matrix \M(q)\ is checked for ill‑conditioning and regularised by adding a small diagonal term ((\varepsilon I)). When ill‑conditioned, a pseudo‑inverse is used to compute the equivalent control.</p></li>
<li><p><strong>Fallback control:</strong> If the matrix inversion still fails due to singularity, the controller saturates the output to zero and returns an error flag, preventing instability.</p></li>
<li><p><strong>Actuator saturation:</strong> The control input is saturated by <code class="docutils literal notranslate"><span class="pre">max_force</span></code> to respect actuator limits.
These features make the classic SMC implementation stable and safe even when the model parameters deviate from their nominal values.</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="variant-ii-supertwisting-algorithm-sta-smc">
<h2>Variant II: Super‑Twisting Algorithm (STA) SMC<a class="headerlink" href="#variant-ii-supertwisting-algorithm-sta-smc" title="Link to this heading">¶</a></h2>
<section id="theory-and-formulation">
<h3>Theory and formulation<a class="headerlink" href="#theory-and-formulation" title="Link to this heading">¶</a></h3>
<p>The <strong>super‑twisting algorithm</strong> (STA) is a second‑order sliding mode technique that suppresses chattering by applying the discontinuity on the <strong>derivative</strong> of the control signal rather than on the control itself. By moving the discontinuity to the derivative, the control input becomes continuous, which greatly reduces high‑frequency oscillations while preserving the robustness of sliding‑mode control and guaranteeing finite‑time convergence to the sliding set [6]. The sliding variable (\sigma) for the STA controller is similar to the classic one but is scaled by separate gains. In <code class="docutils literal notranslate"><span class="pre">sta_smc.py</span></code> it is computed as</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>\sigma = k_{1}\,\left( {\dot{\theta}}_{1} + \lambda_{1}\,\theta_{1} \right) + k_{2}\,\left( {\dot{\theta}}_{2} + \lambda_{2}\,\theta_{2} \right).
</pre></div>
</div>
<p>The STA control comprises two components:</p>
<ol class="arabic simple">
<li><p><strong>Continuous term</strong> (u_{c}=-K_{1}\sqrt{|\sigma|},\mathrm{sgn}(\sigma)); this term acts like a damping force proportional to (\sqrt{|\sigma|}).</p></li>
<li><p><strong>Integral term</strong> (u_{i}) generated by integrating the sign of (\sigma): the internal state (z) is updated as (z\leftarrow z - K_{2},\mathrm{sgn}(\sigma),\mathrm{d}t). The integral of the discontinuity produces a continuous control signal, effectively moving the discontinuity to its derivative.</p></li>
</ol>
<p>The total control is (u = u_{\mathrm{eq}} + u_{c} + z). Because the discontinuity is applied to the derivative rather than to the control itself, the resulting control law is continuous and enforces finite‑time convergence of both the sliding variable and its derivative [6].  In our implementation the internal integrator for (z) is updated explicitly using the time step <code class="docutils literal notranslate"><span class="pre">dt</span></code>; the previously supported <code class="docutils literal notranslate"><span class="pre">semi_implicit</span></code> configuration key has been removed from the code and should not appear in <code class="docutils literal notranslate"><span class="pre">config.yaml</span></code>.</p>
</section>
<section id="lyapunov-stability-and-numerical-verification">
<h3>Lyapunov stability and numerical verification<a class="headerlink" href="#lyapunov-stability-and-numerical-verification" title="Link to this heading">¶</a></h3>
<p>A Lyapunov function (V=\tfrac12\sigma^{2}) can be shown to decrease along system trajectories under the STA law, guaranteeing finite‑time convergence of both (\sigma) and (\dot{\sigma}) to zero. The project includes a test, <code class="docutils literal notranslate"><span class="pre">test_lyapunov_decrease_sta</span></code> in <code class="docutils literal notranslate"><span class="pre">tests/test_core/test_lyapunov.py</span></code>, that numerically confirms this property. The test evaluates (V) at successive time steps and asserts that (V(t_{i+1}) &lt; V(t_{i})). This demonstrates that the implementation adheres to the theoretical stability proof and that the STA drives the system to the origin in the ((\sigma,\dot{\sigma}))-plane more aggressively than classic SMC.</p>
</section>
<section id="tuning-guidance">
<h3>Tuning guidance<a class="headerlink" href="#tuning-guidance" title="Link to this heading">¶</a></h3>
<p>Tuning the STA gains (K_{1}) and (K_{2}) is crucial. In practice:</p>
<ul class="simple">
<li><p><strong>(K_{1})</strong> determines the magnitude of the continuous term. It should be larger than the maximum possible derivative of the disturbance to ensure finite‑time convergence. Increasing (K_{1}) accelerates convergence but can amplify control effort.</p></li>
<li><p><strong>(K_{2})</strong> governs the integral action. A higher (K_{2}) increases the speed of the integral term, improving sliding accuracy, but excessive (K_{2}) may cause oscillations. Selecting (K_{2}\approx K_{1}) is common to balance the proportional and integral actions.</p></li>
</ul>
<p>The configuration file allows setting <code class="docutils literal notranslate"><span class="pre">K1_init</span></code> and <code class="docutils literal notranslate"><span class="pre">K2_init</span></code> for the hybrid controller and similar parameters for the pure STA controller under the <code class="docutils literal notranslate"><span class="pre">gains</span></code> entry. The <code class="docutils literal notranslate"><span class="pre">dt</span></code> parameter controls integration accuracy.</p>
</section>
</section>
<hr class="docutils" />
<section id="variant-iii-adaptive-smc">
<h2>Variant III: Adaptive SMC<a class="headerlink" href="#variant-iii-adaptive-smc" title="Link to this heading">¶</a></h2>
<section id="adaptation-law-and-dead-zone">
<h3>Adaptation law and dead zone<a class="headerlink" href="#adaptation-law-and-dead-zone" title="Link to this heading">¶</a></h3>
<p>Adaptive SMC adjusts the switching gain (K) on‑line to compensate for unknown disturbance bounds. Rather than fixing (K) using the worst‑case disturbance, the controller updates (K(t)) according to an adaptation law that increases the gain when the system is far from the sliding manifold and decreases it when the state enters a neighbourhood of the manifold. This approach eliminates the need for a priori knowledge of the disturbance bound and avoids overly conservative gains [7]. In <code class="docutils literal notranslate"><span class="pre">adaptive_smc.py</span></code>, the <code class="docutils literal notranslate"><span class="pre">compute_control</span></code> method implements the adaptation:</p>
<p>1. When (|\sigma|) exceeds a specified <strong>dead zone</strong> (parameter <code class="docutils literal notranslate"><span class="pre">dead_zone</span></code>), the switching gain grows proportionally to (|\sigma|).  Increasing the gain outside the dead zone enlarges the disturbance bound and improves robustness when the state is far from the sliding manifold.  This piece‑wise adaptation strategy is supported by nonlinear control theory: adaptive sliding‑mode controllers that allow the gain to increase until the sliding mode occurs and then decrease once the state enters a neighbourhood of the manifold achieve semi‑global stability without requiring a priori disturbance bounds [8].
2. Inside the dead zone the gain is held constant or allowed to decay slowly.  Decreasing the gain in this neighbourhood prevents unnecessary wind‑up and reduces chattering caused by measurement noise.  The nominal gain value is recovered through a leak term (<code class="docutils literal notranslate"><span class="pre">leak_rate</span></code>) and the growth rate is limited by <code class="docutils literal notranslate"><span class="pre">adapt_rate_limit</span></code> to avoid abrupt changes.</p>
<p>The gain is confined between <code class="docutils literal notranslate"><span class="pre">K_min</span></code> and <code class="docutils literal notranslate"><span class="pre">K_max</span></code> to prevent unbounded growth. A leak term (<code class="docutils literal notranslate"><span class="pre">leak_rate</span></code>) pulls the gain back toward its nominal value and prevents indefinite wind‑up. An additional limit (<code class="docutils literal notranslate"><span class="pre">adapt_rate_limit</span></code>) restricts how quickly the gain can change, avoiding abrupt jumps during adaptation.</p>
</section>
<section id="practical-considerations">
<h3>Practical considerations<a class="headerlink" href="#practical-considerations" title="Link to this heading">¶</a></h3>
<p>Adaptive SMC eliminates the need for prior knowledge of disturbance bounds and produces a continuous control signal, reducing chattering. However, it introduces additional parameters (adaptation rate, leak rate, dead zone) that require tuning and may yield slower transient response compared to fixed‑gain SMC if tuned conservatively.</p>
</section>
</section>
<hr class="docutils" />
<section id="variant-iv-hybrid-adaptivesta-smc">
<h2>Variant IV: Hybrid Adaptive–STA SMC<a class="headerlink" href="#variant-iv-hybrid-adaptivesta-smc" title="Link to this heading">¶</a></h2>
<section id="unified-sliding-surface-and-recentering">
<h3>Unified sliding surface and recentering<a class="headerlink" href="#unified-sliding-surface-and-recentering" title="Link to this heading">¶</a></h3>
<p>The hybrid controller combines the adaptive law with the super‑twisting algorithm using a <strong>single sliding surface</strong> that captures both pendulum dynamics and cart recentering.  By default the sliding surface uses absolute joint coordinates:</p>
<p>[
\sigma = c_{1},(\dot{\theta}<em>{1} + \lambda</em>{1},\theta_{1}) + c_{2},(\dot{\theta}<em>{2} + \lambda</em>{2},\theta_{2}) + k_{c},(\dot{x} + \lambda_{c},x),
]</p>
<p>where (c_{i}&gt;0) and (\lambda_{i}&gt;0) weight the pendulum angle and velocity errors, and (k_{c}), (\lambda_{c}) weight the cart velocity and position in the sliding manifold.  Selecting <strong>positive coefficients</strong> ensures that the sliding manifold is attractive and defines a stable reduced‑order error surface—this is a standard requirement in sliding‑mode design【895515998216162†L326-L329】.  The terms involving the cart state encourage the cart to recenter without destabilising the pendula.  The implementation also supports a <strong>relative formulation</strong> in which the second pendulum is represented by (\theta_{2}-\theta_{1}) and (\dot{\theta}<em>{2}-\dot{\theta}</em>{1}); users can enable this mode with <code class="docutils literal notranslate"><span class="pre">use_relative_surface=True</span></code> to study coupled pendulum dynamics.  Keeping both options accessible avoids hard‑coding a specific manifold and lets users explore alternative designs.</p>
<p>The PD recentering behaviour is further reinforced by separate proportional–derivative gains (p_{\mathrm{gain}}) and (p_{\lambda}) applied to the cart velocity and position.  These gains shape the transient response of the cart and are exposed as <code class="docutils literal notranslate"><span class="pre">cart_p_gain</span></code> and <code class="docutils literal notranslate"><span class="pre">cart_p_lambda</span></code> in the configuration.</p>
</section>
<section id="supertwisting-with-adaptive-gains">
<h3>Super‑twisting with adaptive gains<a class="headerlink" href="#supertwisting-with-adaptive-gains" title="Link to this heading">¶</a></h3>
<p>The hybrid control input consists of an equivalent part, a <strong>super‑twisting continuous term</strong> and an <strong>integral term</strong>.  The continuous term uses the square‑root law from the STA, (-k_{1}\sqrt{|\sigma|},\mathrm{sgn}(\sigma)), while the integral term (z) obeys (\dot{z} = -k_{2},\mathrm{sgn}(\sigma)).  Both gains (k_{1}) and (k_{2}) adapt online according to the same dead‑zone logic as in the adaptive SMC: when (|\sigma|) exceeds the dead‑zone threshold, the gains increase proportionally to (|\sigma|); inside the dead zone they are held constant or allowed to decay slowly.  To prevent runaway adaptation the gains are clipped at configurable maxima <code class="docutils literal notranslate"><span class="pre">k1_max</span></code> and <code class="docutils literal notranslate"><span class="pre">k2_max</span></code>, and the integral term <code class="docutils literal notranslate"><span class="pre">u_int</span></code> is limited by <code class="docutils literal notranslate"><span class="pre">u_int_max</span></code>.  Separating these bounds from the actuator saturation ensures that adaptation can proceed even when the actuator saturates【895515998216162†L326-L329】.  The equivalent control term (u_{\mathrm{eq}}) is <strong>enabled by default</strong>; it can be disabled via <code class="docutils literal notranslate"><span class="pre">enable_equivalent=False</span></code> if a purely sliding‑mode law is desired.  This piece‑wise adaptation law is supported by recent research showing that the gain should increase until sliding occurs and then decrease once the trajectory enters a neighbourhood of the manifold to avoid over‑estimation【462167782799487†L186-L195】.</p>
</section>
<section id="advantages-and-tuning">
<h3>Advantages and tuning<a class="headerlink" href="#advantages-and-tuning" title="Link to this heading">¶</a></h3>
<p>The hybrid adaptive–STA controller inherits the robustness of second‑order sliding mode and the flexibility of adaptive gain scheduling while remaining simpler than earlier dual‑surface designs.  Its unified sliding surface ensures consistent dynamics across all modes, and the adaptive gains allow the controller to handle unknown disturbance bounds without a priori tuning.  However, this comes at the expense of additional parameters: the sliding surface weights (c_{1},c_{2},\lambda_{1},\lambda_{2},k_{c},\lambda_{c}), the PD recentering gains (p_{\mathrm{gain}},p_{\lambda}), adaptation rates and dead‑zone widths.  Careful tuning of these parameters is essential to balance response speed, robustness and chattering.</p>
</section>
</section>
<hr class="docutils" />
<section id="new-section-controller-configuration-and-config-yaml">
<h2>New Section: Controller Configuration and <code class="docutils literal notranslate"><span class="pre">config.yaml</span></code><a class="headerlink" href="#new-section-controller-configuration-and-config-yaml" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">config.yaml</span></code> file defines tunable parameters for each controller. Mapping these keys to the mathematical symbols used in the theory clarifies how to adjust the controllers in practice. Table 1–4 summarise the mappings for each variant.</p>
<section id="classical-smc">
<h3>Classical SMC<a class="headerlink" href="#classical-smc" title="Link to this heading">¶</a></h3>
<div class="table-wrapper colwidths-auto docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><code class="docutils literal notranslate"><span class="pre">config.yaml</span></code> key</p></th>
<th class="head"><p>Mathematical symbol(s)</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gains</span></code> (in <code class="docutils literal notranslate"><span class="pre">controller_defaults</span></code>)</p></td>
<td><p>(\lambda_{1},\lambda_{2},k_{1},k_{2},K,k_{\mathrm{d}})</p></td>
<td><p>Initial values for sliding surface weights ((\lambda_{1},\lambda_{2})), velocity gains ((k_{1},k_{2})), switching gain (K) and damping gain (k_{\mathrm{d}}). They appear in (\sigma) and (u_{\mathrm{sw}}).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">boundary_layer</span></code></p></td>
<td><p>(\epsilon)</p></td>
<td><p>Half‑width of the boundary layer used in the saturation function.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">max_force</span></code></p></td>
<td><p>Saturation limit</p></td>
<td><p>Maximum magnitude of the control input (u).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">controllability_threshold</span></code></p></td>
<td><p>–</p></td>
<td><p>Lower bound on (</p></td>
</tr>
</tbody>
</table>
</div>
<!-- Removed `rate_weight` and `use_adaptive_boundary` rows as these parameters are no longer used in the implementation. -->
</section>
<section id="supertwisting-smc">
<h3>Super‑Twisting SMC<a class="headerlink" href="#supertwisting-smc" title="Link to this heading">¶</a></h3>
<div class="table-wrapper colwidths-auto docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><code class="docutils literal notranslate"><span class="pre">config.yaml</span></code> key</p></th>
<th class="head"><p>Mathematical symbol(s)</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gains</span></code></p></td>
<td><p>(\lambda_{1},\lambda_{2},k_{1},K_{1},K_{2},k_{\mathrm{d}})</p></td>
<td><p>Sliding surface weights, velocity gains, super‑twisting proportional gain (K_{1}), integral gain (K_{2}) and optional damping gain.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">damping_gain</span></code></p></td>
<td><p>(k_{\mathrm{d}})</p></td>
<td><p>Linear damping added to the control law.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">dt</span></code></p></td>
<td><p>(\mathrm{d}t)</p></td>
<td><p>Integration time step for updating the internal state (z).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">max_force</span></code></p></td>
<td><p>Saturation limit</p></td>
<td><p>Maximum control magnitude.</p></td>
</tr>
</tbody>
</table>
</div>
<!-- Removed `semi_implicit` and `rate_weight` parameters as they are no longer used. -->
</section>
<section id="adaptive-smc">
<h3>Adaptive SMC<a class="headerlink" href="#adaptive-smc" title="Link to this heading">¶</a></h3>
<div class="table-wrapper colwidths-auto docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><code class="docutils literal notranslate"><span class="pre">config.yaml</span></code> key</p></th>
<th class="head"><p>Mathematical symbol(s)</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gains</span></code></p></td>
<td><p>(\lambda_{1},\lambda_{2},k_{1},k_{2},K_{0})</p></td>
<td><p>Initial sliding surface and switching gain values.</p></td>
</tr>
</tbody>
</table>
</div>
<!-- Removed `rate_weight` row; the updated controller does not include a control‑rate term. -->
<p>| <code class="docutils literal notranslate"><span class="pre">leak_rate</span></code> | (\alpha) | Forgetting factor that allows the adaptive gain to decay when disturbances subside. |
| <code class="docutils literal notranslate"><span class="pre">dead_zone</span></code> | (\delta) | Dead‑zone width for suppressing gain growth when (|\sigma|) is small. |
| <code class="docutils literal notranslate"><span class="pre">adapt_rate_limit</span></code> | (\Gamma_{\max}) | Upper limit on how fast the gain can grow. |
| <code class="docutils literal notranslate"><span class="pre">K_{\min}</span></code>, <code class="docutils literal notranslate"><span class="pre">K_{\max}</span></code> | (K_{\min},K_{\max}) | Hard bounds on the adaptive gain. |
| <code class="docutils literal notranslate"><span class="pre">dt</span></code> | (\mathrm{d}t) | Time step for numerical integration. |
| <code class="docutils literal notranslate"><span class="pre">smooth_switch</span></code> | – | If true, uses a smooth transition function to improve continuity near switching events. |
| <code class="docutils literal notranslate"><span class="pre">boundary_layer</span></code> | (\epsilon) | Boundary layer width for the saturation function. |</p>
</section>
<section id="hybrid-adaptivesta-smc">
<h3>Hybrid Adaptive–STA SMC<a class="headerlink" href="#hybrid-adaptivesta-smc" title="Link to this heading">¶</a></h3>
<div class="table-wrapper colwidths-auto docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><code class="docutils literal notranslate"><span class="pre">config.yaml</span></code> key</p></th>
<th class="head"><p>Mathematical symbol(s)</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gains</span></code> (in <code class="docutils literal notranslate"><span class="pre">controller_defaults</span></code>)</p></td>
<td><p>(c_{1},\lambda_{1},c_{2},\lambda_{2})</p></td>
<td><p>Gains defining the sliding surfaces: (c_{1}), (c_{2}) scale the velocity terms and (\lambda_{1},\lambda_{2}) the position terms.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">max_force</span></code></p></td>
<td><p>Saturation limit</p></td>
<td><p>Maximum cart force.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">dt</span></code></p></td>
<td><p>(\mathrm{d}t)</p></td>
<td><p>Time step used for updating adaptive gains and the STA integrator.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">k1_init</span></code>, <code class="docutils literal notranslate"><span class="pre">k2_init</span></code></p></td>
<td><p>(k_{1}(0),k_{2}(0))</p></td>
<td><p>Initial values for the adaptive super‑twisting gains.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">gamma1</span></code>, <code class="docutils literal notranslate"><span class="pre">gamma2</span></code></p></td>
<td><p>(\gamma_{1},\gamma_{2})</p></td>
<td><p>Adaptation rates for (k_{1}) and (k_{2}) respectively. Larger values yield faster adaptation but can increase oscillatory behaviour.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">dead_zone</span></code></p></td>
<td><p>(\delta)</p></td>
<td><p>Dead‑zone width preventing gain wind‑up due to noise.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">enable_equivalent</span></code></p></td>
<td><p>–</p></td>
<td><p>If true, includes an equivalent control term computed from the system dynamics.  This option replaces the deprecated <code class="docutils literal notranslate"><span class="pre">use_equivalent</span></code> flag, which is still accepted as an alias.  The equivalent control is <strong>enabled by default</strong> in the revised implementation.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">use_relative_surface</span></code></p></td>
<td><p>–</p></td>
<td><p>When true, defines the sliding surface using relative coordinates (\theta_{2}-\theta_{1}) and (\dot{\theta}<em>{2}-\dot{\theta}</em>{1}).  When false (default), uses absolute angles.  This switch allows users to explore alternative manifold definitions without modifying code.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">k1_max</span></code>, <code class="docutils literal notranslate"><span class="pre">k2_max</span></code></p></td>
<td><p>–</p></td>
<td><p>Maximum allowed values for the adaptive gains (k_{1}) and (k_{2}).  Bounding these gains independently of the actuator limit prevents runaway adaptation and preserves stability【895515998216162†L326-L329】.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">u_int_max</span></code></p></td>
<td><p>–</p></td>
<td><p>Maximum absolute value of the integral term in the super‑twisting algorithm.  Decoupling this bound from <code class="docutils literal notranslate"><span class="pre">max_force</span></code> avoids overly conservative integral clipping and improves robustness.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">damping_gain</span></code></p></td>
<td><p>(k_{\mathrm{d}})</p></td>
<td><p>Linear damping gain applied to the super‑twisting control.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">adapt_rate_limit</span></code></p></td>
<td><p>(\Gamma_{\max})</p></td>
<td><p>Maximum rate of change allowed for the adaptive super‑twisting gains.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sat_soft_width</span></code></p></td>
<td><p>(\delta_{\mathrm{soft}})</p></td>
<td><p>Width of the soft saturation used in the adaptation law to smooth transitions near the dead zone.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cart_gain</span></code></p></td>
<td><p>(k_{c})</p></td>
<td><p>Weight applied to the cart velocity and position in the sliding surface for recentering.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cart_lambda</span></code></p></td>
<td><p>(\lambda_{c})</p></td>
<td><p>Rate applied to the cart position term in the sliding surface.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">cart_p_gain</span></code></p></td>
<td><p>(p_{\mathrm{gain}})</p></td>
<td><p>Proportional gain for the cart recentering term.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">cart_p_lambda</span></code></p></td>
<td><p>(p_{\lambda})</p></td>
<td><p>Derivative gain for the cart recentering term.</p></td>
</tr>
</tbody>
</table>
</div>
<p>These tables enable practitioners to relate the theoretical parameters (gains, boundary layer, adaptation rates) to the YAML file used to configure the controllers.</p>
</section>
</section>
<hr class="docutils" />
<section id="new-section-robustness-and-singularity-handling">
<h2>New Section: Robustness and Singularity Handling<a class="headerlink" href="#new-section-robustness-and-singularity-handling" title="Link to this heading">¶</a></h2>
<p>High‑performance control of the DIP requires careful handling of numerical issues and singularities inherent in the dynamic model. The inertia matrix \M(q)\ can become ill‑conditioned when the pendulum angles approach certain configurations, leading to large rounding errors in its inversion. The implementation addresses these problems as follows:</p>
<ul class="simple">
<li><p><strong>Condition‑number checking:</strong> The <code class="docutils literal notranslate"><span class="pre">_compute_equivalent_control</span></code> method in both <code class="docutils literal notranslate"><span class="pre">classic_smc.py</span></code> and <code class="docutils literal notranslate"><span class="pre">sta_smc.py</span></code> computes the condition number of \M(q)\ (<code class="docutils literal notranslate"><span class="pre">np.linalg.cond</span></code>). If the condition number exceeds a threshold (<code class="docutils literal notranslate"><span class="pre">singularity_cond_threshold</span></code> in <code class="docutils literal notranslate"><span class="pre">config.yaml</span></code>), the method logs a warning and uses a pseudo‑inverse instead of the standard inverse.</p></li>
<li><p><strong>Matrix regularisation:</strong> To prevent singularities due to modelling uncertainties, a small regularisation term (\varepsilon I) is added to \M(q)\ before inversion. This ensures that (M(q)+\varepsilon I) is always invertible, albeit with some approximation error.</p></li>
<li><p><strong>Safe inversion with pseudo‑inverse:</strong> When the matrix is ill‑conditioned, the code uses <code class="docutils literal notranslate"><span class="pre">np.linalg.pinv</span></code>, which computes the Moore–Penrose pseudo‑inverse and yields a least‑squares solution that minimises the effect of noise.</p></li>
<li><p><strong>Regularisation justification:</strong>  Adding a positive constant to the diagonal of a symmetric matrix shifts all of its eigenvalues upward and can convert an indefinite matrix into a positive‑definite one【385796022798831†L145-L149】.  This mathematical result justifies the use of the diagonal regularisation term (\varepsilon I): by perturbing (M(q)) in this way, (M(q)+\varepsilon I) remains invertible even when (M(q)) is nearly singular, though at the cost of a small approximation error.</p></li>
<li><p><strong>Fallback control:</strong> If the pseudo‑inverse computation still fails (for example, if the system becomes uncontrollable), the controller saturates the output to zero and reports failure rather than producing unbounded values. This conservative action prevents destabilisation.</p></li>
</ul>
<p>By systematically checking for singularities and regularising the matrix inversion, the project ensures that the control law remains well‑defined even when the physical system operates near its limits or when the model parameters are uncertain.</p>
</section>
<hr class="docutils" />
<section id="comparative-summary-and-recommendations">
<h2>Comparative Summary and Recommendations<a class="headerlink" href="#comparative-summary-and-recommendations" title="Link to this heading">¶</a></h2>
<p>The four implemented SMC variants offer a spectrum of robustness, smoothness and complexity. <strong>Classic SMC</strong> provides a simple and effective baseline; it achieves finite‑time convergence but suffers from chattering and requires known disturbance bounds. <strong>Super‑twisting SMC</strong> adds a second‑order sliding mechanism that reduces chattering and yields continuous control; it demands tuning of two gains and a higher computational cost. <strong>Adaptive SMC</strong> learns the disturbance bound on‑line, eliminating the need to specify (K) a priori; its continuous control avoids chattering but involves more parameters and possible slower response. <strong>Hybrid adaptive–STA</strong> combines adaptive gain adjustment with the super‑twisting algorithm while relying on a <strong>single sliding surface</strong>.  This unified approach retains the robustness and smoothness of second‑order sliding mode, allows the gains to adapt to unknown disturbances, and simplifies the switching logic compared with earlier dual‑surface designs.  The trade‑off is a larger set of tunable parameters (sliding surface weights, adaptation rates, dead‑zone widths and recentering gains), making careful tuning essential.</p>
<p>For a given DIP application, the choice among these controllers should consider the available actuator bandwidth, desired response speed and tolerance to chattering.  The configuration tables provide a starting point for tuning, and the robust implementation ensures safe operation even under parameter variations and modelling uncertainties.</p>
</section>
<hr class="docutils" />
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading">¶</a></h2>
<p>[1] A. Boubaker, “The inverted pendulum: a fundamental benchmark in control theory and robotics,” <em>International Journal of Automation &amp; Control</em>, vol. 8, no. 2, pp. 94–115, 2014.</p>
<p>[2] I. Irfan, U. Irfan, M. W. Ahmad and A. Saleem, “Control strategies for a double inverted pendulum system,” <em>PLOS ONE</em>, vol. 18, no. 3, p. e0282522, 2023.</p>
<p>[3] H. Dong, M. Zhu and S. Cui, “Integral sliding mode control for nonlinear systems with matched and unmatched perturbations,” <em>IEEE Transactions on Automatic Control</em>, vol. 57, no. 11, pp. 2986–2991, 2012.</p>
<p>[4] S. Saha and S. Banerjee, “Methodologies of chattering attenuation in sliding mode controller,” <em>International Journal of Hybrid Information Technology</em>, vol. 9, no. 2, pp. 221–232, 2016.</p>
<p>[5] A. Parvat, P. G. Kadam and V. R. Prasanna, “Design and implementation of sliding mode controller for level control,” in <em>Proc. Int. Conf. Control, Instrumentation, Energy and Communication</em>, 2013, pp. 71–75.</p>
<p>[6] S. u. Din, A. Hussain, M. F. Iftikhar and M. A. Rahman, “Smooth super‑twisting sliding mode control for the class of underactuated systems,” <em>PLOS ONE</em>, vol. 13, no. 9, p. e0204095, 2018.</p>
<p>[7] R. Roy, “Adaptive sliding mode control without knowledge of uncertainty bounds,” <em>International Journal of Control</em>, vol. 93, no. 12, pp. 3051–3062, 2020.</p>
<p>[8] Y. Sun, Y. Wang and B. Wu, “Adaptive gain sliding mode control for uncertain nonlinear systems using barrier‑like functions,” <em>Nonlinear Dynamics</em>, vol. 99, no. 4, pp. 2775–2787, 2020.</p>
<p>[9] A. Levant and V. Orlov, “Sliding mode manifolds and their design,” in <em>Recent Advances in Sliding Modes: Theory and Applications</em>, IOP Publishing, 2017, ch. 1, pp. 1–31.</p>
<p>[10] S. Li and M. Hibi, “Positive definiteness via off‑diagonal scaling of a symmetric indefinite matrix,” <em>Applied Mathematics and Computation</em>, vol. 371, p. 124959, 2020.</p>
<hr class="docutils" />
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="chattering-mitigation.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Abstract</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="system-modeling.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title"><strong>A Comprehensive Technical Report on the Modeling and Configuration of a Cart‑Based Double Inverted Pendulum System</strong></div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Research Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on Oct 04, 2025</div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Sliding Mode Control for a Double‑Inverted Pendulum: Bridging Theory and Implementation</a><ul>
<li><a class="reference internal" href="#introduction-why-sliding-mode-control">Introduction – Why Sliding Mode Control?</a><ul>
<li><a class="reference internal" href="#structure-of-the-report">Structure of the report</a></li>
</ul>
</li>
<li><a class="reference internal" href="#variant-i-classic-sliding-mode-control-smc">Variant I: Classic Sliding Mode Control (SMC)</a><ul>
<li><a class="reference internal" href="#principles-and-sliding-surface">Principles and sliding surface</a></li>
<li><a class="reference internal" href="#control-law-equivalent-and-switching-parts">Control law: equivalent and switching parts</a><ul>
<li><a class="reference internal" href="#equivalent-control-computation">Equivalent control computation</a></li>
<li><a class="reference internal" href="#boundary-layer-and-saturation">Boundary layer and saturation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#numerical-robustness">Numerical robustness</a></li>
</ul>
</li>
<li><a class="reference internal" href="#variant-ii-supertwisting-algorithm-sta-smc">Variant II: Super‑Twisting Algorithm (STA) SMC</a><ul>
<li><a class="reference internal" href="#theory-and-formulation">Theory and formulation</a></li>
<li><a class="reference internal" href="#lyapunov-stability-and-numerical-verification">Lyapunov stability and numerical verification</a></li>
<li><a class="reference internal" href="#tuning-guidance">Tuning guidance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#variant-iii-adaptive-smc">Variant III: Adaptive SMC</a><ul>
<li><a class="reference internal" href="#adaptation-law-and-dead-zone">Adaptation law and dead zone</a></li>
<li><a class="reference internal" href="#practical-considerations">Practical considerations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#variant-iv-hybrid-adaptivesta-smc">Variant IV: Hybrid Adaptive–STA SMC</a><ul>
<li><a class="reference internal" href="#unified-sliding-surface-and-recentering">Unified sliding surface and recentering</a></li>
<li><a class="reference internal" href="#supertwisting-with-adaptive-gains">Super‑twisting with adaptive gains</a></li>
<li><a class="reference internal" href="#advantages-and-tuning">Advantages and tuning</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-section-controller-configuration-and-config-yaml">New Section: Controller Configuration and <code class="docutils literal notranslate"><span class="pre">config.yaml</span></code></a><ul>
<li><a class="reference internal" href="#classical-smc">Classical SMC</a></li>
<li><a class="reference internal" href="#supertwisting-smc">Super‑Twisting SMC</a></li>
<li><a class="reference internal" href="#adaptive-smc">Adaptive SMC</a></li>
<li><a class="reference internal" href="#hybrid-adaptivesta-smc">Hybrid Adaptive–STA SMC</a></li>
</ul>
</li>
<li><a class="reference internal" href="#new-section-robustness-and-singularity-handling">New Section: Robustness and Singularity Handling</a></li>
<li><a class="reference internal" href="#comparative-summary-and-recommendations">Comparative Summary and Recommendations</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=4ebf8126"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=5fa4622c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=08e7b316"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../_static/back-to-top.js?v=840797bb"></script>
    <script src="../_static/lazy-load.js?v=dc25293c"></script>
    <script src="../_static/dark-mode.js?v=bf328970"></script>
    </body>
</html>