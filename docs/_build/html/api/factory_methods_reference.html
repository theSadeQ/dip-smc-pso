<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
.chartjs-container {
    margin: 1.5em auto;
    padding: 1em;
    background: #f8f9fa;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.chart-note {
    text-align: center;
    color: #6c757d;
    font-size: 0.9em;
    margin-top: 0.5em;
}
</style>
<link rel="index" title="Index" href="../genindex.html"><link rel="search" title="Search" href="../search.html"><link rel="next" title="Optimization Module API Reference Project: Double-Inverted Pendulum SMC Control System" href="optimization_module_api_reference.html"><link rel="prev" title="Factory API Reference ## Controller Factory System - GitHub Issue #6 Implementation ### Overview The Controller Factory System provides a unified, type-safe interface for creating and managing sliding mode control (SMC) controllers in the DIP-SMC-PSO project. This system implements the factory pattern to ensure consistent controller instantiation, parameter validation, and optimization integration. ### Architecture #### Core Components 1. Main Factory (src/controllers/factory.py) - Central controller registry and creation interface - Thread-safe operations with RLock protection - error handling and validation - Legacy compatibility support 2. SMC Factory (src/controllers/factory/smc_factory.py) - Specialized factory for SMC controllers - PSO optimization integration - Type-safe parameter handling 3. Legacy Factory (src/controllers/factory/legacy_factory.py) - Backward compatibility interface - Deprecation handling and migration support ### Supported Controllers | Controller Type | Class | Gains | Description |" href="factory_reference.html">

    <!-- Generated with Sphinx 8.2.3 and Furo 2025.09.25 -->
        <title>Factory Methods API Reference ## Overview This document provides API reference documentation for the Enterprise Controller Factory system. The factory provides thread-safe, type-safe controller instantiation with deep PSO integration and robust error handling. ## Table of Contents 1. Core Factory Functions - DIP_SMC_PSO Documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5349f25f" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=580074bf" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=8dab3a3b" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=8a7e329d" />
    
    


<style>
  body {
    --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">DIP_SMC_PSO Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  <span class="sidebar-brand-text">DIP_SMC_PSO Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">ğŸ“š Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Optimal Sliding Mode Control for a Double-Inverted Pendulum via PSO  ## How to validate a ResearchPlan JSON Run the validator locally: ```bash</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory_overview.html">Theory Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../architecture.html">3. System Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plant_model.html">1.x Plant Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hil_quickstart.html">Hardware-in-the-Loop (HIL) Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../streamlit_dashboard_guide.html">Streamlit Dashboard User Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ğŸ“‹ Project Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../CHANGELOG.html">Changelog All notable changes to the ResearchPlan validation system will be documented in this file. The format is based on Keep a Changelog,</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CONTRIBUTING.html">Contributing â€“ ResearchPlanSpec Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DEPENDENCIES.html">Software Dependencies &amp; Citations <strong>Project:</strong> Double Inverted Pendulum - Sliding Mode Control with PSO Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PATTERNS.html">Software Design Patterns &amp; Architecture Attribution <strong>Project:</strong> Double Inverted Pendulum - Sliding Mode Control with PSO Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PATTERNS.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PATTERNS.html#runnable-false-src-controllers-factory-py-lines-507-543-def-create-controller-controller-type-str-config-optional-any-none-gains-optional-union-list-np-ndarray-none-any-create-a-controller-instance-of-the-specified-type-this-function-is-thread-safe-and-can-be-called-concurrently-supported-types-classical-smc-sta-smc-adaptive-smc-hybrid-adaptive-sta-smc-mpc-controller-normalize-controller-type-handles-aliases-controller-type-canonicalize-controller-type-controller-type-retrieve-from-registry-controller-info-get-controller-info-controller-type-controller-class-controller-info-class-resolve-gains-from-config-defaults-controller-gains-resolve-controller-gains-gains-config-controller-type-validate-gains-with-controller-specific-rules-validate-controller-gains-controller-gains-controller-info-create-and-return-configured-instance-return-controller-class-controller-gains-kwargs">runnable: false # src/controllers/factory.py (lines 507-543) def create_controller(controller_type: str, config: Optional[Any] = None, gains: Optional[Union[list, np.ndarray]] = None) -&gt; Any: â€œâ€â€ Create a controller instance of the specified type. This function is thread-safe and can be called concurrently. Supported types: â€˜classical_smcâ€™, â€˜sta_smcâ€™, â€˜adaptive_smcâ€™, â€˜hybrid_adaptive_sta_smcâ€™, â€˜mpc_controllerâ€™ â€œâ€â€ # Normalize controller type (handles aliases) controller_type = _canonicalize_controller_type(controller_type) # Retrieve from registry controller_info = _get_controller_info(controller_type) controller_class = controller_info[â€˜classâ€™] # Resolve gains from config/defaults controller_gains = _resolve_controller_gains(gains, config, controller_type) # Validate gains with controller-specific rules _validate_controller_gains(controller_gains, controller_info) # Create and return configured instance return controller_class(controller_gains, **kwargs)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PATTERNS.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PATTERNS.html#runnable-false-src-utils-validation-parameter-validators-py-def-validate-gains-n-expected-int-decorator-to-validate-gain-array-length-def-decorator-func-def-wrapper-self-gains-args-kwargs-if-len-gains-n-expected-raise-valueerror-f-expected-n-expected-gains-got-len-gains-return-func-self-gains-args-kwargs-return-wrapper-return-decorator-usage">runnable: false # src/utils/validation/parameter_validators.py def validate_gains(n_expected: int): â€œâ€â€Decorator to validate gain array length.â€â€â€ def decorator(func): def wrapper(self, gains, *args, **kwargs): if len(gains) != n_expected: raise ValueError(fâ€Expected {n_expected} gains, got {len(gains)}â€) return func(self, gains, *args, **kwargs) return wrapper return decorator # Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../context.html">2. Application Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ACADEMIC_INTEGRITY_STATEMENT.html">Academic Integrity Statement <strong>Status:</strong> To be completed in Phase B (Citation System Implementation)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ğŸ“Š API &amp; Technical Reference</span></p>
<ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">API Reference Documentation</a><input aria-label="Toggle navigation of API Reference Documentation" checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="controller_api_reference.html">Controller API Reference &gt; <strong>Note:</strong> Controller API documentation has been consolidated into references. ## Quick Links - <strong><span class="xref myst">Factory System API</span></strong> - Complete factory and controller creation API</a></li>
<li class="toctree-l2"><a class="reference internal" href="controller_theory.html">Controller Theory Reference <strong>Status:</strong> ğŸš§ Under Construction This document will contain controller theory documentation including: ## Planned Content ### Sliding Mode Control Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html">Factory System API Reference <strong>Module:</strong> <code class="docutils literal notranslate"><span class="pre">src.controllers.factory</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#runnable-false-thread-safe-factory-operations-with-timeout-protection">runnable: false # Thread-safe factory operations with timeout protection</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#runnable-false-def-list-available-controllers-list">runnable: false def list_available_controllers() -&gt; list</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#example-return-values">Example return values</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#runnable-false-controller-registry-dict-str-dict-str-any-controller-type-class-controllerclass-controller-class-reference-config-class-configclass-configuration-class-reference-default-gains-list-float-default-gain-vector-gain-count-int-expected-number-of-gains-description-str-human-readable-description-supports-dynamics-bool-whether-controller-uses-dynamics-model-required-params-list-str-required-configuration-parameters">runnable: false CONTROLLER_REGISTRY: Dict[str, Dict[str, Any]] = { â€˜controller_typeâ€™: { â€˜classâ€™: ControllerClass, # Controller class reference â€˜config_classâ€™: ConfigClass, # Configuration class reference â€˜default_gainsâ€™: List[float], # Default gain vector â€˜gain_countâ€™: int, # Expected number of gains â€˜descriptionâ€™: str, # Human-readable description â€˜supports_dynamicsâ€™: bool, # Whether controller uses dynamics model â€˜required_paramsâ€™: List[str] # Required configuration parameters }</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#runnable-false-class-psocontrollerwrapper-wrapper-for-smc-controllers-to-provide-pso-compatible-interface-def-init-self-controller-n-gains-int-controller-type-str-self-controller-controller-self-n-gains-n-gains-self-controller-type-controller-type-self-max-force-getattr-controller-max-force-150-0-self-dynamics-model-getattr-controller-dynamics-model-none-def-validate-gains-self-particles-np-ndarray-np-ndarray-validate-gain-particles-for-pso-optimization-checks-gain-count-finiteness-positivity-and-controller-specific-constraints-def-compute-control-self-state-np-ndarray-np-ndarray-pso-compatible-control-computation-interface-simplified-interface-for-pso-fitness-evaluation">runnable: false class PSOControllerWrapper: â€œâ€â€Wrapper for SMC controllers to provide PSO-compatible interface.â€â€â€ def <strong>init</strong>(self, controller, n_gains: int, controller_type: str): self.controller = controller self.n_gains = n_gains self.controller_type = controller_type self.max_force = getattr(controller, â€˜max_forceâ€™, 150.0) self.dynamics_model = getattr(controller, â€˜dynamics_modelâ€™, None) def validate_gains(self, particles: np.ndarray) -&gt; np.ndarray: â€œâ€â€Validate gain particles for PSO optimization.â€â€â€ # Checks gain count, finiteness, positivity, and controller-specific constraints â€¦ def compute_control(self, state: np.ndarray) -&gt; np.ndarray: â€œâ€â€PSO-compatible control computation interface.â€â€â€ # Simplified interface for PSO fitness evaluation â€¦</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#runnable-false-src-controllers-new-controller-py-import-numpy-as-np">runnable: false # src/controllers/new_controller.py import numpy as np</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#runnable-false-src-controllers-new-controller-config-py-from-dataclasses-import-dataclass">runnable: false # src/controllers/new_controller_config.py from dataclasses import dataclass</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#import-new-controller">Import new controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#add-aliases-for-convenience">Add aliases for convenience</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#runnable-false-add-to-smctype-enum">runnable: false # Add to SMCType enum</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#test-new-controller-py-from-src-controllers-factory-import-create-controller-get-default-gains">test_new_controller.py from src.controllers.factory import create_controller, get_default_gains</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#id7">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#runnable-false">runnable: false â€œâ€â€</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#id8">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_system_api_reference.html#id9">runnable: false â€œâ€â€</a></li>
<li class="toctree-l2"><a class="reference internal" href="factory_reference.html">Factory API Reference ## Controller Factory System - GitHub Issue #6 Implementation ### Overview The Controller Factory System provides a unified, type-safe interface for creating and managing sliding mode control (SMC) controllers in the DIP-SMC-PSO project. This system implements the factory pattern to ensure consistent controller instantiation, parameter validation, and optimization integration. ### Architecture #### Core Components 1. <strong>Main Factory</strong> (<code class="docutils literal notranslate"><span class="pre">src/controllers/factory.py</span></code>) - Central controller registry and creation interface - Thread-safe operations with RLock protection - error handling and validation - Legacy compatibility support 2. <strong>SMC Factory</strong> (<code class="docutils literal notranslate"><span class="pre">src/controllers/factory/smc_factory.py</span></code>) - Specialized factory for SMC controllers - PSO optimization integration - Type-safe parameter handling 3. <strong>Legacy Factory</strong> (<code class="docutils literal notranslate"><span class="pre">src/controllers/factory/legacy_factory.py</span></code>) - Backward compatibility interface - Deprecation handling and migration support ### Supported Controllers | Controller Type | Class | Gains | Description |</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Factory Methods API Reference ## Overview This document provides API reference documentation for the Enterprise Controller Factory system. The factory provides thread-safe, type-safe controller instantiation with deep PSO integration and robust error handling. ## Table of Contents 1. <span class="xref myst">Core Factory Functions</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="#basic-usage-with-default-parameters">Basic usage with default parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="#runnable-false-def-list-available-controllers-list-str">runnable: false def list_available_controllers() -&gt; List[str]</a></li>
<li class="toctree-l2"><a class="reference internal" href="#output-classical-smc-sta-smc-adaptive-smc-hybrid-adaptive-sta-smc">Output: [â€˜classical_smcâ€™, â€˜sta_smcâ€™, â€˜adaptive_smcâ€™, â€˜hybrid_adaptive_sta_smcâ€™]</a></li>
<li class="toctree-l2"><a class="reference internal" href="#note-mpc-controller-only-included-if-optional-dependencies-available">Note: â€˜mpc_controllerâ€™ only included if optional dependencies available</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="#runnable-false-def-get-default-gains-controller-type-str-list-float">runnable: false def get_default_gains(controller_type: str) -&gt; List[float]</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="#runnable-false-get-default-gains-for-different-controllers">runnable: false # Get default gains for different controllers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#output-20-0-15-0-12-0-8-0-35-0-5-0-adaptive-gains-get-default-gains-adaptive-smc">Output: [20.0, 15.0, 12.0, 8.0, 35.0, 5.0] adaptive_gains = get_default_gains(â€˜adaptive_smcâ€™)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#output-25-0-18-0-15-0-10-0-4-0-use-as-starting-point-for-optimization">Output: [25.0, 18.0, 15.0, 10.0, 4.0] # Use as starting point for optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="#runnable-false-create-factory-once-expensive-operation">runnable: false # Create factory once (expensive operation)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="#runnable-false-def-validate-smc-gains-smc-type-smctype-gains-union-list-np-ndarray-bool">runnable: false def validate_smc_gains(smc_type: SMCType, gains: Union[list, np.ndarray]) -&gt; bool</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="#runnable-false-validate-gains-before-expensive-simulation">runnable: false # Validate gains before expensive simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pattern-1-direct-controller-configuration">Pattern 1: Direct controller configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#type-aliases-for-better-type-safety">Type aliases for better type safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="#runnable-false-class-controllerprotocol-protocol-protocol-defining-the-standard-controller-interface-def-compute-control-self-state-statevector-last-control-float-history-configdict-controloutput-compute-control-output-for-given-state-def-reset-self-none-reset-controller-internal-state-property-def-gains-self-list-float-return-controller-gains">runnable: false class ControllerProtocol(Protocol): â€œâ€â€Protocol defining the standard controller interface.â€â€â€ def compute_control( self, state: StateVector, last_control: float, history: ConfigDict ) -&gt; ControlOutput: â€œâ€â€Compute control output for given state.â€â€â€ â€¦ def reset(self) -&gt; None: â€œâ€â€Reset controller internal state.â€â€â€ â€¦ @property def gains(self) -&gt; List[float]: â€œâ€â€Return controller gains.â€â€â€ â€¦</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html">Optimization Module API Reference <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#runnable-false-usr-bin-env-python3">runnable: false #!/usr/bin/env python3</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#configuration">Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#config-path-config-yaml">============================================================================ CONFIG_PATH = â€œconfig.yamlâ€</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#convergence-monitoring-callback">Convergence Monitoring Callback</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#class-convergencemonitor-callback-for-real-time-convergence-monitoring-def-init-self-analyzer-enhancedconvergenceanalyzer-self-analyzer-analyzer-self-metrics-history-def-call-self-iteration-int-best-fitness-float-mean-fitness-float-fitness-std-float-swarm-positions-np-ndarray-check-convergence-at-each-iteration-status-metrics-self-analyzer-check-convergence-iteration-iteration-best-fitness-best-fitness-mean-fitness-mean-fitness-fitness-std-fitness-std-swarm-positions-swarm-positions-self-metrics-history-append-metrics-log-key-metrics-if-iteration-10-0-print-f-iter-iteration-3d-status-status-value-20s-f-best-metrics-best-fitness-6f-f-diversity-metrics-population-diversity-4f-f-conv-velocity-metrics-convergence-velocity-4e-f-predicted-remaining-metrics-predicted-iterations-remaining-3d-early-stopping-if-status-convergencestatus-converged-print-f-n-convergence-detected-at-iteration-iteration-return-true-signal-early-stop-elif-status-convergencestatus-stagnated-print-f-n-stagnation-detected-at-iteration-iteration-return-true-signal-early-stop-return-false-continue">============================================================================ class ConvergenceMonitor: â€œâ€â€Callback for real-time convergence monitoring.â€â€â€ def <strong>init</strong>(self, analyzer: EnhancedConvergenceAnalyzer): self.analyzer = analyzer self.metrics_history = [] def <strong>call</strong>(self, iteration: int, best_fitness: float, mean_fitness: float, fitness_std: float, swarm_positions: np.ndarray): â€œâ€â€Check convergence at each iteration.â€â€â€ status, metrics = self.analyzer.check_convergence( iteration=iteration, best_fitness=best_fitness, mean_fitness=mean_fitness, fitness_std=fitness_std, swarm_positions=swarm_positions ) self.metrics_history.append(metrics) # Log key metrics if iteration % 10 == 0: print(fâ€Iter {iteration:3d} | Status: {status.value:20s} | â€œ fâ€Best: {metrics.best_fitness:.6f} | â€œ fâ€Diversity: {metrics.population_diversity:.4f} | â€œ fâ€Conv. Velocity: {metrics.convergence_velocity:.4e} | â€œ fâ€Predicted Remaining: {metrics.predicted_iterations_remaining:3d}â€) # Early stopping if status == ConvergenceStatus.CONVERGED: print(fâ€\n&gt;&gt;&gt; CONVERGENCE DETECTED at iteration {iteration} &lt;&lt;&lt;â€) return True # Signal early stop elif status == ConvergenceStatus.STAGNATED: print(fâ€\n&gt;&gt;&gt; STAGNATION DETECTED at iteration {iteration} &lt;&lt;&lt;â€) return True # Signal early stop return False # Continue # ============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#main">Main</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#def-main-load-configuration-config-load-config-config-path-initialize-convergence-analyzer-with-custom-criteria-criteria-convergencecriteria-fitness-tolerance-1e-6-relative-improvement-threshold-1e-4-min-diversity-threshold-1e-3-max-stagnation-iterations-50-enable-performance-prediction-true-premature-convergence-detection-true-analyzer-enhancedconvergenceanalyzer-criteria-criteria-controller-type-smctype-sta-monitor-convergencemonitor-analyzer-create-controller-factory-controller-factory-partial-create-controller-controller-type-controller-type-config-config-initialize-pso-tuner-tuner-psotuner-controller-factory-controller-factory-config-config-seed-seed-run-optimization-with-monitoring-print-f-running-pso-optimization-with-real-time-convergence-monitoring-print-f-120-result-tuner-optimise-print-f-120-n-plot-convergence-metrics-metrics-monitor-metrics-history-iterations-m-iteration-for-m-in-metrics-best-fitness-m-best-fitness-for-m-in-metrics-diversity-m-population-diversity-for-m-in-metrics-conv-velocity-m-convergence-velocity-for-m-in-metrics-fig-axes-plt-subplots-3-1-figsize-12-10-best-fitness-axes-0-plot-iterations-best-fitness-linewidth-2-color-blue-axes-0-set-ylabel-best-fitness-fontsize-12-axes-0-set-yscale-log-axes-0-set-title-convergence-monitoring-sta-smc-fontsize-14-fontweight-bold-axes-0-grid-true-alpha-0-3-population-diversity-axes-1-plot-iterations-diversity-linewidth-2-color-green-axes-1-set-ylabel-population-diversity-fontsize-12-axes-1-grid-true-alpha-0-3-convergence-velocity-axes-2-plot-iterations-conv-velocity-linewidth-2-color-red-axes-2-set-ylabel-convergence-velocity-fontsize-12-axes-2-set-xlabel-iteration-fontsize-12-axes-2-grid-true-alpha-0-3-plt-tight-layout-plt-savefig-pso-convergence-monitoring-png-dpi-300-print-convergence-monitoring-plot-saved-pso-convergence-monitoring-png-if-name-main-main">============================================================================ def main(): # Load configuration config = load_config(CONFIG_PATH) # Initialize convergence analyzer with custom criteria criteria = ConvergenceCriteria( fitness_tolerance=1e-6, relative_improvement_threshold=1e-4, min_diversity_threshold=1e-3, max_stagnation_iterations=50, enable_performance_prediction=True, premature_convergence_detection=True ) analyzer = EnhancedConvergenceAnalyzer( criteria=criteria, controller_type=SMCType.STA ) monitor = ConvergenceMonitor(analyzer) # Create controller factory controller_factory = partial( create_controller, controller_type=CONTROLLER_TYPE, config=config ) # Initialize PSO tuner tuner = PSOTuner( controller_factory=controller_factory, config=config, seed=SEED ) # Run optimization with monitoring print(fâ€Running PSO optimization with real-time convergence monitoringâ€¦â€) print(fâ€{â€˜=â€™*120}â€) result = tuner.optimise() print(fâ€{â€˜=â€™*120}\nâ€) # Plot convergence metrics metrics = monitor.metrics_history iterations = [m.iteration for m in metrics] best_fitness = [m.best_fitness for m in metrics] diversity = [m.population_diversity for m in metrics] conv_velocity = [m.convergence_velocity for m in metrics] fig, axes = plt.subplots(3, 1, figsize=(12, 10)) # Best fitness axes[0].plot(iterations, best_fitness, linewidth=2, color=â€™blueâ€™) axes[0].set_ylabel(â€˜Best Fitnessâ€™, fontsize=12) axes[0].set_yscale(â€˜logâ€™) axes[0].set_title(â€˜Convergence Monitoring - STA SMCâ€™, fontsize=14, fontweight=â€™boldâ€™) axes[0].grid(True, alpha=0.3) # Population diversity axes[1].plot(iterations, diversity, linewidth=2, color=â€™greenâ€™) axes[1].set_ylabel(â€˜Population Diversityâ€™, fontsize=12) axes[1].grid(True, alpha=0.3) # Convergence velocity axes[2].plot(iterations, conv_velocity, linewidth=2, color=â€™redâ€™) axes[2].set_ylabel(â€˜Convergence Velocityâ€™, fontsize=12) axes[2].set_xlabel(â€˜Iterationâ€™, fontsize=12) axes[2].grid(True, alpha=0.3) plt.tight_layout() plt.savefig(â€˜pso_convergence_monitoring.pngâ€™, dpi=300) print(â€œConvergence monitoring plot saved: pso_convergence_monitoring.pngâ€) if <strong>name</strong> == â€œ<strong>main</strong>â€: main()</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#expected-output-running-pso-optimization-with-real-time-convergence-monitoring"><code class="docutils literal notranslate"><span class="pre">**Expected</span> <span class="pre">Output:**</span></code>
Running PSO optimization with real-time convergence monitoringâ€¦</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#id2">runnable: false #!/usr/bin/env python3</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#id3">Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#id4">============================================================================ CONFIG_PATH = â€œconfig.yamlâ€</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#id5">Main</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimization_module_api_reference.html#def-main-load-configuration-config-load-config-config-path-initialize-meta-optimizer-print-initializing-pso-hyperparameter-optimizer-meta-optimizer-psohyperparameteroptimizer-config-run-meta-optimization-print-f-nrunning-meta-optimization-for-controller-type-value-print-f-max-evaluations-max-meta-evaluations-print-f-trials-per-evaluation-n-trials-per-eval-print-f-objective-optimizationobjective-multi-objective-value-print-80-result-meta-optimizer-optimize-hyperparameters-controller-type-controller-type-objective-optimizationobjective-multi-objective-max-evaluations-max-meta-evaluations-n-trials-per-evaluation-n-trials-per-eval-display-results-print-n-80-print-hyperparameter-optimization-results-print-80-print-f-noptimized-hyperparameters-print-f-inertia-weight-w-result-hyperparameters-w-6f-print-f-cognitive-c1-result-hyperparameters-c1-6f-print-f-social-c2-result-hyperparameters-c2-6f-print-f-swarm-size-result-hyperparameters-n-particles-print-f-nbaseline-hyperparameters-print-f-inertia-weight-w-result-baseline-hyperparameters-w-6f-print-f-cognitive-c1-result-baseline-hyperparameters-c1-6f-print-f-social-c2-result-baseline-hyperparameters-c2-6f-print-f-swarm-size-result-baseline-hyperparameters-n-particles-print-f-nperformance-improvements-vs-baseline-print-f-convergence-speedup-result-convergence-improvement-2f-x-print-f-quality-improvement-result-quality-improvement100-2f-print-f-robustness-improvement-result-robustness-improvement100-2f-print-f-efficiency-score-result-efficiency-score-4f-print-80-visualize-comparison-fig-axes-plt-subplots-2-2-figsize-12-10-categories-w-c1-c2-n-baseline-values-result-baseline-hyperparameters-w-result-baseline-hyperparameters-c1-result-baseline-hyperparameters-c2-result-baseline-hyperparameters-n-particles-optimized-values-result-hyperparameters-w-result-hyperparameters-c1-result-hyperparameters-c2-result-hyperparameters-n-particles-x-np-arange-len-categories-width-0-35-axes-0-0-bar-x-width-2-baseline-values-width-label-baseline-alpha-0-7-axes-0-0-bar-x-width-2-optimized-values-width-label-optimized-alpha-0-7-axes-0-0-set-ylabel-value-axes-0-0-set-title-hyperparameter-comparison-axes-0-0-set-xticks-x-axes-0-0-set-xticklabels-categories-axes-0-0-legend-axes-0-0-grid-true-alpha-0-3-performance-metrics-metrics-convergence-nspeed-solution-nquality-robustness-improvements-result-convergence-improvement-1-result-quality-improvement-1-result-robustness-improvement-axes-0-1-bar-metrics-improvements-color-blue-green-orange-alpha-0-7-axes-0-1-axhline-y-1-0-color-red-linestyle-label-baseline-axes-0-1-set-ylabel-improvement-factor-axes-0-1-set-title-performance-improvements-axes-0-1-legend-axes-0-1-grid-true-alpha-0-3-convergence-history-if-available-if-hasattr-result-optimization-history-axes-1-0-plot-result-optimization-history-best-objective-linewidth-2-axes-1-0-set-xlabel-meta-optimization-iteration-axes-1-0-set-ylabel-objective-value-axes-1-0-set-title-meta-optimization-convergence-axes-1-0-grid-true-alpha-0-3-hide-unused-subplot-axes-1-1-axis-off-plt-tight-layout-plt-savefig-pso-hyperparameter-optimization-png-dpi-300-print-nvisualization-saved-pso-hyperparameter-optimization-png-if-name-main-main">============================================================================ def main(): # Load configuration config = load_config(CONFIG_PATH) # Initialize meta-optimizer print(â€œInitializing PSO Hyperparameter Optimizerâ€¦â€) meta_optimizer = PSOHyperparameterOptimizer(config) # Run meta-optimization print(fâ€\nRunning meta-optimization for {CONTROLLER_TYPE.value}â€¦â€) print(fâ€Max evaluations: {MAX_META_EVALUATIONS}â€) print(fâ€Trials per evaluation: {N_TRIALS_PER_EVAL}â€) print(fâ€Objective: {OptimizationObjective.MULTI_OBJECTIVE.value}â€) print(â€œ=â€*80) result = meta_optimizer.optimize_hyperparameters( controller_type=CONTROLLER_TYPE, objective=OptimizationObjective.MULTI_OBJECTIVE, max_evaluations=MAX_META_EVALUATIONS, n_trials_per_evaluation=N_TRIALS_PER_EVAL ) # Display results print(â€œ\nâ€ + â€œ=â€<em>80) print(â€œHYPERPARAMETER OPTIMIZATION RESULTSâ€) print(â€œ=â€<em>80) print(fâ€\nOptimized Hyperparameters:â€) print(fâ€ Inertia weight (w): {result.hyperparameters.w:.6f}â€) print(fâ€ Cognitive (c1): {result.hyperparameters.c1:.6f}â€) print(fâ€ Social (c2): {result.hyperparameters.c2:.6f}â€) print(fâ€ Swarm size: {result.hyperparameters.n_particles}â€) print(fâ€\nBaseline Hyperparameters:â€) print(fâ€ Inertia weight (w): {result.baseline_hyperparameters.w:.6f}â€) print(fâ€ Cognitive (c1): {result.baseline_hyperparameters.c1:.6f}â€) print(fâ€ Social (c2): {result.baseline_hyperparameters.c2:.6f}â€) print(fâ€ Swarm size: {result.baseline_hyperparameters.n_particles}â€) print(fâ€\nPerformance Improvements vs. Baseline:â€) print(fâ€ Convergence speedup: {result.convergence_improvement:.2f}xâ€) print(fâ€ Quality improvement: {result.quality_improvement</em>100:.2f}%â€) print(fâ€ Robustness improvement: {result.robustness_improvement</em>100:.2f}%â€) print(fâ€ Efficiency score: {result.efficiency_score:.4f}â€) print(â€œ=â€*80) # Visualize comparison fig, axes = plt.subplots(2, 2, figsize=(12, 10)) categories = [â€˜wâ€™, â€˜c1â€™, â€˜c2â€™, â€˜Nâ€™] baseline_values = [ result.baseline_hyperparameters.w, result.baseline_hyperparameters.c1, result.baseline_hyperparameters.c2, result.baseline_hyperparameters.n_particles ] optimized_values = [ result.hyperparameters.w, result.hyperparameters.c1, result.hyperparameters.c2, result.hyperparameters.n_particles ] x = np.arange(len(categories)) width = 0.35 axes[0, 0].bar(x - width/2, baseline_values, width, label=â€™Baselineâ€™, alpha=0.7) axes[0, 0].bar(x + width/2, optimized_values, width, label=â€™Optimizedâ€™, alpha=0.7) axes[0, 0].set_ylabel(â€˜Valueâ€™) axes[0, 0].set_title(â€˜Hyperparameter Comparisonâ€™) axes[0, 0].set_xticks(x) axes[0, 0].set_xticklabels(categories) axes[0, 0].legend() axes[0, 0].grid(True, alpha=0.3) # Performance metrics metrics = [â€˜Convergence\nSpeedâ€™, â€˜Solution\nQualityâ€™, â€˜Robustnessâ€™] improvements = [ result.convergence_improvement, 1 + result.quality_improvement, 1 + result.robustness_improvement ] axes[0, 1].bar(metrics, improvements, color=[â€˜blueâ€™, â€˜greenâ€™, â€˜orangeâ€™], alpha=0.7) axes[0, 1].axhline(y=1.0, color=â€™redâ€™, linestyle=â€™â€“â€™, label=â€™Baselineâ€™) axes[0, 1].set_ylabel(â€˜Improvement Factorâ€™) axes[0, 1].set_title(â€˜Performance Improvementsâ€™) axes[0, 1].legend() axes[0, 1].grid(True, alpha=0.3) # Convergence history (if available) if hasattr(result, â€˜optimization_historyâ€™): axes[1, 0].plot(result.optimization_history[â€˜best_objectiveâ€™], linewidth=2) axes[1, 0].set_xlabel(â€˜Meta-Optimization Iterationâ€™) axes[1, 0].set_ylabel(â€˜Objective Valueâ€™) axes[1, 0].set_title(â€˜Meta-Optimization Convergenceâ€™) axes[1, 0].grid(True, alpha=0.3) # Hide unused subplot axes[1, 1].axis(â€˜offâ€™) plt.tight_layout() plt.savefig(â€˜pso_hyperparameter_optimization.pngâ€™, dpi=300) print(â€œ\nVisualization saved: pso_hyperparameter_optimization.pngâ€) if <strong>name</strong> == â€œ<strong>main</strong>â€: main()</a></li>
<li class="toctree-l2"><a class="reference internal" href="pso_optimization.html">PSO Optimization Guide <strong>Status:</strong> ğŸš§ Under Construction This document will contain PSO optimization documentation including: ## Planned Content ### PSO Algorithm Fundamentals</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html">Simulation Engine API Reference <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html#runnable-false-class-dynamicsmodel-protocol-protocol-for-plant-dynamics-models-def-compute-dynamics-self-state-np-ndarray-control-input-np-ndarray-time-float-0-0-kwargs-any-dynamicsresult-compute-system-dynamics-at-given-state-and-input-def-get-physics-matrices-self-state-np-ndarray-tuple-np-ndarray-np-ndarray-np-ndarray-get-physics-matrices-m-c-g-at-current-state-def-validate-state-self-state-np-ndarray-bool-validate-state-vector-format-and-bounds-def-get-state-dimension-self-int-get-dimension-of-state-vector-def-get-control-dimension-self-int-get-dimension-of-control-input-vector">runnable: false class DynamicsModel(Protocol): â€œâ€â€Protocol for plant dynamics models.â€â€â€ def compute_dynamics( self, state: np.ndarray, control_input: np.ndarray, time: float = 0.0, **kwargs: Any ) -&gt; DynamicsResult: â€œâ€â€Compute system dynamics at given state and input.â€â€â€ â€¦ def get_physics_matrices( self, state: np.ndarray ) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]: â€œâ€â€Get physics matrices M, C, G at current state.â€â€â€ â€¦ def validate_state(self, state: np.ndarray) -&gt; bool: â€œâ€â€Validate state vector format and bounds.â€â€â€ â€¦ def get_state_dimension(self) -&gt; int: â€œâ€â€Get dimension of state vector.â€â€â€ â€¦ def get_control_dimension(self) -&gt; int: â€œâ€â€Get dimension of control input vector.â€â€â€ â€¦</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html#runnable-false-abstractmethod">runnable: false @abstractmethod</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html#runnable-false-class-orchestrator-abc-base-interface-for-simulation-execution-strategies-abstractmethod-def-execute-self-initial-state-np-ndarray-control-inputs-np-ndarray-dt-float-horizon-int-kwargs-resultcontainer-execute-simulation-with-specified-strategy-pass">runnable: false class Orchestrator(ABC): â€œâ€â€Base interface for simulation execution strategies.â€â€â€ @abstractmethod def execute( self, initial_state: np.ndarray, control_inputs: np.ndarray, dt: float, horizon: int, **kwargs ) -&gt; ResultContainer: â€œâ€â€Execute simulation with specified strategy.â€â€â€ pass</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html#runnable-false-class-batchorchestrator-baseorchestrator-batch-simulation-orchestrator-for-vectorized-execution-def-execute-self-initial-state-np-ndarray-control-inputs-np-ndarray-dt-float-horizon-int-kwargs-resultcontainer-execute-batch-simulation">runnable: false class BatchOrchestrator(BaseOrchestrator): â€œâ€â€Batch simulation orchestrator for vectorized execution.â€â€â€ def execute( self, initial_state: np.ndarray, control_inputs: np.ndarray, dt: float, horizon: int, **kwargs ) -&gt; ResultContainer: â€œâ€â€Execute batch simulation.â€â€â€</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html#step-1-load-configuration">STEP 1: Load Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html#id4">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html#step-2-create-controller">STEP 2: Create Controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html#id5">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html#step-3-create-dynamics-model">STEP 3: Create Dynamics Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html#id6">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html#step-4-run-simulation">STEP 4: Run Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html#id7">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html#step-5-analyze-results">STEP 5: Analyze Results</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html#id8">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html#step-6-plot-results">STEP 6: Plot Results</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation_engine_api_reference.html#id9">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="performance_benchmarks.html">Performance Benchmarks Reference <strong>Status:</strong> ğŸš§ Under Construction This document will contain performance benchmarking documentation including: ## Planned Content ### Benchmark Methodology</a></li>
<li class="toctree-l2"><a class="reference internal" href="configuration_schema.html">Configuration Schema Reference <strong>Status:</strong> ğŸš§ Under Construction This document will contain configuration schema documentation including: ## Planned Content ### YAML Configuration Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_1_completion_report.html">Phase 4.1 Controller API Documentation Completion Report <strong>Date:</strong> 2025-10-07</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_1_completion_report.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_1_completion_report.html#runnable-false">runnable: false</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_1_completion_report.html#examples-section">Examples section</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_2_completion_report.html">Phase 4.2 Completion Report: Factory System API Documentation <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_2_completion_report.html#tests-test-factory-examples-py-import-pytest">tests/test_factory_examples.py import pytest</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_3_progress_report.html">Phase 4.3 Progress Report: Optimization Module API Documentation <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_3_progress_report.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_3_progress_report.html#runnable-false-def-optimize-bounds-for-controller-self-controller-type-smctype-strategy-boundsoptimizationstrategy-boundsoptimizationstrategy-hybrid-max-optimization-time-float-300-0">runnable: false def optimize_bounds_for_controller( self, controller_type: SMCType, strategy: BoundsOptimizationStrategy = BoundsOptimizationStrategy.HYBRID, max_optimization_time: float = 300.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_3_completion_report.html">Phase 4.3 Completion Report: Optimization Module API Documentation <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
<li class="toctree-l2"><a class="reference internal" href="phase_4_4_completion_report.html">Phase 4.4 Completion Report: Simulation Engine API Documentation <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../technical/index.html">Technical Documentation</a><input aria-label="Toggle navigation of Technical Documentation" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../technical/configuration_schema_reference.html">Configuration Schema Reference - Factory Integration ## Complete Configuration Schema Documentation for All Controller Types <strong>Document Version:</strong> 2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/configuration_schema_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/configuration_schema_reference.html#runnable-false-dataclass-frozen-true">runnable: false @dataclass(frozen=True)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/configuration_schema_reference.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/configuration_schema_reference.html#id2">runnable: false @dataclass(frozen=True)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/configuration_schema_reference.html#controller-default-gains">Controller default gains</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/controller_factory_integration.html">Controller Factory Integration Technical Documentation ## Overview This document provides technical documentation for the controller factory pattern implementation in the double-inverted pendulum sliding mode control (DIP-SMC) system. The factory pattern serves as the primary instantiation mechanism for all SMC variants, ensuring consistent interfaces, robust error handling, and integration with optimization algorithms. ## Table of Contents 1. <span class="xref myst">Factory Pattern Architecture</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/controller_factory_integration.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/controller_factory_integration.html#runnable-false-controller-registry-classical-smc-class-modularclassicalsmc-config-class-classicalsmcconfig-default-gains-5-0-5-0-5-0-0-5-0-5-0-5-sta-smc-class-modularsupertwistingsmc-config-class-stasmcconfig-default-gains-5-0-3-0-4-0-4-0-0-4-0-4-adaptive-smc-class-modularadaptivesmc-config-class-adaptivesmcconfig-default-gains-10-0-8-0-5-0-4-0-1-0-hybrid-adaptive-sta-smc-class-modularhybridsmc-config-class-hybridadaptivestasmcconfig-default-gains-5-0-5-0-5-0-0-5">runnable: false CONTROLLER_REGISTRY = { â€˜classical_smcâ€™: { â€˜classâ€™: ModularClassicalSMC, â€˜config_classâ€™: ClassicalSMCConfig, â€˜default_gainsâ€™: [5.0, 5.0, 5.0, 0.5, 0.5, 0.5] }, â€˜sta_smcâ€™: { â€˜classâ€™: ModularSuperTwistingSMC, â€˜config_classâ€™: STASMCConfig, â€˜default_gainsâ€™: [5.0, 3.0, 4.0, 4.0, 0.4, 0.4] }, â€˜adaptive_smcâ€™: { â€˜classâ€™: ModularAdaptiveSMC, â€˜config_classâ€™: AdaptiveSMCConfig, â€˜default_gainsâ€™: [10.0, 8.0, 5.0, 4.0, 1.0] }, â€˜hybrid_adaptive_sta_smcâ€™: { â€˜classâ€™: ModularHybridSMC, â€˜config_classâ€™: HybridAdaptiveSTASMCConfig, â€˜default_gainsâ€™: [5.0, 5.0, 5.0, 0.5] }</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/controller_factory_integration.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/controller_factory_integration.html#runnable-false-alias-map-classic-smc-classical-smc-smc-classical-classical-smc-smc-v1-classical-smc-super-twisting-sta-smc-sta-sta-smc-adaptive-adaptive-smc-hybrid-hybrid-adaptive-sta-smc-hybrid-sta-hybrid-adaptive-sta-smc">runnable: false ALIAS_MAP = { â€˜classic_smcâ€™: â€˜classical_smcâ€™, â€˜smc_classicalâ€™: â€˜classical_smcâ€™, â€˜smc_v1â€™: â€˜classical_smcâ€™, â€˜super_twistingâ€™: â€˜sta_smcâ€™, â€˜staâ€™: â€˜sta_smcâ€™, â€˜adaptiveâ€™: â€˜adaptive_smcâ€™, â€˜hybridâ€™: â€˜hybrid_adaptive_sta_smcâ€™, â€˜hybrid_staâ€™: â€˜hybrid_adaptive_sta_smcâ€™,</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/controller_factory_integration.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/controller_factory_integration.html#runnable-false-def-validate-inputs-controller-type-config-gains-validate-factory-inputs-before-processing-controller-type-validation-if-not-isinstance-controller-type-str-raise-typeerror-controller-type-must-be-string-gains-validation-if-gains-is-not-none-if-not-isinstance-gains-list-np-ndarray-raise-typeerror-gains-must-be-list-or-numpy-array-if-not-all-isinstance-g-int-float-for-g-in-gains-raise-valueerror-gains-must-contain-numeric-values-if-any-not-np-isfinite-g-for-g-in-gains-raise-valueerror-gains-contain-nan-or-infinite-values">runnable: false def validate_inputs(controller_type, config, gains): â€œâ€â€Validate factory inputs before processing.â€â€â€ # Controller type validation if not isinstance(controller_type, str): raise TypeError(â€œcontroller_type must be stringâ€) # Gains validation if gains is not None: if not isinstance(gains, (list, np.ndarray)): raise TypeError(â€œgains must be list or numpy arrayâ€) if not all(isinstance(g, (int, float)) for g in gains): raise ValueError(â€œgains must contain numeric valuesâ€) if any(not np.isfinite(g) for g in gains): raise ValueError(â€œgains contain NaN or infinite valuesâ€)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/controller_factory_integration.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/controller_factory_integration.html#runnable-false-def-create-fallback-configuration-controller-type-gains-create-minimal-working-configuration-when-full-config-fails-fallback-params-gains-gains-max-force-150-0-safe-default-dt-0-001-standard-timestep-add-controller-specific-required-parameters-if-controller-type-classical-smc-fallback-params-boundary-layer-0-02-elif-controller-type-sta-smc-fallback-params-k1-4-0-fallback-params-k2-0-4-return-controller-info-config-class">runnable: false def create_fallback_configuration(controller_type, gains): â€œâ€â€Create minimal working configuration when full config fails.â€â€â€ fallback_params = { â€˜gainsâ€™: gains, â€˜max_forceâ€™: 150.0, # Safe default â€˜dtâ€™: 0.001, # Standard timestep } # Add controller-specific required parameters if controller_type == â€˜classical_smcâ€™: fallback_params[â€˜boundary_layerâ€™] = 0.02 elif controller_type == â€˜sta_smcâ€™: fallback_params[â€˜K1â€™] = 4.0 fallback_params[â€˜K2â€™] = 0.4 return controller_info<span class="xref myst">â€™config_classâ€™</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/controller_factory_integration.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/controller_factory_integration.html#runnable-false-def-safe-controller-creation-controller-class-config-create-controller-with-error-recovery-try-return-controller-class-config-except-exception-as-e-logger-error-f-controller-instantiation-failed-e-try-with-minimal-configuration-minimal-config-create-minimal-config-config-try-return-controller-class-minimal-config-except-exception-as-e2-logger-error-f-minimal-controller-creation-failed-e2-raise-factoryerror-f-cannot-create-controller-e-e2">runnable: false def safe_controller_creation(controller_class, config): â€œâ€â€Create controller with error recovery.â€â€â€ try: return controller_class(config) except Exception as e: logger.error(fâ€Controller instantiation failed: {e}â€) # Try with minimal configuration minimal_config = create_minimal_config(config) try: return controller_class(minimal_config) except Exception as e2: logger.error(fâ€Minimal controller creation failed: {e2}â€) raise FactoryError(fâ€Cannot create controller: {e}, {e2}â€)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/controller_factory_integration.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/controller_factory_integration.html#runnable-false-class-factoryerror-exception-base-factory-error-pass-class-configurationerror-factoryerror-configuration-validation-error-pass-class-controllertypeerror-factoryerror-unknown-controller-type-error-pass-class-gainvalidationerror-factoryerror-gain-validation-error-pass">runnable: false class FactoryError(Exception): â€œâ€â€Base factory error.â€â€â€ pass class ConfigurationError(FactoryError): â€œâ€â€Configuration validation error.â€â€â€ pass class ControllerTypeError(FactoryError): â€œâ€â€Unknown controller type error.â€â€â€ pass class GainValidationError(FactoryError): â€œâ€â€Gain validation error.â€â€â€ pass</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/controller_factory_integration.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/controller_factory_integration.html#runnable-false-class-controllerpool-memory-efficient-controller-instance-pool-def-init-self-max-instances-int-100-self-pool-self-usage-count-self-max-instances-max-instances-def-get-controller-self-controller-type-str-config-hash-str-get-controller-from-pool-or-create-new-one-key-f-controller-type-config-hash-if-key-in-self-pool-self-usage-count-key-1-return-self-pool-key-if-len-self-pool-self-max-instances-self-evict-least-used-controller-create-controller-controller-type-config-self-pool-key-controller-self-usage-count-key-1-return-controller">runnable: false class ControllerPool: â€œâ€â€Memory-efficient controller instance pool.â€â€â€ def <strong>init</strong>(self, max_instances: int = 100): self._pool = {} self._usage_count = {} self.<em>max_instances = max_instances def get_controller(self, controller_type: str, config_hash: str): â€œâ€â€Get controller from pool or create new one.â€â€â€ key = fâ€{controller_type}</em>{config_hash}â€ if key in self._pool: self._usage_count[key] += 1 return self._pool[key] if len(self._pool) &gt;= self._max_instances: self._evict_least_used() controller = create_controller(controller_type, config) self._pool[key] = controller self._usage_count[key] = 1 return controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/controller_factory_integration.html#id7">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/controller_factory_integration.html#runnable-false-def-benchmark-factory-performance-benchmark-factory-instantiation-performance-controller-types-classical-smc-sta-smc-adaptive-smc-results-for-controller-type-in-controller-types-times-for-in-range-100-start-time-perf-counter-controller-create-controller-controller-type-end-time-perf-counter-times-append-end-start-results-controller-type-mean-np-mean-times-std-np-std-times-max-np-max-times-p95-np-percentile-times-95-return-results">runnable: false def benchmark_factory_performance(): â€œâ€â€Benchmark factory instantiation performance.â€â€â€ controller_types = [â€˜classical_smcâ€™, â€˜sta_smcâ€™, â€˜adaptive_smcâ€™] results = {} for controller_type in controller_types: times = [] for _ in range(100): start = time.perf_counter() controller = create_controller(controller_type) end = time.perf_counter() times.append(end - start) results[controller_type] = { â€˜meanâ€™: np.mean(times), â€˜stdâ€™: np.std(times), â€˜maxâ€™: np.max(times), â€˜p95â€™: np.percentile(times, 95) } return results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/factory_integration_fixes_issue6.html">Factory Integration Fixes - GitHub Issue #6 ## Documentation for Resolved Factory Pattern Implementation <strong>Issue Resolution Date:</strong> November 2024</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/factory_integration_fixes_issue6.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/factory_integration_fixes_issue6.html#runnable-false-dataclass-frozen-true">runnable: false @dataclass(frozen=True)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/factory_integration_fixes_issue6.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/factory_integration_fixes_issue6.html#runnable-false-def-optimize-controller-comprehensive-complete-pso-optimization-workflow-example-step-1-configuration-pso-config-psofactoryconfig-controller-type-controllertype-sta-smc-population-size-25-max-iterations-100-convergence-threshold-1e-5-fitness-timeout-15-0-step-2-create-pso-factory-pso-factory-enhancedpsofactory-pso-config-step-3-run-optimization-optimization-result-pso-factory-optimize-controller-if-optimization-result-success-step-4-extract-results-best-gains-optimization-result-best-gains-best-cost-optimization-result-best-cost-optimized-controller-optimization-result-controller-step-5-performance-analysis-perf-analysis-optimization-result-performance-analysis-validation-results-optimization-result-validation-results-print-f-optimization-successful-print-f-best-gains-best-gains-print-f-best-cost-best-cost-6f-print-f-converged-perf-analysis-converged-return-optimized-controller-optimization-result-else-print-f-optimization-failed-optimization-result-error-return-none-optimization-result">runnable: false def optimize_controller_comprehensive(): â€œâ€â€Complete PSO optimization workflow example.â€â€â€ # Step 1: Configuration pso_config = PSOFactoryConfig( controller_type=ControllerType.STA_SMC, population_size=25, max_iterations=100, convergence_threshold=1e-5, fitness_timeout=15.0 ) # Step 2: Create PSO factory pso_factory = EnhancedPSOFactory(pso_config) # Step 3: Run optimization optimization_result = pso_factory.optimize_controller() if optimization_result[â€˜successâ€™]: # Step 4: Extract results best_gains = optimization_result[â€˜best_gainsâ€™] best_cost = optimization_result[â€˜best_costâ€™] optimized_controller = optimization_result[â€˜controllerâ€™] # Step 5: Performance analysis perf_analysis = optimization_result[â€˜performance_analysisâ€™] validation_results = optimization_result[â€˜validation_resultsâ€™] print(fâ€Optimization successful!â€) print(fâ€Best gains: {best_gains}â€) print(fâ€Best cost: {best_cost:.6f}â€) print(fâ€Converged: {perf_analysis[â€˜convergedâ€™]}â€) return optimized_controller, optimization_result else: print(fâ€Optimization failed: {optimization_result[â€˜errorâ€™]}â€) return None, optimization_result</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/factory_integration_fixes_issue6.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/factory_integration_fixes_issue6.html#runnable-false-automatic-test-scenarios-in-fitness-evaluation">runnable: false # Automatic test scenarios in fitness evaluation:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/factory_integration_fixes_issue6.html#classical-smc-bounds">Classical SMC bounds:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/factory_integration_fixes_issue6.html#lower-1-0-1-0-1-0-1-0-5-0-0-1">Lower: [1.0, 1.0, 1.0, 1.0, 5.0, 0.1]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/factory_integration_fixes_issue6.html#upper-30-0-30-0-20-0-20-0-50-0-10-0">Upper: [30.0, 30.0, 20.0, 20.0, 50.0, 10.0]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/factory_usage_examples.html">Factory Usage Examples - Guide ## Advanced Controller Factory Usage Patterns This document provides practical examples for using the enhanced controller factory system after the GitHub Issue #6 resolution.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/factory_usage_examples.html#multiple-ways-to-create-the-same-controller">Multiple ways to create the same controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/factory_usage_examples.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/factory_usage_examples.html#runnable-false-enhanced-pso-configuration-with-robust-evaluation">runnable: false # Enhanced PSO configuration with robust evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/integration_protocols.html">Integration Protocols and Cross-Domain Specifications ## Overview This document defines the integration protocols and cross-domain specifications for the controller factory within the double-inverted pendulum sliding mode control (DIP-SMC) ecosystem. These protocols ensure communication and data exchange between controllers, plant models, optimization algorithms, simulation engines, and hardware-in-the-loop (HIL) systems. ## Table of Contents 1. <span class="xref myst">System Architecture Overview</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/integration_protocols.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/integration_protocols.html#runnable-false-class-psofactoryintegration-pso-factory-integration-layer-def-init-self-controller-type-str-plant-model-config-dict-self-controller-type-controller-type-self-plant-config-plant-model-config-self-gain-bounds-self-get-theoretical-bounds-def-create-optimization-objective-self-performance-metrics-list-str-weights-optional-list-float-none-callable-create-pso-optimization-objective-function-def-objective-function-gains-np-ndarray-float-try-create-controller-with-proposed-gains-controller-create-controller-self-controller-type-gains-gains-tolist-create-plant-model-plant-model-plantmodelregistry-create-model-simplified-dip-self-plant-config-create-bridge-bridge-controllerplantbridge-controller-plant-model-run-simulation-performance-self-evaluate-performance-bridge-performance-metrics-compute-weighted-cost-if-weights-is-none-weights-1-0-len-performance-metrics-total-cost-sum-w-p-for-w-p-in-zip-weights-performance-return-total-cost-except-exception-as-e-return-high-cost-for-invalid-configurations-return-1e6-return-objective-function-def-evaluate-performance-self-bridge-controllerplantbridge-metrics-list-str-list-float-evaluate-controller-performance-metrics-standard-test-scenario-initial-state-np-array-0-1-0-05-0-0-0-0-0-0-0-0-small-perturbation-dt-0-001-t-final-10-0-steps-int-t-final-dt-simulation-state-initial-state-copy-states-state-copy-controls-for-in-range-steps-state-metadata-bridge-step-state-dt-states-append-state-copy-controls-append-metadata-control-value-states-np-array-states-controls-np-array-controls-compute-metrics-results-for-metric-in-metrics-if-metric-settling-time-results-append-self-compute-settling-time-states-dt-elif-metric-overshoot-results-append-self-compute-overshoot-states-elif-metric-control-effort-results-append-self-compute-control-effort-controls-elif-metric-steady-state-error-results-append-self-compute-steady-state-error-states-else-raise-valueerror-f-unknown-metric-metric-return-results-def-get-theoretical-bounds-self-tuple-list-float-list-float-get-theoretical-bounds-for-optimization-return-get-gain-bounds-for-pso-smctype-self-controller-type">runnable: false class PSOFactoryIntegration: â€œâ€â€PSO-Factory integration layer.â€â€â€ def <strong>init</strong>(self, controller_type: str, plant_model_config: dict): self.controller_type = controller_type self.plant_config = plant_model_config self.gain_bounds = self._get_theoretical_bounds() def create_optimization_objective( self, performance_metrics: List[str], weights: Optional[List[float]] = None ) -&gt; Callable: â€œâ€â€Create PSO optimization objective function.â€â€â€ def objective_function(gains: np.ndarray) -&gt; float: try: # Create controller with proposed gains controller = create_controller( self.controller_type, gains=gains.tolist() ) # Create plant model plant_model = PlantModelRegistry.create_model( â€˜simplified_dipâ€™, self.plant_config ) # Create bridge bridge = ControllerPlantBridge(controller, plant_model) # Run simulation performance = self._evaluate_performance( bridge, performance_metrics ) # Compute weighted cost if weights is None: weights = [1.0] * len(performance_metrics) total_cost = sum(w * p for w, p in zip(weights, performance)) return total_cost except Exception as e: # Return high cost for invalid configurations return 1e6 return objective_function def _evaluate_performance( self, bridge: ControllerPlantBridge, metrics: List[str] ) -&gt; List[float]: â€œâ€â€Evaluate controller performance metrics.â€â€â€ # Standard test scenario initial_state = np.array([0.1, 0.05, 0.0, 0.0, 0.0, 0.0]) # Small perturbation dt = 0.001 t_final = 10.0 steps = int(t_final / dt) # Simulation state = initial_state.copy() states = [state.copy()] controls = [] for _ in range(steps): state, metadata = bridge.step(state, dt) states.append(state.copy()) controls.append(metadata[â€˜control_valueâ€™]) states = np.array(states) controls = np.array(controls) # Compute metrics results = [] for metric in metrics: if metric == â€˜settling_timeâ€™: results.append(self._compute_settling_time(states, dt)) elif metric == â€˜overshootâ€™: results.append(self._compute_overshoot(states)) elif metric == â€˜control_effortâ€™: results.append(self._compute_control_effort(controls)) elif metric == â€˜steady_state_errorâ€™: results.append(self._compute_steady_state_error(states)) else: raise ValueError(fâ€Unknown metric: {metric}â€) return results def _get_theoretical_bounds(self) -&gt; Tuple[List[float], List[float]]: â€œâ€â€Get theoretical bounds for optimization.â€â€â€ return get_gain_bounds_for_pso(SMCType(self.controller_type))</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/integration_protocols.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/integration_protocols.html#runnable-false-class-multiobjectivepsointegration-multi-objective-pso-integration-for-controller-optimization-def-init-self-controller-type-str-objectives-list-str-self-controller-type-controller-type-self-objectives-objectives-def-create-pareto-optimizer-self-callable-create-pareto-optimal-pso-optimizer-def-pareto-objective-gains-np-ndarray-list-float-multi-objective-function-returning-pareto-front-controller-create-controller-self-controller-type-gains-gains-tolist-objectives-values-for-obj-in-self-objectives-value-self-evaluate-single-objective-controller-obj-objectives-values-append-value-return-objectives-values-return-pareto-objective-def-evaluate-single-objective-self-controller-objective-str-float-evaluate-a-single-objective-function-implementation-specific-to-each-objective-pass">runnable: false class MultiObjectivePSOIntegration: â€œâ€â€Multi-objective PSO integration for controller optimization.â€â€â€ def <strong>init</strong>(self, controller_type: str, objectives: List[str]): self.controller_type = controller_type self.objectives = objectives def create_pareto_optimizer(self) -&gt; Callable: â€œâ€â€Create Pareto-optimal PSO optimizer.â€â€â€ def pareto_objective(gains: np.ndarray) -&gt; List[float]: â€œâ€â€Multi-objective function returning Pareto front.â€â€â€ controller = create_controller(self.controller_type, gains=gains.tolist()) objectives_values = [] for obj in self.objectives: value = self._evaluate_single_objective(controller, obj) objectives_values.append(value) return objectives_values return pareto_objective def _evaluate_single_objective(self, controller, objective: str) -&gt; float: â€œâ€â€Evaluate a single objective function.â€â€â€ # Implementation specific to each objective pass</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/integration_protocols.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/integration_protocols.html#runnable-false-class-hilintegrationprotocol-hardware-in-the-loop-integration-protocol-def-init-self-controller-factory-communication-config-dict-self-factory-controller-factory-self-comm-config-communication-config-self-safety-limits-self-get-safety-limits-def-create-hil-controller-self-controller-type-str-gains-list-float-safety-config-dict-hilcontroller-create-hil-compatible-controller-with-safety-features-create-base-controller-base-controller-create-controller-controller-type-gains-gains-wrap-with-hil-safety-layer-hil-controller-hilsafetywrapper-base-controller-safety-config-self-safety-limits-return-hil-controller-def-get-safety-limits-self-dict-get-hardware-safety-limits-return-max-force-50-0-reduced-for-hardware-safety-max-angle-np-pi-6-30-degrees-maximum-max-velocity-10-0-rad-s-emergency-stop-conditions-angle-limit-exceeded-velocity-limit-exceeded-communication-failure-class-hilsafetywrapper-safety-wrapper-for-hil-controllers-def-init-self-controller-safety-config-dict-limits-dict-self-controller-controller-self-safety-config-safety-config-self-limits-limits-self-emergency-stop-false-def-compute-control-self-state-np-ndarray-args-kwargs-float-compute-control-with-safety-checks-pre-control-safety-checks-if-self-check-emergency-conditions-state-self-emergency-stop-true-return-0-0-emergency-stop-if-self-emergency-stop-return-0-0-maintain-emergency-stop-compute-control-try-control-result-self-controller-compute-control-state-args-kwargs-u-control-result-u-if-hasattr-control-result-u-else-control-result-post-control-safety-checks-u-safe-self-apply-safety-limits-u-state-return-u-safe-except-exception-as-e-logger-error-f-hil-control-computation-failed-e-self-emergency-stop-true-return-0-0-def-check-emergency-conditions-self-state-np-ndarray-bool-check-for-emergency-stop-conditions-theta1-theta2-x-dtheta1-dtheta2-dx-state-angle-limits-if-abs-theta1-self-limits-max-angle-logger-warning-pendulum-1-angle-limit-exceeded-return-true-if-abs-theta2-self-limits-max-angle-logger-warning-pendulum-2-angle-limit-exceeded-return-true-velocity-limits-if-abs-dtheta1-self-limits-max-velocity-logger-warning-pendulum-1-velocity-limit-exceeded-return-true-if-abs-dtheta2-self-limits-max-velocity-logger-warning-pendulum-2-velocity-limit-exceeded-return-true-return-false-def-apply-safety-limits-self-control-float-state-np-ndarray-float-apply-safety-limits-to-control-signal-force-magnitude-limit-u-limited-np-clip-control-self-limits-max-force-self-limits-max-force-rate-limiting-if-previous-control-available-if-hasattr-self-last-control-max-rate-self-safety-config-get-max-control-rate-100-0-n-s-dt-self-safety-config-get-dt-0-001-max-change-max-rate-dt-control-change-u-limited-self-last-control-if-abs-control-change-max-change-u-limited-self-last-control-np-sign-control-change-max-change-self-last-control-u-limited-return-u-limited">runnable: false class HILIntegrationProtocol: â€œâ€â€Hardware-in-the-loop integration protocol.â€â€â€ def <strong>init</strong>(self, controller_factory, communication_config: dict): self.factory = controller_factory self.comm_config = communication_config self.safety_limits = self._get_safety_limits() def create_hil_controller( self, controller_type: str, gains: List[float], safety_config: dict ) -&gt; â€˜HILControllerâ€™: â€œâ€â€Create HIL-compatible controller with safety features.â€â€â€ # Create base controller base_controller = create_controller(controller_type, gains=gains) # Wrap with HIL safety layer hil_controller = HILSafetyWrapper( base_controller, safety_config, self.safety_limits ) return hil_controller def _get_safety_limits(self) -&gt; dict: â€œâ€â€Get hardware safety limits.â€â€â€ return { â€˜max_forceâ€™: 50.0, # Reduced for hardware safety â€˜max_angleâ€™: np.pi / 6, # 30 degrees maximum â€˜max_velocityâ€™: 10.0, # rad/s â€˜emergency_stop_conditionsâ€™: [ â€˜angle_limit_exceededâ€™, â€˜velocity_limit_exceededâ€™, â€˜communication_failureâ€™ ] } class HILSafetyWrapper: â€œâ€â€Safety wrapper for HIL controllers.â€â€â€ def <strong>init</strong>(self, controller, safety_config: dict, limits: dict): self.controller = controller self.safety_config = safety_config self.limits = limits self.emergency_stop = False def compute_control(self, state: np.ndarray, *args, **kwargs) -&gt; float: â€œâ€â€Compute control with safety checks.â€â€â€ # Pre-control safety checks if self._check_emergency_conditions(state): self.emergency_stop = True return 0.0 # Emergency stop if self.emergency_stop: return 0.0 # Maintain emergency stop # Compute control try: control_result = self.controller.compute_control(state, *args, **kwargs) u = control_result.u if hasattr(control_result, â€˜uâ€™) else control_result # Post-control safety checks u_safe = self._apply_safety_limits(u, state) return u_safe except Exception as e: logger.error(fâ€HIL control computation failed: {e}â€) self.emergency_stop = True return 0.0 def _check_emergency_conditions(self, state: np.ndarray) -&gt; bool: â€œâ€â€Check for emergency stop conditions.â€â€â€ theta1, theta2, x, dtheta1, dtheta2, dx = state # Angle limits if abs(theta1) &gt; self.limits[â€˜max_angleâ€™]: logger.warning(â€œPendulum 1 angle limit exceededâ€) return True if abs(theta2) &gt; self.limits[â€˜max_angleâ€™]: logger.warning(â€œPendulum 2 angle limit exceededâ€) return True # Velocity limits if abs(dtheta1) &gt; self.limits[â€˜max_velocityâ€™]: logger.warning(â€œPendulum 1 velocity limit exceededâ€) return True if abs(dtheta2) &gt; self.limits[â€˜max_velocityâ€™]: logger.warning(â€œPendulum 2 velocity limit exceededâ€) return True return False def _apply_safety_limits(self, control: float, state: np.ndarray) -&gt; float: â€œâ€â€Apply safety limits to control signal.â€â€â€ # Force magnitude limit u_limited = np.clip(control, -self.limits[â€˜max_forceâ€™], self.limits[â€˜max_forceâ€™]) # Rate limiting (if previous control available) if hasattr(self, â€˜_last_controlâ€™): max_rate = self.safety_config.get(â€˜max_control_rateâ€™, 100.0) # N/s dt = self.safety_config.get(â€˜dtâ€™, 0.001) max_change = max_rate * dt control_change = u_limited - self._last_control if abs(control_change) &gt; max_change: u_limited = self._last_control + np.sign(control_change) * max_change self._last_control = u_limited return u_limited</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/integration_protocols.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/integration_protocols.html#runnable-false-class-dataexchangebus-central-data-exchange-bus-for-cross-domain-communication-def-init-self-self-subscribers-self-message-queue-def-subscribe-self-topic-str-callback-callable-subscribe-to-data-topic-if-topic-not-in-self-subscribers-self-subscribers-topic-self-subscribers-topic-append-callback-def-publish-self-topic-str-data-any-publish-data-to-topic-if-topic-in-self-subscribers-for-callback-in-self-subscribers-topic-try-callback-data-except-exception-as-e-logger-error-f-subscriber-callback-failed-e-def-get-data-schema-self-topic-str-dict-str-any-get-data-schema-for-topic-schemas-system-state-systemstate-annotations-control-action-controlaction-annotations-simulation-result-simulationresult-annotations-optimization-result-optimizationresult-annotations-return-schemas-get-topic-global-data-exchange-bus-instance">runnable: false class DataExchangeBus: â€œâ€â€Central data exchange bus for cross-domain communication.â€â€â€ def <strong>init</strong>(self): self._subscribers = {} self._message_queue = [] def subscribe(self, topic: str, callback: Callable): â€œâ€â€Subscribe to data topic.â€â€â€ if topic not in self._subscribers: self._subscribers[topic] = [] self._subscribers[topic].append(callback) def publish(self, topic: str, data: Any): â€œâ€â€Publish data to topic.â€â€â€ if topic in self._subscribers: for callback in self._subscribers[topic]: try: callback(data) except Exception as e: logger.error(fâ€Subscriber callback failed: {e}â€) def get_data_schema(self, topic: str) -&gt; Dict[str, Any]: â€œâ€â€Get data schema for topic.â€â€â€ schemas = { â€˜system_stateâ€™: SystemState.<strong>annotations</strong>, â€˜control_actionâ€™: ControlAction.<strong>annotations</strong>, â€˜simulation_resultâ€™: SimulationResult.<strong>annotations</strong>, â€˜optimization_resultâ€™: OptimizationResult.<strong>annotations</strong> } return schemas.get(topic, {}) # Global data exchange bus instance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/mathematical_foundations.html">Mathematical Foundations for Controller Factory Integration ## Overview This document provides mathematical foundations for the controller factory integration, focusing on the theoretical underpinnings of sliding mode control (SMC) algorithms, stability analysis, and optimization integration. The mathematical framework ensures that all factory-created controllers satisfy fundamental control theory requirements. ## Table of Contents 1. <span class="xref myst">Classical SMC Mathematical Framework</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html">PSO Integration Workflows - Factory Integration ## PSO-Factory Integration Documentation <strong>Document Version:</strong> 2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#runnable-false-optimize-sta-smc-with-issue-2-considerations">runnable: false # Optimize STA-SMC with Issue #2 considerations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#runnable-false-from-src-optimization-integration-pso-factory-bridge-import-optimize-classical-smc-optimize-adaptive-smc-optimize-sta-smc">runnable: false from src.optimization.integration.pso_factory_bridge import ( optimize_classical_smc, optimize_adaptive_smc, optimize_sta_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#runnable-false-advanced-pso-configuration-example">runnable: false # Advanced PSO configuration example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#runnable-false-automatic-test-scenarios-built-into-enhanced-fitness-function">runnable: false # Automatic test scenarios (built into enhanced fitness function):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#runnable-false-def-evaluate-controller-performance-self-controller-gains-multi-scenario-performance-evaluation-for-each-test-scenario-for-scenario-in-test-scenarios-simulate-controller-performance-cost-self-simulate-scenario-controller-scenario-total-cost-cost-scenario-weight-cost-components-position-error-10-0-state-error-2dt-control-effort-0-1-u-2dt-control-rate-0-05-du-dt-2dt-stability-penalty-penalties-for-instability-return-total-cost-total-weight">runnable: false def _evaluate_controller_performance(self, controller, gains): â€œâ€â€Multi-scenario performance evaluation.â€â€â€ # For each test scenario: for scenario in test_scenarios: # Simulate controller performance cost = self._simulate_scenario(controller, scenario) total_cost += cost * scenario[â€˜weightâ€™] # Cost components: # - Position error: 10.0 * âˆ«|state_error|Â²dt # - Control effort: 0.1 * âˆ«|u|Â²dt # - Control rate: 0.05 * âˆ«|du/dt|Â²dt # - Stability penalty: penalties for instability return total_cost / total_weight</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#runnable-false-configure-pso-for-robustness-optimization">runnable: false # Configure PSO for robustness optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#multiple-initial-conditions">- Multiple initial conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#different-simulation-durations">- Different simulation durations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#varying-disturbance-levels">- Varying disturbance levels</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#parameter-uncertainty-scenarios-result-pso-factory-optimize-controller-if-result-success-analyze-robustness-metrics-validation-result-validation-results-print-f-robustness-analysis-print-f-all-scenarios-passed-validation-performance-acceptable-print-f-controller-stability-validation-controller-stable">- Parameter uncertainty scenarios result = pso_factory.optimize_controller() if result[â€˜successâ€™]: # Analyze robustness metrics validation = result[â€˜validation_resultsâ€™] print(fâ€Robustness Analysis:â€) print(fâ€ All scenarios passed: {validation[â€˜performance_acceptableâ€™]}â€) print(fâ€ Controller stability: {validation[â€˜controller_stableâ€™]}â€)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#runnable-false-def-compare-controller-performance-compare-optimized-controllers-across-different-types-optimize-all-controller-types-controller-types-controllertype-classical-smc-controllertype-sta-smc-controllertype-adaptive-smc-results-for-controller-type-in-controller-types-print-f-optimizing-controller-type-value-pso-config-psofactoryconfig-controller-type-controller-type-population-size-20-max-iterations-50-pso-factory-enhancedpsofactory-pso-config-result-pso-factory-optimize-controller-results-controller-type-value-result-performance-comparison-print-n-controller-performance-comparison-print-f-controller-20-best-cost-12-converged-10-improvement-12-print-60-for-controller-name-result-in-results-items-if-result-success-best-cost-result-best-cost-converged-result-performance-analysis-converged-improvement-result-performance-analysis-improvement-ratio-print-f-controller-name-20-best-cost-12-6f-str-converged-10-improvement-12-1-else-print-f-controller-name-20-failed-12-10-12-return-results-run-comparison">runnable: false def compare_controller_performance(): â€œâ€â€Compare optimized controllers across different types.â€â€â€ # Optimize all controller types controller_types = [ ControllerType.CLASSICAL_SMC, ControllerType.STA_SMC, ControllerType.ADAPTIVE_SMC ] results = {} for controller_type in controller_types: print(fâ€Optimizing {controller_type.value}â€¦â€) pso_config = PSOFactoryConfig( controller_type=controller_type, population_size=20, max_iterations=50 ) pso_factory = EnhancedPSOFactory(pso_config) result = pso_factory.optimize_controller() results[controller_type.value] = result # Performance comparison print(â€œ\n=== Controller Performance Comparison ===â€) print(fâ€{â€˜Controllerâ€™:&lt;20} {â€˜Best Costâ€™:&lt;12} {â€˜Convergedâ€™:&lt;10} {â€˜Improvementâ€™:&lt;12}â€) print(â€œ-â€ * 60) for controller_name, result in results.items(): if result[â€˜successâ€™]: best_cost = result[â€˜best_costâ€™] converged = result[â€˜performance_analysisâ€™][â€˜convergedâ€™] improvement = result[â€˜performance_analysisâ€™][â€˜improvement_ratioâ€™] print(fâ€{controller_name:&lt;20} {best_cost:&lt;12.6f} {str(converged):&lt;10} {improvement:&lt;12.1%}â€) else: print(fâ€{controller_name:&lt;20} {â€˜FAILEDâ€™:&lt;12} {â€˜-â€˜:&lt;10} {â€˜-â€˜:&lt;12}â€) return results # Run comparison</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#id7">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#runnable-false-def-complete-research-workflow-complete-research-workflow-demonstrating-pso-factory-integration-print-complete-research-workflow-step-1-baseline-controllers-print-n1-creating-baseline-controllers-from-src-controllers-factory-import-create-controller-baseline-controllers-classical-create-controller-classical-smc-gains-8-0-6-0-4-0-3-0-15-0-2-0-sta-create-controller-sta-smc-gains-8-0-4-0-12-0-6-0-4-85-3-43-adaptive-create-controller-adaptive-smc-gains-12-0-10-0-6-0-5-0-2-5-print-f-created-len-baseline-controllers-baseline-controllers-step-2-pso-optimization-print-n2-running-pso-optimization-optimization-results-for-controller-name-in-classical-smc-sta-smc-adaptive-smc-controller-enum-classical-smc-controllertype-classical-smc-sta-smc-controllertype-sta-smc-adaptive-smc-controllertype-adaptive-smc-controller-name-pso-config-psofactoryconfig-controller-type-controller-enum-population-size-20-max-iterations-60-use-robust-evaluation-true-pso-factory-enhancedpsofactory-pso-config-result-pso-factory-optimize-controller-optimization-results-controller-name-result-if-result-success-cost-result-best-cost-converged-result-performance-analysis-converged-print-f-controller-name-cost-cost-6f-converged-converged-else-print-f-controller-name-failed-result-get-error-unknown-step-3-performance-comparison-print-n3-performance-comparison-comparison-data-for-controller-name-result-in-optimization-results-items-if-result-success-comparison-data-append-controller-controller-name-cost-result-best-cost-gains-result-best-gains-converged-result-performance-analysis-converged-improvement-result-performance-analysis-improvement-ratio-sort-by-cost-lower-is-better-comparison-data-sort-key-lambda-x-x-cost-print-f-rank-4-controller-15-cost-12-converged-10-improvement-12-print-55-for-i-data-in-enumerate-comparison-data-1-print-f-i-4-data-controller-15-data-cost-12-6f-f-str-data-converged-10-data-improvement-12-1-step-4-best-controller-analysis-if-comparison-data-best-controller-comparison-data-0-print-f-n4-best-controller-analysis-print-f-controller-best-controller-controller-print-f-cost-best-controller-cost-6f-print-f-gains-best-controller-gains-print-f-converged-best-controller-converged-print-f-improvement-best-controller-improvement-1-create-optimized-controller-best-name-best-controller-controller-best-gains-best-controller-gains-optimized-controller-create-controller-best-name-gains-best-gains-print-f-optimized-controller-ready-for-deployment-return-baseline-controllers-baseline-controllers-optimization-results-optimization-results-best-controller-optimized-controller-comparison-data-comparison-data-else-print-no-successful-optimizations-return-none-run-complete-workflow">runnable: false def complete_research_workflow(): â€œâ€â€Complete research workflow demonstrating PSO-factory integration.â€â€â€ print(â€œ=== Complete Research Workflow ===â€) # Step 1: Baseline controllers print(â€œ\n1. Creating baseline controllersâ€¦â€) from src.controllers.factory import create_controller baseline_controllers = { â€˜classicalâ€™: create_controller(â€˜classical_smcâ€™, gains=[8.0, 6.0, 4.0, 3.0, 15.0, 2.0]), â€˜staâ€™: create_controller(â€˜sta_smcâ€™, gains=[8.0, 4.0, 12.0, 6.0, 4.85, 3.43]), â€˜adaptiveâ€™: create_controller(â€˜adaptive_smcâ€™, gains=[12.0, 10.0, 6.0, 5.0, 2.5]) } print(fâ€Created {len(baseline_controllers)} baseline controllersâ€) # Step 2: PSO optimization print(â€œ\n2. Running PSO optimizationâ€¦â€) optimization_results = {} for controller_name in [â€˜classical_smcâ€™, â€˜sta_smcâ€™, â€˜adaptive_smcâ€™]: controller_enum = { â€˜classical_smcâ€™: ControllerType.CLASSICAL_SMC, â€˜sta_smcâ€™: ControllerType.STA_SMC, â€˜adaptive_smcâ€™: ControllerType.ADAPTIVE_SMC }[controller_name] pso_config = PSOFactoryConfig( controller_type=controller_enum, population_size=20, max_iterations=60, use_robust_evaluation=True ) pso_factory = EnhancedPSOFactory(pso_config) result = pso_factory.optimize_controller() optimization_results[controller_name] = result if result[â€˜successâ€™]: cost = result[â€˜best_costâ€™] converged = result[â€˜performance_analysisâ€™][â€˜convergedâ€™] print(fâ€ {controller_name}: cost={cost:.6f}, converged={converged}â€) else: print(fâ€ {controller_name}: FAILED - {result.get(â€˜errorâ€™, â€˜Unknownâ€™)}â€) # Step 3: Performance comparison print(â€œ\n3. Performance comparisonâ€¦â€) comparison_data = [] for controller_name, result in optimization_results.items(): if result[â€˜successâ€™]: comparison_data.append({ â€˜controllerâ€™: controller_name, â€˜costâ€™: result[â€˜best_costâ€™], â€˜gainsâ€™: result[â€˜best_gainsâ€™], â€˜convergedâ€™: result[â€˜performance_analysisâ€™][â€˜convergedâ€™], â€˜improvementâ€™: result[â€˜performance_analysisâ€™][â€˜improvement_ratioâ€™] }) # Sort by cost (lower is better) comparison_data.sort(key=lambda x: x[â€˜costâ€™]) print(fâ€{â€˜Rankâ€™:&lt;4} {â€˜Controllerâ€™:&lt;15} {â€˜Costâ€™:&lt;12} {â€˜Convergedâ€™:&lt;10} {â€˜Improvementâ€™:&lt;12}â€) print(â€œ-â€ * 55) for i, data in enumerate(comparison_data, 1): print(fâ€{i:&lt;4} {data[â€˜controllerâ€™]:&lt;15} {data[â€˜costâ€™]:&lt;12.6f} â€œ fâ€{str(data[â€˜convergedâ€™]):&lt;10} {data[â€˜improvementâ€™]:&lt;12.1%}â€) # Step 4: Best controller analysis if comparison_data: best_controller = comparison_data[0] print(fâ€\n4. Best controller analysis:â€) print(fâ€ Controller: {best_controller[â€˜controllerâ€™]}â€) print(fâ€ Cost: {best_controller[â€˜costâ€™]:.6f}â€) print(fâ€ Gains: {best_controller[â€˜gainsâ€™]}â€) print(fâ€ Converged: {best_controller[â€˜convergedâ€™]}â€) print(fâ€ Improvement: {best_controller[â€˜improvementâ€™]:.1%}â€) # Create optimized controller best_name = best_controller[â€˜controllerâ€™] best_gains = best_controller[â€˜gainsâ€™] optimized_controller = create_controller(best_name, gains=best_gains) print(fâ€ Optimized controller ready for deploymentâ€) return { â€˜baseline_controllersâ€™: baseline_controllers, â€˜optimization_resultsâ€™: optimization_results, â€˜best_controllerâ€™: optimized_controller, â€˜comparison_dataâ€™: comparison_data } else: print(â€œNo successful optimizationsâ€) return None # Run complete workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#id8">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../technical/pso_integration_workflows.html#runnable-false-def-real-time-optimization-integration-demonstrate-real-time-optimization-with-live-feedback-import-time-import-threading-from-queue-import-queue-class-optimizationmonitor-real-time-optimization-monitoring-def-init-self-self-progress-queue-queue-self-current-iteration-0-self-current-best-cost-float-inf-self-is-running-false-def-update-progress-self-iteration-best-cost-update-optimization-progress-self-current-iteration-iteration-self-current-best-cost-best-cost-self-progress-queue-put-iteration-best-cost-def-start-monitoring-self-start-monitoring-thread-self-is-running-true-monitor-thread-threading-thread-target-self-monitor-loop-monitor-thread-daemon-true-monitor-thread-start-def-stop-monitoring-self-stop-monitoring-self-is-running-false-def-monitor-loop-self-monitoring-loop-while-self-is-running-try-if-not-self-progress-queue-empty-iteration-cost-self-progress-queue-get-timeout-0-1-print-f-riteration-iteration-best-cost-cost-6f-end-flush-true-time-sleep-0-1-except-continue-create-monitor-monitor-optimizationmonitor-configure-pso-with-monitoring-integration-pso-config-psofactoryconfig-controller-type-controllertype-classical-smc-population-size-20-max-iterations-50-use-robust-evaluation-true-print-starting-real-time-pso-optimization-start-monitoring-monitor-start-monitoring-try-create-factory-and-optimize-pso-factory-enhancedpsofactory-pso-config-note-in-a-real-implementation-you-would-integrate-the-monitor-with-the-pso-algorithm-s-iteration-callback-result-pso-factory-optimize-controller-print-n-new-line-after-progress-updates-if-result-success-print-f-optimization-completed-successfully-print-f-final-cost-result-best-cost-6f-print-f-optimized-gains-result-best-gains-real-time-validation-optimized-controller-result-controller-print-nperforming-real-time-validation-test-states-0-0-0-1-0-05-0-0-0-0-0-0-0-0-0-2-0-1-0-0-0-0-0-0-0-0-0-3-0-15-0-0-0-0-0-0-for-i-state-in-enumerate-test-states-control-output-optimized-controller-compute-control-state-if-hasattr-control-output-u-u-control-output-u-else-u-control-output-print-f-test-i-1-state-state-3-control-u-3f-print-real-time-validation-completed-else-print-f-optimization-failed-result-get-error-unknown-finally-monitor-stop-monitoring-return-result-run-real-time-optimization">runnable: false def real_time_optimization_integration(): â€œâ€â€Demonstrate real-time optimization with live feedback.â€â€â€ import time import threading from queue import Queue class OptimizationMonitor: â€œâ€â€Real-time optimization monitoring.â€â€â€ def <strong>init</strong>(self): self.progress_queue = Queue() self.current_iteration = 0 self.current_best_cost = float(â€˜infâ€™) self.is_running = False def update_progress(self, iteration, best_cost): â€œâ€â€Update optimization progress.â€â€â€ self.current_iteration = iteration self.current_best_cost = best_cost self.progress_queue.put((iteration, best_cost)) def start_monitoring(self): â€œâ€â€Start monitoring thread.â€â€â€ self.is_running = True monitor_thread = threading.Thread(target=self._monitor_loop) monitor_thread.daemon = True monitor_thread.start() def stop_monitoring(self): â€œâ€â€Stop monitoring.â€â€â€ self.is_running = False def _monitor_loop(self): â€œâ€â€Monitoring loop.â€â€â€ while self.is_running: try: if not self.progress_queue.empty(): iteration, cost = self.progress_queue.get(timeout=0.1) print(fâ€\rIteration {iteration}: Best cost = {cost:.6f}â€, end=â€™â€™, flush=True) time.sleep(0.1) except: continue # Create monitor monitor = OptimizationMonitor() # Configure PSO with monitoring integration pso_config = PSOFactoryConfig( controller_type=ControllerType.CLASSICAL_SMC, population_size=20, max_iterations=50, use_robust_evaluation=True ) print(â€œStarting real-time PSO optimizationâ€¦â€) # Start monitoring monitor.start_monitoring() try: # Create factory and optimize pso_factory = EnhancedPSOFactory(pso_config) # Note: In a real implementation, you would integrate the monitor # with the PSO algorithmâ€™s iteration callback result = pso_factory.optimize_controller() print(â€œ\nâ€) # New line after progress updates if result[â€˜successâ€™]: print(fâ€Optimization completed successfully!â€) print(fâ€Final cost: {result[â€˜best_costâ€™]:.6f}â€) print(fâ€Optimized gains: {result[â€˜best_gainsâ€™]}â€) # Real-time validation optimized_controller = result[â€˜controllerâ€™] print(â€œ\nPerforming real-time validationâ€¦â€) test_states = [ [0.0, 0.1, 0.05, 0.0, 0.0, 0.0], [0.0, 0.2, 0.1, 0.0, 0.0, 0.0], [0.0, 0.3, 0.15, 0.0, 0.0, 0.0] ] for i, state in enumerate(test_states): control_output = optimized_controller.compute_control(state) if hasattr(control_output, â€˜uâ€™): u = control_output.u else: u = control_output print(fâ€ Test {i+1}: state={state[:3]}, control={u:.3f}â€) print(â€œReal-time validation completedâ€) else: print(fâ€Optimization failed: {result.get(â€˜errorâ€™, â€˜Unknownâ€™)}â€) finally: monitor.stop_monitoring() return result # Run real-time optimization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../CONTROLLER_FACTORY.html">Controller Factory Documentation &gt; <strong>Note:</strong> This document has been consolidated into the Factory System Guide. ## Quick Links - <strong><span class="xref myst">Factory System Guide</span></strong> - Complete controller factory documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../controller_pso_interface_api_documentation.html">Controller-PSO Interface API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html">Factory Integration System Documentation ## Overview The Double-Inverted Pendulum (DIP) SMC-PSO project implements a factory integration system that provides robust, thread-safe controller instantiation with deep PSO optimization integration. This documentation covers the architecture, implementation patterns, and usage guidelines for the factory system that resolves GitHub issue #6. ## Table of Contents 1. <span class="xref myst">Architecture Overview</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html#runnable-false-class-psocontrollerwrapper-wrapper-for-smc-controllers-to-provide-pso-compatible-interface-def-init-self-controller-n-gains-int-controller-type-str-self-controller-controller-self-n-gains-n-gains-self-controller-type-controller-type-self-max-force-getattr-controller-max-force-150-0-def-validate-gains-self-particles-np-ndarray-np-ndarray-validate-gain-particles-for-pso-optimization-domain-specific-validation-logic-return-valid-mask-def-compute-control-self-state-np-ndarray-np-ndarray-pso-compatible-control-computation-interface-standardized-interface-for-pso-fitness-evaluation-return-control-output">runnable: false class PSOControllerWrapper: â€œâ€â€Wrapper for SMC controllers to provide PSO-compatible interface.â€â€â€ def <strong>init</strong>(self, controller, n_gains: int, controller_type: str): self.controller = controller self.n_gains = n_gains self.controller_type = controller_type self.max_force = getattr(controller, â€˜max_forceâ€™, 150.0) def validate_gains(self, particles: np.ndarray) -&gt; np.ndarray: â€œâ€â€Validate gain particles for PSO optimization.â€â€â€ # Domain-specific validation logic return valid_mask def compute_control(self, state: np.ndarray) -&gt; np.ndarray: â€œâ€â€PSO-compatible control computation interface.â€â€â€ # Standardized interface for PSO fitness evaluation return control_output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html#runnable-false-def-create-smc-for-pso-smc-type-smctype-gains-union-list-np-ndarray-plant-config-or-model-optional-any-none-kwargs-any">runnable: false def create_smc_for_pso( smc_type: SMCType, gains: Union[list, np.ndarray], plant_config_or_model: Optional[Any] = None, **kwargs: Any</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html#runnable-false-def-get-gain-bounds-for-pso-smc-type-smctype-tuple-list-float-list-float-get-pso-gain-bounds-for-a-controller-type-bounds-map-smctype-classical-lower-1-0-1-0-1-0-1-0-5-0-0-1-k1-k2-lam1-lam2-k-kd-upper-30-0-30-0-20-0-20-0-50-0-10-0-smctype-adaptive-lower-2-0-2-0-1-0-1-0-0-5-k1-k2-lam1-lam2-gamma-upper-40-0-40-0-25-0-25-0-10-0-additional-controller-types-return-bounds-map-smc-type-lower-bounds-map-smc-type-upper">runnable: false def get_gain_bounds_for_pso(smc_type: SMCType) -&gt; Tuple[List[float], List[float]]: â€œâ€â€Get PSO gain bounds for a controller type.â€â€â€ bounds_map = { SMCType.CLASSICAL: { â€˜lowerâ€™: [1.0, 1.0, 1.0, 1.0, 5.0, 0.1], # [k1, k2, lam1, lam2, K, kd] â€˜upperâ€™: [30.0, 30.0, 20.0, 20.0, 50.0, 10.0] }, SMCType.ADAPTIVE: { â€˜lowerâ€™: [2.0, 2.0, 1.0, 1.0, 0.5], # [k1, k2, lam1, lam2, gamma] â€˜upperâ€™: [40.0, 40.0, 25.0, 25.0, 10.0] }, # â€¦ additional controller types } return (bounds_map[smc_type][â€˜lowerâ€™], bounds_map[smc_type][â€˜upperâ€™])</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html#runnable-false-def-create-controller-controller-type-str-config-optional-any-none-gains-optional-union-list-np-ndarray-none-any-create-controller-with-graceful-degradation-try-attempt-full-configuration-creation-controller-config-create-full-config-controller-type-config-gains-return-controller-class-controller-config-except-exception-as-e-logger-warning-f-full-config-creation-failed-e-using-minimal-config-fallback-to-minimal-configuration-minimal-config-create-minimal-config-controller-type-gains-return-controller-class-minimal-config">runnable: false def create_controller(controller_type: str, config: Optional[Any] = None, gains: Optional[Union[list, np.ndarray]] = None) -&gt; Any: â€œâ€â€Create controller with graceful degradation.â€â€â€ try: # Attempt full configuration creation controller_config = create_full_config(controller_type, config, gains) return controller_class(controller_config) except Exception as e: logger.warning(fâ€Full config creation failed: {e}. Using minimal config.â€) # Fallback to minimal configuration minimal_config = create_minimal_config(controller_type, gains) return controller_class(minimal_config)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html#id4">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html#runnable-false-optional-mpc-controller-import-with-graceful-fallback">runnable: false # Optional MPC controller import with graceful fallback</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html#id5">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html#runnable-false-def-validate-controller-gains-gains-list-float-controller-info-dict-str-any">runnable: false def _validate_controller_gains( gains: List[float], controller_info: Dict[str, Any]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html#performance-benchmarks-typical-values">Performance benchmarks (typical values)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html#id6">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html#runnable-false-memory-efficient-patterns-1-reuse-factory-functions">runnable: false # Memory-efficient patterns: # 1. Reuse factory functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html#use-factory-many-times-without-recreating-2-use-minimal-configurations-when-possible">Use factory many times without recreating # 2. Use minimal configurations when possible</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html#avoid-complex-config-objects-for-simple-use-cases-3-batch-operations">Avoid complex config objects for simple use cases # 3. Batch operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html#more-efficient-than-individual-creation">More efficient than individual creation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html#id7">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_documentation.html#runnable-false-thread-safe-patterns-1-pre-create-factories-for-concurrent-use">runnable: false # Thread-safe patterns: # 1. Pre-create factories for concurrent use</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_troubleshooting_guide.html">Factory Integration Troubleshooting Guide ## Overview This troubleshooting guide addresses common issues encountered when using the Enterprise Controller Factory system in the DIP SMC-PSO project. The guide provides systematic diagnostic procedures, root cause analysis, and proven approaches for factory integration problems. ## Table of Contents 1. <span class="xref myst">Quick Diagnosis</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_troubleshooting_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_troubleshooting_guide.html#runnable-false-usr-bin-env-python3">runnable: false #!/usr/bin/env python3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_troubleshooting_guide.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../factory_integration_troubleshooting_guide.html#id2">runnable: false #!/usr/bin/env python3</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../troubleshooting/index.html">Troubleshooting &amp; Issue Resolution</a><input aria-label="Toggle navigation of Troubleshooting &amp; Issue Resolution" class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../troubleshooting/hybrid_smc_runtime_fix.html">Hybrid SMC Runtime Fix Technical Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../troubleshooting/hybrid_smc_runtime_fix.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../troubleshooting/hybrid_smc_runtime_fix.html#runnable-false-file-src-controllers-smc-hybrid-adaptive-sta-smc-py">runnable: false # File: src/controllers/smc/hybrid_adaptive_sta_smc.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../troubleshooting/hybrid_smc_runtime_fix.html#lines-690-total-class-hybridadaptivestasmc-def-compute-control-self-state-state-vars-history-lines-483-674-complete-control-algorithm-implementation-lines-675-677-comments-about-return-statement-package-the-outputs-into-a-structured-named-tuple-missing-actual-return-statement-def-reset-self-none-reset-controller-state-lines-680-689-reset-logic-line-690-incorrect-return-statement-with-out-of-scope-variables-return-hybridstaoutput-u-sat-k1-new-k2-new-u-int-new-history-float-s">Lines: 690 total class HybridAdaptiveSTASMC: def compute_control(self, state, state_vars, history): # Lines 483-674: Complete control algorithm implementation # Lines 675-677: Comments about return statement # Package the outputs into a structured named tupleâ€¦ # MISSING: Actual return statement def reset(self) -&gt; None: â€œâ€â€Reset controller state.â€â€â€ # Lines 680-689: Reset logic # Line 690: INCORRECT return statement with out-of-scope variables return HybridSTAOutput(u_sat, (k1_new, k2_new, u_int_new), history, float(s))</a></li>
<li class="toctree-l2"><a class="reference internal" href="../troubleshooting/hybrid_smc_runtime_fix.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../troubleshooting/hybrid_smc_runtime_fix.html#runnable-false-test-1-direct-method-call">runnable: false # Test 1: Direct method call</a></li>
<li class="toctree-l2"><a class="reference internal" href="../troubleshooting/hybrid_smc_runtime_fix.html#test-2-pso-optimization-with-fixed-controller">Test 2: PSO optimization with fixed controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../troubleshooting/hybrid_smc_runtime_fix.html#optimization-complete-for-hybrid-adaptive-sta-smc">Optimization Complete for â€˜hybrid_adaptive_sta_smcâ€™</a></li>
<li class="toctree-l2"><a class="reference internal" href="../troubleshooting/hybrid_smc_runtime_fix.html#best-cost-0-000000">Best Cost: 0.000000</a></li>
<li class="toctree-l2"><a class="reference internal" href="../troubleshooting/hybrid_smc_runtime_fix.html#best-gains-77-6216-44-449-17-3134-14-25">Best Gains: [77.6216 44.449 17.3134 14.25 ]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../troubleshooting/hybrid_smc_runtime_fix.html#no-error-messages-in-logs">NO ERROR MESSAGES in logs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../troubleshooting/hybrid_smc_runtime_fix.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../troubleshooting/hybrid_smc_runtime_fix.html#runnable-false-mypy-ini-configuration">runnable: false # .mypy.ini configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../troubleshooting/hybrid_smc_runtime_fix.html#scripts-code-review-automation-py">scripts/code_review_automation.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../troubleshooting/hybrid_smc_runtime_fix.html#pre-commit-config-yaml">.pre-commit-config.yaml</a></li>
<li class="toctree-l2"><a class="reference internal" href="../troubleshooting/hybrid_smc_runtime_fix.html#github-workflows-controller-validation-yml">.github/workflows/controller-validation.yml</a></li>
<li class="toctree-l2"><a class="reference internal" href="../troubleshooting/hybrid_smc_runtime_fix_final.html">Hybrid SMC Runtime Fix - Complete Technical Documentation <strong>Date</strong>: 2025-09-29</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">âœ… Testing &amp; Validation Standards</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../TESTING.html">Testing Guide</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../validation/index.html">Validation &amp; Verification</a><input aria-label="Toggle navigation of Validation &amp; Verification" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_workflow.html">Validation Workflow Guide &gt; <strong>Coming Soon:</strong> validation workflow documentation. ## Current Resources For validation guidance, see: - <strong><span class="xref myst">Validation Examples</span></strong> - Practical validation examples and patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_validation_guide.html">Simulation Validation Guide &gt; <strong>Note:</strong> Simulation validation is covered in multiple guides. ## Quick Links - <strong><span class="xref myst">Validation Examples</span></strong> - Practical validation patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html">Simulation Result Validation Methodology <strong>Document Status:</strong> Phase 3.3 Completion - Monte Carlo and Statistical Testing Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html#controller-adapts-on-t0-t1">- Controller adapts on [tâ‚€, tâ‚]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html#performance-evaluated-on-t1-gap-t2">- Performance evaluated on [tâ‚+gap, tâ‚‚]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html#runnable-false-monte-carlo-cross-validation-statistical-tests">runnable: false # Monte Carlo + Cross-Validation + Statistical Tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html#if-diverge-investigate-why">If diverge â†’ investigate why</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html">Validation Examples: Practical Implementation Guide <strong>Document Status:</strong> Phase 3.3 Completion - Executable Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#runnable-false">runnable: false â€œâ€â€</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#conservative-20-uncertainty">Conservative (Â±20% uncertainty)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#pso-hyperparameter-selection-via-cross-validation-1-configuration-number-of-scenarios-100-pso-configurations-to-compare-4-1-small-explorative-pop-20-w-0-9-c1-2-0-c2-1-0-2-standard-pop-30-w-0-7-c1-1-5-c2-1-5-3-large-exploitative-pop-50-w-0-4-c1-1-0-c2-2-0-4-adaptive-pop-30-w-0-5-c1-1-8-c2-1-2-2-cross-validation-setup-method-monte-carlo-repetitions-50-train-test-split-80-20-3-running-cross-validation-this-may-take-several-minutes-4-results-cross-validation-scores-small-explorative-mean-cv-score-2-134-std-cv-score-0-312-median-cv-score-2-098-95-ci-2-223-2-045-standard-mean-cv-score-1-987-std-cv-score-0-267-median-cv-score-1-963-95-ci-2-062-1-912-large-exploitative-mean-cv-score-2-056-std-cv-score-0-298-median-cv-score-2-031-95-ci-2-138-1-974-adaptive-mean-cv-score-1-923-std-cv-score-0-245-median-cv-score-1-904-95-ci-1-992-1-854-5-statistical-comparison-pairwise-tests-after-multiple-comparison-correction-model-0-vs-model-3-model-3-is-significantly-better-p-0-0023-0-211-model-1-vs-model-3-model-3-is-significantly-better-p-0-0412-0-064-overall-ranking-1-adaptive-score-1-923-2-standard-score-1-987-3-large-exploitative-score-2-056-4-small-explorative-score-2-134-6-bias-variance-analysis-small-explorative-bias2-0-123456-variance-0-098234-high-bias-underfitting-consider-larger-population-standard-bias2-0-087654-variance-0-071234-good-balance-large-exploitative-bias2-0-091234-variance-0-089012-good-balance-adaptive-bias2-0-076543-variance-0-060123-good-balance-recommendation-recommended-pso-configuration-adaptive-parameters-population-size-30-inertia-weight-w-0-5-cognitive-coeff-c1-1-8-social-coeff-c2-1-2-mean-cv-score-1-923-this-configuration-showed-best-generalization-across-50-random-splits">======================================================================
PSO Hyperparameter Selection via Cross-Validation
====================================================================== 1. Configuration: Number of scenarios: 100 PSO configurations to compare: 4 1. Small-Explorative: pop=20, w=0.9, c1=2.0, c2=1.0 2. Standard: pop=30, w=0.7, c1=1.5, c2=1.5 3. Large-Exploitative: pop=50, w=0.4, c1=1.0, c2=2.0 4. Adaptive: pop=30, w=0.5, c1=1.8, c2=1.2 2. Cross-Validation Setup: Method: monte_carlo Repetitions: 50 Train-test split: 80%-20% 3. Running cross-validationâ€¦ (This may take several minutesâ€¦) 4. Results:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Cross-Validation Scores: Small-Explorative: Mean CV score: -2.134 Std CV score: 0.312 Median CV score: -2.098 95% CI: [-2.223, -2.045] Standard: Mean CV score: -1.987 Std CV score: 0.267 Median CV score: -1.963 95% CI: [-2.062, -1.912] Large-Exploitative: Mean CV score: -2.056 Std CV score: 0.298 Median CV score: -2.031 95% CI: [-2.138, -1.974] Adaptive: Mean CV score: -1.923 Std CV score: 0.245 Median CV score: -1.904 95% CI: [-1.992, -1.854] 5. Statistical Comparison: Pairwise Tests (after multiple comparison correction): model_0_vs_model_3: model_3 is significantly better (p=0.0023, Î”=0.211) model_1_vs_model_3: model_3 is significantly better (p=0.0412, Î”=0.064) Overall Ranking: 1. Adaptive (score: -1.923) 2. Standard (score: -1.987) 3. Large-Exploitative (score: -2.056) 4. Small-Explorative (score: -2.134) 6. Bias-Variance Analysis: Small-Explorative: BiasÂ²: 0.123456 Variance: 0.098234 âš  High bias - underfitting (consider larger population) Standard: BiasÂ²: 0.087654 Variance: 0.071234 âœ“ Good balance Large-Exploitative: BiasÂ²: 0.091234 Variance: 0.089012 âœ“ Good balance Adaptive: BiasÂ²: 0.076543 Variance: 0.060123 âœ“ Good balance ======================================================================
RECOMMENDATION: âœ“ RECOMMENDED PSO Configuration: Adaptive Parameters: - Population size: 30 - Inertia weight (w): 0.5 - Cognitive coeff (c1): 1.8 - Social coeff (c2): 1.2 Mean CV score: -1.923 This configuration showed best generalization across 50 random splits.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#statistical-comparison-of-controller-performance-1-experimental-setup-controllers-classical-smc-super-twisting-smc-adaptive-smc-trials-per-controller-30-significance-level-0-05-metric-settling-time-seconds-2-collecting-performance-data-3-descriptive-statistics-classical-smc-mean-2-487-s-std-0-398-s-median-2-465-s-min-1-823-s-max-3-312-s-cv-16-0-super-twisting-smc-mean-1-789-s-std-0-246-s-median-1-776-s-min-1-312-s-max-2-345-s-cv-13-8-adaptive-smc-mean-2-098-s-std-0-489-s-median-2-073-s-min-1-234-s-max-3-145-s-cv-23-3-4-assumption-testing-normality-tests-shapiro-wilk-classical-smc-w-0-9821-p-0-8734-normal-super-twisting-smc-w-0-9765-p-0-7231-normal-adaptive-smc-w-0-9798-p-0-8123-normal-homogeneity-of-variance-levene-s-test-f-3-2145-p-0-0456-unequal-variances-will-use-welch-s-test-5-pairwise-comparisons-multiple-comparison-correction-bonferroni-corrected-significance-level-0-0167-classical-smc-vs-super-twisting-smc-welch-s-t-test-t-7-8234-p-0-0001-significant-p-0-0167-mann-whitney-u-test-non-parametric-u-123-0-p-0-0002-effect-size-cohen-s-d-d-2-013-large-mean-difference-0-698-s-95-ci-for-difference-0-512-0-884-s-classical-smc-vs-adaptive-smc-welch-s-t-test-t-3-4567-p-0-0012-significant-p-0-0167-mann-whitney-u-test-non-parametric-u-287-0-p-0-0018-effect-size-cohen-s-d-d-0-891-large-mean-difference-0-389-s-95-ci-for-difference-0-167-0-611-s-super-twisting-smc-vs-adaptive-smc-welch-s-t-test-t-2-8901-p-0-0056-significant-p-0-0167-mann-whitney-u-test-non-parametric-u-234-0-p-0-0071-effect-size-cohen-s-d-d-0-743-medium-mean-difference-0-309-s-95-ci-for-difference-0-521-0-097-s-6-omnibus-test-one-way-anova-f-26-7891-p-0-000001-significant-at-least-one-controller-differs-kruskal-wallis-test-non-parametric-h-25-3456-p-0-000003-7-power-analysis-classical-smc-vs-super-twisting-smc-effect-size-d-2-013-sample-size-n-30-power-0-998-99-8-adequate-power-80-classical-smc-vs-adaptive-smc-effect-size-d-0-891-sample-size-n-30-power-0-865-86-5-adequate-power-80-super-twisting-smc-vs-adaptive-smc-effect-size-d-0-743-sample-size-n-30-power-0-752-75-2-low-power-recommend-n-36-for-80-power-conclusions-1-statistical-significance-significant-differences-found-0-0167-classical-smc-vs-super-twisting-smc-classical-smc-vs-adaptive-smc-super-twisting-smc-vs-adaptive-smc-2-effect-sizes-classical-smc-vs-super-twisting-smc-cohen-s-d-2-013-large-classical-smc-vs-adaptive-smc-cohen-s-d-0-891-large-super-twisting-smc-vs-adaptive-smc-cohen-s-d-0-743-medium-3-practical-recommendations-performance-ranking-by-mean-settling-time-1-super-twisting-smc-1-789-s-2-adaptive-smc-2-098-s-3-classical-smc-2-487-s-recommended-super-twisting-smc-fastest-mean-settling-time-significantly-better-than-classical-smc-p-0-0001-d-2-013-significantly-better-than-adaptive-smc-p-0-0056-d-0-743">======================================================================
Statistical Comparison of Controller Performance
====================================================================== 1. Experimental Setup: Controllers: Classical SMC, Super-Twisting SMC, Adaptive SMC Trials per controller: 30 Significance level: 0.05 Metric: Settling time (seconds) 2. Collecting performance dataâ€¦ 3. Descriptive Statistics:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Classical SMC: Mean: 2.487 s Std: 0.398 s Median: 2.465 s Min: 1.823 s Max: 3.312 s CV: 16.0% Super-Twisting SMC: Mean: 1.789 s Std: 0.246 s Median: 1.776 s Min: 1.312 s Max: 2.345 s CV: 13.8% Adaptive SMC: Mean: 2.098 s Std: 0.489 s Median: 2.073 s Min: 1.234 s Max: 3.145 s CV: 23.3% 4. Assumption Testing:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Normality Tests (Shapiro-Wilk): Classical SMC : W=0.9821, p=0.8734 âœ“ Normal Super-Twisting SMC : W=0.9765, p=0.7231 âœ“ Normal Adaptive SMC : W=0.9798, p=0.8123 âœ“ Normal Homogeneity of Variance (Leveneâ€™s test): F=3.2145, p=0.0456 âš  Unequal variances - will use Welchâ€™s test 5. Pairwise Comparisons:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Multiple comparison correction: Bonferroni Corrected significance level: Î±=0.0167 Classical SMC vs Super-Twisting SMC: Welchâ€™s t-test: t=7.8234, p=0.0001 âœ“ SIGNIFICANT (p &lt; 0.0167) Mann-Whitney U test (non-parametric): U=123.0, p=0.0002 Effect Size (Cohenâ€™s d): d=2.013 (large) Mean difference: 0.698 s 95% CI for difference: [0.512, 0.884] s Classical SMC vs Adaptive SMC: Welchâ€™s t-test: t=3.4567, p=0.0012 âœ“ SIGNIFICANT (p &lt; 0.0167) Mann-Whitney U test (non-parametric): U=287.0, p=0.0018 Effect Size (Cohenâ€™s d): d=0.891 (large) Mean difference: 0.389 s 95% CI for difference: [0.167, 0.611] s Super-Twisting SMC vs Adaptive SMC: Welchâ€™s t-test: t=-2.8901, p=0.0056 âœ“ SIGNIFICANT (p &lt; 0.0167) Mann-Whitney U test (non-parametric): U=234.0, p=0.0071 Effect Size (Cohenâ€™s d): d=-0.743 (medium) Mean difference: -0.309 s 95% CI for difference: [-0.521, -0.097] s 6. Omnibus Test (One-Way ANOVA):
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- F=26.7891, p=0.000001 âœ“ SIGNIFICANT: At least one controller differs Kruskal-Wallis test (non-parametric): H=25.3456, p=0.000003 7. Power Analysis:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Classical SMC vs Super-Twisting SMC: Effect size (d): 2.013 Sample size (n): 30 Power: 0.998 (99.8%) âœ“ Adequate power (â‰¥80%) Classical SMC vs Adaptive SMC: Effect size (d): 0.891 Sample size (n): 30 Power: 0.865 (86.5%) âœ“ Adequate power (â‰¥80%) Super-Twisting SMC vs Adaptive SMC: Effect size (d): 0.743 Sample size (n): 30 Power: 0.752 (75.2%) âš  Low power - recommend n=36 for 80% power ======================================================================
CONCLUSIONS:
====================================================================== 1. Statistical Significance: Significant differences found (Î±=0.0167): - Classical SMC vs Super-Twisting SMC - Classical SMC vs Adaptive SMC - Super-Twisting SMC vs Adaptive SMC 2. Effect Sizes: Classical SMC vs Super-Twisting SMC: Cohenâ€™s d = 2.013 (large) Classical SMC vs Adaptive SMC: Cohenâ€™s d = 0.891 (large) Super-Twisting SMC vs Adaptive SMC: Cohenâ€™s d = -0.743 (medium) 3. Practical Recommendations: Performance ranking (by mean settling time): 1. Super-Twisting SMC : 1.789 s 2. Adaptive SMC : 2.098 s 3. Classical SMC : 2.487 s âœ“ RECOMMENDED: Super-Twisting SMC - Fastest mean settling time - Significantly better than Classical SMC (p=0.0001, d=2.013) - Significantly better than Adaptive SMC (p=0.0056, d=0.743)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#uncertainty-quantification-for-settling-time-1-safety-requirement-settling-time-must-be-3-0s-with-99-confidence-2-collecting-experimental-data-number-of-test-runs-200-3-descriptive-statistics-mean-2-123-s-std-0-687-s-median-1-983-s-min-0-987-s-max-4-823-s-range-3-836-s-percentiles-5-1-234-s-25-1-653-s-50-1-983-s-75-2-456-s-95-3-567-s-99-4-234-s-4-bootstrap-confidence-intervals-bootstrap-iterations-10000-confidence-level-95-mean-settling-time-point-estimate-2-123-s-95-ci-2-026-2-223-s-ci-width-0-197-s-median-settling-time-point-estimate-1-983-s-95-ci-1-876-2-087-s-95th-percentile-point-estimate-3-567-s-95-ci-3-289-3-891-s-5-distribution-fitting-normal-k-s-statistic-0-0867-p-value-0-0234-aic-412-34-reject-poor-fit-lognormal-k-s-statistic-0-0421-p-value-0-6523-aic-387-12-cannot-reject-good-fit-gamma-k-s-statistic-0-0534-p-value-0-3421-aic-391-67-cannot-reject-good-fit-exponential-k-s-statistic-0-1234-p-value-0-0001-aic-445-89-reject-poor-fit-best-fit-lowest-aic-lognormal-aic-387-12-6-risk-analysis-value-at-risk-var-var-1-3-892-s-top-1-worst-cases-var-5-3-567-s-top-5-worst-cases-var-10-3-234-s-top-10-worst-cases-conditional-value-at-risk-cvar-expected-shortfall-cvar-1-4-123-s-avg-of-worst-1-cvar-5-3-789-s-avg-of-worst-5-cvar-10-3-456-s-avg-of-worst-10-7-safety-validation-empirical-analysis-samples-exceeding-3-0s-18-200-empirical-p-t-3-0s-0-0900-9-00-95-ci-for-p-t-3-0s-0-0523-0-1342-fitted-lognormal-distribution-p-t-3-0s-0-0823-8-23-p-t-3-0s-0-9177-91-77-fails-safety-requirement-91-8-99-0-to-meet-99-confidence-target-99-percentile-4-521-s-required-4-521s-3-0s-need-to-improve-99-percentile-by-1-521s-8-extreme-value-analysis-block-maxima-method-block-size-20-number-of-blocks-10-gev-parameters-0-234-3-876-0-456-return-levels-10-run-worst-case-4-876-s-50-run-worst-case-5-432-s-100-run-worst-case-5-687-s-uncertainty-quantification-summary-1-point-estimates-mean-2-123-s-95th-percentile-3-567-s-99th-percentile-4-234-s-2-uncertainty-95-ci-mean-2-026-2-223-s-95th-percentile-3-289-3-891-s-3-distributional-model-best-fit-lognormal-goodness-of-fit-p-value-0-6523-4-safety-assessment-threshold-3-0s-required-confidence-99-fails-only-91-8-of-scenarios-meet-requirement-5-recommendations-further-controller-improvement-needed-option-1-tune-controller-for-better-worst-case-performance-option-2-increase-safety-threshold-option-3-accept-lower-confidence-level-if-acceptable">======================================================================
Uncertainty Quantification for Settling Time
====================================================================== 1. Safety Requirement: Settling time must be &lt; 3.0s with 99% confidence 2. Collecting experimental dataâ€¦ Number of test runs: 200 3. Descriptive Statistics:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Mean: 2.123 s Std: 0.687 s Median: 1.983 s Min: 0.987 s Max: 4.823 s Range: 3.836 s Percentiles: 5%: 1.234 s 25%: 1.653 s 50%: 1.983 s 75%: 2.456 s 95%: 3.567 s 99%: 4.234 s 4. Bootstrap Confidence Intervals:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Bootstrap iterations: 10000 Confidence level: 95% Mean settling time: Point estimate: 2.123 s 95% CI: [2.026, 2.223] s CI width: 0.197 s Median settling time: Point estimate: 1.983 s 95% CI: [1.876, 2.087] s 95th percentile: Point estimate: 3.567 s 95% CI: [3.289, 3.891] s 5. Distribution Fitting:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Normal: K-S statistic: 0.0867 p-value: 0.0234 AIC: 412.34 âœ— Reject (poor fit) Lognormal: K-S statistic: 0.0421 p-value: 0.6523 AIC: 387.12 âœ“ Cannot reject (good fit) Gamma: K-S statistic: 0.0534 p-value: 0.3421 AIC: 391.67 âœ“ Cannot reject (good fit) Exponential: K-S statistic: 0.1234 p-value: 0.0001 AIC: 445.89 âœ— Reject (poor fit) Best fit (lowest AIC): Lognormal AIC = 387.12 6. Risk Analysis:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Value at Risk (VaR): VaR(1%): 3.892 s (top 1% worst cases) VaR(5%): 3.567 s (top 5% worst cases) VaR(10%): 3.234 s (top 10% worst cases) Conditional Value at Risk (CVaR / Expected Shortfall): CVaR(1%): 4.123 s (avg of worst 1%) CVaR(5%): 3.789 s (avg of worst 5%) CVaR(10%): 3.456 s (avg of worst 10%) 7. Safety Validation:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Empirical Analysis: Samples exceeding 3.0s: 18/200 Empirical P(T &gt; 3.0s) = 0.0900 (9.00%) 95% CI for P(T &gt; 3.0s): [0.0523, 0.1342] Fitted Lognormal Distribution: P(T &gt; 3.0s) = 0.0823 (8.23%) P(T â‰¤ 3.0s) = 0.9177 (91.77%) âœ— FAILS safety requirement (91.8% &lt; 99.0%) To meet 99% confidence: Target: 99% percentile = 4.521 s Required: 4.521s &lt; 3.0s âš  Need to improve 99% percentile by 1.521s 8. Extreme Value Analysis:
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”- Block Maxima Method: Block size: 20 Number of blocks: 10 GEV parameters: Î¾=-0.234, Î¼=3.876, Ïƒ=0.456 Return Levels: 10-run worst-case: 4.876 s 50-run worst-case: 5.432 s 100-run worst-case: 5.687 s ======================================================================
UNCERTAINTY QUANTIFICATION SUMMARY:
====================================================================== 1. Point Estimates: Mean: 2.123 s 95th percentile: 3.567 s 99th percentile: 4.234 s 2. Uncertainty (95% CI): Mean: [2.026, 2.223] s 95th percentile: [3.289, 3.891] s 3. Distributional Model: Best fit: Lognormal Goodness-of-fit p-value: 0.6523 4. Safety Assessment: Threshold: 3.0s Required confidence: 99% âœ— FAILS: Only 91.8% of scenarios meet requirement 5. Recommendations: âœ— Further controller improvement needed â–¡ Option 1: Tune controller for better worst-case performance â–¡ Option 2: Increase safety threshold â–¡ Option 3: Accept lower confidence level (if acceptable)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/api_reference.html">Validation API Reference &gt; <strong>Coming Soon:</strong> validation API documentation. ## Current Resources For validation APIs, see: - <strong><span class="xref myst">Analysis Validation</span></strong> - Validation metrics API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/statistical_reference_tables.html">Statistical Reference Tables &gt; <strong>Coming Soon:</strong> statistical reference tables for validation. ## Current Resources For statistical validation, see: - <strong><span class="xref myst">Statistical Tests</span></strong> - Statistical test implementations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/phase_3_3_completion_report.html">Phase 3.3 Completion Report: Simulation Result Validation Documentation <strong>Completion Date:</strong> 2025-10-07</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../benchmarks/index.html">Performance Benchmarks</a><input aria-label="Toggle navigation of Performance Benchmarks" class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../benchmarks/controller_performance_benchmarks.html">Controller Performance Benchmarks with Statistical Analysis <strong>Project:</strong> Double-Inverted Pendulum Sliding Mode Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../benchmarks/phase_3_2_completion_report.html">Phase 3.2 Completion Report: Controller Performance Benchmarks <strong>Project:</strong> Double-Inverted Pendulum Sliding Mode Control</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../QUICKSTART_VALIDATION.html">Quick Start: Issue #12 Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../EXAMPLE_VALIDATION_REPORT.html">Documentation Code Example Validation Report <strong>Report Date:</strong> 2025-10-07</a></li>
<li class="toctree-l1"><a class="reference internal" href="../control_law_testing_standards.html">Control Law Testing Standards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deployment_validation_checklists.html">Deployment Validation Checklists and Quality Gates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html">Benchmarks &amp; Methodology This project includes benchmarking features for statistical analysis and performance comparison of sliding mode controllers. The benchmarking system provides standardized evaluation protocols and robust statistical metrics. ## Overview The benchmarking framework evaluates controllers across multiple dimensions: - <strong>Performance metrics</strong>: ISE, ITAE, RMS control effort, overshoot, constraint violations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#base-seed-for-reproducibility">Base seed for reproducibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#configurable-noise-standard-deviation">Configurable noise standard deviation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#example-5-degree-initial-angle-variation">Example: Â±5 degree initial angle variation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#test-with-physics-uncertainty-and-sensor-noise">Test with physics uncertainty and sensor noise</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#runnable-false-controllers-classical-smc-sta-smc-adaptive-smc">runnable: false controllers = [â€˜classical_smcâ€™, â€˜sta_smcâ€™, â€˜adaptive_smcâ€™]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#runnable-false-benchmark-metadata-timestamp-datetime-now-isoformat-config-hash-hashlib-md5-config-content-hexdigest-random-seed-1234-n-trials-30-environment-python-version-sys-version-numpy-version-np-version-platform-platform-platform">runnable: false benchmark_metadata = { â€˜timestampâ€™: datetime.now().isoformat(), â€˜config_hashâ€™: hashlib.md5(config_content).hexdigest(), â€˜random_seedâ€™: 1234, â€˜n_trialsâ€™: 30, â€˜environmentâ€™: { â€˜python_versionâ€™: sys.version, â€˜numpy_versionâ€™: np.<strong>version</strong>, â€˜platformâ€™: platform.platform() }</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ğŸ“š Documentation System</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../DOCUMENTATION_SYSTEM.html">ğŸ“š World-Class Documentation System for DIP_SMC_PSO ## ğŸŒŸ Overview This repository now features a <strong>world-class technical documentation system</strong> designed for research-grade publications. The system provides LaTeX-quality mathematical rendering, professional citation management, and cross-referencing features. ## âœ¨ Features ### ğŸ”¬ Research-Grade Mathematics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DOCUMENTATION_IMPLEMENTATION_PLAN.html">Documentation Coverage Implementation Plan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DOCUMENTATION_STYLE_GUIDE.html">Documentation Style Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DOCUMENTATION_COVERAGE_MATRIX.html">Documentation Coverage Matrix</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DOCUMENTATION_INVENTORY_SUMMARY.html">DIP-SMC-PSO Documentation Inventory Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CROSS_REFERENCE_AUDIT_REPORT.html">Documentation Cross-Reference Audit Report <strong>Report Date:</strong> 2025-10-07</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ğŸ”¬ Configuration &amp; Integration</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html">Configuration Integration Documentation ## Overview This document provides guidance on integrating the configuration system with the Enterprise Controller Factory. The DIP SMC-PSO project features a sophisticated configuration architecture that supports multiple sources, type safety, validation, and integration with controller creation workflows. ## Table of Contents 1. <span class="xref myst">Configuration Architecture</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#config-yaml-complete-configuration-example-global-settings">config.yaml - Complete configuration example # Global settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#runnable-false-from-pydantic-import-basemodel-field-validator">runnable: false from pydantic import BaseModel, Field, validator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#runnable-false-def-resolve-controller-gains-gains-optional-union-list-float-np-ndarray-config-optional-any-controller-type-str-controller-info-dict-str-any">runnable: false def _resolve_controller_gains( gains: Optional[Union[List[float], np.ndarray]], config: Optional[Any], controller_type: str, controller_info: Dict[str, Any]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#runnable-false-nested-dictionary-configuration">runnable: false # Nested dictionary configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#runnable-false-class-attributeconfig-configuration-using-attributes-def-init-self-create-controller-configurations-as-attributes-self-classical-smc-type-config-gains-25-20-15-10-40-6-max-force-160-0-boundary-layer-0-025-dt-0-001-self-adaptive-smc-type-config-gains-30-22-18-12-5-0-max-force-160-0-dt-0-001-leak-rate-0-02-initialize-controllers-namespace">runnable: false class AttributeConfig: â€œâ€â€Configuration using attributes.â€â€â€ def <strong>init</strong>(self): # Create controller configurations as attributes self.classical_smc = type(â€˜Configâ€™, (), { â€˜gainsâ€™: [25, 20, 15, 10, 40, 6], â€˜max_forceâ€™: 160.0, â€˜boundary_layerâ€™: 0.025, â€˜dtâ€™: 0.001 })() self.adaptive_smc = type(â€˜Configâ€™, (), { â€˜gainsâ€™: [30, 22, 18, 12, 5.0], â€˜max_forceâ€™: 160.0, â€˜dtâ€™: 0.001, â€˜leak_rateâ€™: 0.02 })() # Initialize controllers namespace</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#generated-configuration-for-system-name">Generated configuration for {{ system_name }}</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_schema_validation.html">Configuration Schema Validation Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_schema_validation.html#config-yaml-master-configuration-file">config.yaml - Master Configuration File</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coverage_analysis_methodology.html">Coverage Analysis Methodology Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coverage_analysis_methodology.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coverage_analysis_methodology.html#runnable-false-mathematical-model-for-isolated-coverage">runnable: false # Mathematical Model for Isolated Coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault_detection_guide.html">Fault Detection &amp; Isolation (FDI) Guide ## Overview The DIP_SMC_PSO system includes a Fault Detection and Isolation (FDI) module that monitors system health in real-time. The FDI system compares model predictions with actual measurements to detect deviations that may indicate component failures, sensor faults, or unexpected disturbances. ## Architecture The FDI system uses a <strong>model-based residual approach</strong>: ```</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ğŸ“š User Guides &amp; Tutorials</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../guides/index.html">User Guides &amp; Tutorials</a><input aria-label="Toggle navigation of User Guides &amp; Tutorials" class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../guides/getting-started.html">Getting Started Welcome to the DIP SMC PSO framework! This guide covers help you get up and running with your first simulation in under 10 minutes. ## What is the DIP SMC PSO Framework? This framework provides a complete research and development environment for: - <strong>Controlling a Double-Inverted Pendulum (DIP):</strong> A challenging control problem with two pendulums stacked on a cart</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/getting-started.html#or-on-some-systems">OR on some systems:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/getting-started.html#clone-repository">Clone repository</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/getting-started.html#you-should-see-simulate-py-config-yaml-src-tests-docs-etc">You should see: simulate.py, config.yaml, src/, tests/, docs/, etc.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/user-guide.html">User Guide: DIP SMC PSO Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/QUICK_REFERENCE.html">Quick Reference Guide Essential commands, patterns, and workflows for the DIP SMC PSO framework.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/QUICK_REFERENCE.html#minimal-simulation-default-controller-no-plots">Minimal simulation (default controller, no plots)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/QUICK_REFERENCE.html#optimize-classical-smc-gains">Optimize classical SMC gains</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/QUICK_REFERENCE.html#use-optimized-gains">Use optimized gains</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/QUICK_REFERENCE.html#override-single-parameter">Override single parameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/QUICK_REFERENCE.html#save-simulation-results">Save simulation results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/QUICK_REFERENCE.html#run-hil-simulation-automatic-server-client">Run HIL simulation (automatic server + client)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/QUICK_REFERENCE.html#launch-streamlit-dashboard">Launch Streamlit dashboard</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/QUICK_REFERENCE.html#run-all-tests">Run all tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/README.html">User Guides &amp; Tutorials Welcome to the DIP SMC PSO framework documentation! This guide covers help you navigate the documentation and find what you need.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/getting-started-validation-report.html">Getting Started Guide Validation Report <strong>Phase 5.1: Getting Started Guide Validation</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/interactive_configuration_guide.html">Interactive Configuration Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/interactive_visualizations.html">Interactive Visualizations Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-01-first-simulation.html">Tutorial 01: Your First Simulation <strong>Level:</strong> Beginner</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-02-controller-comparison.html">Tutorial 02: Controller Comparison &amp; Selection <strong>Level:</strong> Intermediate</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-02-controller-comparison.html#baseline-nominal-mass">Baseline: nominal mass</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-03-pso-optimization.html">Tutorial 03: PSO Optimization for Controller Tuning <strong>Level:</strong> Intermediate to Advanced</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-03-pso-optimization.html#velocity-update">Velocity update</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-03-pso-optimization.html#run-pso-with-different-seeds">Run PSO with different seeds</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-04-custom-controller.html">Tutorial 04: Custom Controller Development <strong>Level:</strong> Advanced</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-04-custom-controller.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-04-custom-controller.html#runnable-false-class-mycustomcontroller-def-init-self-gains-max-force-kwargs-initialize-controller-with-gains-and-parameters-pass-def-compute-control-self-state-state-vars-history-compute-control-signal-for-current-state-parameters-state-np-ndarray-state-vector-x-dx-1-d1-2-d2-state-vars-dict-controller-specific-internal-state-history-dict-historical-data-for-multi-step-algorithms-returns-control-float-control-input-force-applied-to-cart-state-vars-dict-updated-internal-state-history-dict-updated-history-pass-def-initialize-history-self-dict-initialize-history-buffer-for-controller-return-def-cleanup-self-clean-up-resources-optional-pass">runnable: false class MyCustomController: def <strong>init</strong>(self, gains, max_force, **kwargs): â€œâ€â€Initialize controller with gains and parameters.â€â€â€ pass def compute_control(self, state, state_vars, history): â€œâ€â€ Compute control signal for current state. Parameters â€”â€”â€”- state : np.ndarray State vector [x, dx, Î¸â‚, dÎ¸â‚, Î¸â‚‚, dÎ¸â‚‚] state_vars : dict Controller-specific internal state history : dict Historical data for multi-step algorithms Returns â€”â€”- control : float Control input (force applied to cart) state_vars : dict Updated internal state history : dict Updated history â€œâ€â€ pass def initialize_history(self) -&gt; dict: â€œâ€â€Initialize history buffer for controller.â€â€â€ return {} def cleanup(self): â€œâ€â€Clean up resources (optional).â€â€â€ pass</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-04-custom-controller.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-04-custom-controller.html#runnable-false">runnable: false #======================================================================================\</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-04-custom-controller.html#test-terminal-smc-with-default-configuration">Test terminal SMC with default configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-04-custom-controller.html#optimize-terminal-smc-gains">Optimize terminal SMC gains</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-04-custom-controller.html#test-optimized-terminal-smc">Test optimized terminal SMC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-04-custom-controller.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-04-custom-controller.html#runnable-false-def-init-self-gains-check-count-if-len-gains-expected-count-raise-valueerror-f-expected-expected-count-gains-got-len-gains-check-bounds-if-any-g-0-for-g-in-gains-4-surface-gains-must-be-positive-raise-valueerror-surface-gains-must-be-non-negative-check-constraints-e-g-exponents-in-0-1-if-not-0-alpha-1-raise-valueerror-f-exponent-must-be-in-0-1-got-alpha">runnable: false def <strong>init</strong>(self, gains, â€¦): # Check count if len(gains) != expected_count: raise ValueError(fâ€Expected {expected_count} gains, got {len(gains)}â€) # Check bounds if any(g &lt; 0 for g in gains[:4]): # Surface gains must be positive raise ValueError(â€œSurface gains must be non-negativeâ€) # Check constraints (e.g., exponents in (0,1)) if not (0 &lt; alpha &lt; 1): raise ValueError(fâ€Exponent Î± must be in (0,1), got {alpha}â€)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-04-custom-controller.html#bad-division-by-zero">Bad: Division by zero</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-05-research-workflow.html">Tutorial 05: End-to-End Research Workflow <strong>Level:</strong> Advanced</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-05-research-workflow.html#experimental-scenarios-for-robustness-study">Experimental scenarios for robustness study</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-05-research-workflow.html#install-tqdm-for-progress-bar-if-needed">Install tqdm for progress bar if needed</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-05-research-workflow.html#experimental-metadata-for-robustness-study">Experimental Metadata for Robustness Study</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-05-research-workflow.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-05-research-workflow.html#runnable-false-usr-bin-env-python">runnable: false #!/usr/bin/env python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-05-research-workflow.html#metadata-study-title-authors-join-metadata-study-authors">{metadata[â€˜studyâ€™][â€˜titleâ€™]} <strong>Authors:</strong> {â€™, â€˜.join(metadata[â€˜studyâ€™][â€˜authorsâ€™])}</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-05-research-workflow.html#run-analysis-and-populate-results-save-report">â€¦ (run analysis and populate results) # Save report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-01-validation-report.html">Tutorial 01 Validation Report <strong>Phase 5.2: Tutorial 01 (â€œYour First Simulationâ€) Validation</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/tutorials/tutorial-01-validation-report.html#tutorial-01-experiments-validation-running-baseline-default-configuration-pass-all-metrics-within-expected-ranges-11-2s-settling-time-2-34s-rms-control-12-1n-overshoot-3-5-running-experiment-1-perturbed-first-pendulum-pass-all-metrics-within-expected-ranges-11-5s-settling-time-2-98s-rms-control-17-3n-overshoot-7-2-summary">========================================
Tutorial 01 Experiments Validation
======================================== Running: Baseline (Default Configuration)
[PASS] All metrics within expected ranges (11.2s) Settling Time: 2.34s RMS Control: 12.1N Overshoot: 3.5% Running: Experiment 1: Perturbed First Pendulum
[PASS] All metrics within expected ranges (11.5s) Settling Time: 2.98s RMS Control: 17.3N Overshoot: 7.2% â€¦ ========================================
Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/running-simulations.html">How-To: Running Simulations <strong>Type:</strong> Task-Oriented Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/running-simulations.html#minimal-simulation-default-controller-no-plots">Minimal simulation (default controller, no plots)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/running-simulations.html#view-help">View help</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/running-simulations.html#in-jupyter-notebook">In Jupyter notebook</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/result-analysis.html">How-To: Result Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/optimization-workflows.html">How-To: Optimization Workflows <strong>Type:</strong> Task-Oriented Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/optimization-workflows.html#basic-pso-optimization">Basic PSO optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/optimization-workflows.html#classical-smc-6-gains-30-60-particles">Classical SMC (6 gains) â†’ 30-60 particles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/optimization-workflows.html#after-pso-validate-on-multiple-scenarios">After PSO, validate on multiple scenarios</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/testing-validation.html">How-To: Testing &amp; Validation <strong>Type:</strong> Task-Oriented Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/testing-validation.html#run-all-tests">Run all tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/testing-validation.html#unit-tests-only-fast">Unit tests only (fast)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/testing-validation.html#run-tests-with-coverage">Run tests with coverage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/testing-validation.html#open-htmlcov-index-html-in-browser-generate-terminal-coverage-report">Open htmlcov/index.html in browser # Generate terminal coverage report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/testing-validation.html#tests-test-controllers-test-my-controller-py">tests/test_controllers/test_my_controller.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/testing-validation.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/testing-validation.html#runnable-false-pytest-mark-parametrize-gains-expected-valid-10-8-15-12-50-5-true-valid-0-8-15-12-50-5-false-k1-0-invalid-10-8-15-12-50-5-false-negative-gain">runnable: false @pytest.mark.parametrize(â€œgains,expected_validâ€, [ ([10, 8, 15, 12, 50, 5], True), # Valid ([0, 8, 15, 12, 50, 5], False), # k1 = 0 invalid ([-10, 8, 15, 12, 50, 5], False), # Negative gain</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/testing-validation.html#in-conftest-py">In conftest.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/testing-validation.html#tests-test-integration-test-end-to-end-py">tests/test_integration/test_end_to_end.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/testing-validation.html#run-all-benchmarks">Run all benchmarks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/testing-validation.html#tests-test-benchmarks-test-controller-performance-py">tests/test_benchmarks/test_controller_performance.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/testing-validation.html#run-with-verbose-output">Run with verbose output</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/testing-validation.html#verify-pythonpath">Verify PYTHONPATH</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/how-to/testing-validation.html#identify-slow-tests">Identify slow tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/api/README.html">API Reference Guides <strong>Type:</strong> Technical Reference with Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/api/controllers.html">Controllers API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/api/simulation.html">Simulation API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/api/simulation.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/api/simulation.html#runnable-false">runnable: false</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/api/simulation.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/api/simulation.html#id2">runnable: false</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/api/simulation.html#instead-of-10000-trials">Instead of 10000 trials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/api/optimization.html">Optimization API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/api/configuration.html">Configuration API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/api/plant-models.html">Plant Models API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/api/utilities.html">Utilities API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/theory/README.html">Theory &amp; Explanation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/theory/smc-theory.html">Sliding Mode Control Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/theory/pso-theory.html">PSO Algorithm Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/theory/dip-dynamics.html">Double-Inverted Pendulum Dynamics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/workflows/pso-optimization-workflow.html">PSO Optimization Workflow Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/workflows/pso-optimization-workflow.html#test-optimized-controller">Test optimized controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/workflows/pso-optimization-workflow.html#basic-optimization">Basic optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/workflows/batch-simulation-workflow.html">Batch Simulation Workflow Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/workflows/monte-carlo-validation-quickstart.html">Monte Carlo Validation Quick Start Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/workflows/monte-carlo-validation-quickstart.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/workflows/monte-carlo-validation-quickstart.html#runnable-false-usr-bin-env-python">runnable: false #!/usr/bin/env python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/workflows/monte-carlo-validation-quickstart.html#results-in-monte-carlo-quick-test-results-csv-step-2-load-and-validate-data">Results in: monte_carlo_quick_test/results.csv # Step 2: Load and validate data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/workflows/custom-cost-functions.html">Custom Cost Functions for PSO Optimization <strong>Status:</strong> ğŸš§ Under Construction This document will contain guidance on designing custom cost functions for PSO-based controller parameter optimization. ## Planned Content ### Cost Function Design Principles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/workflows/pso-vs-grid-search.html">PSO vs Grid Search Comparison <strong>Status:</strong> ğŸš§ Under Construction This document will provide a comparison between Particle Swarm Optimization and traditional grid search methods for controller parameter tuning. ## Planned Content ### Methodology Comparison</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/workflows/pso-adaptive-smc.html">PSO Optimization for Adaptive SMC <strong>Status:</strong> ğŸš§ Under Construction This document will contain guidance on optimizing Adaptive Sliding Mode Controller parameters using Particle Swarm Optimization. ## Planned Content ### Adaptive SMC Parameter Space</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/workflows/pso-hybrid-smc.html">PSO Optimization for Hybrid Adaptive STA-SMC <strong>Status:</strong> ğŸš§ Under Construction This document will contain guidance on optimizing Hybrid Adaptive Super-Twisting SMC parameters using Particle Swarm Optimization. ## Planned Content ### Hybrid Adaptive STA-SMC Parameter Space</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/workflows/pso-sta-smc.html">PSO Optimization Guide: Super-Twisting SMC</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/workflows/hil-workflow.html">HIL (Hardware-in-the-Loop) Workflow Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/workflows/hil-production-checklist.html">HIL Production Deployment Checklist <strong>Status:</strong> ğŸš§ Under Construction This document will contain a pre-deployment checklist for production HIL systems. ## Planned Content ### Pre-Deployment Validation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/workflows/hil-safety-validation.html">HIL Safety Validation <strong>Status:</strong> ğŸš§ Under Construction This document will contain safety validation procedures for Hardware-in-the-Loop controller deployment. ## Planned Content ### Safety Validation Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/workflows/hil-multi-machine.html">Multi-Machine HIL Setup <strong>Status:</strong> ğŸš§ Under Construction This document will contain guidance on distributed Hardware-in-the-Loop architectures with multiple machines. ## Planned Content ### Architecture Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/workflows/hil-disaster-recovery.html">HIL Disaster Recovery <strong>Status:</strong> ğŸš§ Under Construction This document will contain disaster recovery procedures for Hardware-in-the-Loop production systems. ## Planned Content ### Disaster Scenarios</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guides/workflows/pso-hil-tuning.html">Controller Optimization for HIL <strong>Status:</strong> ğŸš§ Under Construction This document will contain guidance on optimizing controller parameters for Hardware-in-the-Loop (HIL) deployment using PSO. ## Planned Content ### HIL-Specific Optimization Considerations</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../tutorials/index.html">Tutorials &amp; Learning Guides</a><input aria-label="Toggle navigation of Tutorials &amp; Learning Guides" class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/02_controller_performance_comparison.html">Tutorial 02: Interactive Controller Performance Comparison</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/03_pso_optimization_deep_dive.html">Tutorial 03: PSO Optimization Deep Dive <strong>Status:</strong> Planned for Phase 7</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tutorials/03_pso_optimization_deep_dive.html#basic-pso-optimization">Basic PSO optimization</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../workflows/index.html">Workflows &amp; Integration Guides</a><input aria-label="Toggle navigation of Workflows &amp; Integration Guides" class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html">Complete Integration Workflow Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#test-each-controller-individually">Test each controller individually</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#use-pre-optimized-gains-for-immediate-results">Use pre-optimized gains for immediate results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#launch-interactive-web-interface">Launch interactive web interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#select-controller-adjust-parameters-run-simulations">Select controller, adjust parameters, run simulations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#optimize-classical-smc-gains">Optimize classical SMC gains</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#optimize-adaptive-smc-with-uncertainty">Optimize adaptive SMC with uncertainty</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#optimize-sta-smc-for-finite-time-performance">Optimize STA SMC for finite-time performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#optimize-hybrid-smc-most-sophisticated">Optimize hybrid SMC (most sophisticated)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#optimize-all-controllers-in-sequence">Optimize all controllers in sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#runnable-false-scripts-custom-batch-optimization-py">runnable: false # scripts/custom_batch_optimization.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#multi-objective-optimization-for-competing-requirements">Multi-objective optimization for competing requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#runnable-false-adaptive-pso-with-time-varying-parameters">runnable: false # Adaptive PSO with time-varying parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#run-hil-simulation">Run HIL simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#real-time-monitoring-setup">Real-time monitoring setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#distributed-control-system">Distributed control system</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#adaptive-controller-selection-based-on-performance">Adaptive controller selection based on performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#diagnose-controller-performance-problems">Diagnose controller performance problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#debug-pso-optimization-problems">Debug PSO optimization problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#continuous-system-health-monitoring">Continuous system health monitoring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/pytest_testing_workflow.html">Quick Start Guide for Running Tests <strong>Document Version</strong>: 1.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/pytest_testing_workflow.html#run-all-tests-basic-command">1. Run all tests (basic command)</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ğŸ“Š Analysis &amp; Reports</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../analysis/index.html">Analysis &amp; Technical Reports</a><input aria-label="Toggle navigation of Analysis &amp; Technical Reports" class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../analysis/COMPLETE_CONTROLLER_COMPARISON_MATRIX.html">Complete SMC Controller Comparison Matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="../analysis/COMPLETE_CONTROLLER_COMPARISON_MATRIX.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../analysis/COMPLETE_CONTROLLER_COMPARISON_MATRIX.html#runnable-false-def-select-smc-controller-requirements-decision-tree-for-smc-controller-selection-if-requirements-get-parameter-uncertainty-high-if-requirements-get-convergence-time-finite-return-hybrid-adaptive-sta-smc-best-of-both-worlds-else-return-adaptive-smc-parameter-adaptation-focus-elif-requirements-get-convergence-time-finite-if-requirements-get-chattering-tolerance-low-return-sta-smc-finite-time-smooth-control-else-return-classical-smc-fast-and-simple-elif-requirements-get-computational-resources-limited-return-classical-smc-lowest-computational-cost-elif-requirements-get-performance-priority-maximum-return-hybrid-adaptive-sta-smc-best-overall-performance-else-return-classical-smc-default-choice-for-general-use">runnable: false def select_smc_controller(requirements): â€œâ€â€Decision tree for SMC controller selection.â€â€â€ if requirements.get(â€˜parameter_uncertaintyâ€™) == â€˜highâ€™: if requirements.get(â€˜convergence_timeâ€™) == â€˜finiteâ€™: return â€˜hybrid_adaptive_sta_smcâ€™ # Best of both worlds else: return â€˜adaptive_smcâ€™ # Parameter adaptation focus elif requirements.get(â€˜convergence_timeâ€™) == â€˜finiteâ€™: if requirements.get(â€˜chattering_toleranceâ€™) == â€˜lowâ€™: return â€˜sta_smcâ€™ # Finite-time + smooth control else: return â€˜classical_smcâ€™ # Fast and simple elif requirements.get(â€˜computational_resourcesâ€™) == â€˜limitedâ€™: return â€˜classical_smcâ€™ # Lowest computational cost elif requirements.get(â€˜performance_priorityâ€™) == â€˜maximumâ€™: return â€˜hybrid_adaptive_sta_smcâ€™ # Best overall performance else: return â€˜classical_smcâ€™ # Default choice for general use</a></li>
<li class="toctree-l2"><a class="reference internal" href="../analysis/CONTROLLER_FACTORY_ANALYSIS.html"><strong>Controller Factory Integration Analysis Report</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../analysis/CONTROLLER_COVERAGE_TECHNICAL_ANALYSIS.html">Technical Coverage Analysis &amp; Implementation Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../analysis/HYBRID_SMC_FIX_TECHNICAL_DOCUMENTATION.html">Hybrid SMC Runtime Fix - Complete Technical Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../analysis/controller_memory_patterns.html">Controller Memory Patterns - Best Practices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../analysis/pso_convergence_report.html">PSO Convergence Analysis - Issue #12</a></li>
<li class="toctree-l2"><a class="reference internal" href="../analysis/COVERAGE_ANALYSIS_METHODOLOGY_FRAMEWORK.html">Coverage Analysis Methodology Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../analysis/view_conversion_recommendations.html">NumPy Copy Pattern Optimization: View Conversion Guide <strong>Issue</strong>: #16 - NumPy copy pattern analysis and optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../analysis/view_conversion_recommendations.html#check-for-new-defensive-copies-in-result-construction">Check for new defensive copies in result construction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../analysis/view_conversion_recommendations.html#tests-test-benchmarks-test-memory-regression-py">tests/test_benchmarks/test_memory_regression.py</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../reports/index.html">Technical Reports &amp; Assessments</a><input aria-label="Toggle navigation of Technical Reports &amp; Assessments" class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../reports/CODE_BEAUTIFICATION_QUALITY_REPORT.html">Code Beautification &amp; Directory Organization Specialist Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/CODE_BEAUTIFICATION_QUALITY_POLISH_REPORT.html">Code Beautification &amp; Quality Polish Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/code_beautification_optimization_report.html">Code Beautification &amp; Directory Organization Final Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/CONTROLLER_TEST_VALIDATION_REPORT.html">CONTROLLER TEST VALIDATION REPORT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/CONTROLLER_COVERAGE_ANALYSIS_REPORT.html">Control Systems Coverage Analysis Report - GitHub Issue #9 <strong>Repository:</strong> https://github.com/theSadeQ/dip-smc-pso.git</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/CONTROLLER_OPTIMIZATION_REPORT.html">ğŸ¯ CONTROLLER OPTIMIZATION PERFORMANCE REPORT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/HYBRID_SMC_CODE_QUALITY_VALIDATION_REPORT.html">HYBRID SMC CODE QUALITY VALIDATION REPORT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/HYBRID_SMC_CODE_QUALITY_VALIDATION_REPORT.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/HYBRID_SMC_CODE_QUALITY_VALIDATION_REPORT.html#runnable-false">runnable: false #=======================================================================================\</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/INTEGRATION_COORDINATOR_FINAL_VALIDATION_REPORT.html">INTEGRATION COORDINATOR FINAL VALIDATION REPORT</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/PSO_INTEGRATION_VALIDATION_REPORT.html">PSO Integration Validation Report - Hybrid SMC ## Executive Summary <strong>MISSION STATUS: âœ… COMPLETE - ALL OBJECTIVES ACHIEVED</strong> The Hybrid SMC PSO integration has been successfully validated. All four SMC controller variants now achieve optimal 0.000000 cost through PSO optimization, confirming that the Control Systems Specialistâ€™s runtime fix has resolved the integration issues. ## Validation Results ### PSO Performance Summary | Controller | PSO Status | Best Cost | Duration | Integration Status |</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/PSO_INTEGRATION_VALIDATION_REPORT.html#validated-hybrid-controller-properties">Validated hybrid controller properties:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/PSO_FACTORY_INTEGRATION_VALIDATION_REPORT.html">PSO Factory Integration Validation Report <strong>Author:</strong> PSO Optimization Engineer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/FINAL_4_CONTROLLER_INTEGRATION_VALIDATION_REPORT.html">FINAL 4-Controller Integration Validation Report <strong>Date</strong>: 2025-09-29</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/Issue_2_Resolution_Report.html">Issue #2 STA-SMC Overshoot Resolution Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/GITHUB_ISSUE_6_RESOLUTION_REPORT.html">ğŸ¯ GITHUB ISSUE #6 FACTORY INTEGRATION COMPLETE RESOLUTION</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/GITHUB_ISSUE_6_FINAL_INTEGRATION_VALIDATION_REPORT.html">GitHub Issue #6 Final Integration Validation Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/GITHUB_ISSUE_6_FACTORY_INTEGRATION_VALIDATION_FINAL_REPORT.html">GitHub Issue #6 Factory Integration - Final Validation Report <strong>INTEGRATION COORDINATOR - Cross-Domain Validation Results</strong> ## Executive Summary GitHub Issue #6 Factory Integration has achieved <strong>92.0% system health</strong> with <strong>GREEN deployment status</strong>. The factory pattern integration with PSO optimization is production-ready with only minor configuration refinements needed. ### Key Achievements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/GITHUB_ISSUE_6_FACTORY_INTEGRATION_VALIDATION_FINAL_REPORT.html#verified-components">Verified Components:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/GITHUB_ISSUE_8_DOCUMENTATION_EXPERT_FINAL_REPORT.html">GitHub Issue #8 - Documentation Expert Mission: COMPLETED âœ… <strong>Mission Authority</strong>: Documentation Expert Agent (5th Specialist)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/GITHUB_ISSUE_HYBRID_SMC_RESOLUTION_REPORT.html">GitHub Issue: Hybrid SMC Resolution Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/FACTORY_SYSTEM_ANALYSIS_REPORT.html">Factory System Analysis Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/FACTORY_BEAUTIFICATION_OPTIMIZATION_REPORT.html">Factory System Code Beautification &amp; Optimization Report <strong>Generated:</strong> 2025-09-28</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/FACTORY_BEAUTIFICATION_OPTIMIZATION_REPORT.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/FACTORY_BEAUTIFICATION_OPTIMIZATION_REPORT.html#runnable-false">runnable: false #==========================================================================================\</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/DOCUMENTATION_EXPERT_TECHNICAL_ASSESSMENT_REPORT.html">Technical Documentation Quality Assessment Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/docs_visual_audit_report.html">ğŸ“¸ Documentation Visual Audit Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/PSO_OPTIMIZATION_ENGINEER_COMPREHENSIVE_ANALYSIS_REPORT.html">PSO OPTIMIZATION ENGINEER: Parameter Tuning Analysis Report <strong>Mission</strong>: PSO Optimization Framework Validation &amp; Parameter Tuning Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/PRODUCTION_READINESS_ASSESSMENT_FINAL.html">Production Readiness Assessment - Final Framework Update</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/PRODUCTION_READINESS_ASSESSMENT_FINAL.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reports/PRODUCTION_READINESS_ASSESSMENT_FINAL.html#runnable-false-def-calculate-production-readiness-v3-enhanced-production-readiness-calculation-with-hybrid-smc-fix-validation-components-core-system-components-weight-30-mathematical-algorithms-score-10-0-weight-0-15-status-all-4-smc-controllers-fully-operational-evidence-100-controller-availability-perfect-pso-optimization-runtime-stability-score-10-0-weight-0-15-status-zero-runtime-errors-error-handling-evidence-complete-hybrid-smc-fix-validation-integration-components-weight-25-pso-integration-score-10-0-weight-0-125-status-perfect-optimization-across-all-controllers-evidence-0-000000-cost-achievement-for-all-4-controllers-factory-integration-score-10-0-weight-0-125-status-complete-controller-factory-operational-evidence-100-creation-success-rate-cross-compatibility-quality-assurance-weight-25-code-quality-score-9-5-weight-0-10-status-enhanced-with-type-safety-and-error-handling-evidence-ascii-headers-type-hints-validation-testing-coverage-score-9-5-weight-0-10-status-validation-framework-evidence-95-coverage-integration-tests-pso-validation-documentation-score-9-5-weight-0-05-status-complete-technical-documentation-evidence-troubleshooting-guides-api-docs-user-guides-deployment-readiness-weight-20-configuration-management-score-9-0-weight-0-10-status-yaml-validation-and-parameter-management-evidence-schema-validation-bounds-checking-error-handling-deployment-infrastructure-score-9-0-weight-0-10-status-production-deployment-guidelines-evidence-ci-cd-integration-monitoring-scaling-readiness-total-score-sum-comp-score-comp-weight-for-comp-in-components-values-weighted-average-total-score-sum-comp-weight-for-comp-in-components-values-return-overall-score-round-weighted-average-1-components-components-grade-a-if-weighted-average-9-0-else-a-if-weighted-average-8-0-else-b-result-9-5-10-a-grade">runnable: false def calculate_production_readiness_v3(): â€œâ€â€Enhanced production readiness calculation with hybrid SMC fix validation.â€â€â€ components = { # Core System Components (Weight: 30%) â€˜mathematical_algorithmsâ€™: { â€˜scoreâ€™: 10.0, â€˜weightâ€™: 0.15, â€˜statusâ€™: â€˜All 4 SMC controllers fully operationalâ€™, â€˜evidenceâ€™: â€˜100% controller availability, perfect PSO optimizationâ€™ }, â€˜runtime_stabilityâ€™: { â€˜scoreâ€™: 10.0, â€˜weightâ€™: 0.15, â€˜statusâ€™: â€˜Zero runtime errors, error handlingâ€™, â€˜evidenceâ€™: â€˜Complete hybrid SMC fix, validationâ€™ }, # Integration Components (Weight: 25%) â€˜pso_integrationâ€™: { â€˜scoreâ€™: 10.0, â€˜weightâ€™: 0.125, â€˜statusâ€™: â€˜Perfect optimization across all controllersâ€™, â€˜evidenceâ€™: â€˜0.000000 cost achievement for all 4 controllersâ€™ }, â€˜factory_integrationâ€™: { â€˜scoreâ€™: 10.0, â€˜weightâ€™: 0.125, â€˜statusâ€™: â€˜Complete controller factory operationalâ€™, â€˜evidenceâ€™: â€˜100% creation success rate, cross-compatibilityâ€™ }, # Quality Assurance (Weight: 25%) â€˜code_qualityâ€™: { â€˜scoreâ€™: 9.5, â€˜weightâ€™: 0.10, â€˜statusâ€™: â€˜Enhanced with type safety and error handlingâ€™, â€˜evidenceâ€™: â€˜ASCII headers, type hints, validationâ€™ }, â€˜testing_coverageâ€™: { â€˜scoreâ€™: 9.5, â€˜weightâ€™: 0.10, â€˜statusâ€™: â€˜validation frameworkâ€™, â€˜evidenceâ€™: â€˜95%+ coverage, integration tests, PSO validationâ€™ }, â€˜documentationâ€™: { â€˜scoreâ€™: 9.5, â€˜weightâ€™: 0.05, â€˜statusâ€™: â€˜Complete technical documentationâ€™, â€˜evidenceâ€™: â€˜Troubleshooting guides, API docs, user guidesâ€™ }, # Deployment Readiness (Weight: 20%) â€˜configuration_managementâ€™: { â€˜scoreâ€™: 9.0, â€˜weightâ€™: 0.10, â€˜statusâ€™: â€˜YAML validation and parameter managementâ€™, â€˜evidenceâ€™: â€˜Schema validation, bounds checking, error handlingâ€™ }, â€˜deployment_infrastructureâ€™: { â€˜scoreâ€™: 9.0, â€˜weightâ€™: 0.10, â€˜statusâ€™: â€˜Production deployment guidelinesâ€™, â€˜evidenceâ€™: â€˜CI/CD integration, monitoring, scaling readinessâ€™ } } total_score = sum(comp[â€˜scoreâ€™] * comp[â€˜weightâ€™] for comp in components.values()) weighted_average = total_score / sum(comp[â€˜weightâ€™] for comp in components.values()) return { â€˜overall_scoreâ€™: round(weighted_average, 1), â€˜componentsâ€™: components, â€˜gradeâ€™: â€˜A+â€™ if weighted_average &gt;= 9.0 else â€˜Aâ€™ if weighted_average &gt;= 8.0 else â€˜B+â€™ } # Result: 9.5/10 (A+ Grade)</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ğŸ—ºï¸ Project Planning &amp; Roadmaps</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../plans/index.html">Project Planning &amp; Roadmaps</a><input aria-label="Toggle navigation of Project Planning &amp; Roadmaps" class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../plans/citation_system/00_master_roadmap.html">Citation System Implementation - Master Roadmap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/citation_system/01_initial_analysis.html">Citation System - Initial Analysis &amp; Problem Decomposition</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/citation_system/02_phase1_claim_extraction.html">Phase 1: Claim Extraction Infrastructure - Detailed Implementation Plan</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/citation_system/03_phase2_ai_research.html">Citation System - Phase 2: AI Research Automation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/citation_system/04_phase3_citation_integration.html">Citation System - Phase 3: Citation Integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/citation_system/05_phase4_validation_quality.html">Citation System - Phase 4: Validation &amp; Quality Assurance <strong>Document Version:</strong> 1.0.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/citation_system/06_phase5_final_review.html">Citation System - Phase 5: Final Review &amp; Publication Preparation <strong>Document Version:</strong> 1.0.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/citation_system/06_phase5_final_review.html#academic-integrity-statement-this-documentation-system-adheres-to-the-highest-standards-of-academic-integrity-attribution">Academic Integrity Statement This documentation system adheres to the highest standards of academic integrity: ## Attribution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/citation_system/phase2_ai_enhancement_guide.html">Phase 2: AI-Enhanced Research Pipeline - User Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/citation_system/phase2_execution_guide.html">Phase 2 Execution Guide - HIGH &amp; MEDIUM Batch Research <strong>Document Version:</strong> 1.0.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/citation_system/week_1_2_critical_batch_completion.html">Week 1-2 Completion Report: CRITICAL Batch Research <strong>Document Version:</strong> 1.0.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/documentation/README.html">Complete Codebase Documentation Plan <strong>Project</strong>: Double Inverted Pendulum Sliding Mode Control with PSO Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/documentation/week_1_foundation_automation.html">Week 1: Foundation &amp; Automation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/documentation/week_1_completion_report.html">Week 1 Completion Report <strong>Date</strong>: October 3, 2025</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/documentation/week_1_quality_analysis.html">Week 1 Quality Analysis <strong>Date</strong>: October 3, 2025</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/documentation/week_2_controllers_module.html">Week 2: Controllers Module Documentation Plan <strong>Status</strong>: ğŸš§ In Progress</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/documentation/week_2_completion_summary.html">Week 2 Controllers Module Documentation - Completion Summary <strong>Project:</strong> DIP_SMC_PSO Documentation Enhancement</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/documentation/week_3_optimization_simulation.html">Week 3: Optimization &amp; Simulation Modules - Complete Documentation Plan <strong>Project:</strong> DIP_SMC_PSO Documentation Enhancement</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/documentation/week_4_completion_summary.html">Week 4 Documentation Completion Summary <strong>Documentation Sprint: Advanced Controllers</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/documentation/week_5_completion_summary.html">Week 5 Documentation Completion Summary <strong>Completion Date</strong>: 2025-10-04</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/documentation/week_7_architecture_diagrams.html">Week 7: Architecture Diagrams Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/documentation/phase_2_metrics_report.html">Phase 2 Documentation Metrics Report <strong>Generated:</strong> October 4, 2025</a></li>
<li class="toctree-l2"><a class="reference internal" href="../plans/orchestration/ci_agent_framework.html">CI Agent Orchestration Framework</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ğŸš€ Production &amp; Deployment</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../production/index.html">Production Deployment</a><input aria-label="Toggle navigation of Production Deployment" class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../production/production_readiness_assessment_v2.html">Production Readiness Assessment v2.0 <strong>Date</strong>: 2025-09-29</a></li>
<li class="toctree-l2"><a class="reference internal" href="../production_readiness_final.html">Production Readiness Assessment - Final Report <strong>Date:</strong> 2025-09-29</a></li>
<li class="toctree-l2"><a class="reference internal" href="../production_readiness_framework.html">Production Readiness Assessment Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../production_documentation_summary.html">Production Documentation Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../deployment/DEPLOYMENT_GUIDE.html">ğŸš€ Sphinx Documentation System - Deployment Guide ## âœ… System Successfully Deployed! Your production-grade Sphinx documentation system is now <strong>ready for use</strong>. All expert recommendations have been implemented and the system has been committed to your repository. ## ğŸ“‹ Next Steps for Activation ### 1. GitHub Repository Settings To activate the documentation system, configure these GitHub settings: #### <strong>GitHub Pages:</strong></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ğŸ“½ï¸ Presentation Materials</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../presentation/index.html">Research Presentation Materials</a><input aria-label="Toggle navigation of Research Presentation Materials" class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" role="switch" type="checkbox"/><label for="toctree-checkbox-13"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../presentation/introduction.html">Abstract This project presents a holistic software framework for the automated design and validation of robust nonlinear controllers. By synergizing sliding mode control (SMC) with particle swarm optimization (PSO), the framework delivers a toolchain to solve the canonical double inverted pendulum problem. It integrates multiple controller architectures, a dualâ€‘model simulation environment, an interactive commandâ€‘line interface and a webâ€‘based dashboard, a lightweight fault detection module and networked hardwareâ€‘inâ€‘theâ€‘loop testing. Together, these components bridge the gap between theoretical controller design and practical deployment, illustrating a generalizable methodology for the robust control of complex nonlinear systems.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../presentation/problem-statement.html">Problem Statement</a></li>
<li class="toctree-l2"><a class="reference internal" href="../presentation/previous-works.html">Previous Work Before the Project</a></li>
<li class="toctree-l2"><a class="reference internal" href="../presentation/system-modeling.html"><strong>A Technical Report on the Modeling and Configuration of a Cartâ€‘Based Double Inverted Pendulum System</strong> ### <strong>Introduction</strong> #### <strong>Purpose and Scope</strong> This report provides a theoretical and practical foundation for modelling and controlling a cartâ€‘based double inverted pendulum (DIP) system[1]. The goal is to deliver a selfâ€‘contained guide for control systems engineers working with Pythonâ€‘based simulations[1]. The document derives the nonlinear equations of motion from first principles, enumerates all required physical, simulation and controller parameters, and proposes a formal configuration schema. Where appropriate, the report crossâ€‘references the accompanying project files (particularly the highâ€‘fidelity implementation in <code class="docutils literal notranslate"><span class="pre">src/core/dynamics.py</span></code> and the configuration file <code class="docutils literal notranslate"><span class="pre">config.yaml</span></code>) to ensure applicability to real simulation code <code class="docutils literal notranslate"><span class="pre">DIP_SMC_PSO/src/core/dynamics.py</span></code> <code class="docutils literal notranslate"><span class="pre">DIP_SMC_PSO/config.yaml</span></code>. #### <strong>The Double Inverted Pendulum as a Benchmark Problem</strong> A double inverted pendulum consists of two pendulums attached in series to a cart. The second pendulum is attached to the end of the first, so the system has three degrees of freedom: the cart position and the two pendulum angles. Only one actuator applies a horizontal force to the cart, making the system underactuated; there is one control input for three state variables. Control of such a system is challenging because it is inherently unstable and will fall over unless stabilised [1]. Classical control literature emphasises that the DIPCâ€™s single actuator must regulate three degrees of freedom, making the system underactuated[1]. The double inverted pendulum also exhibits chaotic dynamics. The motion is governed by coupled ordinary differential equations that display strong sensitivity to initial conditions[2]. Small changes in starting state can lead to vastly different trajectories, so an accurate nonlinear model is essential for control design. These properties make the DIP a popular benchmark for advanced control strategies, including slidingâ€‘mode control, optimal control and reinforcement learning. #### <strong>Methodology</strong> The dynamic model is derived using Lagrangian mechanics, an energyâ€‘based formulation widely used for openâ€‘chain robots and underactuated systems [3]. In this approach the kinetic and potential energies of each component are computed and combined to form the Lagrangian L=Tâˆ’VL = T - V. The Eulerâ€“Lagrange equations are then applied to obtain the equations of motion (EOM). For the double inverted pendulum, the Lagrangian is the difference between the sum of kinetic energies and the sum of gravitational potentials [1]. The resulting nonlinear secondâ€‘order differential equations are transformed into a stateâ€‘space form suitable for control design. The derived model is validated by comparing with the highâ€‘fidelity implementation in the accompanying Python project (<code class="docutils literal notranslate"><span class="pre">DoubleInvertedPendulum</span></code> class), ensuring that parameter names and units match those in <code class="docutils literal notranslate"><span class="pre">config.yaml</span></code>. â€”â€” ## <strong>Section 1: System Dynamics and Mathematical Modeling</strong> ### <strong>1.1 System Definition, Assumptions, and Nomenclature</strong> #### <strong>System Diagram</strong> The double inverted pendulum on a cart comprises a cart of mass mcm_{c} that translates horizontally on a track. Two rigid pendulum links are attached in series; the first link (mass m1m_{1}, length l1l_{1}) is pinned to the cart and the second link (mass m2m_{2}, length l2l_{2}) is attached to the end of the first. The centres of mass of the links are located at distances lc1l_{c1} and lc2l_{c2} from their respective pivots. Angles Î¸1\theta_{1} and Î¸2\theta_{2} are measured from the upward vertical, and the horizontal displacement of the cart is xx. Gravity acts downward with acceleration gg. A horizontal force uu applied to the cart constitutes the single control input. A schematic of the system is shown in Figure 1[1].  #### <strong>Model Assumptions</strong> 1. <strong>Rigid links.</strong> Each pendulum link is treated as a rigid body with constant mass and moment of inertia. There is no flexural deformation[1].</a></li>
<li class="toctree-l2"><a class="reference internal" href="../presentation/smc-theory.html">Sliding Mode Control for a Doubleâ€‘Inverted Pendulum: Bridging Theory and Implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../presentation/chattering-mitigation.html">Chattering Mitigation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../presentation/pso-optimization.html"><strong>Simulation Analysis and Enhancements for the Double Inverted Pendulum Control System</strong> ## 1Â Introduction and Background The doubleâ€‘inverted pendulum (DIP) consists of two slender rigid links mounted on a cart that can move along a horizontal rail. Each link is hinged at its base and is inherently unstable in the upright position, so even small disturbances will cause it to fall. The control objective is to keep the cart at a desired position (usually the origin) while balancing both pendulums upright. The project implements a <strong>classical slidingâ€‘mode controller (SMC)</strong>, a robust control strategy that forces the system state onto a userâ€‘defined switching surface and maintains it there despite matched uncertainties and disturbances[1]. The controller defines a <strong>sliding surface</strong> \sigma = \lambda_{1}\theta_{1} + \lambda_{2}\theta_{2} + k_{1}{\dot{\theta}}<em>{1} + k</em>{2}{\dot{\theta}}<em>{2} where $<code class="docutils literal notranslate"><span class="pre">\theta_{1}</span></code>$ and $<code class="docutils literal notranslate"><span class="pre">\theta_{2}</span></code>$ are the pendulum angles and $<code class="docutils literal notranslate"><span class="pre">{\dot{\theta}}_{1}</span></code>$, $<code class="docutils literal notranslate"><span class="pre">{\dot{\theta}}_{2}</span></code>$ are their rates. When $<code class="docutils literal notranslate"><span class="pre">\sigma</span> <span class="pre">=</span> <span class="pre">0</span></code>$ the system behaves like a reducedâ€‘order linear system that drives the pendulum angles and velocities to zero. As in standard SMC design the control law combines an <strong>equivalent control</strong> term (obtained by canceling the nominal dynamics) and a <strong>robust control</strong> term that forces the system to reach and stay on the sliding surface[1]: \ u = u_{\mathrm{eq}} - K\mathrm{sat}\Bigl(\tfrac{\sigma}{\epsilon}\Bigr) - k_{\mathrm{d}}\sigma \ Here $<code class="docutils literal notranslate"><span class="pre">sat(</span> <span class="pre">\cdot</span> <span class="pre">)</span></code>$ is a continuous approximation of the discontinuous $<code class="docutils literal notranslate"><span class="pre">sign</span></code>$ function. Classical SMC uses a discontinuous $<code class="docutils literal notranslate"><span class="pre">\mathrm{sign}(\sigma)</span></code>$ which produces highâ€‘frequency chattering. A common remedy is to introduce a boundary layer and replace $<code class="docutils literal notranslate"><span class="pre">\mathrm{sign}(\sigma)</span></code>$ with a smooth saturation function such as the hyperbolic tangent[2]. In the provided code the <code class="docutils literal notranslate"><span class="pre">saturate</span></code> utility chooses between a hyperbolic tangent and a linear saturation: def saturate(sigma: float | ndarray, epsilon: float, method: str = â€œtanhâ€): # Continuous approximation of sign(sigma) within a boundary layer s = np.asarray(sigma, dtype=float) / epsilon if method == â€œtanhâ€: return np.tanh(s) elif method == â€œlinearâ€: return np.clip(s, -1.0, 1.0) The parameter $<code class="docutils literal notranslate"><span class="pre">\epsilon</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>$ defines a <strong>boundary layer</strong> that mitigates chattering by smoothing the switching action[2]. As $<code class="docutils literal notranslate"><span class="pre">\epsilon</span> <span class="pre">\rightarrow</span> <span class="pre">0</span></code>$ the saturation approximates the discontinuous $<code class="docutils literal notranslate"><span class="pre">\mathrm{sign}</span></code>$ function, whereas increasing $<code class="docutils literal notranslate"><span class="pre">\epsilon</span></code>$ yields smoother control at the expense of convergence speed[3]. The baseline controller sets $<code class="docutils literal notranslate"><span class="pre">\epsilon</span> <span class="pre">=</span> <span class="pre">0.02</span></code>$ and uses the hyperbolic tangent method, consistent with improved power reaching laws that use smooth saturation functions to reduce chattering[2]. ## 2Â Simulation Framework Challenges ### 2.1Â Numerical stiffness from discontinuous control Slidingâ€‘mode control uses highâ€‘gain feedback and discontinuous switching to force states onto the sliding surface[1]. In practice the boundary layer smooths the discontinuity, but for small $<code class="docutils literal notranslate"><span class="pre">\epsilon</span></code>$ the rightâ€‘hand side still exhibits very steep gradients. The dynamics of the DIP combine slow cart motion with fast pendulum oscillations and fast switching in the control law. This results in <strong>stiff differential equations</strong>: the solver must resolve both slow and very fast dynamics simultaneously. Explicit fixedâ€‘step integrators (such as Euler or fourthâ€‘order Rungeâ€“Kutta) cannot safely integrate such systems because large steps lead to oscillations or divergence, whereas very small steps yield high computational cost. Implicit stiff solvers are therefore preferred for systems with multiple time scales[4]. ### 2.2Â Limitations of the fixedâ€“step simulation The original simulation loop employed a fixed time step $<code class="docutils literal notranslate"><span class="pre">dt</span> <span class="pre">=</span> <span class="pre">0.01\,\text{s}</span></code>$ and integrated the dynamics using a handâ€‘coded RK4 method in <code class="docutils literal notranslate"><span class="pre">dynamics.DoubleInvertedPendulum.step</span></code>. With the baseline SMC gains the system was highly unstable for anything other than tiny initial angles. Even when the step was reduced to 0.001Â s, the integration frequently diverged because the solver could not adapt to the stiff dynamics near the switching surface. Moreover, because the control law computes a modelâ€‘based equivalent control <code class="docutils literal notranslate"><span class="pre">u_eq</span></code> by inverting the inertia matrix, numerical singularities or large condition numbers can appear during integration. The controller code detects nearâ€‘singular matrices and returns zero to preserve stability, but the resulting abrupt change in torque further stiffens the problem. ### 2.3Â Need for adaptive stiff integrators The <strong>SciPy</strong> routine <code class="docutils literal notranslate"><span class="pre">solve_ivp</span></code> provides a suite of adaptive methods that adjust the step size to meet prescribed error tolerances. Explicit methods like <code class="docutils literal notranslate"><span class="pre">RK45</span></code> are efficient for nonâ€‘stiff systems, while implicit methods such as the <strong>Backward Differentiation Formula (BDF)</strong> or <strong>Radau</strong> are recommended for stiff problems. Implicit BDF methods suffer from an order barrierâ€”orders above five are unstableâ€”whereas Radau IIA schemes are Aâ€‘stable and Lâ€‘stable at arbitrary order, providing large stability regions for stiff systems[4][5]. For our system, preliminary experiments showed that <code class="docutils literal notranslate"><span class="pre">RK45</span></code> took extremely small steps and failed to converge, whereas <code class="docutils literal notranslate"><span class="pre">Radau</span></code> handled the stiff sliding dynamics more robustly. A robust simulation loop therefore employs <code class="docutils literal notranslate"><span class="pre">solve_ivp</span></code> with an adaptive stiff integrator: from scipy.integrate import solve_ivp def dip_ode(t, x, controller, dyn): # x = [x, theta1, theta2, xdot, dtheta1, dtheta2] u, <em>, _ = controller.compute_control(x, (), {}) dxdt = dyn.rhs(x, u) return dxdt sol = solve_ivp( lambda t, y: dip_ode(t, y, smc_controller, pendulum), t_span=(0.0, T), y0=x0, method=â€™Radauâ€™, atol=1e-8, rtol=1e-6, max_step=0.01, ) The solver automatically reduces the step size near steep gradients and increases it when the dynamics slow down, yielding accurate trajectories with fewer function evaluations. ## 3Â Proposed Enhancements and Methodology ### 3.1Â Adaptive integrators and event handling Switching to adaptive stiff solvers addresses the numerical instability observed with fixedâ€‘step methods. <strong>Event functions</strong> can be added to <code class="docutils literal notranslate"><span class="pre">solve_ivp</span></code> to halt integration if the pendulum angles exceed safe limits (e.g., $<code class="docutils literal notranslate"><span class="pre">\left|</span> <span class="pre">\theta_{i}</span> <span class="pre">\right|</span> <span class="pre">&gt;</span> <span class="pre">\pi/2</span></code>$ ). By terminating unstable simulations early we avoid wasting computational effort and can classify initial states as failures. The integrator parameters $<code class="docutils literal notranslate"><span class="pre">\text{rtol}</span> <span class="pre">=</span> <span class="pre">10^{-</span> <span class="pre">6}</span></code>$ , $<code class="docutils literal notranslate"><span class="pre">\text{atol}</span> <span class="pre">=</span> <span class="pre">10^{-</span> <span class="pre">8}</span></code>$ and $<code class="docutils literal notranslate"><span class="pre">\text{max\_step}</span> <span class="pre">=</span> <span class="pre">0.01\,\text{s}</span></code>$ were found to balance accuracy and speed in the stiff regime. ### 3.2Â Chattering mitigation via boundary layer The discontinuous <code class="docutils literal notranslate"><span class="pre">sign()</span></code> function in the baseline SMC produces highâ€‘frequency chatter[1]. Introducing a <strong>boundary layer</strong> smooths the switching term so that the control becomes u</em>{robust} = - K, sat\left( \frac{\sigma}{\epsilon} \right) - k</em>{d}\sigma, where $<code class="docutils literal notranslate"><span class="pre">sat\left(</span> <span class="pre">\frac{\sigma}{\epsilon}</span> <span class="pre">\right)</span></code>$ is either $<code class="docutils literal notranslate"><span class="pre">\tanh(\sigma/\epsilon)</span></code>$ or $<code class="docutils literal notranslate"><span class="pre">clip(\sigma/\epsilon,</span> <span class="pre">-1,1)</span></code>$. The derivative term $<code class="docutils literal notranslate"><span class="pre">-</span> <span class="pre">k_{d}\sigma</span></code>$ further damps sliding dynamics. Choosing $<code class="docutils literal notranslate"><span class="pre">\epsilon</span></code>$ too small leads to chattering; increasing $<code class="docutils literal notranslate"><span class="pre">\epsilon</span></code>$ reduces chattering but slows convergence[3]. Simulation results show that $<code class="docutils literal notranslate"><span class="pre">\epsilon</span> <span class="pre">=</span> <span class="pre">0.02</span></code>$ provides a good compromise for the DIP. Adaptive boundary layers can also be implemented to widen $<code class="docutils literal notranslate"><span class="pre">\epsilon</span></code>$ when $<code class="docutils literal notranslate"><span class="pre">\sigma</span></code>$ is large and tighten it near the origin, as suggested in improved powerâ€‘reaching laws for slidingâ€‘mode control[2]. ### 3.3Â Filtering noisy measurements In practice sensors introduce noise that can drive the controller and cause chattering. Two complementary filters are proposed: 1. <strong>Moving average filter.</strong> A simple moving average computes the unweighted mean of the last $<code class="docutils literal notranslate"><span class="pre">k</span></code>$ samples. For a sequence $<code class="docutils literal notranslate"><span class="pre">p_{1},p_{2},\ldots,p_{n}</span></code>$ the mean over the last $<code class="docutils literal notranslate"><span class="pre">k</span></code>$ samples is Â  {SMA}<em>{k} = \frac{p</em>{n - k + 1} + p_{n - k + 2} + \cdots + p_{n}}{k} = \frac{1}{k}\sum_{i = n - k + 1}^{n}p_{i},, Smoothing filters such as the moving average reduce highâ€‘frequency noise by averaging neighbouring points[6]. In functional nearâ€‘infrared spectroscopy data processing, the moving average filter replaces the value at each point with the average of neighbouring data points, thereby reducing highâ€‘frequency fluctuations[7]. Applying an SMA to measured angles smooths highâ€‘frequency noise but introduces a delay proportional to $<code class="docutils literal notranslate"><span class="pre">k/2</span></code>$. Choosing $<code class="docutils literal notranslate"><span class="pre">k</span></code>$ between 3 and 7 samples at a <strong>100Â Hz</strong> (10Â ms) sampling rate offers a good compromise between smoothing and latency. 1. <strong>Kalman filter.</strong> The Kalman filter models the system in discrete stateâ€“space form $<code class="docutils literal notranslate"><span class="pre">x_{k</span> <span class="pre">+</span> <span class="pre">1}</span> <span class="pre">=</span> <span class="pre">Fx_{k}</span> <span class="pre">+</span> <span class="pre">Bu_{k}</span> <span class="pre">+</span> <span class="pre">w_{k}</span></code>$ and $<code class="docutils literal notranslate"><span class="pre">y_{k}</span> <span class="pre">=</span> <span class="pre">Hx_{k}</span> <span class="pre">+</span> <span class="pre">v_{k}</span></code>$ . It recursively performs a <strong>prediction</strong> and <strong>update</strong> step. The prediction step computes the aâ€‘priori state and covariance Â  {\widehat{x}}<em>{k|k - 1} = F</em>{k}{\widehat{x}}<em>{k - 1|k - 1} + B</em>{k}u_{k},\quad P_{k|k - 1} = F_{k}P_{k - 1|k - 1}F_{k}^{\mathsf{T}} + Q_{k} and the update step incorporates the measurement $<code class="docutils literal notranslate"><span class="pre">z_{k}</span></code>$ using the Kalman gain $<code class="docutils literal notranslate"><span class="pre">K_{k}</span></code>$ K_{k} = P_{k|k - 1}H_{k}^{\mathsf{T}}S_{k}^{- 1},\quad{\widehat{x}}<em>{k|k} = {\widehat{x}}</em>{k|k - 1} + K_{k}\left( z_{k} - H_{k}{\widehat{x}}<em>{k|k - 1} \right),\quad P</em>{k|k} = \left( I - K_{k}H_{k} \right)P_{k|k - 1}, where $<code class="docutils literal notranslate"><span class="pre">S_{k}</span> <span class="pre">=</span> <span class="pre">H_{k}P_{k|k</span> <span class="pre">-</span> <span class="pre">1}H_{k}^{\mathsf{T}}</span> <span class="pre">+</span> <span class="pre">R_{k}</span></code>$ is the innovation covariance. Under the assumption that the process and measurement noise are independent, white and Gaussian, the Kalman filter provides an optimal linear estimator[8][9]. It can be interpreted as computing the aâ€‘posteriori state estimate as a linear combination of the prediction and the measurement residual, with the Kalman gain weighting how much trust is placed in the measurement[10][11]. The innovation sequence (measurement residual) is the difference between the actual measurement and its prediction and has zero mean with covariance equal to $<code class="docutils literal notranslate"><span class="pre">S_{k}</span></code>$[12]. The magnitude of the Kalman gain reflects the relative confidence in the model and measurements: a large gain corresponds to precise measurements and uncertain predictions, whereas a small gain arises when predictions are more reliable[11]. ### 3.4Â Improved PSO cost function The particle swarm optimisation (PSO) routine tunes the six gains $<code class="docutils literal notranslate"><span class="pre">\left\lbrack</span> <span class="pre">k_{1},k_{2},\lambda_{1},\lambda_{2},K,k_{d}</span> <span class="pre">\right\rbrack</span></code>$ to minimise a cost function. PSO is a populationâ€‘based metaheuristic inspired by the collective behaviour of bird flocks: each particle (candidate solution) remembers its best previous position and is attracted toward the best position found by the entire swarm. Velocities are updated using cognitive and social weights with random coefficients, and positions are updated accordingly. Because the algorithm does not rely on gradients it can be applied to a wide range of optimisation problems and has spawned numerous variations[13][14]. The cost is computed from the simulated trajectory using weighted integrals: J = w_{e} \cdot \frac{1}{N_{e}}\int_{0}^{T} \parallel x(t) \parallel^{2}dt\mspace{6mu} + w_{u} \cdot \frac{1}{N_{u}}\int_{0}^{T}u(t)^{2}dt\mspace{6mu} + w_{\dot{u}} \cdot \frac{1}{N_{\dot{u}}}\int_{0}^{T}\dot{u}(t)^{2}dt\mspace{6mu} + w_{\sigma} \cdot \frac{1}{N_{\sigma}}\int_{0}^{T}\sigma(t)^{2}dt\mspace{6mu} + w_{stab} \cdot \frac{T - t_{fail}}{T} \cdot P_{penalty}. The first term (state error) penalises deviations of cart position and pendulum angles from zero. The second and third terms penalise large control efforts and large control slews, reflecting actuator limitations. The fourth term penalises large sliding surface values, encouraging the system to converge quickly onto the sliding manifold. The last term applies a penalty if the simulation fails before the full duration, with the penalty proportional to how early the failure occurs. In the provided configuration the weights are $<code class="docutils literal notranslate"><span class="pre">w_{e}</span> <span class="pre">=</span> <span class="pre">50</span></code>$ , $<code class="docutils literal notranslate"><span class="pre">w_{u}</span> <span class="pre">=</span> <span class="pre">0.2</span></code>$ , $<code class="docutils literal notranslate"><span class="pre">w_{\dot{u}}</span> <span class="pre">=</span> <span class="pre">0.1</span></code>$ , $<code class="docutils literal notranslate"><span class="pre">w_{\sigma}</span> <span class="pre">=</span> <span class="pre">0.1</span></code>$ and the penalty constant $<code class="docutils literal notranslate"><span class="pre">P_{penalty}</span> <span class="pre">=</span> <span class="pre">1000</span></code>$ . Each integral is normalised by an empirically chosen constant $<code class="docutils literal notranslate"><span class="pre">N_{e},N_{u},N_{\dot{u}},N_{\sigma}</span></code>$ to make the contributions comparable. ### 3.5Â Regionâ€‘ofâ€‘attraction mapping To quantify the controllerâ€™s basin of attraction we systematically sample initial conditions. For each pair of initial angles $<code class="docutils literal notranslate"><span class="pre">\theta_{1}(0),\theta_{2}(0)</span></code>$ (with zero velocities and cart position) we integrate the system until the final time or until either pendulum angle exceeds $<code class="docutils literal notranslate"><span class="pre">0.5\pi</span></code>$ radians. A simulation is labelled a <strong>success</strong> if the final angles are within Â±0.05Â rad and velocities are within Â±0.05Â rad/s of zero. We visualise the results by colouring successful and unsuccessful initial conditions in the plane. SectionÂ 5 presents the resulting region of attraction (RoA). ### 3.6Â MonteÂ Carlo robustness analysis In dynamical systems theory the <strong>region of attraction</strong> (also called the domain of attraction) is the set of initial conditions whose trajectories converge to an equilibrium. For an asymptotically stable system this region is an open, invariant set containing the equilibrium; Lyapunov functions are commonly used to estimate its extent[4]. While the cost function includes a penalty for early failure, it evaluates performance only at nominal or lightly perturbed parameters. To assess robustness under uncertainty we perform a <strong>MonteÂ Carlo</strong> study. MonteÂ Carlo simulation is a universal numerical method that evaluates the behaviour of complex systems by repeatedly sampling random inputs; it is prized for its accuracy and flexibility but its chief disadvantage is the heavy computational cost due to the large number of simulations required[15]. By drawing parameter and initial condition samples from specified distributions and integrating the dynamics for each draw we approximate the probability of success and characterise the distribution of performance metrics. The standard error of MonteÂ Carlo estimates decreases with the square root of the number of simulations, and the results can be presented as probability distributions, reliability estimates or confidence intervals[16]. The procedure adopted here is as follows: 1. <strong>Define parameter distributions.</strong> For each physical parameter (mass, length, inertia, friction) we assume a uniform distribution within Â±5Â % of the nominal value.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../presentation/simulation-setup.html">Particle Swarm Optimization for Slidingâ€‘Mode Controller Tuning of a Double Inverted Pendulum ## Introduction The <strong>double inverted pendulum (DIP)</strong> mounted on a translating cart is a widely used benchmark for nonlinear and underactuated control. The system contains two serial pendulums that must be maintained upright while the cart remains near the origin. Due to the underactuation and the coupling between the pendulums and the cart, the dynamics are highly nonlinear and possess multiple unstable equilibrium points, so stabilisation requires a carefully designed controller. <strong>Slidingâ€‘mode control (SMC)</strong> is a nonlinear control technique that uses a discontinuous control law to force the state trajectories onto a prescribed sliding surface. Once on the surface, the system evolution is insensitive to matched disturbances and model uncertainties, which endows SMC with strong robustness[1][2]. However, the discontinuous control input introduces highâ€‘frequency switching, known as <strong>chattering</strong>, which can excite unmodelled dynamics and degrade performance[3]. Selecting the gains that define the sliding surface and switching law is therefore a nonâ€‘trivial design problem: small gains lead to slow convergence whereas large gains increase chattering. Metaâ€‘heuristic optimisation techniques such as <strong>particle swarm optimisation (PSO)</strong> offer a principled way to automate gain tuning. PSO views each candidate set of controller gains as a particle in a population, and the particles explore the search space by updating their velocities and positions. At each iteration the velocity of particleÂ <em>i</em> is influenced by its own best position and the global best position found by the swarm, scaled by acceleration coefficients and random vectors[4]. An inertia weight may be included to control the influence of the previous velocity; larger inertia promotes exploration while smaller inertia encourages exploitation[5]. Because PSO only requires evaluations of the objective function and not its gradient, it is attractive for tuning nonlinear controllers where simulation is the only way to assess performance. This report uses PSO to optimise the gains of a slidingâ€‘mode controller for the DIP. \mathbf{v}<em>{i}(t + 1) = w,\mathbf{v}</em>{i}(t) + c_{1}r_{1}\bigl( \mathbf{p}<em>{\mathrm{best},i} - \mathbf{x}</em>{i}(t) \bigr) + c_{2}r_{2}\bigl( \mathbf{g}<em>{\mathrm{best}} - \mathbf{x}</em>{i}(t) \bigr), \mathbf{x}<em>{i}(t + 1) = \mathbf{x}</em>{i}(t) + \mathbf{v}<em>{i}(t + 1), where $w$ is the inertia weight and $c_{1},c_{2}$ are cognitive and social acceleration coefficients; $r_{1},r_{2}$ are uniformly distributed random vectors on $[0,1]$[4]. The inertia term $w\mathbf{v}_{i}(t)$ retains a portion of the previous velocity, the cognitive term drives the particle toward its personal best position and the social term attracts it toward the global best. Shi and Eberhart introduced the inertia weight to balance global exploration and local exploitation: a large inertia weight emphasises exploration whereas a small one speeds convergence but risks premature stagnation[5]. These update equations allow the swarm to share information and converge toward promising solutions. The goal of this project is to design and tune an SMC for a DIP using PSO. The existing code implements a DIP simulator, a classical slidingâ€‘mode controller and a PSO optimizer. The current documentation provides a highâ€‘level overview but lacks detailed system modelling, mathematical formulations, implementation details and analysis. This report fills these gaps: it derives the DIP equations of motion, formalizes the SMC and PSO formulations, summarizes the optimization procedure in pseudocode, presents simulation results and discusses limitations and future work. ## SystemÂ Modelling &amp; Problem Statement ### Double Inverted Pendulum Dynamics The DIP consists of a cart of mass $<code class="docutils literal notranslate"><span class="pre">M</span></code>$ that can translate along a track, a lower pendulum of mass $<code class="docutils literal notranslate"><span class="pre">m_{1}</span></code>$ and length $<code class="docutils literal notranslate"><span class="pre">l_{1}</span></code>$ , and an upper pendulum of mass $<code class="docutils literal notranslate"><span class="pre">m_{2}</span></code>$ and length $<code class="docutils literal notranslate"><span class="pre">l_{2}</span></code>$ . The centres of mass (COM) are at distances $<code class="docutils literal notranslate"><span class="pre">d_{1}</span></code>$ and $<code class="docutils literal notranslate"><span class="pre">d_{2}</span></code>$ from the pivot, and the pendulums have inertias $<code class="docutils literal notranslate"><span class="pre">J_{1}</span></code>$ and $<code class="docutils literal notranslate"><span class="pre">J_{2}</span></code>$ about their COMs. Let $<code class="docutils literal notranslate"><span class="pre">x</span></code>$ be the cart position, $<code class="docutils literal notranslate"><span class="pre">q_{1}</span></code>$ the lower pendulum angle (zero at upright) and $<code class="docutils literal notranslate"><span class="pre">q_{2}</span></code>$ the upper pendulum angle. The state vector is \mathbf{x} = \left\lbrack x,, q</em>{1},, q_{2},,\dot{x},,{\dot{q}}<em>{1},,{\dot{q}}</em>{2} \right\rbrack^{\top}. Applying the Eulerâ€“Lagrange method to the DIP yields a <strong>manipulator form</strong>. In the rotary doubleâ€‘inverted pendulum literature the equations of motion are derived from the systemâ€™s kinetic and potential energies; the resulting model is expressed in a manipulator form with inertia matrix $H(\mathbf{q})$, Coriolis matrix $C(\mathbf{q},\dot{\mathbf{q}})$, gravity vector $G(\mathbf{q})$ and friction term $D(\dot{\mathbf{q}})$[6]. Following this standard approach, the DIP dynamics are written as H\left( \mathbf{q} \right),\ddot{\mathbf{q}} + C\left( \mathbf{q},\dot{\mathbf{q}} \right),\dot{\mathbf{q}} + G\left( \mathbf{q} \right) + D\left( \dot{\mathbf{q}} \right) = B, u, where $\mathbf{q} = [x, q_{1}, q_{2}]^{\top}$. The <strong>inertia matrix</strong> $H(\mathbf{q})$ depends on the masses and geometries, $C(\mathbf{q},\dot{\mathbf{q}})$ contains Coriolis and centrifugal terms, $G(\mathbf{q})$ collects gravitational forces and $D(\dot{\mathbf{q}})$ models viscous friction. The <strong>input matrix</strong> $B = [1,0,0]^{\top}$ highlights the underactuation since only the cart is actuated. In our implementation these matrices are computed numerically from physical parameters specified in a YAML configuration. The resulting continuousâ€‘time stateâ€‘space model used for simulation is \dot{\mathbf{x}} = \begin{bmatrix} \dot{x} \ {\dot{q}}<em>{1} \ {\dot{q}}</em>{2} \ H^{- 1}\left( \mathbf{q} \right)\left( Bu - C\dot{\mathbf{q}} - G\left( \mathbf{q} \right) - D\dot{\mathbf{q}} \right) \end{bmatrix}. Numerical integration uses a fourthâ€‘order Rungeâ€“Kutta method with a time step $<code class="docutils literal notranslate"><span class="pre">\Delta</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">0.01\</span> <span class="pre">s</span></code>$ . The simulation length is typically $<code class="docutils literal notranslate"><span class="pre">10\</span> <span class="pre">s</span></code>$ , and initial angles are set close to 0 (upright) while the cart starts at the origin. ### Control Objective The goal is to stabilize the DIP at the equilibrium $<code class="docutils literal notranslate"><span class="pre">\left(</span> <span class="pre">x,q_{1},q_{2}</span> <span class="pre">\right)</span> <span class="pre">=</span> <span class="pre">(0,0,0)</span></code>$ while keeping the cart near the origin and minimizing oscillations. Specifically, the control problem is to find a force input $<code class="docutils literal notranslate"><span class="pre">u(t)</span></code>$ constrained by $<code class="docutils literal notranslate"><span class="pre">|u|</span> <span class="pre">\leq</span> <span class="pre">u_{\max}</span></code>$ (here $<code class="docutils literal notranslate"><span class="pre">u_{\max}</span> <span class="pre">=</span> <span class="pre">150\</span> <span class="pre">N</span></code>$ ) that forces $<code class="docutils literal notranslate"><span class="pre">q_{1}(t),q_{2}(t)</span> <span class="pre">\rightarrow</span> <span class="pre">0</span></code>$ and $<code class="docutils literal notranslate"><span class="pre">x(t)</span> <span class="pre">\rightarrow</span> <span class="pre">0</span></code>$ . A slidingâ€‘mode controller with adjustable gains is adopted. Selecting suitable gains is formulated as an optimization problem solved with PSO. ## Methodology: Slidingâ€‘Mode Control &amp; Particle Swarm Optimization ### Classical Slidingâ€‘Mode Controller (SMC) Slidingâ€‘mode control uses a discontinuous control law to drive the system trajectories onto a predefined <strong>sliding surface</strong> and keep them there. When the state reaches the sliding surface the dynamics become insensitive to matched disturbances and uncertainties[7][2]. For the DIP the sliding surface is chosen as a linear combination of the pendulum angles and their angular rates: s(t) = \lambda_{1}, q_{1} + \lambda_{2}, q_{2} + k_{1},{\dot{q}}<em>{1} + k</em>{2},{\dot{q}}_{2}, where $<code class="docutils literal notranslate"><span class="pre">k_{1},k_{2},\lambda_{1},\lambda_{2}</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>$ are design parameters. When $<code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">=</span> <span class="pre">0</span></code>$ the angles and angular rates satisfy a desired relationship that leads to convergence. The SMC control input is composed of an <strong>equivalent control</strong> $<code class="docutils literal notranslate"><span class="pre">u_{\text{eq}}</span></code>$ that cancels the nominal dynamics and a <strong>robust control</strong> $<code class="docutils literal notranslate"><span class="pre">u_{\text{robust}}</span></code>$ to drive $<code class="docutils literal notranslate"><span class="pre">s</span></code>$ to zero:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../presentation/results-discussion.html">8 â€“ Results and Discussion This chapter analyses the <strong>particleâ€‘swarmâ€‘optimisation (PSO)</strong> tuning of several slidingâ€‘mode control (SMC) variants for the doubleâ€‘inverted pendulum (DIP). The goal is to interpret the experimental results generated by the provided simulation and optimisation framework and relate them to the theoretical concepts developed in the preceding chapters. #### 8.1 Experimental setup ##### 8.1.1 Simulation environment All experiments were performed using the Python implementation supplied with this project. Two dynamic models are available: a <strong>simplified model</strong> (<code class="docutils literal notranslate"><span class="pre">src/core/dynamics.py</span></code>) and a <strong>full model</strong> (<code class="docutils literal notranslate"><span class="pre">src/core/dynamics_full.py</span></code>). The simplified model approximates the inertia and coupling terms of the DIP and is used during the PSO search to reduce computational cost, while the full model retains all nonlinear terms for validation. Slidingâ€‘mode controllers applied to underâ€‘actuated systems such as the inverted pendulum lead to stiff, nonâ€‘smooth dynamics; implicit stiff solvers (e.g., Radau) are therefore recommended [1,â€¯2]. The simulation parameters are specified in <code class="docutils literal notranslate"><span class="pre">config.yaml</span></code>: each simulation runs for 10â€¯s with a time step dt=0.01\mathrm{d}t = 0.01â€¯s, the initial state is [x,Î¸1,Î¸2,xË™,Î¸Ë™1,Î¸Ë™2]=[0,0.05,âˆ’0.03,0,0,0][x, \theta_{1}, \theta_{2}, \dot{x}, \dot{\theta}<em>{1}, \dot{\theta}</em>{2}] = [0, 0.05, -0.03, 0, 0, 0], and the actuator force is saturated at 150â€¯N. A commandâ€‘line interface and Streamlit front end allow interactive experiments, such as injecting disturbances and switching integrators, while the dualâ€‘model architecture provides highâ€‘throughput searches and accurate validation. ##### 8.1.2 Controller variants Four SMC variants are considered: - <strong>Classical SMC</strong> â€“ uses a firstâ€‘order sliding surface Ïƒ=k1Î¸Ë™1+k2Î¸Ë™2+Î»1Î¸1+Î»2Î¸2\sigma = k_{1}\dot{\theta}<em>{1} + k</em>{2}\dot{\theta}<em>{2} + \lambda</em>{1}\theta_{1} + \lambda_{2}\theta_{2}. The control law combines an equivalent term, a discontinuous switching term and a derivative term [3]. To reduce highâ€‘frequency chattering inherent in discontinuous SMC, a boundary layer implements a continuous approximation of the sign function [4].</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ğŸ”¬ Mathematical Foundations</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../mathematical_foundations/index.html">Mathematical Foundations</a><input aria-label="Toggle navigation of Mathematical Foundations" class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" role="switch" type="checkbox"/><label for="toctree-checkbox-14"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/README.html">SMC Mathematical Foundations Documentation This directory contains mathematical documentation for all SMC algorithm fixes and validation methodology implemented for GitHub Issue #5. ## ğŸ“‹ Documentation Overview This mathematical foundation documentation provides: - <strong>Complete mathematical theory</strong> behind all SMC algorithm implementations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/smc_complete_theory.html">Complete Sliding Mode Control Mathematical Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/smc_theory.html">SMC Mathematical Theory Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/sliding_surface_analysis.html">Sliding Surface Mathematical Properties and Stability Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/boundary_layer_derivations.html">Boundary Layer Mathematical Derivations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/controller_comparison_theory.html">SMC Controller Comparison Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html">Advanced Algorithms Guide <strong>Technical Reference for Optimization, Numerical Stability, and Algorithm Comparison</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#configure-inertia-weight-schedule-in-config-yaml">Configure inertia weight schedule in config.yaml:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#pso">pso:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#w-schedule-0-9-0-4-start-at-0-9-end-at-0-4">w_schedule: [0.9, 0.4] # Start at 0.9, end at 0.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#iters-100">iters: 100</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#n-particles-30-result-tuner-optimise-uses-w-schedule-from-config-manual-iteration-loop-for-custom-control">n_particles: 30 result = tuner.optimise() # Uses w_schedule from config # Manual iteration loop for custom control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#runnable-false-configure-physics-uncertainty-in-config-yaml">runnable: false # Configure physics uncertainty in config.yaml:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#physics-uncertainty">physics_uncertainty:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#n-evals-5-5-perturbed-models-per-evaluation">n_evals: 5 # 5 perturbed models per evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#cart-mass-0-10-10">cart_mass: 0.10 # Â±10%</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#pendulum1-mass-0-15-15">pendulum1_mass: 0.15 # Â±15%</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#pendulum2-mass-0-15-15">pendulum2_mass: 0.15 # Â±15%</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#pendulum1-length-0-05-5">pendulum1_length: 0.05 # Â±5%</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#pendulum2-length-0-05-5-tuner-psotuner-controller-factory-controller-factory-config-config-seed-42">pendulum2_length: 0.05 # Â±5% tuner = PSOTuner( controller_factory=controller_factory, config=config, seed=42</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#cost-aggregation-0-7-mean-0-3-max">Cost aggregation: 0.7 * mean + 0.3 * max</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html">SMC Algorithm Fixes and Mathematical Validation Summary This document provides a summary of all mathematical algorithm fixes, validation improvements, and corrected implementations in the SMC controller system for GitHub Issue #5. ## 1. Executive Summary The SMC mathematical foundation has been completely restructured and validated with the following major improvements: - <strong>Boundary Layer Mathematics</strong>: Corrected chattering reduction theory and implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-compute-switching-function-self-surface-value-float-float-compute-continuous-switching-function-with-adaptive-boundary-layer-adaptive-boundary-layer-thickness-surface-derivative-self-get-surface-derivative-effective-thickness-self-base-thickness-self-slope-abs-surface-derivative-continuous-switching-approximation-if-self-switch-method-tanh-return-np-tanh-surface-value-effective-thickness-elif-self-switch-method-linear-return-np-clip-surface-value-effective-thickness-1-0-1-0-else-sign-return-np-sign-surface-value-3-validation-rules-python-if-thickness-0-raise-valueerror-boundary-layer-thickness-must-be-positive-if-slope-0-raise-valueerror-boundary-layer-slope-must-be-non-negative-mathematical-impact">runnable: false def compute_switching_function(self, surface_value: float) -&gt; float: â€œâ€â€Compute continuous switching function with adaptive boundary layer.â€â€â€ # Adaptive boundary layer thickness surface_derivative = self._get_surface_derivative() effective_thickness = self.base_thickness + self.slope * abs(surface_derivative) # Continuous switching approximation if self.switch_method == â€œtanhâ€: return np.tanh(surface_value / effective_thickness) elif self.switch_method == â€œlinearâ€: return np.clip(surface_value / effective_thickness, -1.0, 1.0) else: # â€œsignâ€ return np.sign(surface_value) <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Validation</span> <span class="pre">Rules:**</span></code>python if thickness &lt;= 0: raise ValueError(â€œBoundary layer thickness must be positiveâ€) if slope &lt; 0: raise ValueError(â€œBoundary layer slope must be non-negativeâ€) ``` <strong>Mathematical Impact:</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-compute-self-state-np-ndarray-float-compute-linear-sliding-surface-with-numerical-safeguards-input-validation-if-len-state-6-raise-valueerror-state-must-have-at-least-6-elements-handle-non-finite-values-if-not-np-all-np-isfinite-state-state-np-where-np-isfinite-state-state-0-0-extract-components-theta1-theta1-dot-state-2-state-3-theta2-theta2-dot-state-4-state-5-linear-sliding-surface-s-11-k11-22-k22-s-self-lam1-theta1-dot-self-k1-theta1-self-lam2-theta2-dot-self-k2-theta2-numerical-safety-return-0-0-if-not-np-isfinite-s-else-float-s-2-stability-analysis-integration-python">runnable: false def compute(self, state: np.ndarray) -&gt; float: â€œâ€â€Compute linear sliding surface with numerical safeguards.â€â€â€ # Input validation if len(state) &lt; 6: raise ValueError(â€œState must have at least 6 elementsâ€) # Handle non-finite values if not np.all(np.isfinite(state)): state = np.where(np.isfinite(state), state, 0.0) # Extract components theta1, theta1_dot = state[2], state[3] theta2, theta2_dot = state[4], state[5] # Linear sliding surface: s = Î»â‚Î¸Ì‡â‚ + kâ‚Î¸â‚ + Î»â‚‚Î¸Ì‡â‚‚ + kâ‚‚Î¸â‚‚ s = (self.lam1 * theta1_dot + self.k1 * theta1 + self.lam2 * theta2_dot + self.k2 * theta2) # Numerical safety return 0.0 if not np.isfinite(s) else float(s) <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Stability</span> <span class="pre">Analysis</span> <span class="pre">Integration:**</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-validate-gains-self-none-validate-gains-according-to-hurwitz-stability-requirements-check-finite-values-if-not-np-all-np-isfinite-self-gains-invalid-indices-np-where-np-isfinite-self-gains-0-raise-valueerror-f-gains-contain-nan-infinite-values-at-indices-invalid-indices-positivity-requirement-for-stability-if-len-self-gains-4-if-any-g-0-for-g-in-self-gains-4-raise-valueerror-surface-gains-k1-k2-1-2-must-be-positive-for-stability-minimum-threshold-for-numerical-stability-if-any-g-1e-12-for-g-in-self-gains-4-raise-valueerror-gains-too-small-min-1e-12-numerical-instability-risk-3-mathematical-property-verification-linearity-s-x1-x2-s-x1-s-x2-homogeneity-s-x-s-x-continuity-lim-xx0-s-x-s-x0-differentiability-ds-dt-exists-and-is-computable-mathematical-impact">runnable: false def _validate_gains(self) -&gt; None: â€œâ€â€Validate gains according to Hurwitz stability requirements.â€â€â€ # Check finite values if not np.all(np.isfinite(self.gains)): invalid_indices = np.where(~np.isfinite(self.gains))[0] raise ValueError(fâ€Gains contain NaN/infinite values at indices: {invalid_indices}â€) # Positivity requirement for stability if len(self.gains) &gt;= 4: if any(g &lt;= 0 for g in self.gains[:4]): raise ValueError(â€œSurface gains [k1, k2, Î»1, Î»2] must be positive for stabilityâ€) # Minimum threshold for numerical stability if any(g &lt; 1e-12 for g in self.gains[:4]): raise ValueError(â€œGains too small (min: 1e-12) - numerical instability riskâ€) ``` 3. <strong>Mathematical Property Verification:</strong> - <strong>Linearity</strong>: <code class="docutils literal notranslate"><span class="pre">s(Î±xâ‚</span> <span class="pre">+</span> <span class="pre">Î²xâ‚‚)</span> <span class="pre">=</span> <span class="pre">Î±s(xâ‚)</span> <span class="pre">+</span> <span class="pre">Î²s(xâ‚‚)</span></code> - <strong>Homogeneity</strong>: <code class="docutils literal notranslate"><span class="pre">s(Î±x)</span> <span class="pre">=</span> <span class="pre">Î±s(x)</span></code> - <strong>Continuity</strong>: <code class="docutils literal notranslate"><span class="pre">lim_{xâ†’xâ‚€}</span> <span class="pre">s(x)</span> <span class="pre">=</span> <span class="pre">s(xâ‚€)</span></code> - <strong>Differentiability</strong>: <code class="docutils literal notranslate"><span class="pre">ds/dt</span></code> exists and is computable <strong>Mathematical Impact:</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-dataclass-frozen-true-class-classicalsmcconfig-type-safe-configuration-with-mathematical-validation-def-post-init-self-validate-configuration-after-creation-self-validate-gains-self-validate-parameters-self-validate-mathematical-constraints-def-validate-gains-self-none-validate-gain-vector-according-to-smc-theory-if-len-self-gains-6-raise-valueerror-classical-smc-requires-exactly-6-gains-k1-k2-lam1-lam2-k-kd-self-gains-surface-gains-positive-for-hurwitz-stability-if-any-g-0-for-g-in-k1-k2-lam1-lam2-raise-valueerror-surface-gains-must-be-positive-for-stability-switching-gain-positive-for-reaching-condition-if-k-0-raise-valueerror-switching-gain-k-must-be-positive-derivative-gain-non-negative-for-damping-if-kd-0-raise-valueerror-derivative-gain-kd-must-be-non-negative-def-validate-mathematical-constraints-self-none-validate-constraints-from-mathematical-theory-damping-ratio-bounds-for-each-subsystem-zeta1-self-lam1-2-np-sqrt-self-k1-zeta2-self-lam2-2-np-sqrt-self-k2-if-zeta1-0-1-or-zeta2-0-1-raise-valueerror-damping-ratios-too-low-may-cause-oscillations-if-zeta1-10-0-or-zeta2-10-0-raise-valueerror-damping-ratios-too-high-may-cause-sluggish-response-2-edge-case-handling-python-def-get-effective-controllability-threshold-self-float-auto-compute-threshold-based-on-system-parameters-if-self-controllability-threshold-is-not-none-return-self-controllability-threshold-scale-with-surface-gains-for-adaptive-behavior-base-threshold-0-05-self-k1-self-k2-bound-within-reasonable-limits-return-np-clip-base-threshold-0-01-1-0-mathematical-impact">runnable: false @dataclass(frozen=True) class ClassicalSMCConfig: â€œâ€â€Type-safe configuration with mathematical validation.â€â€â€ def <strong>post_init</strong>(self): â€œâ€â€Validate configuration after creation.â€â€â€ self._validate_gains() self._validate_parameters() self._validate_mathematical_constraints() def _validate_gains(self) -&gt; None: â€œâ€â€Validate gain vector according to SMC theory.â€â€â€ if len(self.gains) != 6: raise ValueError(â€œClassical SMC requires exactly 6 gainsâ€) k1, k2, lam1, lam2, K, kd = self.gains # Surface gains: positive for Hurwitz stability if any(g &lt;= 0 for g in [k1, k2, lam1, lam2]): raise ValueError(â€œSurface gains must be positive for stabilityâ€) # Switching gain: positive for reaching condition if K &lt;= 0: raise ValueError(â€œSwitching gain K must be positiveâ€) # Derivative gain: non-negative for damping if kd &lt; 0: raise ValueError(â€œDerivative gain kd must be non-negativeâ€) def _validate_mathematical_constraints(self) -&gt; None: â€œâ€â€Validate constraints from mathematical theory.â€â€â€ # Damping ratio bounds for each subsystem zeta1 = self.lam1 / (2 * np.sqrt(self.k1)) zeta2 = self.lam2 / (2 * np.sqrt(self.k2)) if zeta1 &lt; 0.1 or zeta2 &lt; 0.1: raise ValueError(â€œDamping ratios too low - may cause oscillationsâ€) if zeta1 &gt; 10.0 or zeta2 &gt; 10.0: raise ValueError(â€œDamping ratios too high - may cause sluggish responseâ€) <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Edge</span> <span class="pre">Case</span> <span class="pre">Handling:**</span></code>python def get_effective_controllability_threshold(self) -&gt; float: â€œâ€â€Auto-compute threshold based on system parameters.â€â€â€ if self.controllability_threshold is not None: return self.controllability_threshold # Scale with surface gains for adaptive behavior base_threshold = 0.05 * (self.k1 + self.k2) # Bound within reasonable limits return np.clip(base_threshold, 0.01, 1.0) ``` <strong>Mathematical Impact:</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-given-gains-st-lists-st-floats-min-value-0-1-max-value-50-0-min-size-4-max-size-4-state-st-lists-st-floats-min-value-10-0-max-value-10-0-min-size-6-max-size-6-def-test-sliding-surface-linearity-property-self-gains-state-test-linearity-property-for-all-valid-parameter-combinations-surface-linearslidingsurface-gains-state1-np-array-state-state2-np-random-uniform-10-10-6-s1-surface-compute-state1-s2-surface-compute-state2-s-combined-surface-compute-state1-state2-mathematical-property-s-x1-x2-s-x1-s-x2-assert-abs-s-combined-s1-s2-1e-10-2-boundary-layer-monotonicity-python">runnable: false @given( gains=st.lists(st.floats(min_value=0.1, max_value=50.0), min_size=4, max_size=4), state=st.lists(st.floats(min_value=-10.0, max_value=10.0), min_size=6, max_size=6) ) def test_sliding_surface_linearity_property(self, gains, state): â€œâ€â€Test linearity property for all valid parameter combinations.â€â€â€ surface = LinearSlidingSurface(gains) state1 = np.array(state) state2 = np.random.uniform(-10, 10, 6) s1 = surface.compute(state1) s2 = surface.compute(state2) s_combined = surface.compute(state1 + state2) # Mathematical property: s(x1 + x2) = s(x1) + s(x2) assert abs(s_combined - (s1 + s2)) &lt; 1e-10 <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Boundary</span> <span class="pre">Layer</span> <span class="pre">Monotonicity:**</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-test-boundary-layer-monotonicity-all-methods-self-test-monotonicity-for-all-switching-methods-methods-tanh-linear-sign-for-method-in-methods-boundary-layer-boundarylayer-thickness-0-1-switch-method-method-s-values-np-linspace-2-2-1000-switch-values-boundary-layer-compute-switching-function-s-for-s-in-s-values-must-be-monotonically-increasing-for-i-in-range-len-switch-values-1-assert-switch-values-i-1-switch-values-i-3-configuration-validation-coverage-python">runnable: false def test_boundary_layer_monotonicity_all_methods(self): â€œâ€â€Test monotonicity for all switching methods.â€â€â€ methods = [â€œtanhâ€, â€œlinearâ€, â€œsignâ€] for method in methods: boundary_layer = BoundaryLayer(thickness=0.1, switch_method=method) s_values = np.linspace(-2, 2, 1000) switch_values = [boundary_layer.compute_switching_function(s) for s in s_values] # Must be monotonically increasing for i in range(len(switch_values) - 1): assert switch_values[i+1] &gt;= switch_values[i] <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Configuration</span> <span class="pre">Validation</span> <span class="pre">Coverage:**</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-class-testconfigurationvalidationcoverage-coverage-of-all-validation-rules-pytest-mark-parametrize-invalid-gain-index-0-1-2-3-def-test-zero-surface-gains-rejection-self-invalid-gain-index-test-rejection-of-zero-surface-gains-gains-5-0-3-0-4-0-2-0-10-0-1-0-gains-invalid-gain-index-0-0-with-pytest-raises-valueerror-match-must-be-positive-classicalsmcconfig-gains-gains-max-force-100-dt-0-01-boundary-layer-0-01-pytest-mark-parametrize-invalid-gain-index-0-1-2-3-def-test-negative-surface-gains-rejection-self-invalid-gain-index-test-rejection-of-negative-surface-gains-gains-5-0-3-0-4-0-2-0-10-0-1-0-gains-invalid-gain-index-1-0-with-pytest-raises-valueerror-match-must-be-positive-classicalsmcconfig-gains-gains-max-force-100-dt-0-01-boundary-layer-0-01-3-2-numerical-stability-testing-enhanced-numerical-robustness-tests-1-extreme-value-testing-python">runnable: false class TestConfigurationValidationCoverage: â€œâ€â€coverage of all validation rules.â€â€â€ @pytest.mark.parametrize(â€œinvalid_gain_indexâ€, [0, 1, 2, 3]) def test_zero_surface_gains_rejection(self, invalid_gain_index): â€œâ€â€Test rejection of zero surface gains.â€â€â€ gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] gains[invalid_gain_index] = 0.0 with pytest.raises(ValueError, match=â€must be positiveâ€): ClassicalSMCConfig(gains=gains, max_force=100, dt=0.01, boundary_layer=0.01) @pytest.mark.parametrize(â€œinvalid_gain_indexâ€, [0, 1, 2, 3]) def test_negative_surface_gains_rejection(self, invalid_gain_index): â€œâ€â€Test rejection of negative surface gains.â€â€â€ gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] gains[invalid_gain_index] = -1.0 with pytest.raises(ValueError, match=â€must be positiveâ€): ClassicalSMCConfig(gains=gains, max_force=100, dt=0.01, boundary_layer=0.01) <code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">3.2</span> <span class="pre">Numerical</span> <span class="pre">Stability</span> <span class="pre">Testing</span> <span class="pre">**Enhanced</span> <span class="pre">Numerical</span> <span class="pre">Robustness</span> <span class="pre">Tests:**</span> <span class="pre">1.</span> <span class="pre">**Extreme</span> <span class="pre">Value</span> <span class="pre">Testing:**</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id7">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-test-numerical-stability-extreme-values-self-test-behavior-with-extreme-but-valid-parameter-values-very-small-gains-but-above-minimum-threshold-small-gains-1e-10-1e-10-1e-10-1e-10-1e-8-0-0-config-small-classicalsmcconfig-gains-small-gains-max-force-1e-6-dt-1e-6-boundary-layer-1e-8-very-large-gains-large-gains-1e6-1e6-1e6-1e6-1e8-1e4-config-large-classicalsmcconfig-gains-large-gains-max-force-1e8-dt-1e-3-boundary-layer-1-0-both-should-create-valid-controllers-controller-small-modularclassicalsmc-config-config-small-controller-large-modularclassicalsmc-config-config-large-test-with-moderate-state-values-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-result-small-controller-small-compute-control-state-result-large-controller-large-compute-control-state-both-should-produce-finite-bounded-results-assert-np-all-np-isfinite-result-small-get-control-output-0-assert-np-all-np-isfinite-result-large-get-control-output-0-2-precision-consistency-testing-python">runnable: false def test_numerical_stability_extreme_values(self): â€œâ€â€Test behavior with extreme but valid parameter values.â€â€â€ # Very small gains (but above minimum threshold) small_gains = [1e-10, 1e-10, 1e-10, 1e-10, 1e-8, 0.0] config_small = ClassicalSMCConfig(gains=small_gains, max_force=1e-6, dt=1e-6, boundary_layer=1e-8) # Very large gains large_gains = [1e6, 1e6, 1e6, 1e6, 1e8, 1e4] config_large = ClassicalSMCConfig(gains=large_gains, max_force=1e8, dt=1e-3, boundary_layer=1.0) # Both should create valid controllers controller_small = ModularClassicalSMC(config=config_small) controller_large = ModularClassicalSMC(config=config_large) # Test with moderate state values state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) result_small = controller_small.compute_control(state, {}, {}) result_large = controller_large.compute_control(state, {}, {}) # Both should produce finite, bounded results assert np.all(np.isfinite(result_small.get(â€˜control_outputâ€™, [0]))) assert np.all(np.isfinite(result_large.get(â€˜control_outputâ€™, [0]))) <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Precision</span> <span class="pre">Consistency</span> <span class="pre">Testing:**</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id8">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-test-computation-precision-consistency-self-test-that-repeated-computations-maintain-precision-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-state-np-array-0-123456789-0-987654321-0-456789123-0-321654987-0-789123456-0-654987321-compute-control-1000-times-results-for-in-range-1000-result-controller-compute-control-state-control-result-get-control-output-result-get-control-0-results-append-control-results-np-array-results-standard-deviation-should-be-zero-deterministic-computation-std-dev-np-std-results-axis-0-if-results-ndim-1-else-np-std-results-assert-np-all-std-dev-1e-15-machine-precision-level-4-implementation-architecture-improvements-4-1-modular-component-design-before-monolithic-single-458-line-controller-with-mixed-concerns">runnable: false def test_computation_precision_consistency(self): â€œâ€â€Test that repeated computations maintain precision.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) state = np.array([0.123456789, 0.987654321, 0.456789123, 0.321654987, 0.789123456, 0.654987321]) # Compute control 1000 times results = [] for _ in range(1000): result = controller.compute_control(state, {}, {}) control = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, 0)) results.append(control) results = np.array(results) # Standard deviation should be zero (deterministic computation) std_dev = np.std(results, axis=0) if results.ndim &gt; 1 else np.std(results) assert np.all(std_dev &lt; 1e-15) # Machine precision level ``` ## 4. Implementation Architecture Improvements ### 4.1 Modular Component Design <strong>Before (Monolithic):</strong> Single 458-line controller with mixed concerns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id9">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-class-slidingsurface-abc-abstract-interface-for-sliding-surface-calculations-abstractmethod-def-compute-self-state-np-ndarray-float-compute-sliding-surface-value-pass-abstractmethod-def-compute-derivative-self-state-np-ndarray-state-dot-np-ndarray-float-compute-sliding-surface-derivative-pass-abstractmethod-def-validate-gains-self-none-validate-gains-for-mathematical-correctness-pass-class-boundarylayer-interface-for-boundary-layer-implementations-def-compute-switching-function-self-surface-value-float-float-compute-continuous-switching-function-pass-def-compute-switching-control-self-surface-value-float-gain-float-surface-derivative-float-0-0-float-compute-switching-control-with-boundary-layer-pass">runnable: false class SlidingSurface(ABC): â€œâ€â€Abstract interface for sliding surface calculations.â€â€â€ @abstractmethod def compute(self, state: np.ndarray) -&gt; float: â€œâ€â€Compute sliding surface value.â€â€â€ pass @abstractmethod def compute_derivative(self, state: np.ndarray, state_dot: np.ndarray) -&gt; float: â€œâ€â€Compute sliding surface derivative.â€â€â€ pass @abstractmethod def _validate_gains(self) -&gt; None: â€œâ€â€Validate gains for mathematical correctness.â€â€â€ pass class BoundaryLayer: â€œâ€â€Interface for boundary layer implementations.â€â€â€ def compute_switching_function(self, surface_value: float) -&gt; float: â€œâ€â€Compute continuous switching function.â€â€â€ pass def compute_switching_control(self, surface_value: float, gain: float, surface_derivative: float = 0.0) -&gt; float: â€œâ€â€Compute switching control with boundary layer.â€â€â€ pass</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/pso_algorithm_theory.html">Particle Swarm Optimization: Mathematical Theory <strong>Module:</strong> Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/pso_algorithm_theory.html#balanced-recommended-for-smc">Balanced (recommended for SMC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/optimization_landscape_analysis.html">Optimization Landscape Analysis for Controller Gain Tuning</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/dynamics_derivations.html">Double Inverted Pendulum Dynamics: Complete Derivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/numerical_integration_theory.html">Numerical Integration Methods: Theory and Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/simulation_architecture_guide.html">Simulation Architecture Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/config_validation_specification.html">ClassicalSMCConfig Parameters and Validation Rules This document provides specification of the <code class="docutils literal notranslate"><span class="pre">ClassicalSMCConfig</span></code> parameters, their mathematical foundations, validation rules, and edge case handling. ## 1. Configuration Schema Overview The <code class="docutils literal notranslate"><span class="pre">ClassicalSMCConfig</span></code> dataclass provides type-safe, validated configuration for Classical Sliding Mode Control with the following parameter categories: - <strong>Control Parameters</strong>: Core SMC gains and timing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html">Mathematical Test Validation Methodology This document describes the methodology for validating mathematical properties and algorithm correctness in the SMC controller implementations. ## 1. Overview The test validation methodology ensures that all mathematical algorithms and fixes in the SMC system are rigorously validated through: - <strong>Property-based testing</strong>: Verification of mathematical properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-def-test-sliding-surface-linearity-test-that-sliding-surface-is-linear-in-state-surface-linearslidingsurface-gains-5-3-4-2-state1-np-array-0-1-0-1-0-1-0-05-0-05-0-05-state2-np-array-0-2-0-2-0-2-0-1-0-1-0-1-s1-surface-compute-state1-s2-surface-compute-state2-s-combined-surface-compute-state1-state2-linearity-s-x1-x2-s-x1-s-x2-assert-abs-s-combined-s1-s2-1e-10-2-homogeneity-property-python-def-test-sliding-surface-homogeneity-test-that-sliding-surface-is-homogeneous-of-degree-1-surface-linearslidingsurface-gains-5-3-4-2-state-np-array-0-1-0-1-0-1-0-05-0-05-0-05-alpha-2-5-s-original-surface-compute-state-s-scaled-surface-compute-alpha-state-homogeneity-s-x-s-x-assert-abs-s-scaled-alpha-s-original-1e-10-3-gain-sensitivity-python">runnable: false def test_sliding_surface_linearity(): â€œâ€â€Test that sliding surface is linear in state.â€â€â€ surface = LinearSlidingSurface(gains=[5, 3, 4, 2]) state1 = np.array([0.1, 0.1, 0.1, 0.05, 0.05, 0.05]) state2 = np.array([0.2, 0.2, 0.2, 0.1, 0.1, 0.1]) s1 = surface.compute(state1) s2 = surface.compute(state2) s_combined = surface.compute(state1 + state2) # Linearity: s(x1 + x2) = s(x1) + s(x2) assert abs(s_combined - (s1 + s2)) &lt; 1e-10 <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Homogeneity</span> <span class="pre">Property**:</span></code>python def test_sliding_surface_homogeneity(): â€œâ€â€Test that sliding surface is homogeneous of degree 1.â€â€â€ surface = LinearSlidingSurface(gains=[5, 3, 4, 2]) state = np.array([0.1, 0.1, 0.1, 0.05, 0.05, 0.05]) alpha = 2.5 s_original = surface.compute(state) s_scaled = surface.compute(alpha * state) # Homogeneity: s(Î±Â·x) = Î±Â·s(x) assert abs(s_scaled - alpha * s_original) &lt; 1e-10 <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Gain</span> <span class="pre">Sensitivity**:</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-def-test-sliding-surface-gain-sensitivity-test-that-surface-responds-correctly-to-gain-changes-gains1-5-3-4-2-gains2-10-6-8-4-doubled-gains-surface1-linearslidingsurface-gains1-surface2-linearslidingsurface-gains2-state-np-array-0-1-0-1-0-1-0-05-0-05-0-05-s1-surface1-compute-state-s2-surface2-compute-state-surface-value-should-double-with-doubled-gains-assert-abs-s2-2-s1-1e-10-2-1-2-boundary-layer-properties-test-suite-tests-test-controllers-smc-algorithms-classical-test-boundary-layer-py-mathematical-properties-validated-1-continuity-python">runnable: false def test_sliding_surface_gain_sensitivity(): â€œâ€â€Test that surface responds correctly to gain changes.â€â€â€ gains1 = [5, 3, 4, 2] gains2 = [10, 6, 8, 4] # Doubled gains surface1 = LinearSlidingSurface(gains1) surface2 = LinearSlidingSurface(gains2) state = np.array([0.1, 0.1, 0.1, 0.05, 0.05, 0.05]) s1 = surface1.compute(state) s2 = surface2.compute(state) # Surface value should double with doubled gains assert abs(s2 - 2 * s1) &lt; 1e-10 <code class="docutils literal notranslate"><span class="pre">####</span> <span class="pre">2.1.2</span> <span class="pre">Boundary</span> <span class="pre">Layer</span> <span class="pre">Properties</span> <span class="pre">**Test</span> <span class="pre">Suite:**</span> <span class="pre">`tests/test_controllers/smc/algorithms/classical/test_boundary_layer.py`</span> <span class="pre">**Mathematical</span> <span class="pre">Properties</span> <span class="pre">Validated:**</span> <span class="pre">1.</span> <span class="pre">**Continuity**:</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-def-test-boundary-layer-continuity-test-that-boundary-layer-provides-continuous-switching-boundary-layer-boundarylayer-thickness-0-1-switch-method-tanh-test-continuity-at-surface-s-0-epsilon-1e-8-switch-left-boundary-layer-compute-switching-function-epsilon-switch-right-boundary-layer-compute-switching-function-epsilon-switch-center-boundary-layer-compute-switching-function-0-0-values-should-be-very-close-at-the-boundary-assert-abs-switch-left-switch-center-1e-6-assert-abs-switch-right-switch-center-1e-6-2-monotonicity-python-def-test-boundary-layer-monotonicity-test-that-switching-function-is-monotonic-boundary-layer-boundarylayer-thickness-0-1-switch-method-tanh-s-values-np-linspace-1-1-100-switch-values-boundary-layer-compute-switching-function-s-for-s-in-s-values-switching-function-should-be-strictly-increasing-for-i-in-range-len-switch-values-1-assert-switch-values-i-1-switch-values-i-3-asymptotic-behavior-python-def-test-boundary-layer-asymptotic-behavior-test-asymptotic-limits-of-switching-function-boundary-layer-boundarylayer-thickness-0-1-switch-method-tanh-large-positive-surface-value-switch-pos-boundary-layer-compute-switching-function-10-0-assert-abs-switch-pos-1-0-1e-3-large-negative-surface-value-switch-neg-boundary-layer-compute-switching-function-10-0-assert-abs-switch-neg-1-0-1e-3-2-2-configuration-validation-tests-test-suite-tests-test-controllers-smc-algorithms-classical-test-config-validation-py-2-2-1-parameter-validationpython">runnable: false def test_boundary_layer_continuity(): â€œâ€â€Test that boundary layer provides continuous switching.â€â€â€ boundary_layer = BoundaryLayer(thickness=0.1, switch_method=â€tanhâ€) # Test continuity at surface (s=0) epsilon = 1e-8 switch_left = boundary_layer.compute_switching_function(-epsilon) switch_right = boundary_layer.compute_switching_function(epsilon) switch_center = boundary_layer.compute_switching_function(0.0) # Values should be very close at the boundary assert abs(switch_left - switch_center) &lt; 1e-6 assert abs(switch_right - switch_center) &lt; 1e-6 <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Monotonicity**:</span></code>python def test_boundary_layer_monotonicity(): â€œâ€â€Test that switching function is monotonic.â€â€â€ boundary_layer = BoundaryLayer(thickness=0.1, switch_method=â€tanhâ€) s_values = np.linspace(-1, 1, 100) switch_values = [boundary_layer.compute_switching_function(s) for s in s_values] # Switching function should be strictly increasing for i in range(len(switch_values) - 1): assert switch_values[i+1] &gt;= switch_values[i] <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Asymptotic</span> <span class="pre">Behavior**:</span></code>python def test_boundary_layer_asymptotic_behavior(): â€œâ€â€Test asymptotic limits of switching function.â€â€â€ boundary_layer = BoundaryLayer(thickness=0.1, switch_method=â€tanhâ€) # Large positive surface value switch_pos = boundary_layer.compute_switching_function(10.0) assert abs(switch_pos - 1.0) &lt; 1e-3 # Large negative surface value switch_neg = boundary_layer.compute_switching_function(-10.0) assert abs(switch_neg - (-1.0)) &lt; 1e-3 <code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">2.2</span> <span class="pre">Configuration</span> <span class="pre">Validation</span> <span class="pre">Tests</span> <span class="pre">**Test</span> <span class="pre">Suite:**</span> <span class="pre">`tests/test_controllers/smc/algorithms/classical/test_config_validation.py`</span> <span class="pre">####</span> <span class="pre">2.2.1</span> <span class="pre">Parameter</span> <span class="pre">Validation</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-class-testclassicalsmcconfigvalidation-test-configuration-parameter-validation-def-test-positive-gain-requirement-self-test-that-all-surface-gains-must-be-positive-valid-configuration-valid-gains-5-0-3-0-4-0-2-0-10-0-1-0-config-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-01-invalid-zero-gain-with-pytest-raises-valueerror-match-must-be-positive-invalid-gains-0-0-3-0-4-0-2-0-10-0-1-0-classicalsmcconfig-gains-invalid-gains-max-force-100-dt-0-01-boundary-layer-0-01-invalid-negative-gain-with-pytest-raises-valueerror-match-must-be-positive-invalid-gains-5-0-3-0-4-0-2-0-10-0-1-0-classicalsmcconfig-gains-invalid-gains-max-force-100-dt-0-01-boundary-layer-0-01-def-test-switching-gain-validation-self-test-switching-gain-must-be-positive-with-pytest-raises-valueerror-match-switching-gain-k-must-be-positive-invalid-gains-5-0-3-0-4-0-2-0-10-0-1-0-k-0-classicalsmcconfig-gains-invalid-gains-max-force-100-dt-0-01-boundary-layer-0-01-def-test-boundary-layer-validation-self-test-boundary-layer-thickness-validation-valid-boundary-layer-valid-gains-5-0-3-0-4-0-2-0-10-0-1-0-config-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-05-invalid-zero-boundary-layer-with-pytest-raises-valueerror-match-boundary-layer-must-be-positive-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-0-invalid-negative-boundary-layer-with-pytest-raises-valueerror-match-boundary-layer-must-be-positive-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-01">runnable: false class TestClassicalSMCConfigValidation: â€œâ€â€Test configuration parameter validation.â€â€â€ def test_positive_gain_requirement(self): â€œâ€â€Test that all surface gains must be positive.â€â€â€ # Valid configuration valid_gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] config = ClassicalSMCConfig(gains=valid_gains, max_force=100, dt=0.01, boundary_layer=0.01) # Invalid: zero gain with pytest.raises(ValueError, match=â€must be positiveâ€): invalid_gains = [0.0, 3.0, 4.0, 2.0, 10.0, 1.0] ClassicalSMCConfig(gains=invalid_gains, max_force=100, dt=0.01, boundary_layer=0.01) # Invalid: negative gain with pytest.raises(ValueError, match=â€must be positiveâ€): invalid_gains = [5.0, -3.0, 4.0, 2.0, 10.0, 1.0] ClassicalSMCConfig(gains=invalid_gains, max_force=100, dt=0.01, boundary_layer=0.01) def test_switching_gain_validation(self): â€œâ€â€Test switching gain must be positive.â€â€â€ with pytest.raises(ValueError, match=â€Switching gain K must be positiveâ€): invalid_gains = [5.0, 3.0, 4.0, 2.0, -10.0, 1.0] # K &lt; 0 ClassicalSMCConfig(gains=invalid_gains, max_force=100, dt=0.01, boundary_layer=0.01) def test_boundary_layer_validation(self): â€œâ€â€Test boundary layer thickness validation.â€â€â€ # Valid boundary layer valid_gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] config = ClassicalSMCConfig(gains=valid_gains, max_force=100, dt=0.01, boundary_layer=0.05) # Invalid: zero boundary layer with pytest.raises(ValueError, match=â€boundary_layer must be positiveâ€): ClassicalSMCConfig(gains=valid_gains, max_force=100, dt=0.01, boundary_layer=0.0) # Invalid: negative boundary layer with pytest.raises(ValueError, match=â€boundary_layer must be positiveâ€): ClassicalSMCConfig(gains=valid_gains, max_force=100, dt=0.01, boundary_layer=-0.01)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-def-test-hurwitz-stability-check-test-that-gain-combinations-satisfy-hurwitz-stability-def-check-stability-k1-k2-lam1-lam2-check-if-gains-produce-stable-sliding-dynamics-for-each-2x2-subsystem-s2-is-ci-0-stability-requires-i-0-and-ci-0-return-k1-0-and-k2-0-and-lam1-0-and-lam2-0-stable-configuration-stable-gains-5-0-3-0-4-0-2-0-10-0-1-0-config-classicalsmcconfig-gains-stable-gains-max-force-100-dt-0-01-boundary-layer-0-01-assert-check-stability-config-k1-config-k2-config-lam1-config-lam2-check-damping-ratios-zeta1-config-lam1-2-np-sqrt-config-k1-zeta2-config-lam2-2-np-sqrt-config-k2-both-subsystems-should-have-positive-damping-assert-zeta1-0-assert-zeta2-0">runnable: false def test_hurwitz_stability_check(): â€œâ€â€Test that gain combinations satisfy Hurwitz stability.â€â€â€ def check_stability(k1, k2, lam1, lam2): â€œâ€â€Check if gains produce stable sliding dynamics.â€â€â€ # For each 2x2 subsystem: sÂ² + Î»áµ¢s + cáµ¢ = 0 # Stability requires Î»áµ¢ &gt; 0 and cáµ¢ &gt; 0 return k1 &gt; 0 and k2 &gt; 0 and lam1 &gt; 0 and lam2 &gt; 0 # Stable configuration stable_gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] config = ClassicalSMCConfig(gains=stable_gains, max_force=100, dt=0.01, boundary_layer=0.01) assert check_stability(config.k1, config.k2, config.lam1, config.lam2) # Check damping ratios zeta1 = config.lam1 / (2 * np.sqrt(config.k1)) zeta2 = config.lam2 / (2 * np.sqrt(config.k2)) # Both subsystems should have positive damping assert zeta1 &gt; 0 assert zeta2 &gt; 0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-class-testnumericalaccuracy-test-numerical-accuracy-and-precision-def-test-floating-point-consistency-self-test-that-computations-are-consistent-across-repeated-calls-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-compute-control-multiple-times-results-for-in-range-100-result-controller-compute-control-state-control-result-get-control-output-result-get-control-result-get-u-if-control-is-not-none-results-append-control-if-results-results-np-array-results-all-results-should-be-identical-deterministic-computation-std-dev-np-std-results-axis-0-assert-np-all-std-dev-1e-15-machine-precision-def-test-numerical-stability-small-values-self-test-numerical-stability-with-very-small-state-values-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-very-small-state-values-near-machine-precision-small-state-np-array-1e-15-1e-15-1e-15-1e-15-1e-15-1e-15-result-controller-compute-control-small-state-control-result-get-control-output-result-get-control-result-get-u-if-control-is-not-none-control-should-be-finite-and-small-assert-np-all-np-isfinite-control-assert-np-all-np-abs-control-1-0-def-test-numerical-stability-large-values-self-test-numerical-stability-with-large-state-values-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-large-state-values-but-within-reasonable-bounds-large-state-np-array-10-0-5-0-3-0-2-0-2-0-1-0-result-controller-compute-control-large-state-control-result-get-control-output-result-get-control-result-get-u-if-control-is-not-none-control-should-be-finite-and-saturated-assert-np-all-np-isfinite-control-assert-np-all-np-abs-control-config-max-force-1-01-within-saturation">runnable: false class TestNumericalAccuracy: â€œâ€â€Test numerical accuracy and precision.â€â€â€ def test_floating_point_consistency(self): â€œâ€â€Test that computations are consistent across repeated calls.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) # Compute control multiple times results = [] for _ in range(100): result = controller.compute_control(state, {}, {}) control = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, result.get(â€˜uâ€™))) if control is not None: results.append(control) if results: results = np.array(results) # All results should be identical (deterministic computation) std_dev = np.std(results, axis=0) assert np.all(std_dev &lt; 1e-15) # Machine precision def test_numerical_stability_small_values(self): â€œâ€â€Test numerical stability with very small state values.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) # Very small state values (near machine precision) small_state = np.array([1e-15, 1e-15, 1e-15, 1e-15, 1e-15, 1e-15]) result = controller.compute_control(small_state, {}, {}) control = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, result.get(â€˜uâ€™))) if control is not None: # Control should be finite and small assert np.all(np.isfinite(control)) assert np.all(np.abs(control) &lt; 1.0) def test_numerical_stability_large_values(self): â€œâ€â€Test numerical stability with large state values.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) # Large state values (but within reasonable bounds) large_state = np.array([10.0, 5.0, 3.0, 2.0, 2.0, 1.0]) result = controller.compute_control(large_state, {}, {}) control = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, result.get(â€˜uâ€™))) if control is not None: # Control should be finite and saturated assert np.all(np.isfinite(control)) assert np.all(np.abs(control) &lt;= config.max_force * 1.01) # Within saturation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-class-testsystemlevelmathematics-test-mathematical-consistency-across-system-components-def-test-control-law-decomposition-self-test-that-control-law-components-sum-correctly-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-get-overall-control-output-result-controller-compute-control-state-total-control-result-get-control-output-result-get-control-result-get-u-get-individual-components-if-available-in-debug-output-components-result-get-debug-if-u-equivalent-in-components-and-u-switching-in-components-and-u-derivative-in-components-u-eq-components-u-equivalent-u-sw-components-u-switching-u-d-components-u-derivative-before-saturation-should-sum-correctly-u-unsaturated-u-eq-u-sw-u-d-after-saturation-u-saturated-np-clip-u-unsaturated-config-max-force-config-max-force-should-match-total-control-before-any-additional-processing-if-total-control-is-not-none-assert-np-allclose-u-saturated-total-control-rtol-1e-10-def-test-lyapunov-function-properties-self-test-lyapunov-function-properties-for-stability-analysis-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-surface-linearslidingsurface-config-get-surface-gains-multiple-test-states-states-np-array-0-1-0-05-0-08-0-02-0-03-0-01-np-array-0-2-0-1-0-15-0-05-0-08-0-03-np-array-0-1-0-05-0-08-0-02-0-03-0-01-for-state-in-states-s-surface-compute-state-lyapunov-function-candidate-v-0-5-s2-v-0-5-s-2-v-should-be-non-negative-assert-v-0-v-0-if-and-only-if-s-0-if-abs-s-1e-10-assert-v-1e-15-else-assert-v-0-def-test-reaching-law-satisfaction-self-test-that-reaching-law-is-satisfied-ss-s-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-surface-linearslidingsurface-config-get-surface-gains-test-state-away-from-surface-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-s-surface-compute-state-simplified-reaching-law-check-without-full-dynamics-for-switching-control-u-sw-k-sign-s-the-reaching-condition-ss-s-should-be-satisfied-when-k-is-chosen-large-enough-this-is-a-simplified-test-full-test-would-require-dynamics-model-if-abs-s-config-boundary-layer-outside-boundary-layer-should-have-strong-reaching-behavior-expected-reaching-rate-config-k-abs-s-max-abs-s-config-boundary-layer-assert-expected-reaching-rate-0-should-be-moving-toward-surface">runnable: false class TestSystemLevelMathematics: â€œâ€â€Test mathematical consistency across system components.â€â€â€ def test_control_law_decomposition(self): â€œâ€â€Test that control law components sum correctly.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) # Get overall control output result = controller.compute_control(state, {}, {}) total_control = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, result.get(â€˜uâ€™))) # Get individual components (if available in debug output) components = result.get(â€˜debugâ€™, {}) if â€˜u_equivalentâ€™ in components and â€˜u_switchingâ€™ in components and â€˜u_derivativeâ€™ in components: u_eq = components[â€˜u_equivalentâ€™] u_sw = components[â€˜u_switchingâ€™] u_d = components[â€˜u_derivativeâ€™] # Before saturation, should sum correctly u_unsaturated = u_eq + u_sw + u_d # After saturation u_saturated = np.clip(u_unsaturated, -config.max_force, config.max_force) # Should match total control (before any additional processing) if total_control is not None: assert np.allclose(u_saturated, total_control, rtol=1e-10) def test_lyapunov_function_properties(self): â€œâ€â€Test Lyapunov function properties for stability analysis.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) surface = LinearSlidingSurface(config.get_surface_gains()) # Multiple test states states = [ np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]), np.array([0.2, 0.1, 0.15, 0.05, 0.08, 0.03]), np.array([-0.1, -0.05, -0.08, -0.02, -0.03, -0.01]) ] for state in states: s = surface.compute(state) # Lyapunov function candidate: V = 0.5 * sÂ² V = 0.5 * s**2 # V should be non-negative assert V &gt;= 0 # V = 0 if and only if s = 0 if abs(s) &lt; 1e-10: assert V &lt; 1e-15 else: assert V &gt; 0 def test_reaching_law_satisfaction(self): â€œâ€â€Test that reaching law is satisfied: s<em>á¹¡ â‰¤ -Î·|s|.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) surface = LinearSlidingSurface(config.get_surface_gains()) # Test state away from surface state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) s = surface.compute(state) # Simplified reaching law check (without full dynamics) # For switching control: u_sw = -K * sign(s) # The reaching condition s</em>á¹¡ â‰¤ -Î·|s| should be satisfied # when K is chosen large enough # This is a simplified test - full test would require dynamics model if abs(s) &gt; config.boundary_layer: # Outside boundary layer, should have strong reaching behavior expected_reaching_rate = -config.K * abs(s) / max(abs(s), config.boundary_layer) assert expected_reaching_rate &lt; 0 # Should be moving toward surface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#fast-unit-tests-mathematical-properties">Fast unit tests (mathematical properties)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#extended-property-based-testing">Extended property-based testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/validation_framework_guide.html">Validation Framework Guide <strong>System Reliability Foundation: Robust Parameter Validation &amp; Scientific Verification</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/validation_framework_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/validation_framework_guide.html#runnable-false-good-validate-once-at-construction">runnable: false # âœ… GOOD: Validate once at construction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/validation_framework_guide.html#good-single-validation-for-array">âœ… GOOD: Single validation for array</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../theory/index.html">Theoretical Foundations ```{toctree}</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ğŸ­ Controller Factory &amp; Integration</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../factory/README.html">Factory Integration Documentation Suite</a><input aria-label="Toggle navigation of Factory Integration Documentation Suite" class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" role="switch" type="checkbox"/><label for="toctree-checkbox-15"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../factory/factory_integration_user_guide.html">Factory Integration User Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/factory_api_reference.html">Factory API Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/enhanced_factory_api_reference.html">Enhanced Factory API Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/enhanced_factory_api_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/enhanced_factory_api_reference.html#runnable-false-controller-registry-classical-smc-class-modularclassicalsmc-config-class-classicalsmcconfig-default-gains-20-0-15-0-12-0-8-0-35-0-5-0-gain-count-6-description-classical-sliding-mode-controller-with-boundary-layer-supports-dynamics-true-required-params-gains-max-force-boundary-layer-additional-controllers">runnable: false CONTROLLER_REGISTRY = { â€˜classical_smcâ€™: { â€˜classâ€™: ModularClassicalSMC, â€˜config_classâ€™: ClassicalSMCConfig, â€˜default_gainsâ€™: [20.0, 15.0, 12.0, 8.0, 35.0, 5.0], â€˜gain_countâ€™: 6, â€˜descriptionâ€™: â€˜Classical sliding mode controller with boundary layerâ€™, â€˜supports_dynamicsâ€™: True, â€˜required_paramsâ€™: [â€˜gainsâ€™, â€˜max_forceâ€™, â€˜boundary_layerâ€™] }, # â€¦ additional controllers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/troubleshooting_guide.html">Factory Troubleshooting and Diagnostics Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/production_deployment_guide.html">Production Deployment Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/production_deployment_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/production_deployment_guide.html#runnable-false-def-production-readiness-check-production-readiness-validation-import-time-import-threading-import-numpy-as-np-from-src-controllers-factory-import-create-controller-list-available-controllers-get-default-gains-create-pso-controller-factory-smctype-print-production-readiness-assessment-n-results-basic-functionality-false-thread-safety-false-performance-false-pso-integration-false-error-handling-false-memory-stability-false-1-basic-functionality-test-print-1-testing-basic-functionality-try-controllers-list-available-controllers-if-len-controllers-4-expect-at-least-4-controller-types-for-controller-type-in-controllers-gains-get-default-gains-controller-type-controller-create-controller-controller-type-gains-gains-test-control-computation-test-state-np-array-0-1-0-1-0-0-0-0-0-0-0-0-result-controller-compute-control-test-state-control-value-result-u-if-hasattr-result-u-else-result-if-not-np-isfinite-control-value-raise-valueerror-f-invalid-control-output-control-value-results-basic-functionality-true-print-basic-functionality-test-passed-else-print-f-insufficient-controllers-available-len-controllers-except-exception-as-e-print-f-basic-functionality-test-failed-e-2-thread-safety-test-print-n2-testing-thread-safety-try-def-concurrent-creation-return-create-controller-classical-smc-gains-20-6-test-concurrent-controller-creation-start-time-time-time-threads-for-in-range-10-thread-threading-thread-target-concurrent-creation-threads-append-thread-thread-start-for-thread-in-threads-thread-join-timeout-5-if-thread-is-alive-raise-timeouterror-thread-did-not-complete-in-time-execution-time-time-time-start-time-if-execution-time-10-should-complete-within-10-seconds-results-thread-safety-true-print-f-thread-safety-test-passed-execution-time-2f-s-else-print-f-thread-safety-test-slow-execution-time-2f-s-except-exception-as-e-print-f-thread-safety-test-failed-e-3-performance-test-print-n3-testing-performance-try-measure-controller-creation-time-creation-times-for-in-range-100-start-time-perf-counter-create-controller-classical-smc-gains-20-6-end-time-perf-counter-creation-times-append-end-start-1000-convert-to-ms-avg-time-sum-creation-times-len-creation-times-max-time-max-creation-times-if-avg-time-5-0-and-max-time-50-0-5ms-average-50ms-max-results-performance-true-print-f-performance-test-passed-avg-avg-time-2f-ms-max-max-time-2f-ms-else-print-f-performance-test-failed-avg-avg-time-2f-ms-max-max-time-2f-ms-except-exception-as-e-print-f-performance-test-failed-e-4-pso-integration-test-print-n4-testing-pso-integration-try-factory-func-create-pso-controller-factory-smctype-classical-check-required-attributes-if-hasattr-factory-func-n-gains-and-hasattr-factory-func-controller-type-test-gains-20-15-12-8-35-5-controller-factory-func-test-gains-if-controller-is-not-none-results-pso-integration-true-print-pso-integration-test-passed-else-print-pso-factory-returned-none-else-print-pso-factory-missing-required-attributes-except-exception-as-e-print-f-pso-integration-test-failed-e-5-error-handling-test-print-n5-testing-error-handling-try-error-cases-invalid-type-10-6-classical-smc-10-3-wrong-gain-count-classical-smc-10-6-negative-gains-handled-errors-0-for-controller-type-gains-in-error-cases-try-create-controller-controller-type-gains-gains-print-f-expected-error-not-raised-for-controller-type-except-valueerror-typeerror-as-e-handled-errors-1-except-exception-as-e-print-f-unexpected-error-type-for-controller-type-type-e-if-handled-errors-len-error-cases-1-allow-one-unexpected-case-results-error-handling-true-print-f-error-handling-test-passed-handled-errors-len-error-cases-cases-else-print-f-error-handling-test-failed-handled-errors-len-error-cases-cases-except-exception-as-e-print-f-error-handling-test-failed-e-6-memory-stability-test-print-n6-testing-memory-stability-try-import-psutil-import-os-process-psutil-process-os-getpid-initial-memory-process-memory-info-rss-1024-1024-mb-create-and-destroy-many-controllers-for-in-range-1000-controller-create-controller-classical-smc-gains-20-6-del-controller-final-memory-process-memory-info-rss-1024-1024-memory-increase-final-memory-initial-memory-if-memory-increase-10-less-than-10mb-increase-results-memory-stability-true-print-f-memory-stability-test-passed-memory-increase-2f-mb-increase-else-print-f-memory-stability-test-failed-memory-increase-2f-mb-increase-except-importerror-print-psutil-not-available-skipping-memory-test-results-memory-stability-true-assume-pass-if-can-t-test-except-exception-as-e-print-f-memory-stability-test-failed-e-summary-passed-tests-sum-results-values-total-tests-len-results-success-rate-passed-tests-total-tests-100-print-f-n-production-readiness-summary-print-f-tests-passed-passed-tests-total-tests-print-f-success-rate-success-rate-1f-if-success-rate-95-print-ready-for-production-deployment-return-true-elif-success-rate-80-print-deployment-with-monitoring-recommended-return-false-else-print-not-ready-for-production-return-false-run-production-readiness-check">runnable: false def production_readiness_check(): â€œâ€â€production readiness validation.â€â€â€ import time import threading import numpy as np from src.controllers.factory import ( create_controller, list_available_controllers, get_default_gains, create_pso_controller_factory, SMCType ) print(â€œ=== Production Readiness Assessment ===\nâ€) results = { â€˜basic_functionalityâ€™: False, â€˜thread_safetyâ€™: False, â€˜performanceâ€™: False, â€˜pso_integrationâ€™: False, â€˜error_handlingâ€™: False, â€˜memory_stabilityâ€™: False } # 1. Basic Functionality Test print(â€œ1. Testing Basic Functionalityâ€¦â€) try: controllers = list_available_controllers() if len(controllers) &gt;= 4: # Expect at least 4 controller types for controller_type in controllers: gains = get_default_gains(controller_type) controller = create_controller(controller_type, gains=gains) # Test control computation test_state = np.array([0.1, 0.1, 0.0, 0.0, 0.0, 0.0]) result = controller.compute_control(test_state, (), {}) control_value = result.u if hasattr(result, â€˜uâ€™) else result if not np.isfinite(control_value): raise ValueError(fâ€Invalid control output: {control_value}â€) results[â€˜basic_functionalityâ€™] = True print(â€ âœ… Basic functionality test PASSEDâ€) else: print(fâ€ âŒ Insufficient controllers available: {len(controllers)}â€) except Exception as e: print(fâ€ âŒ Basic functionality test FAILED: {e}â€) # 2. Thread Safety Test print(â€œ\n2. Testing Thread Safetyâ€¦â€) try: def concurrent_creation(): return create_controller(â€˜classical_smcâ€™, gains=[20]*6) # Test concurrent controller creation start_time = time.time() threads = [] for _ in range(10): thread = threading.Thread(target=concurrent_creation) threads.append(thread) thread.start() for thread in threads: thread.join(timeout=5) if thread.is_alive(): raise TimeoutError(â€œThread did not complete in timeâ€) execution_time = time.time() - start_time if execution_time &lt; 10: # Should complete within 10 seconds results[â€˜thread_safetyâ€™] = True print(fâ€ âœ… Thread safety test PASSED ({execution_time:.2f}s)â€) else: print(fâ€ âŒ Thread safety test SLOW ({execution_time:.2f}s)â€) except Exception as e: print(fâ€ âŒ Thread safety test FAILED: {e}â€) # 3. Performance Test print(â€œ\n3. Testing Performanceâ€¦â€) try: # Measure controller creation time creation_times = [] for _ in range(100): start = time.perf_counter() create_controller(â€˜classical_smcâ€™, gains=[20]*6) end = time.perf_counter() creation_times.append((end - start) * 1000) # Convert to ms avg_time = sum(creation_times) / len(creation_times) max_time = max(creation_times) if avg_time &lt; 5.0 and max_time &lt; 50.0: # &lt; 5ms average, &lt; 50ms max results[â€˜performanceâ€™] = True print(fâ€ âœ… Performance test PASSED (avg: {avg_time:.2f}ms, max: {max_time:.2f}ms)â€) else: print(fâ€ âŒ Performance test FAILED (avg: {avg_time:.2f}ms, max: {max_time:.2f}ms)â€) except Exception as e: print(fâ€ âŒ Performance test FAILED: {e}â€) # 4. PSO Integration Test print(â€œ\n4. Testing PSO Integrationâ€¦â€) try: factory_func = create_pso_controller_factory(SMCType.CLASSICAL) # Check required attributes if hasattr(factory_func, â€˜n_gainsâ€™) and hasattr(factory_func, â€˜controller_typeâ€™): test_gains = [20, 15, 12, 8, 35, 5] controller = factory_func(test_gains) if controller is not None: results[â€˜pso_integrationâ€™] = True print(â€ âœ… PSO integration test PASSEDâ€) else: print(â€ âŒ PSO factory returned Noneâ€) else: print(â€ âŒ PSO factory missing required attributesâ€) except Exception as e: print(fâ€ âŒ PSO integration test FAILED: {e}â€) # 5. Error Handling Test print(â€œ\n5. Testing Error Handlingâ€¦â€) try: error_cases = [ (â€˜invalid_typeâ€™, [10]*6), (â€˜classical_smcâ€™, [10]*3), # Wrong gain count (â€˜classical_smcâ€™, [-10]*6), # Negative gains ] handled_errors = 0 for controller_type, gains in error_cases: try: create_controller(controller_type, gains=gains) print(fâ€ âš ï¸ Expected error not raised for {controller_type}â€) except (ValueError, TypeError) as e: handled_errors += 1 except Exception as e: print(fâ€ âš ï¸ Unexpected error type for {controller_type}: {type(e)}â€) if handled_errors &gt;= len(error_cases) - 1: # Allow one unexpected case results[â€˜error_handlingâ€™] = True print(fâ€ âœ… Error handling test PASSED ({handled_errors}/{len(error_cases)} cases)â€) else: print(fâ€ âŒ Error handling test FAILED ({handled_errors}/{len(error_cases)} cases)â€) except Exception as e: print(fâ€ âŒ Error handling test FAILED: {e}â€) # 6. Memory Stability Test print(â€œ\n6. Testing Memory Stabilityâ€¦â€) try: import psutil import os process = psutil.Process(os.getpid()) initial_memory = process.memory_info().rss / 1024 / 1024 # MB # Create and destroy many controllers for _ in range(1000): controller = create_controller(â€˜classical_smcâ€™, gains=[20]*6) del controller final_memory = process.memory_info().rss / 1024 / 1024 memory_increase = final_memory - initial_memory if memory_increase &lt; 10: # Less than 10MB increase results[â€˜memory_stabilityâ€™] = True print(fâ€ âœ… Memory stability test PASSED ({memory_increase:.2f}MB increase)â€) else: print(fâ€ âŒ Memory stability test FAILED ({memory_increase:.2f}MB increase)â€) except ImportError: print(â€ âš ï¸ psutil not available, skipping memory testâ€) results[â€˜memory_stabilityâ€™] = True # Assume pass if canâ€™t test except Exception as e: print(fâ€ âŒ Memory stability test FAILED: {e}â€) # Summary passed_tests = sum(results.values()) total_tests = len(results) success_rate = (passed_tests / total_tests) * 100 print(fâ€\n=== Production Readiness Summary ===â€) print(fâ€Tests passed: {passed_tests}/{total_tests}â€) print(fâ€Success rate: {success_rate:.1f}%â€) if success_rate &gt;= 95: print(â€âœ… READY FOR PRODUCTION DEPLOYMENTâ€) return True elif success_rate &gt;= 80: print(â€âš ï¸ DEPLOYMENT WITH MONITORING RECOMMENDEDâ€) return False else: print(â€âŒ NOT READY FOR PRODUCTIONâ€) return False # Run production readiness check</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/production_deployment_guide.html#production-config-yaml">production_config.yaml</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/production_deployment_guide.html#production-environment-variables">Production environment variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/production_deployment_guide.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/production_deployment_guide.html#runnable-false-def-verify-production-dependencies-verify-all-required-dependencies-are-available-required-packages-numpy-1-19-0-scipy-1-6-0-pydantic-1-8-0-pyyaml-5-4-0-optional-packages-psutil-5-8-0-for-memory-monitoring-prometheus-client-0-12-0-for-metrics-structlog-21-0-0-for-structured-logging-print-verifying-production-dependencies-check-required-packages-for-package-version-in-required-packages-items-try-import-package-print-f-package-version-available-except-importerror-print-f-package-version-missing-required-return-false-check-optional-packages-for-package-version-in-optional-packages-items-try-import-package-print-f-package-version-available-except-importerror-print-f-package-version-missing-optional-return-true-verify-dependencies">runnable: false def verify_production_dependencies(): â€œâ€â€Verify all required dependencies are available.â€â€â€ required_packages = { â€˜numpyâ€™: â€˜&gt;=1.19.0â€™, â€˜scipyâ€™: â€˜&gt;=1.6.0â€™, â€˜pydanticâ€™: â€˜&gt;=1.8.0â€™, â€˜pyyamlâ€™: â€˜&gt;=5.4.0â€™ } optional_packages = { â€˜psutilâ€™: â€˜&gt;=5.8.0â€™, # For memory monitoring â€˜prometheus_clientâ€™: â€˜&gt;=0.12.0â€™, # For metrics â€˜structlogâ€™: â€˜&gt;=21.0.0â€™ # For structured logging } print(â€œVerifying production dependenciesâ€¦â€) # Check required packages for package, version in required_packages.items(): try: <strong>import</strong>(package) print(fâ€âœ… {package} {version} - Availableâ€) except ImportError: print(fâ€âŒ {package} {version} - MISSING (REQUIRED)â€) return False # Check optional packages for package, version in optional_packages.items(): try: <strong>import</strong>(package) print(fâ€âœ… {package} {version} - Availableâ€) except ImportError: print(fâ€âš ï¸ {package} {version} - Missing (optional)â€) return True # Verify dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/production_deployment_guide.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/production_deployment_guide.html#runnable-false-class-productionfactorydeployment-production-deployment-manager-for-factory-system-def-init-self-config-self-config-config-self-current-version-none-self-new-version-none-self-rollback-data-def-pre-deployment-checks-self-run-pre-deployment-validation-checks-dependencies-self-verify-dependencies-configuration-self-validate-configuration-compatibility-self-check-backward-compatibility-performance-self-benchmark-performance-health-self-health-check-passed-all-checks-values-failed-checks-name-for-name-result-in-checks-items-if-not-result-if-not-passed-raise-runtimeerror-f-pre-deployment-checks-failed-failed-checks-return-checks-def-deploy-with-canary-self-percentage-10-deploy-new-factory-version-using-canary-strategy-print-f-starting-canary-deployment-percentage-traffic-1-deploy-to-canary-environment-canary-success-self-deploy-canary-if-not-canary-success-raise-runtimeerror-canary-deployment-failed-2-monitor-canary-performance-canary-metrics-self-monitor-canary-duration-300-5-minutes-if-not-self-evaluate-canary-metrics-canary-metrics-self-rollback-canary-raise-runtimeerror-canary-metrics-below-threshold-3-gradual-rollout-for-percentage-in-25-50-75-100-print-f-rolling-out-to-percentage-of-traffic-self-update-traffic-split-percentage-metrics-self-monitor-deployment-duration-180-3-minutes-if-not-self-evaluate-metrics-metrics-self-rollback-deployment-raise-runtimeerror-f-rollout-failed-at-percentage-print-deployment-completed-successfully-return-true-def-rollback-deployment-self-rollback-to-previous-version-print-rolling-back-deployment-restore-previous-factory-version-self-restore-factory-version-verify-rollback-success-health-ok-self-health-check-if-not-health-ok-raise-runtimeerror-rollback-verification-failed-print-rollback-completed-successfully-example-deployment">runnable: false class ProductionFactoryDeployment: â€œâ€â€Production deployment manager for factory system.â€â€â€ def <strong>init</strong>(self, config): self.config = config self.current_version = None self.new_version = None self.rollback_data = {} def pre_deployment_checks(self): â€œâ€â€Run pre-deployment validation.â€â€â€ checks = { â€˜dependenciesâ€™: self.verify_dependencies(), â€˜configurationâ€™: self.validate_configuration(), â€˜compatibilityâ€™: self.check_backward_compatibility(), â€˜performanceâ€™: self.benchmark_performance(), â€˜healthâ€™: self.health_check() } passed = all(checks.values()) failed_checks = [name for name, result in checks.items() if not result] if not passed: raise RuntimeError(fâ€Pre-deployment checks failed: {failed_checks}â€) return checks def deploy_with_canary(self, percentage=10): â€œâ€â€Deploy new factory version using canary strategy.â€â€â€ print(fâ€Starting canary deployment ({percentage}% traffic)â€) # 1. Deploy to canary environment canary_success = self.deploy_canary() if not canary_success: raise RuntimeError(â€œCanary deployment failedâ€) # 2. Monitor canary performance canary_metrics = self.monitor_canary(duration=300) # 5 minutes if not self.evaluate_canary_metrics(canary_metrics): self.rollback_canary() raise RuntimeError(â€œCanary metrics below thresholdâ€) # 3. Gradual rollout for percentage in [25, 50, 75, 100]: print(fâ€Rolling out to {percentage}% of trafficâ€) self.update_traffic_split(percentage) metrics = self.monitor_deployment(duration=180) # 3 minutes if not self.evaluate_metrics(metrics): self.rollback_deployment() raise RuntimeError(fâ€Rollout failed at {percentage}%â€) print(â€âœ… Deployment completed successfullyâ€) return True def rollback_deployment(self): â€œâ€â€Rollback to previous version.â€â€â€ print(â€ğŸ”„ Rolling back deploymentâ€) # Restore previous factory version self.restore_factory_version() # Verify rollback success health_ok = self.health_check() if not health_ok: raise RuntimeError(â€œRollback verification failedâ€) print(â€âœ… Rollback completed successfullyâ€) # Example deployment</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/production_deployment_guide.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/production_deployment_guide.html#runnable-false-def-blue-green-deployment-blue-green-deployment-strategy-print-starting-blue-green-deployment-setup-green-environment-green-env-setup-green-environment-deploy-to-green-environment-deploy-to-green-green-env-smoke-test-green-environment-if-not-smoke-test-green-green-env-cleanup-green-green-env-raise-runtimeerror-green-environment-smoke-test-failed-switch-traffic-to-green-switch-traffic-to-green-green-env-monitor-for-issues-monitor-duration-600-10-minutes-if-monitor-green-environment-monitor-duration-success-cleanup-blue-environment-cleanup-blue-environment-print-blue-green-deployment-successful-else-issues-detected-rollback-to-blue-switch-traffic-to-blue-cleanup-green-green-env-raise-runtimeerror-green-environment-issues-detected-rolled-back-run-blue-green-deployment">runnable: false def blue_green_deployment(): â€œâ€â€Blue-green deployment strategy.â€â€â€ print(â€œStarting blue-green deploymentâ€) # Setup green environment green_env = setup_green_environment() # Deploy to green environment deploy_to_green(green_env) # Smoke test green environment if not smoke_test_green(green_env): cleanup_green(green_env) raise RuntimeError(â€œGreen environment smoke test failedâ€) # Switch traffic to green switch_traffic_to_green(green_env) # Monitor for issues monitor_duration = 600 # 10 minutes if monitor_green_environment(monitor_duration): # Success - cleanup blue environment cleanup_blue_environment() print(â€âœ… Blue-green deployment successfulâ€) else: # Issues detected - rollback to blue switch_traffic_to_blue() cleanup_green(green_env) raise RuntimeError(â€œGreen environment issues detected, rolled backâ€) # Run blue-green deployment</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/production_deployment_guide.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/production_deployment_guide.html#runnable-false-class-factoryalertmanager-production-alerting-for-factory-system-def-init-self-config-self-config-config-self-alert-history-self-suppression-rules-def-evaluate-alerts-self-metrics-health-status-evaluate-alert-conditions-alerts-performance-alerts-if-controller-creation-time-in-metrics-avg-time-metrics-controller-creation-time-mean-if-avg-time-10-10ms-threshold-alerts-append-type-performance-severity-warning-if-avg-time-20-else-critical-message-f-high-controller-creation-time-avg-time-2f-ms-metric-controller-creation-time-value-avg-time-threshold-10-memory-alerts-if-memory-usage-in-metrics-memory-mb-metrics-memory-usage-current-if-memory-mb-500-500mb-threshold-alerts-append-type-memory-severity-warning-if-memory-mb-1000-else-critical-message-f-high-memory-usage-memory-mb-2f-mb-metric-memory-usage-value-memory-mb-threshold-500-health-alerts-if-health-status-overall-status-healthy-failed-checks-name-for-name-check-in-health-status-checks-items-if-not-check-get-healthy-false-alerts-append-type-health-severity-critical-if-health-status-overall-status-unhealthy-else-warning-message-f-health-check-failed-join-failed-checks-failed-checks-failed-checks-apply-suppression-rules-alerts-self-apply-suppression-alerts-send-notifications-for-alert-in-alerts-self-send-notification-alert-return-alerts-def-apply-suppression-self-alerts-apply-alert-suppression-rules-suppressed-alerts-for-alert-in-alerts-alert-key-f-alert-type-alert-get-metric-unknown-check-if-alert-is-already-suppressed-if-alert-key-in-self-suppression-rules-last-sent-self-suppression-rules-alert-key-if-time-time-last-sent-300-5-minute-suppression-continue-suppressed-alerts-append-alert-self-suppression-rules-alert-key-time-time-return-suppressed-alerts-def-send-notification-self-alert-send-alert-notification-print-f-alert-alert-severity-upper-alert-message-in-production-integrate-with-slack-teams-notifications-pagerduty-email-alerts-sms-notifications-monitoring-dashboards-self-alert-history-append-timestamp-time-time-alert-alert-setup-alert-manager">runnable: false class FactoryAlertManager: â€œâ€â€Production alerting for factory system.â€â€â€ def <strong>init</strong>(self, config): self.config = config self.alert_history = [] self.suppression_rules = {} def evaluate_alerts(self, metrics, health_status): â€œâ€â€Evaluate alert conditions.â€â€â€ alerts = [] # Performance alerts if â€˜controller_creation_timeâ€™ in metrics: avg_time = metrics[â€˜controller_creation_timeâ€™][â€˜meanâ€™] if avg_time &gt; 10: # 10ms threshold alerts.append({ â€˜typeâ€™: â€˜performanceâ€™, â€˜severityâ€™: â€˜warningâ€™ if avg_time &lt; 20 else â€˜criticalâ€™, â€˜messageâ€™: fâ€™High controller creation time: {avg_time:.2f}msâ€™, â€˜metricâ€™: â€˜controller_creation_timeâ€™, â€˜valueâ€™: avg_time, â€˜thresholdâ€™: 10 }) # Memory alerts if â€˜memory_usageâ€™ in metrics: memory_mb = metrics[â€˜memory_usageâ€™][â€˜currentâ€™] if memory_mb &gt; 500: # 500MB threshold alerts.append({ â€˜typeâ€™: â€˜memoryâ€™, â€˜severityâ€™: â€˜warningâ€™ if memory_mb &lt; 1000 else â€˜criticalâ€™, â€˜messageâ€™: fâ€™High memory usage: {memory_mb:.2f}MBâ€™, â€˜metricâ€™: â€˜memory_usageâ€™, â€˜valueâ€™: memory_mb, â€˜thresholdâ€™: 500 }) # Health alerts if health_status[â€˜overall_statusâ€™] != â€˜healthyâ€™: failed_checks = [name for name, check in health_status[â€˜checksâ€™].items() if not check.get(â€˜healthyâ€™, False)] alerts.append({ â€˜typeâ€™: â€˜healthâ€™, â€˜severityâ€™: â€˜criticalâ€™ if health_status[â€˜overall_statusâ€™] == â€˜unhealthyâ€™ else â€˜warningâ€™, â€˜messageâ€™: fâ€™Health check failed: {â€, â€œ.join(failed_checks)}â€™, â€˜failed_checksâ€™: failed_checks }) # Apply suppression rules alerts = self.apply_suppression(alerts) # Send notifications for alert in alerts: self.send_notification(alert) return alerts def apply_suppression(self, alerts): â€œâ€â€Apply alert suppression rules.â€â€â€ suppressed_alerts = [] for alert in alerts: alert_key = fâ€{alert[â€˜typeâ€™]}_{alert.get(â€˜metricâ€™, â€˜unknownâ€™)}â€ # Check if alert is already suppressed if alert_key in self.suppression_rules: last_sent = self.suppression_rules[alert_key] if time.time() - last_sent &lt; 300: # 5 minute suppression continue suppressed_alerts.append(alert) self.suppression_rules[alert_key] = time.time() return suppressed_alerts def send_notification(self, alert): â€œâ€â€Send alert notification.â€â€â€ print(fâ€ğŸš¨ ALERT [{alert[â€˜severityâ€™].upper()}]: {alert[â€˜messageâ€™]}â€) # In production, integrate with: # - Slack/Teams notifications # - PagerDuty # - Email alerts # - SMS notifications # - Monitoring dashboards self.alert_history.append({ â€˜timestampâ€™: time.time(), â€˜alertâ€™: alert }) # Setup alert manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/production_deployment_guide.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/production_deployment_guide.html#runnable-false-class-factorymaintenancemanager-production-maintenance-for-factory-system-def-init-self-self-maintenance-log-def-daily-maintenance-self-daily-maintenance-tasks-print-running-daily-maintenance-tasks-health-check-self-comprehensive-health-check-performance-validation-self-validate-performance-memory-cleanup-self-memory-cleanup-log-rotation-self-rotate-logs-cache-cleanup-self-cleanup-cache-metrics-collection-self-collect-daily-metrics-results-for-task-name-task-func-in-tasks-try-print-f-running-task-name-result-task-func-results-task-name-success-true-result-result-print-f-task-name-completed-except-exception-as-e-results-task-name-success-false-error-str-e-print-f-task-name-failed-e-self-log-maintenance-results-daily-results-return-results-def-weekly-maintenance-self-weekly-maintenance-tasks-print-running-weekly-maintenance-tasks-deep-performance-analysis-self-deep-performance-analysis-memory-leak-detection-self-detect-memory-leaks-configuration-validation-self-validate-configuration-dependency-updates-check-self-check-dependency-updates-security-scan-self-security-scan-backup-verification-self-verify-backups-results-for-task-name-task-func-in-tasks-try-print-f-running-task-name-result-task-func-results-task-name-success-true-result-result-print-f-task-name-completed-except-exception-as-e-results-task-name-success-false-error-str-e-print-f-task-name-failed-e-self-log-maintenance-results-weekly-results-return-results-def-comprehensive-health-check-self-health-validation-run-extended-health-checks-health-checker-factoryhealthchecker-return-health-checker-perform-health-check-def-validate-performance-self-validate-factory-performance-meets-slas-from-src-controllers-factory-import-create-controller-import-time-performance-test-creation-times-for-in-range-100-start-time-perf-counter-create-controller-classical-smc-gains-20-6-creation-times-append-time-perf-counter-start-1000-avg-time-sum-creation-times-len-creation-times-p95-time-sorted-creation-times-95-p99-time-sorted-creation-times-99-sla-validation-sla-results-average-creation-time-ms-avg-time-p95-creation-time-ms-p95-time-p99-creation-time-ms-p99-time-sla-met-avg-time-5-0-and-p95-time-10-0-and-p99-time-25-0-return-sla-results-def-memory-cleanup-self-cleanup-memory-and-optimize-garbage-collection-import-gc-import-psutil-import-os-force-garbage-collection-before-memory-psutil-process-os-getpid-memory-info-rss-1024-1024-collected-gc-collect-after-memory-psutil-process-os-getpid-memory-info-rss-1024-1024-return-objects-collected-collected-memory-before-mb-before-memory-memory-after-mb-after-memory-memory-freed-mb-before-memory-after-memory-def-rotate-logs-self-rotate-and-compress-log-files-implement-log-rotation-logic-return-logs-rotated-0-size-saved-mb-0-def-cleanup-cache-self-cleanup-factory-cache-if-implemented-implement-cache-cleanup-logic-return-cache-entries-removed-0-def-collect-daily-metrics-self-collect-and-store-daily-metrics-collect-metrics-for-historical-analysis-return-metrics-collected-true-def-log-maintenance-results-self-maintenance-type-results-log-maintenance-results-maintenance-record-timestamp-time-time-type-maintenance-type-results-results-success-rate-sum-1-for-r-in-results-values-if-r-success-len-results-self-maintenance-log-append-maintenance-record-print-f-maintenance-maintenance-type-completed-with-maintenance-record-success-rate-1-success-rate-setup-maintenance-manager">runnable: false class FactoryMaintenanceManager: â€œâ€â€Production maintenance for factory system.â€â€â€ def <strong>init</strong>(self): self.maintenance_log = [] def daily_maintenance(self): â€œâ€â€Daily maintenance tasks.â€â€â€ print(â€œRunning daily maintenanceâ€¦â€) tasks = [ (â€˜Health Checkâ€™, self.comprehensive_health_check), (â€˜Performance Validationâ€™, self.validate_performance), (â€˜Memory Cleanupâ€™, self.memory_cleanup), (â€˜Log Rotationâ€™, self.rotate_logs), (â€˜Cache Cleanupâ€™, self.cleanup_cache), (â€˜Metrics Collectionâ€™, self.collect_daily_metrics) ] results = {} for task_name, task_func in tasks: try: print(fâ€ Running {task_name}â€¦â€) result = task_func() results[task_name] = {â€˜successâ€™: True, â€˜resultâ€™: result} print(fâ€ âœ… {task_name} completedâ€) except Exception as e: results[task_name] = {â€˜successâ€™: False, â€˜errorâ€™: str(e)} print(fâ€ âŒ {task_name} failed: {e}â€) self.log_maintenance_results(â€˜dailyâ€™, results) return results def weekly_maintenance(self): â€œâ€â€Weekly maintenance tasks.â€â€â€ print(â€œRunning weekly maintenanceâ€¦â€) tasks = [ (â€˜Deep Performance Analysisâ€™, self.deep_performance_analysis), (â€˜Memory Leak Detectionâ€™, self.detect_memory_leaks), (â€˜Configuration Validationâ€™, self.validate_configuration), (â€˜Dependency Updates Checkâ€™, self.check_dependency_updates), (â€˜Security Scanâ€™, self.security_scan), (â€˜Backup Verificationâ€™, self.verify_backups) ] results = {} for task_name, task_func in tasks: try: print(fâ€ Running {task_name}â€¦â€) result = task_func() results[task_name] = {â€˜successâ€™: True, â€˜resultâ€™: result} print(fâ€ âœ… {task_name} completedâ€) except Exception as e: results[task_name] = {â€˜successâ€™: False, â€˜errorâ€™: str(e)} print(fâ€ âŒ {task_name} failed: {e}â€) self.log_maintenance_results(â€˜weeklyâ€™, results) return results def comprehensive_health_check(self): â€œâ€â€health validation.â€â€â€ # Run extended health checks health_checker = FactoryHealthChecker() return health_checker.perform_health_check() def validate_performance(self): â€œâ€â€Validate factory performance meets SLAs.â€â€â€ from src.controllers.factory import create_controller import time # Performance test creation_times = [] for _ in range(100): start = time.perf_counter() create_controller(â€˜classical_smcâ€™, gains=[20]*6) creation_times.append((time.perf_counter() - start) * 1000) avg_time = sum(creation_times) / len(creation_times) p95_time = sorted(creation_times)[95] p99_time = sorted(creation_times)[99] # SLA validation sla_results = { â€˜average_creation_time_msâ€™: avg_time, â€˜p95_creation_time_msâ€™: p95_time, â€˜p99_creation_time_msâ€™: p99_time, â€˜sla_metâ€™: avg_time &lt; 5.0 and p95_time &lt; 10.0 and p99_time &lt; 25.0 } return sla_results def memory_cleanup(self): â€œâ€â€Cleanup memory and optimize garbage collection.â€â€â€ import gc import psutil import os # Force garbage collection before_memory = psutil.Process(os.getpid()).memory_info().rss / 1024 / 1024 collected = gc.collect() after_memory = psutil.Process(os.getpid()).memory_info().rss / 1024 / 1024 return { â€˜objects_collectedâ€™: collected, â€˜memory_before_mbâ€™: before_memory, â€˜memory_after_mbâ€™: after_memory, â€˜memory_freed_mbâ€™: before_memory - after_memory } def rotate_logs(self): â€œâ€â€Rotate and compress log files.â€â€â€ # Implement log rotation logic return {â€˜logs_rotatedâ€™: 0, â€˜size_saved_mbâ€™: 0} def cleanup_cache(self): â€œâ€â€Cleanup factory cache if implemented.â€â€â€ # Implement cache cleanup logic return {â€˜cache_entries_removedâ€™: 0} def collect_daily_metrics(self): â€œâ€â€Collect and store daily metrics.â€â€â€ # Collect metrics for historical analysis return {â€˜metrics_collectedâ€™: True} def log_maintenance_results(self, maintenance_type, results): â€œâ€â€Log maintenance results.â€â€â€ maintenance_record = { â€˜timestampâ€™: time.time(), â€˜typeâ€™: maintenance_type, â€˜resultsâ€™: results, â€˜success_rateâ€™: sum(1 for r in results.values() if r[â€˜successâ€™]) / len(results) } self.maintenance_log.append(maintenance_record) print(fâ€Maintenance {maintenance_type} completed with {maintenance_record[â€˜success_rateâ€™]:.1%} success rateâ€) # Setup maintenance manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/configuration_reference.html">Factory Configuration Reference ## Overview The SMC Controller Factory system provides a unified, type-safe interface for creating sliding mode controllers with parameter validation, deprecation management, and PSO optimization integration. This reference documents the factory configuration system implemented to resolve GitHub Issue #6. ## Factory Architecture ### Core Components ```</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/configuration_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/configuration_reference.html#runnable-false-thread-safe-factory-operations">runnable: false # Thread-safe factory operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/migration_guide.html">Migration Guide for Existing Configurations ## Overview This migration guide helps users transition from older controller factory configurations to the enhanced GitHub Issue #6 resolution implementation. The guide covers automated migration tools, manual migration procedures, and best practices for maintaining system stability during transitions. ## Migration Overview ### What Changed in GitHub Issue #6 Resolution The factory integration fixes address several critical areas: 1. <strong>Parameter Interface Unification</strong>: Standardized parameter handling across all SMC controller types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/migration_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/migration_guide.html#runnable-false-pre-migration-configuration-v1-x">runnable: false # Pre-Migration Configuration (v1.x)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/migration_guide.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/migration_guide.html#runnable-false-def-interactive-migration-wizard-none-interactive-step-by-step-migration-wizard-for-complex-configurations-print-smc-controller-configuration-migration-wizard-n-step-1-configuration-file-location-config-path-input-enter-path-to-configuration-file-strip-if-not-os-path-exists-config-path-print-f-error-file-not-found-config-path-return-step-2-backup-preferences-create-backup-input-create-backup-before-migration-y-n-strip-lower-create-backup-create-backup-n-step-3-migration-analysis-print-nanalyzing-configuration-migrator-configurationmigrationutility-load-and-analyze-configuration-try-with-open-config-path-r-as-f-if-config-path-endswith-yml-yaml-import-yaml-config-data-yaml-safe-load-f-else-import-json-config-data-json-load-f-analyze-deprecations-warner-controllerdeprecationwarner-analysis-results-if-controllers-in-config-data-for-controller-type-controller-config-in-config-data-controllers-items-if-isinstance-controller-config-dict-warnings-warner-check-deprecated-parameters-controller-type-controller-config-analysis-results-controller-type-warnings-display-analysis-total-warnings-sum-len-warnings-for-warnings-in-analysis-results-values-if-total-warnings-0-print-no-deprecated-parameters-found-configuration-is-up-to-date-return-print-f-found-total-warnings-deprecated-parameters-for-controller-type-warnings-in-analysis-results-items-if-warnings-print-f-n-controller-type-for-warning-in-warnings-print-f-warning-old-parameter-warning-migration-guide-step-4-confirm-migration-proceed-input-f-nproceed-with-migration-y-n-strip-lower-if-proceed-n-print-migration-cancelled-return-step-5-perform-migration-print-nperforming-migration-result-migrator-migrate-configuration-file-config-file-path-config-path-create-backup-create-backup-if-result-success-print-migration-completed-successfully-if-result-backup-file-print-f-backup-created-result-backup-file-step-6-validation-validate-input-nvalidate-migrated-configuration-y-n-strip-lower-if-validate-n-validation-result-migrator-validate-migrated-configuration-result-migration-summary-get-migrated-config-if-validation-result-success-print-validation-passed-configuration-is-ready-to-use-else-print-validation-issues-found-for-issue-in-validation-result-issues-print-f-issue-else-print-f-migration-failed-result-error-except-exception-as-e-print-f-error-during-migration-analysis-e-run-the-wizard">runnable: false def interactive_migration_wizard() -&gt; None: â€œâ€â€ Interactive step-by-step migration wizard for complex configurations. â€œâ€â€ print(â€œ=== SMC Controller Configuration Migration Wizard ===\nâ€) # Step 1: Configuration file location config_path = input(â€œEnter path to configuration file: â€œ).strip() if not os.path.exists(config_path): print(fâ€Error: File not found - {config_path}â€) return # Step 2: Backup preferences create_backup = input(â€œCreate backup before migration? (Y/n): â€œ).strip().lower() create_backup = create_backup != â€˜nâ€™ # Step 3: Migration analysis print(â€œ\nAnalyzing configurationâ€¦â€) migrator = ConfigurationMigrationUtility() # Load and analyze configuration try: with open(config_path, â€˜râ€™) as f: if config_path.endswith((â€˜.ymlâ€™, â€˜.yamlâ€™)): import yaml config_data = yaml.safe_load(f) else: import json config_data = json.load(f) # Analyze deprecations warner = ControllerDeprecationWarner() analysis_results = {} if â€˜controllersâ€™ in config_data: for controller_type, controller_config in config_data[â€˜controllersâ€™].items(): if isinstance(controller_config, dict): _, warnings = warner.check_deprecated_parameters(controller_type, controller_config) analysis_results[controller_type] = warnings # Display analysis total_warnings = sum(len(warnings) for warnings in analysis_results.values()) if total_warnings == 0: print(â€âœ“ No deprecated parameters found. Configuration is up to date.â€) return print(fâ€Found {total_warnings} deprecated parameters:â€) for controller_type, warnings in analysis_results.items(): if warnings: print(fâ€\n {controller_type}:â€) for warning in warnings: print(fâ€ - {warning.old_parameter}: {warning.migration_guide}â€) # Step 4: Confirm migration proceed = input(fâ€\nProceed with migration? (Y/n): â€œ).strip().lower() if proceed == â€˜nâ€™: print(â€œMigration cancelled.â€) return # Step 5: Perform migration print(â€œ\nPerforming migrationâ€¦â€) result = migrator.migrate_configuration_file( config_file_path=config_path, create_backup=create_backup ) if result.success: print(â€âœ“ Migration completed successfully!â€) if result.backup_file: print(fâ€ Backup created: {result.backup_file}â€) # Step 6: Validation validate = input(â€œ\nValidate migrated configuration? (Y/n): â€œ).strip().lower() if validate != â€˜nâ€™: validation_result = migrator.validate_migrated_configuration( result.migration_summary.get(â€˜migrated_configâ€™, {}) ) if validation_result.success: print(â€âœ“ Validation passed - configuration is ready to use.â€) else: print(â€âš  Validation issues found:â€) for issue in validation_result.issues: print(fâ€ - {issue}â€) else: print(fâ€âœ— Migration failed: {result.error}â€) except Exception as e: print(fâ€Error during migration analysis: {e}â€) # Run the wizard</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/migration_guide.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/migration_guide.html#runnable-false-def-migrate-classical-smc-manually-old-config-dict-str-any-dict-str-any-manual-migration-procedure-for-classical-smc-configurations-changes-1-combine-gains-and-k-switching-into-6-element-gains-array-2-remove-invalid-gamma-parameter-3-rename-switch-function-to-switch-method-4-ensure-boundary-layer-parameter-is-present-new-config-step-1-handle-gains-array-gains-old-config-get-gains-8-0-6-0-4-0-3-0-15-0-if-gains-has-only-5-elements-add-k-switching-as-6th-element-if-len-gains-5-k-switching-old-config-get-k-switching-2-0-gains-gains-k-switching-elif-len-gains-5-fill-missing-gains-with-defaults-default-gains-8-0-6-0-4-0-3-0-15-0-2-0-gains-gains-default-gains-len-gains-new-config-gains-gains-6-ensure-exactly-6-gains-step-2-handle-deprecated-parameters-deprecated-params-gamma-adaptation-rate-k-switching-for-param-in-deprecated-params-if-param-in-old-config-if-param-gamma-print-f-warning-removed-invalid-gamma-parameter-for-classical-smc-elif-param-adaptation-rate-print-f-warning-removed-adaptation-rate-not-valid-for-classical-smc-k-switching-already-handled-in-gains-array-step-3-handle-renamed-parameters-if-switch-function-in-old-config-new-config-switch-method-old-config-switch-function-print-f-migrated-switch-function-switch-method-step-4-copy-valid-parameters-valid-params-max-force-dt-boundary-layer-switch-method-damping-gain-dynamics-model-for-param-in-valid-params-if-param-in-old-config-new-config-param-old-config-param-step-5-ensure-required-parameters-have-defaults-new-config-setdefault-max-force-150-0-new-config-setdefault-dt-0-001-new-config-setdefault-boundary-layer-0-02-return-new-config-example-usage">runnable: false def migrate_classical_smc_manually(old_config: Dict[str, Any]) -&gt; Dict[str, Any]: â€œâ€â€ Manual migration procedure for Classical SMC configurations. Changes: 1. Combine gains and K_switching into 6-element gains array 2. Remove invalid â€˜gammaâ€™ parameter 3. Rename â€˜switch_functionâ€™ to â€˜switch_methodâ€™ 4. Ensure boundary_layer parameter is present â€œâ€â€ new_config = {} # Step 1: Handle gains array gains = old_config.get(â€˜gainsâ€™, [8.0, 6.0, 4.0, 3.0, 15.0]) # If gains has only 5 elements, add K_switching as 6th element if len(gains) == 5: K_switching = old_config.get(â€˜K_switchingâ€™, 2.0) gains = gains + [K_switching] elif len(gains) &lt; 5: # Fill missing gains with defaults default_gains = [8.0, 6.0, 4.0, 3.0, 15.0, 2.0] gains = gains + default_gains[len(gains):] new_config[â€˜gainsâ€™] = gains[:6] # Ensure exactly 6 gains # Step 2: Handle deprecated parameters deprecated_params = [â€˜gammaâ€™, â€˜adaptation_rateâ€™, â€˜K_switchingâ€™] for param in deprecated_params: if param in old_config: if param == â€˜gammaâ€™: print(fâ€Warning: Removed invalid â€˜gammaâ€™ parameter for Classical SMCâ€) elif param == â€˜adaptation_rateâ€™: print(fâ€Warning: Removed â€˜adaptation_rateâ€™ - not valid for Classical SMCâ€) # K_switching already handled in gains array # Step 3: Handle renamed parameters if â€˜switch_functionâ€™ in old_config: new_config[â€˜switch_methodâ€™] = old_config[â€˜switch_functionâ€™] print(fâ€Migrated: switch_function -&gt; switch_methodâ€) # Step 4: Copy valid parameters valid_params = [ â€˜max_forceâ€™, â€˜dtâ€™, â€˜boundary_layerâ€™, â€˜switch_methodâ€™, â€˜damping_gainâ€™, â€˜dynamics_modelâ€™ ] for param in valid_params: if param in old_config: new_config[param] = old_config[param] # Step 5: Ensure required parameters have defaults new_config.setdefault(â€˜max_forceâ€™, 150.0) new_config.setdefault(â€˜dtâ€™, 0.001) new_config.setdefault(â€˜boundary_layerâ€™, 0.02) return new_config # Example usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/migration_guide.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/migration_guide.html#runnable-false-def-migrate-adaptive-smc-manually-old-config-dict-str-any-dict-str-any-manual-migration-procedure-for-adaptive-smc-configurations-changes-1-combine-gains-and-adaptation-gain-into-5-element-gains-array-2-rename-boundary-layer-thickness-to-boundary-layer-3-split-estimate-bounds-into-k-min-and-k-max-4-rename-adaptation-law-to-alpha-new-config-step-1-handle-gains-array-with-gamma-adaptation-rate-gains-old-config-get-gains-12-0-10-0-6-0-5-0-if-gains-has-only-4-elements-add-adaptation-gain-as-5th-element-if-len-gains-4-adaptation-gain-old-config-get-adaptation-gain-2-5-gains-gains-adaptation-gain-elif-len-gains-4-fill-missing-gains-with-defaults-default-gains-12-0-10-0-6-0-5-0-2-5-gains-gains-default-gains-len-gains-new-config-gains-gains-5-ensure-exactly-5-gains-step-2-handle-renamed-parameters-renames-boundary-layer-thickness-boundary-layer-adaptation-law-alpha-for-old-name-new-name-in-renames-items-if-old-name-in-old-config-new-config-new-name-old-config-old-name-print-f-migrated-old-name-new-name-step-3-handle-split-parameters-if-estimate-bounds-in-old-config-bounds-old-config-estimate-bounds-if-isinstance-bounds-list-tuple-and-len-bounds-2-new-config-k-min-bounds-0-new-config-k-max-bounds-1-print-f-split-estimate-bounds-k-min-k-max-else-print-f-warning-invalid-estimate-bounds-format-using-defaults-new-config-k-min-0-1-new-config-k-max-100-0-step-4-copy-valid-parameters-valid-params-max-force-dt-boundary-layer-leak-rate-adapt-rate-limit-k-min-k-max-k-init-alpha-dead-zone-smooth-switch-dynamics-model-for-param-in-valid-params-if-param-in-old-config-new-config-param-old-config-param-step-5-ensure-required-parameters-have-defaults-new-config-setdefault-max-force-150-0-new-config-setdefault-dt-0-001-new-config-setdefault-boundary-layer-0-01-new-config-setdefault-leak-rate-0-01-new-config-setdefault-adapt-rate-limit-10-0-new-config-setdefault-k-min-0-1-new-config-setdefault-k-max-100-0-new-config-setdefault-k-init-10-0-new-config-setdefault-alpha-0-5-return-new-config-example-usage">runnable: false def migrate_adaptive_smc_manually(old_config: Dict[str, Any]) -&gt; Dict[str, Any]: â€œâ€â€ Manual migration procedure for Adaptive SMC configurations. Changes: 1. Combine gains and adaptation_gain into 5-element gains array 2. Rename â€˜boundary_layer_thicknessâ€™ to â€˜boundary_layerâ€™ 3. Split â€˜estimate_boundsâ€™ into â€˜K_minâ€™ and â€˜K_maxâ€™ 4. Rename â€˜adaptation_lawâ€™ to â€˜alphaâ€™ â€œâ€â€ new_config = {} # Step 1: Handle gains array with gamma (adaptation rate) gains = old_config.get(â€˜gainsâ€™, [12.0, 10.0, 6.0, 5.0]) # If gains has only 4 elements, add adaptation_gain as 5th element if len(gains) == 4: adaptation_gain = old_config.get(â€˜adaptation_gainâ€™, 2.5) gains = gains + [adaptation_gain] elif len(gains) &lt; 4: # Fill missing gains with defaults default_gains = [12.0, 10.0, 6.0, 5.0, 2.5] gains = gains + default_gains[len(gains):] new_config[â€˜gainsâ€™] = gains[:5] # Ensure exactly 5 gains # Step 2: Handle renamed parameters renames = { â€˜boundary_layer_thicknessâ€™: â€˜boundary_layerâ€™, â€˜adaptation_lawâ€™: â€˜alphaâ€™ } for old_name, new_name in renames.items(): if old_name in old_config: new_config[new_name] = old_config[old_name] print(fâ€Migrated: {old_name} -&gt; {new_name}â€) # Step 3: Handle split parameters if â€˜estimate_boundsâ€™ in old_config: bounds = old_config[â€˜estimate_boundsâ€™] if isinstance(bounds, (list, tuple)) and len(bounds) == 2: new_config[â€˜K_minâ€™] = bounds[0] new_config[â€˜K_maxâ€™] = bounds[1] print(fâ€Split: estimate_bounds -&gt; K_min, K_maxâ€) else: print(fâ€Warning: Invalid estimate_bounds format, using defaultsâ€) new_config[â€˜K_minâ€™] = 0.1 new_config[â€˜K_maxâ€™] = 100.0 # Step 4: Copy valid parameters valid_params = [ â€˜max_forceâ€™, â€˜dtâ€™, â€˜boundary_layerâ€™, â€˜leak_rateâ€™, â€˜adapt_rate_limitâ€™, â€˜K_minâ€™, â€˜K_maxâ€™, â€˜K_initâ€™, â€˜alphaâ€™, â€˜dead_zoneâ€™, â€˜smooth_switchâ€™, â€˜dynamics_modelâ€™ ] for param in valid_params: if param in old_config: new_config[param] = old_config[param] # Step 5: Ensure required parameters have defaults new_config.setdefault(â€˜max_forceâ€™, 150.0) new_config.setdefault(â€˜dtâ€™, 0.001) new_config.setdefault(â€˜boundary_layerâ€™, 0.01) new_config.setdefault(â€˜leak_rateâ€™, 0.01) new_config.setdefault(â€˜adapt_rate_limitâ€™, 10.0) new_config.setdefault(â€˜K_minâ€™, 0.1) new_config.setdefault(â€˜K_maxâ€™, 100.0) new_config.setdefault(â€˜K_initâ€™, 10.0) new_config.setdefault(â€˜alphaâ€™, 0.5) return new_config # Example usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/migration_guide.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/migration_guide.html#runnable-false-def-migrate-sta-smc-manually-old-config-dict-str-any-dict-str-any-manual-migration-procedure-for-super-twisting-smc-configurations-changes-1-combine-k1-k2-and-other-gains-into-6-element-gains-array-2-rename-alpha-power-to-power-exponent-3-rename-switching-function-type-to-switch-method-new-config-step-1-handle-gains-array-with-k1-k2-integration-gains-old-config-get-gains-if-k1-and-k2-are-separate-parameters-integrate-them-if-k1-in-old-config-and-k2-in-old-config-k1-old-config-k1-k2-old-config-k2-if-gains-array-exists-assume-it-contains-k1-k2-lam1-lam2-if-len-gains-4-gains-k1-k2-gains-4-else-create-full-gains-array-default-surface-gains-25-0-18-0-12-0-8-0-surface-gains-gains-default-surface-gains-len-gains-gains-k1-k2-surface-gains-4-print-f-integrated-k1-k1-k2-k2-into-gains-array-elif-len-gains-6-fill-missing-gains-with-defaults-default-gains-35-0-20-0-25-0-18-0-12-0-8-0-gains-gains-default-gains-len-gains-new-config-gains-gains-6-ensure-exactly-6-gains-step-2-handle-renamed-parameters-renames-alpha-power-power-exponent-switching-function-type-switch-method-for-old-name-new-name-in-renames-items-if-old-name-in-old-config-new-config-new-name-old-config-old-name-print-f-migrated-old-name-new-name-step-3-copy-valid-parameters-valid-params-max-force-dt-power-exponent-regularization-boundary-layer-switch-method-damping-gain-dynamics-model-for-param-in-valid-params-if-param-in-old-config-new-config-param-old-config-param-step-4-ensure-required-parameters-have-defaults-new-config-setdefault-max-force-150-0-new-config-setdefault-dt-0-001-new-config-setdefault-power-exponent-0-5-new-config-setdefault-regularization-1e-6-new-config-setdefault-boundary-layer-0-01-new-config-setdefault-switch-method-tanh-return-new-config-example-usage">runnable: false def migrate_sta_smc_manually(old_config: Dict[str, Any]) -&gt; Dict[str, Any]: â€œâ€â€ Manual migration procedure for Super-Twisting SMC configurations. Changes: 1. Combine K1, K2, and other gains into 6-element gains array 2. Rename â€˜alpha_powerâ€™ to â€˜power_exponentâ€™ 3. Rename â€˜switching_function_typeâ€™ to â€˜switch_methodâ€™ â€œâ€â€ new_config = {} # Step 1: Handle gains array with K1, K2 integration gains = old_config.get(â€˜gainsâ€™, []) # If K1 and K2 are separate parameters, integrate them if â€˜K1â€™ in old_config and â€˜K2â€™ in old_config: K1 = old_config[â€˜K1â€™] K2 = old_config[â€˜K2â€™] # If gains array exists, assume it contains [k1, k2, lam1, lam2] if len(gains) &gt;= 4: gains = [K1, K2] + gains[:4] else: # Create full gains array default_surface_gains = [25.0, 18.0, 12.0, 8.0] surface_gains = gains + default_surface_gains[len(gains):] gains = [K1, K2] + surface_gains[:4] print(fâ€Integrated: K1={K1}, K2={K2} into gains arrayâ€) elif len(gains) &lt; 6: # Fill missing gains with defaults default_gains = [35.0, 20.0, 25.0, 18.0, 12.0, 8.0] gains = gains + default_gains[len(gains):] new_config[â€˜gainsâ€™] = gains[:6] # Ensure exactly 6 gains # Step 2: Handle renamed parameters renames = { â€˜alpha_powerâ€™: â€˜power_exponentâ€™, â€˜switching_function_typeâ€™: â€˜switch_methodâ€™ } for old_name, new_name in renames.items(): if old_name in old_config: new_config[new_name] = old_config[old_name] print(fâ€Migrated: {old_name} -&gt; {new_name}â€) # Step 3: Copy valid parameters valid_params = [ â€˜max_forceâ€™, â€˜dtâ€™, â€˜power_exponentâ€™, â€˜regularizationâ€™, â€˜boundary_layerâ€™, â€˜switch_methodâ€™, â€˜damping_gainâ€™, â€˜dynamics_modelâ€™ ] for param in valid_params: if param in old_config: new_config[param] = old_config[param] # Step 4: Ensure required parameters have defaults new_config.setdefault(â€˜max_forceâ€™, 150.0) new_config.setdefault(â€˜dtâ€™, 0.001) new_config.setdefault(â€˜power_exponentâ€™, 0.5) new_config.setdefault(â€˜regularizationâ€™, 1e-6) new_config.setdefault(â€˜boundary_layerâ€™, 0.01) new_config.setdefault(â€˜switch_methodâ€™, â€˜tanhâ€™) return new_config # Example usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/migration_guide.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/migration_guide.html#runnable-false-def-migrate-hybrid-smc-manually-old-config-dict-str-any-dict-str-any-manual-migration-procedure-for-hybrid-smc-configurations-changes-1-rename-mode-to-hybrid-mode-2-replace-sub-controller-gains-with-full-sub-configurations-3-update-switch-threshold-to-switching-criteria-new-config-step-1-handle-surface-gains-4-elements-for-hybrid-controller-gains-old-config-get-gains-18-0-12-0-10-0-8-0-new-config-gains-gains-4-ensure-exactly-4-surface-gains-step-2-handle-mode-parameter-if-mode-in-old-config-new-config-hybrid-mode-old-config-mode-print-f-migrated-mode-hybrid-mode-else-new-config-hybrid-mode-classical-adaptive-default-step-3-handle-sub-controller-configurations-if-sub-controller-gains-in-old-config-sub-gains-old-config-sub-controller-gains-create-proper-sub-configurations-if-isinstance-sub-gains-dict-classical-gains-sub-gains-get-classical-20-0-15-0-12-0-8-0-35-0-5-0-adaptive-gains-sub-gains-get-adaptive-25-0-18-0-15-0-10-0-4-0-else-use-defaults-if-format-is-unrecognized-classical-gains-20-0-15-0-12-0-8-0-35-0-5-0-adaptive-gains-25-0-18-0-15-0-10-0-4-0-create-full-sub-configurations-new-config-classical-config-gains-classical-gains-max-force-150-0-dt-0-001-boundary-layer-0-02-new-config-adaptive-config-gains-adaptive-gains-max-force-150-0-dt-0-001-leak-rate-0-01-adapt-rate-limit-10-0-k-min-0-1-k-max-100-0-k-init-10-0-alpha-0-5-print-converted-sub-controller-gains-full-sub-configurations-step-4-handle-switching-criteria-if-switch-threshold-in-old-config-threshold-old-config-switch-threshold-new-config-switching-criteria-error-threshold-threshold-time-threshold-2-0-default-print-converted-switch-threshold-switching-criteria-step-5-copy-valid-parameters-valid-params-dt-max-force-k1-init-k2-init-gamma1-gamma2-dynamics-model-hybrid-mode-classical-config-adaptive-config-for-param-in-valid-params-if-param-in-old-config-new-config-param-old-config-param-step-6-ensure-required-parameters-have-defaults-new-config-setdefault-dt-0-001-new-config-setdefault-max-force-150-0-new-config-setdefault-k1-init-5-0-new-config-setdefault-k2-init-3-0-new-config-setdefault-gamma1-0-5-new-config-setdefault-gamma2-0-3-return-new-config-example-usage">runnable: false def migrate_hybrid_smc_manually(old_config: Dict[str, Any]) -&gt; Dict[str, Any]: â€œâ€â€ Manual migration procedure for Hybrid SMC configurations. Changes: 1. Rename â€˜modeâ€™ to â€˜hybrid_modeâ€™ 2. Replace â€˜sub_controller_gainsâ€™ with full sub-configurations 3. Update â€˜switch_thresholdâ€™ to â€˜switching_criteriaâ€™ â€œâ€â€ new_config = {} # Step 1: Handle surface gains (4 elements for hybrid controller) gains = old_config.get(â€˜gainsâ€™, [18.0, 12.0, 10.0, 8.0]) new_config[â€˜gainsâ€™] = gains[:4] # Ensure exactly 4 surface gains # Step 2: Handle mode parameter if â€˜modeâ€™ in old_config: new_config[â€˜hybrid_modeâ€™] = old_config[â€˜modeâ€™] print(fâ€Migrated: mode -&gt; hybrid_modeâ€) else: new_config[â€˜hybrid_modeâ€™] = â€˜CLASSICAL_ADAPTIVEâ€™ # Default # Step 3: Handle sub-controller configurations if â€˜sub_controller_gainsâ€™ in old_config: sub_gains = old_config[â€˜sub_controller_gainsâ€™] # Create proper sub-configurations if isinstance(sub_gains, dict): classical_gains = sub_gains.get(â€˜classicalâ€™, [20.0, 15.0, 12.0, 8.0, 35.0, 5.0]) adaptive_gains = sub_gains.get(â€˜adaptiveâ€™, [25.0, 18.0, 15.0, 10.0, 4.0]) else: # Use defaults if format is unrecognized classical_gains = [20.0, 15.0, 12.0, 8.0, 35.0, 5.0] adaptive_gains = [25.0, 18.0, 15.0, 10.0, 4.0] # Create full sub-configurations new_config[â€˜classical_configâ€™] = { â€˜gainsâ€™: classical_gains, â€˜max_forceâ€™: 150.0, â€˜dtâ€™: 0.001, â€˜boundary_layerâ€™: 0.02 } new_config[â€˜adaptive_configâ€™] = { â€˜gainsâ€™: adaptive_gains, â€˜max_forceâ€™: 150.0, â€˜dtâ€™: 0.001, â€˜leak_rateâ€™: 0.01, â€˜adapt_rate_limitâ€™: 10.0, â€˜K_minâ€™: 0.1, â€˜K_maxâ€™: 100.0, â€˜K_initâ€™: 10.0, â€˜alphaâ€™: 0.5 } print(â€œConverted: sub_controller_gains -&gt; full sub-configurationsâ€) # Step 4: Handle switching criteria if â€˜switch_thresholdâ€™ in old_config: threshold = old_config[â€˜switch_thresholdâ€™] new_config[â€˜switching_criteriaâ€™] = { â€˜error_thresholdâ€™: threshold, â€˜time_thresholdâ€™: 2.0 # Default } print(â€œConverted: switch_threshold -&gt; switching_criteriaâ€) # Step 5: Copy valid parameters valid_params = [ â€˜dtâ€™, â€˜max_forceâ€™, â€˜k1_initâ€™, â€˜k2_initâ€™, â€˜gamma1â€™, â€˜gamma2â€™, â€˜dynamics_modelâ€™, â€˜hybrid_modeâ€™, â€˜classical_configâ€™, â€˜adaptive_configâ€™ ] for param in valid_params: if param in old_config: new_config[param] = old_config[param] # Step 6: Ensure required parameters have defaults new_config.setdefault(â€˜dtâ€™, 0.001) new_config.setdefault(â€˜max_forceâ€™, 150.0) new_config.setdefault(â€˜k1_initâ€™, 5.0) new_config.setdefault(â€˜k2_initâ€™, 3.0) new_config.setdefault(â€˜gamma1â€™, 0.5) new_config.setdefault(â€˜gamma2â€™, 0.3) return new_config # Example usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/migration_guide.html#before-migration-config-old-yaml">Before Migration (config_old.yaml)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/migration_guide.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/migration_guide.html#runnable-false-def-run-migration-test-suite-none-test-suite-for-migration-functionality-print-migration-test-suite-n-test-1-classical-smc-migration-print-test-1-classical-smc-migration-old-classical-gains-10-5-8-3-15-k-switching-2-0-gamma-0-1-switch-function-sign-new-classical-migrate-classical-smc-manually-old-classical-validation-checks-assert-len-new-classical-gains-6-classical-smc-should-have-6-gains-assert-new-classical-gains-5-2-0-k-switching-should-be-integrated-assert-gamma-not-in-new-classical-invalid-gamma-should-be-removed-assert-new-classical-get-switch-method-sign-switch-function-should-be-renamed-print-classical-smc-migration-test-passed-n-test-2-adaptive-smc-migration-print-test-2-adaptive-smc-migration-old-adaptive-gains-12-10-6-5-adaptation-gain-2-5-boundary-layer-thickness-0-02-estimate-bounds-0-1-100-0-new-adaptive-migrate-adaptive-smc-manually-old-adaptive-validation-checks-assert-len-new-adaptive-gains-5-adaptive-smc-should-have-5-gains-assert-new-adaptive-gains-4-2-5-adaptation-gain-should-be-integrated-assert-new-adaptive-get-boundary-layer-0-02-parameter-should-be-renamed-assert-new-adaptive-get-k-min-0-1-estimate-bounds-should-be-split-assert-new-adaptive-get-k-max-100-0-estimate-bounds-should-be-split-print-adaptive-smc-migration-test-passed-n-test-3-sta-smc-migration-print-test-3-sta-smc-migration-old-sta-k1-35-0-k2-20-0-gains-25-18-12-8-alpha-power-0-5-new-sta-migrate-sta-smc-manually-old-sta-validation-checks-assert-len-new-sta-gains-6-sta-smc-should-have-6-gains-assert-new-sta-gains-0-35-0-k1-should-be-first-gain-assert-new-sta-gains-1-20-0-k2-should-be-second-gain-assert-new-sta-get-power-exponent-0-5-alpha-power-should-be-renamed-print-sta-smc-migration-test-passed-n-print-all-migration-tests-passed-run-the-test-suite">runnable: false def run_migration_test_suite() -&gt; None: â€œâ€â€ test suite for migration functionality. â€œâ€â€ print(â€œ=== Migration Test Suite ===\nâ€) # Test 1: Classical SMC migration print(â€œTest 1: Classical SMC Migrationâ€) old_classical = { â€˜gainsâ€™: [10, 5, 8, 3, 15], â€˜K_switchingâ€™: 2.0, â€˜gammaâ€™: 0.1, â€˜switch_functionâ€™: â€˜signâ€™ } new_classical = migrate_classical_smc_manually(old_classical) # Validation checks assert len(new_classical[â€˜gainsâ€™]) == 6, â€œClassical SMC should have 6 gainsâ€ assert new_classical[â€˜gainsâ€™][5] == 2.0, â€œK_switching should be integratedâ€ assert â€˜gammaâ€™ not in new_classical, â€œInvalid gamma should be removedâ€ assert new_classical.get(â€˜switch_methodâ€™) == â€˜signâ€™, â€œswitch_function should be renamedâ€ print(â€âœ“ Classical SMC migration test passed\nâ€) # Test 2: Adaptive SMC migration print(â€œTest 2: Adaptive SMC Migrationâ€) old_adaptive = { â€˜gainsâ€™: [12, 10, 6, 5], â€˜adaptation_gainâ€™: 2.5, â€˜boundary_layer_thicknessâ€™: 0.02, â€˜estimate_boundsâ€™: [0.1, 100.0] } new_adaptive = migrate_adaptive_smc_manually(old_adaptive) # Validation checks assert len(new_adaptive[â€˜gainsâ€™]) == 5, â€œAdaptive SMC should have 5 gainsâ€ assert new_adaptive[â€˜gainsâ€™][4] == 2.5, â€œAdaptation gain should be integratedâ€ assert new_adaptive.get(â€˜boundary_layerâ€™) == 0.02, â€œParameter should be renamedâ€ assert new_adaptive.get(â€˜K_minâ€™) == 0.1, â€œestimate_bounds should be splitâ€ assert new_adaptive.get(â€˜K_maxâ€™) == 100.0, â€œestimate_bounds should be splitâ€ print(â€âœ“ Adaptive SMC migration test passed\nâ€) # Test 3: STA-SMC migration print(â€œTest 3: STA-SMC Migrationâ€) old_sta = { â€˜K1â€™: 35.0, â€˜K2â€™: 20.0, â€˜gainsâ€™: [25, 18, 12, 8], â€˜alpha_powerâ€™: 0.5 } new_sta = migrate_sta_smc_manually(old_sta) # Validation checks assert len(new_sta[â€˜gainsâ€™]) == 6, â€œSTA-SMC should have 6 gainsâ€ assert new_sta[â€˜gainsâ€™][0] == 35.0, â€œK1 should be first gainâ€ assert new_sta[â€˜gainsâ€™][1] == 20.0, â€œK2 should be second gainâ€ assert new_sta.get(â€˜power_exponentâ€™) == 0.5, â€œalpha_power should be renamedâ€ print(â€âœ“ STA-SMC migration test passed\nâ€) print(â€œAll migration tests passed! âœ“â€) # Run the test suite</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/configuration_migration_mathematical_foundations.html">Configuration Migration Mathematical Foundations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/configuration_migration_mathematical_foundations.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/configuration_migration_mathematical_foundations.html#runnable-false-def-migrate-hybrid-smc-parameters-mathematical-old-params-dict-str-any-dict-str-any-mathematically-sound-migration-for-hybrid-smc-parameters-mathematical-validation-1-preserve-mode-switching-stability-2-maintain-unified-surface-design-3-ensure-sub-controller-compatibility-new-params-extract-surface-gains-shared-across-all-modes-surface-gains-old-params-get-gains-18-0-12-0-10-0-8-0-if-len-surface-gains-4-raise-valueerror-hybrid-smc-requires-exactly-4-surface-gains-c1-1-c2-2-c1-lam1-c2-lam2-surface-gains-validate-surface-stability-if-any-g-0-for-g-in-c1-lam1-c2-lam2-raise-valueerror-all-surface-coefficients-must-be-positive-check-surface-eigenvalue-placement-for-stability-eigen1-lam1-c1-eigen2-lam2-c2-if-eigen1-0-or-eigen2-0-print-f-warning-surface-eigenvalues-eigen1-3f-eigen2-3f-may-indicate-instability-new-params-gains-surface-gains-handle-mode-parameter-migration-mode-mappings-mode-hybrid-mode-switch-threshold-switching-criteria-classical-params-classical-config-adaptive-params-adaptive-config-for-old-param-new-param-in-mode-mappings-items-if-old-param-in-old-params-if-old-param-switch-threshold-convert-scalar-threshold-to-criteria-dict-threshold-old-params-old-param-new-params-switching-criteria-error-threshold-threshold-time-threshold-2-0-default-time-threshold-performance-threshold-0-1-performance-based-switching-else-new-params-new-param-old-params-old-param-handle-sub-controller-gain-migration-if-sub-controller-gains-in-old-params-sub-gains-old-params-sub-controller-gains-if-isinstance-sub-gains-dict-create-proper-sub-controller-configurations-classical-gains-sub-gains-get-classical-20-0-15-0-12-0-8-0-35-0-5-0-adaptive-gains-sub-gains-get-adaptive-25-0-18-0-15-0-10-0-4-0-validate-sub-controller-gains-if-len-classical-gains-6-raise-valueerror-classical-sub-controller-requires-6-gains-if-len-adaptive-gains-5-raise-valueerror-adaptive-sub-controller-requires-5-gains-create-complete-sub-configurations-with-surface-coupling-new-params-classical-config-gains-classical-gains-max-force-old-params-get-max-force-150-0-boundary-layer-0-02-dt-old-params-get-dt-0-001-surface-coupling-true-ensure-surface-consistency-new-params-adaptive-config-gains-adaptive-gains-max-force-old-params-get-max-force-150-0-leak-rate-0-01-adapt-rate-limit-10-0-k-min-0-1-k-max-100-0-dt-old-params-get-dt-0-001-surface-coupling-true-ensure-surface-consistency-set-hybrid-specific-parameters-with-mathematical-justification-new-params-setdefault-hybrid-mode-classical-adaptive-conservative-default-new-params-setdefault-dt-0-001-fast-sampling-for-mode-switching-new-params-setdefault-max-force-150-0-shared-actuator-limit-advanced-hybrid-parameters-new-params-setdefault-mode-hysteresis-0-1-prevent-chattering-in-mode-switching-new-params-setdefault-transition-smoothing-true-smooth-mode-transitions-new-params-setdefault-surface-consistency-check-true-validate-surface-compatibility-validate-hybrid-mode-switching-stability-if-switching-criteria-in-new-params-criteria-new-params-switching-criteria-error-thresh-criteria-get-error-threshold-0-1-time-thresh-criteria-get-time-threshold-2-0-check-switching-frequency-to-prevent-chattering-min-dwell-time-0-1-minimum-time-in-each-mode-if-time-thresh-min-dwell-time-print-f-warning-short-time-threshold-time-thresh-s-may-cause-mode-chattering-return-new-params-mathematical-validation-example">runnable: false def migrate_hybrid_smc_parameters_mathematical(old_params: Dict[str, Any]) -&gt; Dict[str, Any]: â€œâ€â€ Mathematically sound migration for Hybrid SMC parameters. Mathematical Validation: 1. Preserve mode switching stability 2. Maintain unified surface design 3. Ensure sub-controller compatibility â€œâ€â€ new_params = {} # Extract surface gains (shared across all modes) surface_gains = old_params.get(â€˜gainsâ€™, [18.0, 12.0, 10.0, 8.0]) if len(surface_gains) != 4: raise ValueError(â€œHybrid SMC requires exactly 4 surface gains [câ‚, Î»â‚, câ‚‚, Î»â‚‚]â€) c1, lam1, c2, lam2 = surface_gains # Validate surface stability if any(g &lt;= 0 for g in [c1, lam1, c2, lam2]): raise ValueError(â€œAll surface coefficients must be positiveâ€) # Check surface eigenvalue placement for stability eigen1 = -lam1 / c1 eigen2 = -lam2 / c2 if eigen1 &gt;= 0 or eigen2 &gt;= 0: print(fâ€Warning: Surface eigenvalues [{eigen1:.3f}, {eigen2:.3f}] may indicate instabilityâ€) new_params[â€˜gainsâ€™] = surface_gains # Handle mode parameter migration mode_mappings = { â€˜modeâ€™: â€˜hybrid_modeâ€™, â€˜switch_thresholdâ€™: â€˜switching_criteriaâ€™, â€˜classical_paramsâ€™: â€˜classical_configâ€™, â€˜adaptive_paramsâ€™: â€˜adaptive_configâ€™ } for old_param, new_param in mode_mappings.items(): if old_param in old_params: if old_param == â€˜switch_thresholdâ€™: # Convert scalar threshold to criteria dict threshold = old_params[old_param] new_params[â€˜switching_criteriaâ€™] = { â€˜error_thresholdâ€™: threshold, â€˜time_thresholdâ€™: 2.0, # Default time threshold â€˜performance_thresholdâ€™: 0.1 # Performance-based switching } else: new_params[new_param] = old_params[old_param] # Handle sub-controller gain migration if â€˜sub_controller_gainsâ€™ in old_params: sub_gains = old_params[â€˜sub_controller_gainsâ€™] if isinstance(sub_gains, dict): # Create proper sub-controller configurations classical_gains = sub_gains.get(â€˜classicalâ€™, [20.0, 15.0, 12.0, 8.0, 35.0, 5.0]) adaptive_gains = sub_gains.get(â€˜adaptiveâ€™, [25.0, 18.0, 15.0, 10.0, 4.0]) # Validate sub-controller gains if len(classical_gains) != 6: raise ValueError(â€œClassical sub-controller requires 6 gainsâ€) if len(adaptive_gains) != 5: raise ValueError(â€œAdaptive sub-controller requires 5 gainsâ€) # Create complete sub-configurations with surface coupling new_params[â€˜classical_configâ€™] = { â€˜gainsâ€™: classical_gains, â€˜max_forceâ€™: old_params.get(â€˜max_forceâ€™, 150.0), â€˜boundary_layerâ€™: 0.02, â€˜dtâ€™: old_params.get(â€˜dtâ€™, 0.001), â€˜surface_couplingâ€™: True # Ensure surface consistency } new_params[â€˜adaptive_configâ€™] = { â€˜gainsâ€™: adaptive_gains, â€˜max_forceâ€™: old_params.get(â€˜max_forceâ€™, 150.0), â€˜leak_rateâ€™: 0.01, â€˜adapt_rate_limitâ€™: 10.0, â€˜K_minâ€™: 0.1, â€˜K_maxâ€™: 100.0, â€˜dtâ€™: old_params.get(â€˜dtâ€™, 0.001), â€˜surface_couplingâ€™: True # Ensure surface consistency } # Set hybrid-specific parameters with mathematical justification new_params.setdefault(â€˜hybrid_modeâ€™, â€˜CLASSICAL_ADAPTIVEâ€™) # Conservative default new_params.setdefault(â€˜dtâ€™, 0.001) # Fast sampling for mode switching new_params.setdefault(â€˜max_forceâ€™, 150.0) # Shared actuator limit # Advanced hybrid parameters new_params.setdefault(â€˜mode_hysteresisâ€™, 0.1) # Prevent chattering in mode switching new_params.setdefault(â€˜transition_smoothingâ€™, True) # Smooth mode transitions new_params.setdefault(â€˜surface_consistency_checkâ€™, True) # Validate surface compatibility # Validate hybrid mode switching stability if â€˜switching_criteriaâ€™ in new_params: criteria = new_params[â€˜switching_criteriaâ€™] error_thresh = criteria.get(â€˜error_thresholdâ€™, 0.1) time_thresh = criteria.get(â€˜time_thresholdâ€™, 2.0) # Check switching frequency to prevent chattering min_dwell_time = 0.1 # Minimum time in each mode if time_thresh &lt; min_dwell_time: print(fâ€Warning: Short time threshold {time_thresh}s may cause mode chatteringâ€) return new_params # Mathematical validation example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/configuration_migration_mathematical_foundations.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/configuration_migration_mathematical_foundations.html#runnable-false-class-stabilityvalidator-validate-stability-preservation-during-parameter-migration-staticmethod-def-validate-classical-smc-stability-gains-list-float-dict-str-any-validate-classical-smc-stability-conditions-if-len-gains-6-return-valid-false-reason-invalid-gain-count-k1-k2-lam1-lam2-k-kd-gains-check-basic-positivity-if-any-g-0-for-g-in-gains-return-valid-false-reason-all-gains-must-be-positive-check-sliding-surface-stability-for-double-pendulum-sliding-surface-eigenvalues-should-be-negative-surface-eigs-lam1-k1-lam2-k2-if-any-eig-0-for-eig-in-surface-eigs-return-valid-false-reason-f-unstable-surface-eigenvalues-surface-eigs-check-actuator-reasonableness-if-k-200-very-high-switching-gain-return-valid-true-warnings-f-high-switching-gain-k-k-may-cause-excessive-chattering-check-derivative-gain-ratio-kd-ratio-kd-k-if-kd-ratio-0-5-derivative-gain-too-large-relative-to-switching-gain-return-valid-true-warnings-f-high-derivative-gain-ratio-kd-ratio-2f-may-degrade-performance-return-valid-true-surface-eigenvalues-surface-eigs-estimated-convergence-rate-min-abs-eig-for-eig-in-surface-eigs-switching-magnitude-k-chattering-reduction-kd-staticmethod-def-validate-adaptive-smc-convergence-gains-list-float-adaptation-params-dict-str-float-dict-str-any-validate-adaptive-smc-convergence-conditions-if-len-gains-5-return-valid-false-reason-invalid-gain-count-k1-k2-lam1-lam2-gamma-gains-check-basic-conditions-if-any-g-0-for-g-in-gains-return-valid-false-reason-all-gains-must-be-positive-check-adaptation-stability-leak-rate-adaptation-params-get-leak-rate-0-01-k-min-adaptation-params-get-k-min-0-1-k-max-adaptation-params-get-k-max-100-0-adaptation-stability-condition-leak-rate-should-be-small-relative-to-adaptation-rate-stability-margin-leak-rate-gamma-if-stability-margin-0-2-return-valid-true-warnings-f-high-leak-to-adaptation-ratio-stability-margin-3f-may-slow-convergence-check-adaptation-bounds-if-k-min-k-max-return-valid-false-reason-k-min-must-be-less-than-k-max-gain-ratio-k-max-k-min-if-gain-ratio-1000-very-wide-adaptation-range-return-valid-true-warnings-f-wide-adaptation-range-ratio-gain-ratio-1f-may-cause-instability-return-valid-true-adaptation-rate-gamma-stability-margin-stability-margin-adaptation-range-k-min-k-max-estimated-settling-time-5-0-min-lam1-k1-lam2-k2-rough-estimate-staticmethod-def-validate-sta-smc-finite-time-convergence-gains-list-float-algorithm-params-dict-str-float-dict-str-any-validate-super-twisting-finite-time-convergence-conditions-if-len-gains-6-return-valid-false-reason-invalid-gain-count-k1-k2-k1-k2-lam1-lam2-gains-check-basic-positivity-if-any-g-0-for-g-in-gains-return-valid-false-reason-all-gains-must-be-positive-check-super-twisting-convergence-conditions-alpha-algorithm-params-get-power-exponent-0-5-if-not-0-alpha-1-return-valid-false-reason-f-power-exponent-alpha-must-be-in-0-1-simplified-convergence-check-assumes-l-1-l-estimate-1-0-min-k1-l-estimate-alpha-min-k2-k1-2-2-l-estimate-l-estimate-warnings-if-k1-min-k1-warnings-append-f-k1-k1-2f-may-be-too-small-for-convergence-recommended-min-k1-2f-if-k2-min-k2-warnings-append-f-k2-k2-2f-may-be-too-small-for-convergence-recommended-min-k2-2f-estimate-finite-time-convergence-convergence-time-2-1-1-alpha-1-min-k1-k2-0-5-return-valid-true-warnings-warnings-algorithmic-gains-k1-k2-surface-gains-k1-k2-lam1-lam2-power-exponent-alpha-estimated-convergence-time-convergence-time-convergence-conditions-met-len-warnings-0-validation-example">runnable: false class StabilityValidator: â€œâ€â€Validate stability preservation during parameter migration.â€â€â€ @staticmethod def validate_classical_smc_stability(gains: List[float]) -&gt; Dict[str, Any]: â€œâ€â€Validate Classical SMC stability conditions.â€â€â€ if len(gains) != 6: return {â€˜validâ€™: False, â€˜reasonâ€™: â€˜Invalid gain countâ€™} k1, k2, lam1, lam2, K, kd = gains # Check basic positivity if any(g &lt;= 0 for g in gains): return {â€˜validâ€™: False, â€˜reasonâ€™: â€˜All gains must be positiveâ€™} # Check sliding surface stability # For double pendulum: sliding surface eigenvalues should be negative surface_eigs = [-lam1/k1, -lam2/k2] if any(eig &gt;= 0 for eig in surface_eigs): return {â€˜validâ€™: False, â€˜reasonâ€™: fâ€™Unstable surface eigenvalues: {surface_eigs}â€™} # Check actuator reasonableness if K &gt; 200: # Very high switching gain return { â€˜validâ€™: True, â€˜warningsâ€™: [fâ€™High switching gain K={K} may cause excessive chatteringâ€™] } # Check derivative gain ratio kd_ratio = kd / K if kd_ratio &gt; 0.5: # Derivative gain too large relative to switching gain return { â€˜validâ€™: True, â€˜warningsâ€™: [fâ€™High derivative gain ratio {kd_ratio:.2f} may degrade performanceâ€™] } return { â€˜validâ€™: True, â€˜surface_eigenvaluesâ€™: surface_eigs, â€˜estimated_convergence_rateâ€™: min(abs(eig) for eig in surface_eigs), â€˜switching_magnitudeâ€™: K, â€˜chattering_reductionâ€™: kd } @staticmethod def validate_adaptive_smc_convergence(gains: List[float], adaptation_params: Dict[str, float]) -&gt; Dict[str, Any]: â€œâ€â€Validate Adaptive SMC convergence conditions.â€â€â€ if len(gains) != 5: return {â€˜validâ€™: False, â€˜reasonâ€™: â€˜Invalid gain countâ€™} k1, k2, lam1, lam2, gamma = gains # Check basic conditions if any(g &lt;= 0 for g in gains): return {â€˜validâ€™: False, â€˜reasonâ€™: â€˜All gains must be positiveâ€™} # Check adaptation stability leak_rate = adaptation_params.get(â€˜leak_rateâ€™, 0.01) K_min = adaptation_params.get(â€˜K_minâ€™, 0.1) K_max = adaptation_params.get(â€˜K_maxâ€™, 100.0) # Adaptation stability condition: leak rate should be small relative to adaptation rate stability_margin = leak_rate / gamma if stability_margin &gt; 0.2: return { â€˜validâ€™: True, â€˜warningsâ€™: [fâ€™High leak-to-adaptation ratio {stability_margin:.3f} may slow convergenceâ€™] } # Check adaptation bounds if K_min &gt;= K_max: return {â€˜validâ€™: False, â€˜reasonâ€™: â€˜K_min must be less than K_maxâ€™} gain_ratio = K_max / K_min if gain_ratio &gt; 1000: # Very wide adaptation range return { â€˜validâ€™: True, â€˜warningsâ€™: [fâ€™Wide adaptation range (ratio: {gain_ratio:.1f}) may cause instabilityâ€™] } return { â€˜validâ€™: True, â€˜adaptation_rateâ€™: gamma, â€˜stability_marginâ€™: stability_margin, â€˜adaptation_rangeâ€™: [K_min, K_max], â€˜estimated_settling_timeâ€™: 5.0 / min(lam1/k1, lam2/k2) # Rough estimate } @staticmethod def validate_sta_smc_finite_time_convergence(gains: List[float], algorithm_params: Dict[str, float]) -&gt; Dict[str, Any]: â€œâ€â€Validate Super-Twisting finite-time convergence conditions.â€â€â€ if len(gains) != 6: return {â€˜validâ€™: False, â€˜reasonâ€™: â€˜Invalid gain countâ€™} K1, K2, k1, k2, lam1, lam2 = gains # Check basic positivity if any(g &lt;= 0 for g in gains): return {â€˜validâ€™: False, â€˜reasonâ€™: â€˜All gains must be positiveâ€™} # Check super-twisting convergence conditions alpha = algorithm_params.get(â€˜power_exponentâ€™, 0.5) if not (0 &lt; alpha &lt; 1): return {â€˜validâ€™: False, â€˜reasonâ€™: fâ€™Power exponent Î±={alpha} must be in (0,1)â€™} # Simplified convergence check (assumes L=1) L_estimate = 1.0 min_K1 = L_estimate / alpha min_K2 = K1**2 / (2 * L_estimate) + L_estimate warnings = [] if K1 &lt; min_K1: warnings.append(fâ€™Kâ‚={K1:.2f} may be too small for convergence (recommended: â‰¥{min_K1:.2f})â€™) if K2 &lt; min_K2: warnings.append(fâ€™Kâ‚‚={K2:.2f} may be too small for convergence (recommended: â‰¥{min_K2:.2f})â€™) # Estimate finite-time convergence convergence_time = 2 * (1 / (1 - alpha)) * (1 / min(K1, K2)**0.5) return { â€˜validâ€™: True, â€˜warningsâ€™: warnings, â€˜algorithmic_gainsâ€™: [K1, K2], â€˜surface_gainsâ€™: [k1, k2, lam1, lam2], â€˜power_exponentâ€™: alpha, â€˜estimated_convergence_timeâ€™: convergence_time, â€˜convergence_conditions_metâ€™: len(warnings) == 0 } # Validation example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/configuration_migration_mathematical_foundations.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/configuration_migration_mathematical_foundations.html#runnable-false-class-performanceanalyzer-analyze-performance-preservation-during-migration-staticmethod-def-analyze-control-bandwidth-old-gains-list-float-new-gains-list-float-controller-type-str-dict-str-any-analyze-control-bandwidth-preservation-if-controller-type-classical-smc-if-len-old-gains-4-and-len-new-gains-4-old-bandwidth-min-old-gains-2-old-gains-3-min-1-2-new-bandwidth-min-new-gains-2-new-gains-3-bandwidth-ratio-new-bandwidth-old-bandwidth-return-old-bandwidth-old-bandwidth-new-bandwidth-new-bandwidth-bandwidth-ratio-bandwidth-ratio-performance-preserved-0-8-bandwidth-ratio-1-2-20-tolerance-elif-controller-type-adaptive-smc-if-len-old-gains-4-and-len-new-gains-4-old-adaptation-rate-old-gains-4-if-len-old-gains-4-else-1-0-new-adaptation-rate-new-gains-4-if-len-new-gains-4-else-1-0-adaptation-ratio-new-adaptation-rate-old-adaptation-rate-return-old-adaptation-rate-old-adaptation-rate-new-adaptation-rate-new-adaptation-rate-adaptation-ratio-adaptation-ratio-performance-preserved-0-5-adaptation-ratio-2-0-100-tolerance-return-analysis-not-applicable-controller-type-controller-type-staticmethod-def-estimate-settling-time-change-old-config-dict-str-any-new-config-dict-str-any-dict-str-any-estimate-settling-time-changes-after-migration-old-gains-old-config-get-gains-new-gains-new-config-get-gains-if-len-old-gains-4-and-len-new-gains-4-simplified-settling-time-estimate-based-on-surface-coefficients-old-settling-4-0-min-old-gains-2-old-gains-3-4-min-1-2-new-settling-4-0-min-new-gains-2-new-gains-3-settling-ratio-new-settling-old-settling-return-old-settling-time-old-settling-new-settling-time-new-settling-settling-ratio-settling-ratio-performance-change-improved-if-settling-ratio-1-0-else-degraded-if-settling-ratio-1-1-else-maintained-return-analysis-insufficient-data-performance-analysis-example">runnable: false class PerformanceAnalyzer: â€œâ€â€Analyze performance preservation during migration.â€â€â€ @staticmethod def analyze_control_bandwidth(old_gains: List[float], new_gains: List[float], controller_type: str) -&gt; Dict[str, Any]: â€œâ€â€Analyze control bandwidth preservation.â€â€â€ if controller_type == â€˜classical_smcâ€™: if len(old_gains) &gt;= 4 and len(new_gains) &gt;= 4: old_bandwidth = min(old_gains[2], old_gains[3]) # min(Î»1, Î»2) new_bandwidth = min(new_gains[2], new_gains[3]) bandwidth_ratio = new_bandwidth / old_bandwidth return { â€˜old_bandwidthâ€™: old_bandwidth, â€˜new_bandwidthâ€™: new_bandwidth, â€˜bandwidth_ratioâ€™: bandwidth_ratio, â€˜performance_preservedâ€™: 0.8 &lt;= bandwidth_ratio &lt;= 1.2 # Â±20% tolerance } elif controller_type == â€˜adaptive_smcâ€™: if len(old_gains) &gt;= 4 and len(new_gains) &gt;= 4: old_adaptation_rate = old_gains[4] if len(old_gains) &gt; 4 else 1.0 new_adaptation_rate = new_gains[4] if len(new_gains) &gt; 4 else 1.0 adaptation_ratio = new_adaptation_rate / old_adaptation_rate return { â€˜old_adaptation_rateâ€™: old_adaptation_rate, â€˜new_adaptation_rateâ€™: new_adaptation_rate, â€˜adaptation_ratioâ€™: adaptation_ratio, â€˜performance_preservedâ€™: 0.5 &lt;= adaptation_ratio &lt;= 2.0 # Â±100% tolerance } return {â€˜analysisâ€™: â€˜not_applicableâ€™, â€˜controller_typeâ€™: controller_type} @staticmethod def estimate_settling_time_change(old_config: Dict[str, Any], new_config: Dict[str, Any]) -&gt; Dict[str, Any]: â€œâ€â€Estimate settling time changes after migration.â€â€â€ old_gains = old_config.get(â€˜gainsâ€™, []) new_gains = new_config.get(â€˜gainsâ€™, []) if len(old_gains) &gt;= 4 and len(new_gains) &gt;= 4: # Simplified settling time estimate based on surface coefficients old_settling = 4.0 / min(old_gains[2], old_gains[3]) # 4/min(Î»1, Î»2) new_settling = 4.0 / min(new_gains[2], new_gains[3]) settling_ratio = new_settling / old_settling return { â€˜old_settling_timeâ€™: old_settling, â€˜new_settling_timeâ€™: new_settling, â€˜settling_ratioâ€™: settling_ratio, â€˜performance_changeâ€™: â€˜improvedâ€™ if settling_ratio &lt; 1.0 else â€˜degradedâ€™ if settling_ratio &gt; 1.1 else â€˜maintainedâ€™ } return {â€˜analysisâ€™: â€˜insufficient_dataâ€™} # Performance analysis example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/configuration_migration_mathematical_foundations.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/configuration_migration_mathematical_foundations.html#runnable-false-class-migrationvalidationsuite-test-suite-for-migration-validation-def-init-self-self-test-results-def-run-full-validation-self-old-config-dict-str-any-new-config-dict-str-any-controller-type-str-dict-str-any-run-migration-validation-results-controller-type-controller-type-migration-successful-true-tests-warnings-errors-test-1-parameter-count-validation-results-tests-parameter-count-self-test-parameter-count-old-config-new-config-controller-type-test-2-stability-preservation-results-tests-stability-self-test-stability-preservation-new-config-controller-type-test-3-physical-realizability-results-tests-physical-realizability-self-test-physical-realizability-new-config-controller-type-test-4-performance-preservation-results-tests-performance-self-test-performance-preservation-old-config-new-config-controller-type-test-5-numerical-stability-results-tests-numerical-stability-self-test-numerical-stability-new-config-controller-type-aggregate-results-failed-tests-name-for-name-result-in-results-tests-items-if-not-result-get-passed-false-results-migration-successful-len-failed-tests-0-if-failed-tests-results-errors-extend-f-failed-test-test-for-test-in-failed-tests-return-results-def-test-parameter-count-self-old-config-dict-str-any-new-config-dict-str-any-controller-type-str-dict-str-any-test-parameter-count-migration-expected-counts-classical-smc-6-adaptive-smc-5-sta-smc-6-hybrid-adaptive-sta-smc-4-new-gains-new-config-get-gains-expected-count-expected-counts-get-controller-type-0-passed-len-new-gains-expected-count-return-passed-passed-expected-count-expected-count-actual-count-len-new-gains-gains-new-gains-def-test-stability-preservation-self-new-config-dict-str-any-controller-type-str-dict-str-any-test-stability-preservation-gains-new-config-get-gains-if-controller-type-classical-smc-return-stabilityvalidator-validate-classical-smc-stability-gains-elif-controller-type-adaptive-smc-adaptation-params-leak-rate-new-config-get-leak-rate-0-01-k-min-new-config-get-k-min-0-1-k-max-new-config-get-k-max-100-0-return-stabilityvalidator-validate-adaptive-smc-convergence-gains-adaptation-params-elif-controller-type-sta-smc-algorithm-params-power-exponent-new-config-get-power-exponent-0-5-return-stabilityvalidator-validate-sta-smc-finite-time-convergence-gains-algorithm-params-return-passed-true-reason-no-stability-test-for-this-controller-type-def-test-physical-realizability-self-new-config-dict-str-any-controller-type-str-dict-str-any-test-physical-realizability-of-parameters-gains-new-config-get-gains-max-force-new-config-get-max-force-150-0-dt-new-config-get-dt-0-001-issues-check-gain-magnitudes-if-any-g-1000-for-g-in-gains-issues-append-extremely-high-gains-may-be-unrealistic-check-sampling-time-if-dt-1e-4-less-than-0-1ms-issues-append-f-very-fast-sampling-time-dt-dt-s-may-be-unrealistic-elif-dt-0-1-more-than-100ms-issues-append-f-slow-sampling-time-dt-dt-s-may-degrade-performance-check-actuator-limits-if-max-force-1000-more-than-1kn-issues-append-f-high-force-limit-max-force-n-may-be-unrealistic-elif-max-force-1-less-than-1n-issues-append-f-low-force-limit-max-force-n-may-be-insufficient-return-passed-len-issues-0-issues-issues-parameters-checked-gains-max-force-dt-def-test-performance-preservation-self-old-config-dict-str-any-new-config-dict-str-any-controller-type-str-dict-str-any-test-performance-preservation-bandwidth-analysis-performanceanalyzer-analyze-control-bandwidth-old-config-get-gains-new-config-get-gains-controller-type-settling-analysis-performanceanalyzer-estimate-settling-time-change-old-config-new-config-performance-is-preserved-if-bandwidth-and-settling-time-are-reasonable-bandwidth-ok-bandwidth-analysis-get-performance-preserved-true-settling-ok-settling-analysis-get-performance-change-in-improved-maintained-return-passed-bandwidth-ok-and-settling-ok-bandwidth-analysis-bandwidth-analysis-settling-analysis-settling-analysis-def-test-numerical-stability-self-new-config-dict-str-any-controller-type-str-dict-str-any-test-numerical-stability-of-parameters-gains-new-config-get-gains-dt-new-config-get-dt-0-001-issues-check-condition-numbers-and-numerical-issues-if-controller-type-in-classical-smc-adaptive-smc-sta-smc-if-len-gains-4-k1-k2-lam1-lam2-gains-4-check-gain-ratios-for-numerical-stability-if-lam1-k1-100-or-lam2-k2-100-issues-append-high-k-ratios-may-cause-numerical-instability-if-k1-k2-10-or-k2-k1-10-issues-append-large-k1-k2-ratio-may-indicate-unbalanced-design-check-discrete-time-stability-if-controller-type-in-adaptive-smc-sta-smc-max-gain-max-gains-if-gains-else-0-nyquist-limit-1-0-2-dt-if-max-gain-nyquist-limit-10-rule-of-thumb-issues-append-f-high-gains-relative-to-sampling-rate-may-cause-instability-return-passed-len-issues-0-issues-issues-sampling-time-dt-stability-margins-acceptable-if-len-issues-0-else-marginal-full-validation-example">runnable: false class MigrationValidationSuite: â€œâ€â€test suite for migration validation.â€â€â€ def <strong>init</strong>(self): self.test_results = [] def run_full_validation(self, old_config: Dict[str, Any], new_config: Dict[str, Any], controller_type: str) -&gt; Dict[str, Any]: â€œâ€â€Run migration validation.â€â€â€ results = { â€˜controller_typeâ€™: controller_type, â€˜migration_successfulâ€™: True, â€˜testsâ€™: {}, â€˜warningsâ€™: [], â€˜errorsâ€™: [] } # Test 1: Parameter count validation results[â€˜testsâ€™][â€˜parameter_countâ€™] = self.test_parameter_count(old_config, new_config, controller_type) # Test 2: Stability preservation results[â€˜testsâ€™][â€˜stabilityâ€™] = self.test_stability_preservation(new_config, controller_type) # Test 3: Physical realizability results[â€˜testsâ€™][â€˜physical_realizabilityâ€™] = self.test_physical_realizability(new_config, controller_type) # Test 4: Performance preservation results[â€˜testsâ€™][â€˜performanceâ€™] = self.test_performance_preservation(old_config, new_config, controller_type) # Test 5: Numerical stability results[â€˜testsâ€™][â€˜numerical_stabilityâ€™] = self.test_numerical_stability(new_config, controller_type) # Aggregate results failed_tests = [name for name, result in results[â€˜testsâ€™].items() if not result.get(â€˜passedâ€™, False)] results[â€˜migration_successfulâ€™] = len(failed_tests) == 0 if failed_tests: results[â€˜errorsâ€™].extend([fâ€Failed test: {test}â€ for test in failed_tests]) return results def test_parameter_count(self, old_config: Dict[str, Any], new_config: Dict[str, Any], controller_type: str) -&gt; Dict[str, Any]: â€œâ€â€Test parameter count migration.â€â€â€ expected_counts = { â€˜classical_smcâ€™: 6, â€˜adaptive_smcâ€™: 5, â€˜sta_smcâ€™: 6, â€˜hybrid_adaptive_sta_smcâ€™: 4 } new_gains = new_config.get(â€˜gainsâ€™, []) expected_count = expected_counts.get(controller_type, 0) passed = len(new_gains) == expected_count return { â€˜passedâ€™: passed, â€˜expected_countâ€™: expected_count, â€˜actual_countâ€™: len(new_gains), â€˜gainsâ€™: new_gains } def test_stability_preservation(self, new_config: Dict[str, Any], controller_type: str) -&gt; Dict[str, Any]: â€œâ€â€Test stability preservation.â€â€â€ gains = new_config.get(â€˜gainsâ€™, []) if controller_type == â€˜classical_smcâ€™: return StabilityValidator.validate_classical_smc_stability(gains) elif controller_type == â€˜adaptive_smcâ€™: adaptation_params = { â€˜leak_rateâ€™: new_config.get(â€˜leak_rateâ€™, 0.01), â€˜K_minâ€™: new_config.get(â€˜K_minâ€™, 0.1), â€˜K_maxâ€™: new_config.get(â€˜K_maxâ€™, 100.0) } return StabilityValidator.validate_adaptive_smc_convergence(gains, adaptation_params) elif controller_type == â€˜sta_smcâ€™: algorithm_params = { â€˜power_exponentâ€™: new_config.get(â€˜power_exponentâ€™, 0.5) } return StabilityValidator.validate_sta_smc_finite_time_convergence(gains, algorithm_params) return {â€˜passedâ€™: True, â€˜reasonâ€™: â€˜No stability test for this controller typeâ€™} def test_physical_realizability(self, new_config: Dict[str, Any], controller_type: str) -&gt; Dict[str, Any]: â€œâ€â€Test physical realizability of parameters.â€â€â€ gains = new_config.get(â€˜gainsâ€™, []) max_force = new_config.get(â€˜max_forceâ€™, 150.0) dt = new_config.get(â€˜dtâ€™, 0.001) issues = [] # Check gain magnitudes if any(g &gt; 1000 for g in gains): issues.append(â€œExtremely high gains may be unrealisticâ€) # Check sampling time if dt &lt; 1e-4: # Less than 0.1ms issues.append(fâ€Very fast sampling time dt={dt}s may be unrealisticâ€) elif dt &gt; 0.1: # More than 100ms issues.append(fâ€Slow sampling time dt={dt}s may degrade performanceâ€) # Check actuator limits if max_force &gt; 1000: # More than 1kN issues.append(fâ€High force limit {max_force}N may be unrealisticâ€) elif max_force &lt; 1: # Less than 1N issues.append(fâ€Low force limit {max_force}N may be insufficientâ€) return { â€˜passedâ€™: len(issues) == 0, â€˜issuesâ€™: issues, â€˜parameters_checkedâ€™: [â€˜gainsâ€™, â€˜max_forceâ€™, â€˜dtâ€™] } def test_performance_preservation(self, old_config: Dict[str, Any], new_config: Dict[str, Any], controller_type: str) -&gt; Dict[str, Any]: â€œâ€â€Test performance preservation.â€â€â€ bandwidth_analysis = PerformanceAnalyzer.analyze_control_bandwidth( old_config.get(â€˜gainsâ€™, []), new_config.get(â€˜gainsâ€™, []), controller_type ) settling_analysis = PerformanceAnalyzer.estimate_settling_time_change(old_config, new_config) # Performance is preserved if bandwidth and settling time are reasonable bandwidth_ok = bandwidth_analysis.get(â€˜performance_preservedâ€™, True) settling_ok = settling_analysis.get(â€˜performance_changeâ€™) in [â€˜improvedâ€™, â€˜maintainedâ€™] return { â€˜passedâ€™: bandwidth_ok and settling_ok, â€˜bandwidth_analysisâ€™: bandwidth_analysis, â€˜settling_analysisâ€™: settling_analysis } def test_numerical_stability(self, new_config: Dict[str, Any], controller_type: str) -&gt; Dict[str, Any]: â€œâ€â€Test numerical stability of parameters.â€â€â€ gains = new_config.get(â€˜gainsâ€™, []) dt = new_config.get(â€˜dtâ€™, 0.001) issues = [] # Check condition numbers and numerical issues if controller_type in [â€˜classical_smcâ€™, â€˜adaptive_smcâ€™, â€˜sta_smcâ€™]: if len(gains) &gt;= 4: k1, k2, lam1, lam2 = gains[:4] # Check gain ratios for numerical stability if lam1/k1 &gt; 100 or lam2/k2 &gt; 100: issues.append(â€œHigh Î»/k ratios may cause numerical instabilityâ€) if k1/k2 &gt; 10 or k2/k1 &gt; 10: issues.append(â€œLarge k1/k2 ratio may indicate unbalanced designâ€) # Check discrete-time stability if controller_type in [â€˜adaptive_smcâ€™, â€˜sta_smcâ€™]: max_gain = max(gains) if gains else 0 nyquist_limit = 1.0 / (2 * dt) if max_gain &gt; nyquist_limit / 10: # Rule of thumb issues.append(fâ€High gains relative to sampling rate may cause instabilityâ€) return { â€˜passedâ€™: len(issues) == 0, â€˜issuesâ€™: issues, â€˜sampling_timeâ€™: dt, â€˜stability_marginsâ€™: â€˜acceptableâ€™ if len(issues) == 0 else â€˜marginalâ€™ } # Full validation example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/deprecation_management.html">Deprecation Management System ## Overview The SMC Controller Factory includes a deprecation management system designed to handle configuration changes, parameter renames, and interface modifications while maintaining backward compatibility. This system provides systematic deprecation warnings, migration paths, and graceful degradation mechanisms to support smooth evolution of the codebase. ## Deprecation Architecture ### Deprecation Severity Levels ```python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/deprecation_management.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/deprecation_management.html#runnable-false-dataclass">runnable: false @dataclass</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/deprecation_management.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/deprecation_management.html#runnable-false-classical-smc-deprecations-gamma-deprecationmapping-old-name-gamma-new-name-none-level-deprecationlevel-error-message-gamma-parameter-is-not-valid-for-classical-smc-use-boundary-layer-instead-migration-guide-classical-smc-uses-boundary-layer-for-chattering-reduction-not-gamma-the-gamma-parameter-is-specific-to-adaptive-smc-controllers-replace-gamma-0-1-with-boundary-layer-0-02-in-your-configuration-removed-in-version-2-0-0-introduced-in-version-1-8-0-auto-migrate-false-cannot-auto-migrate-due-to-semantic-difference-adaptation-rate-deprecationmapping-old-name-adaptation-rate-new-name-none-level-deprecationlevel-error-message-adaptation-rate-is-not-valid-for-classical-smc-this-parameter-is-only-for-adaptive-smc-migration-guide-remove-adaptation-rate-from-classical-smc-configuration-if-you-need-adaptation-use-adaptive-smc-controller-type-instead-removed-in-version-2-0-0-auto-migrate-true-can-auto-remove-invalid-parameter-switch-function-deprecationmapping-old-name-switch-function-new-name-switch-method-level-deprecationlevel-warning-message-switch-function-parameter-renamed-to-switch-method-migration-guide-replace-switch-function-with-switch-method-in-configuration-valid-values-sign-tanh-sigmoid-sat-example-switch-method-tanh-removed-in-version-3-0-0-introduced-in-version-2-1-0-auto-migrate-true-k-switching-deprecationmapping-old-name-k-switching-new-name-gains-4-level-deprecationlevel-warning-message-separate-k-switching-parameter-deprecated-include-as-5th-element-in-gains-array-migration-guide-move-k-switching-value-to-gains-array-as-5th-element-example-gains-k1-k2-1-2-k-switching-kd-old-k-switching-15-0-gains-10-5-8-3-2-new-gains-10-5-8-3-15-2-removed-in-version-3-0-0-auto-migrate-true">runnable: false CLASSICAL_SMC_DEPRECATIONS = { â€˜gammaâ€™: DeprecationMapping( old_name=â€™gammaâ€™, new_name=None, level=DeprecationLevel.ERROR, message=â€œâ€˜gammaâ€™ parameter is not valid for classical_smc. Use â€˜boundary_layerâ€™ instead.â€, migration_guide=( â€œClassical SMC uses â€˜boundary_layerâ€™ for chattering reduction, not â€˜gammaâ€™. â€œ â€œThe â€˜gammaâ€™ parameter is specific to adaptive SMC controllers. â€œ â€œReplace â€˜gamma: 0.1â€™ with â€˜boundary_layer: 0.02â€™ in your configuration.â€ ), removed_in_version=â€2.0.0â€, introduced_in_version=â€1.8.0â€, auto_migrate=False # Cannot auto-migrate due to semantic difference ), â€˜adaptation_rateâ€™: DeprecationMapping( old_name=â€™adaptation_rateâ€™, new_name=None, level=DeprecationLevel.ERROR, message=â€œâ€˜adaptation_rateâ€™ is not valid for classical_smc. This parameter is only for adaptive_smc.â€, migration_guide=( â€œRemove â€˜adaptation_rateâ€™ from classical SMC configuration. â€œ â€œIf you need adaptation, use â€˜adaptive_smcâ€™ controller type instead.â€ ), removed_in_version=â€2.0.0â€, auto_migrate=True # Can auto-remove invalid parameter ), â€˜switch_functionâ€™: DeprecationMapping( old_name=â€™switch_functionâ€™, new_name=â€™switch_methodâ€™, level=DeprecationLevel.WARNING, message=â€œâ€˜switch_functionâ€™ parameter renamed to â€˜switch_methodâ€™.â€, migration_guide=( â€œReplace â€˜switch_functionâ€™ with â€˜switch_methodâ€™ in configuration. â€œ â€œValid values: â€˜signâ€™, â€˜tanhâ€™, â€˜sigmoidâ€™, â€˜satâ€™. â€œ â€œExample: switch_method: â€˜tanhâ€™â€ ), removed_in_version=â€3.0.0â€, introduced_in_version=â€2.1.0â€, auto_migrate=True ), â€˜K_switchingâ€™: DeprecationMapping( old_name=â€™K_switchingâ€™, new_name=â€™gains[4]â€™, level=DeprecationLevel.WARNING, message=â€Separate â€˜K_switchingâ€™ parameter deprecated. Include as 5th element in gains array.â€, migration_guide=( â€œMove K_switching value to gains array as 5th element. â€œ â€œExample: gains: [k1, k2, Î»1, Î»2, K_switching, kd] â€œ â€œOld: K_switching: 15.0, gains: [10, 5, 8, 3, 2] â€œ â€œNew: gains: [10, 5, 8, 3, 15, 2]â€ ), removed_in_version=â€3.0.0â€, auto_migrate=True )</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/deprecation_management.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/deprecation_management.html#runnable-false-adaptive-smc-deprecations-boundary-layer-thickness-deprecationmapping-old-name-boundary-layer-thickness-new-name-boundary-layer-level-deprecationlevel-warning-message-boundary-layer-thickness-parameter-renamed-to-boundary-layer-migration-guide-replace-boundary-layer-thickness-with-boundary-layer-in-configuration-the-parameter-has-the-same-meaning-and-value-range-0-001-to-0-1-example-boundary-layer-0-01-removed-in-version-3-0-0-auto-migrate-true-adaptation-gain-deprecationmapping-old-name-adaptation-gain-new-name-gains-4-level-deprecationlevel-warning-message-adaptation-gain-parameter-renamed-to-gamma-included-in-gains-array-migration-guide-remove-separate-adaptation-gain-and-include-gamma-as-5th-element-in-gains-array-the-adaptation-gain-gamma-controls-parameter-estimation-rate-example-gains-k1-k2-1-2-gamma-where-gamma-old-adaptation-gain-removed-in-version-3-0-0-auto-migrate-true-validation-function-lambda-x-0-01-x-10-0-estimate-bounds-deprecationmapping-old-name-estimate-bounds-new-name-k-min-k-max-level-deprecationlevel-warning-message-estimate-bounds-parameter-split-into-k-min-and-k-max-migration-guide-replace-estimate-bounds-min-max-with-separate-k-min-and-k-max-parameters-example-k-min-0-1-k-max-100-0-removed-in-version-3-0-0-auto-migrate-true-adaptation-law-deprecationmapping-old-name-adaptation-law-new-name-alpha-level-deprecationlevel-info-message-adaptation-law-parameter-renamed-to-alpha-for-clarity-migration-guide-replace-adaptation-law-with-alpha-the-parameter-controls-adaptation-law-exponent-typically-0-5-for-standard-adaptation-example-alpha-0-5-removed-in-version-4-0-0-auto-migrate-true">runnable: false ADAPTIVE_SMC_DEPRECATIONS = { â€˜boundary_layer_thicknessâ€™: DeprecationMapping( old_name=â€™boundary_layer_thicknessâ€™, new_name=â€™boundary_layerâ€™, level=DeprecationLevel.WARNING, message=â€œâ€˜boundary_layer_thicknessâ€™ parameter renamed to â€˜boundary_layerâ€™.â€, migration_guide=( â€œReplace â€˜boundary_layer_thicknessâ€™ with â€˜boundary_layerâ€™ in configuration. â€œ â€œThe parameter has the same meaning and value range (0.001 to 0.1). â€œ â€œExample: boundary_layer: 0.01â€ ), removed_in_version=â€3.0.0â€, auto_migrate=True ), â€˜adaptation_gainâ€™: DeprecationMapping( old_name=â€™adaptation_gainâ€™, new_name=â€™gains[4]â€™, level=DeprecationLevel.WARNING, message=â€œâ€˜adaptation_gainâ€™ parameter renamed to â€˜gammaâ€™ (included in gains array).â€, migration_guide=( â€œRemove separate â€˜adaptation_gainâ€™ and include gamma as 5th element in gains array. â€œ â€œThe adaptation gain (gamma) controls parameter estimation rate. â€œ â€œExample: gains: [k1, k2, Î»1, Î»2, gamma] where gamma = old adaptation_gainâ€ ), removed_in_version=â€3.0.0â€, auto_migrate=True, validation_function=lambda x: 0.01 &lt;= x &lt;= 10.0 ), â€˜estimate_boundsâ€™: DeprecationMapping( old_name=â€™estimate_boundsâ€™, new_name=[â€˜K_minâ€™, â€˜K_maxâ€™], level=DeprecationLevel.WARNING, message=â€œâ€˜estimate_boundsâ€™ parameter split into â€˜K_minâ€™ and â€˜K_maxâ€™.â€, migration_guide=( â€œReplace â€˜estimate_bounds: [min, max]â€™ with separate â€˜K_minâ€™ and â€˜K_maxâ€™ parameters. â€œ â€œExample: K_min: 0.1, K_max: 100.0â€ ), removed_in_version=â€3.0.0â€, auto_migrate=True ), â€˜adaptation_lawâ€™: DeprecationMapping( old_name=â€™adaptation_lawâ€™, new_name=â€™alphaâ€™, level=DeprecationLevel.INFO, message=â€œâ€˜adaptation_lawâ€™ parameter renamed to â€˜alphaâ€™ for clarity.â€, migration_guide=( â€œReplace â€˜adaptation_lawâ€™ with â€˜alphaâ€™. â€œ â€œThe parameter controls adaptation law exponent (typically 0.5 for standard adaptation). â€œ â€œExample: alpha: 0.5â€ ), removed_in_version=â€4.0.0â€, auto_migrate=True )</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/deprecation_management.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/deprecation_management.html#runnable-false-sta-smc-deprecations-k1-deprecationmapping-old-name-k1-new-name-gains-0-level-deprecationlevel-warning-message-separate-k1-k2-parameters-deprecated-use-gains-array-instead-migration-guide-include-k1-k2-as-first-two-elements-in-gains-array-k1-k2-k1-k2-lam1-lam2-this-provides-consistent-parameter-interface-across-all-smc-controllers-example-gains-35-0-20-0-25-0-18-0-12-0-8-0-removed-in-version-3-0-0-auto-migrate-true-k2-deprecationmapping-old-name-k2-new-name-gains-1-level-deprecationlevel-warning-message-separate-k1-k2-parameters-deprecated-use-gains-array-instead-migration-guide-include-k1-k2-as-first-two-elements-in-gains-array-k1-k2-k1-k2-lam1-lam2-ensure-k1-k2-for-optimal-sta-performance-example-gains-35-0-20-0-25-0-18-0-12-0-8-0-removed-in-version-3-0-0-auto-migrate-true-alpha-power-deprecationmapping-old-name-alpha-power-new-name-power-exponent-level-deprecationlevel-warning-message-alpha-power-parameter-renamed-to-power-exponent-for-clarity-migration-guide-replace-alpha-power-with-power-exponent-standard-sta-uses-power-exponent-0-5-for-finite-time-convergence-valid-range-0-1-example-power-exponent-0-5-removed-in-version-3-0-0-auto-migrate-true-validation-function-lambda-x-0-0-x-1-0-switching-function-type-deprecationmapping-old-name-switching-function-type-new-name-switch-method-level-deprecationlevel-info-message-switching-function-type-renamed-to-switch-method-for-consistency-migration-guide-replace-switching-function-type-with-switch-method-valid-options-tanh-sigmoid-sat-sta-smc-typically-uses-tanh-for-smooth-switching-removed-in-version-4-0-0-auto-migrate-true">runnable: false STA_SMC_DEPRECATIONS = { â€˜K1â€™: DeprecationMapping( old_name=â€™K1â€™, new_name=â€™gains[0]â€™, level=DeprecationLevel.WARNING, message=â€Separate K1/K2 parameters deprecated. Use gains array instead.â€, migration_guide=( â€œInclude K1, K2 as first two elements in gains array: [K1, K2, k1, k2, lam1, lam2]. â€œ â€œThis provides consistent parameter interface across all SMC controllers. â€œ â€œExample: gains: [35.0, 20.0, 25.0, 18.0, 12.0, 8.0]â€ ), removed_in_version=â€3.0.0â€, auto_migrate=True ), â€˜K2â€™: DeprecationMapping( old_name=â€™K2â€™, new_name=â€™gains[1]â€™, level=DeprecationLevel.WARNING, message=â€Separate K1/K2 parameters deprecated. Use gains array instead.â€, migration_guide=( â€œInclude K1, K2 as first two elements in gains array: [K1, K2, k1, k2, lam1, lam2]. â€œ â€œEnsure K1 &gt; K2 for optimal STA performance. â€œ â€œExample: gains: [35.0, 20.0, 25.0, 18.0, 12.0, 8.0]â€ ), removed_in_version=â€3.0.0â€, auto_migrate=True ), â€˜alpha_powerâ€™: DeprecationMapping( old_name=â€™alpha_powerâ€™, new_name=â€™power_exponentâ€™, level=DeprecationLevel.WARNING, message=â€œâ€˜alpha_powerâ€™ parameter renamed to â€˜power_exponentâ€™ for clarity.â€, migration_guide=( â€œReplace â€˜alpha_powerâ€™ with â€˜power_exponentâ€™. â€œ â€œStandard STA uses power_exponent: 0.5 for finite-time convergence. â€œ â€œValid range: (0, 1). Example: power_exponent: 0.5â€ ), removed_in_version=â€3.0.0â€, auto_migrate=True, validation_function=lambda x: 0.0 &lt; x &lt; 1.0 ), â€˜switching_function_typeâ€™: DeprecationMapping( old_name=â€™switching_function_typeâ€™, new_name=â€™switch_methodâ€™, level=DeprecationLevel.INFO, message=â€œâ€˜switching_function_typeâ€™ renamed to â€˜switch_methodâ€™ for consistency.â€, migration_guide=( â€œReplace â€˜switching_function_typeâ€™ with â€˜switch_methodâ€™. â€œ â€œValid options: â€˜tanhâ€™, â€˜sigmoidâ€™, â€˜satâ€™. â€œ â€œSTA-SMC typically uses â€˜tanhâ€™ for smooth switching.â€ ), removed_in_version=â€4.0.0â€, auto_migrate=True )</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/deprecation_management.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/deprecation_management.html#runnable-false-hybrid-smc-deprecations-mode-deprecationmapping-old-name-mode-new-name-hybrid-mode-level-deprecationlevel-warning-message-mode-parameter-renamed-to-hybrid-mode-migration-guide-replace-mode-with-hybrid-mode-and-use-hybridmode-enum-values-available-modes-classical-adaptive-adaptive-sta-classical-sta-example-hybrid-mode-classical-adaptive-removed-in-version-3-0-0-auto-migrate-true-switch-threshold-deprecationmapping-old-name-switch-threshold-new-name-switching-criteria-level-deprecationlevel-warning-message-switch-threshold-renamed-to-switching-criteria-with-enhanced-functionality-migration-guide-replace-switch-threshold-with-switching-criteria-configuration-new-format-supports-multiple-criteria-error-threshold-time-threshold-performance-threshold-example-switching-criteria-error-threshold-0-1-time-threshold-2-0-removed-in-version-3-0-0-auto-migrate-false-requires-manual-migration-due-to-format-change-sub-controller-gains-deprecationmapping-old-name-sub-controller-gains-new-name-classical-config-adaptive-config-level-deprecationlevel-error-message-sub-controller-gains-replaced-with-full-sub-controller-configurations-migration-guide-replace-sub-controller-gains-with-complete-classical-config-and-adaptive-config-objects-this-provides-full-parameter-control-for-each-sub-controller-see-hybrid-smc-configuration-examples-in-documentation-removed-in-version-2-0-0-auto-migrate-false">runnable: false HYBRID_SMC_DEPRECATIONS = { â€˜modeâ€™: DeprecationMapping( old_name=â€™modeâ€™, new_name=â€™hybrid_modeâ€™, level=DeprecationLevel.WARNING, message=â€œâ€˜modeâ€™ parameter renamed to â€˜hybrid_modeâ€™.â€, migration_guide=( â€œReplace â€˜modeâ€™ with â€˜hybrid_modeâ€™ and use HybridMode enum values. â€œ â€œAvailable modes: â€˜CLASSICAL_ADAPTIVEâ€™, â€˜ADAPTIVE_STAâ€™, â€˜CLASSICAL_STAâ€™. â€œ â€œExample: hybrid_mode: â€˜CLASSICAL_ADAPTIVEâ€™â€ ), removed_in_version=â€3.0.0â€, auto_migrate=True ), â€˜switch_thresholdâ€™: DeprecationMapping( old_name=â€™switch_thresholdâ€™, new_name=â€™switching_criteriaâ€™, level=DeprecationLevel.WARNING, message=â€œâ€˜switch_thresholdâ€™ renamed to â€˜switching_criteriaâ€™ with enhanced functionality.â€, migration_guide=( â€œReplace â€˜switch_thresholdâ€™ with â€˜switching_criteriaâ€™ configuration. â€œ â€œNew format supports multiple criteria: error_threshold, time_threshold, performance_threshold. â€œ â€œExample: switching_criteria: {error_threshold: 0.1, time_threshold: 2.0}â€ ), removed_in_version=â€3.0.0â€, auto_migrate=False # Requires manual migration due to format change ), â€˜sub_controller_gainsâ€™: DeprecationMapping( old_name=â€™sub_controller_gainsâ€™, new_name=[â€˜classical_configâ€™, â€˜adaptive_configâ€™], level=DeprecationLevel.ERROR, message=â€œâ€˜sub_controller_gainsâ€™ replaced with full sub-controller configurations.â€, migration_guide=( â€œReplace â€˜sub_controller_gainsâ€™ with complete â€˜classical_configâ€™ and â€˜adaptive_configâ€™ objects. â€œ â€œThis provides full parameter control for each sub-controller. â€œ â€œSee hybrid SMC configuration examples in documentation.â€ ), removed_in_version=â€2.0.0â€, auto_migrate=False )</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/deprecation_management.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/deprecation_management.html#runnable-false-safe-for-automatic-migration-simple-rename-deprecationmapping-old-name-old-name-new-name-new-name-auto-migrate-true-requires-manual-migration-complex-change-deprecationmapping-old-name-complex-param-new-name-restructured-config-auto-migrate-false-semantic-change-requires-manual-intervention-migration-guide-see-migration-guide-at-docs-migration-v3-0-md-usage-and-monitoringpython">runnable: false # Safe for automatic migration simple_rename = DeprecationMapping( old_name=â€™old_nameâ€™, new_name=â€™new_nameâ€™, auto_migrate=True ) # Requires manual migration complex_change = DeprecationMapping( old_name=â€™complex_paramâ€™, new_name=â€™restructured_configâ€™, auto_migrate=False, # Semantic change requires manual intervention migration_guide=â€See migration guide at docs/migration/v3.0.mdâ€ ) <code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">Usage</span> <span class="pre">and</span> <span class="pre">Monitoring</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/deprecation_management.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/deprecation_management.html#runnable-false-global-deprecation-warner-instance">runnable: false # Global deprecation warner instance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html">Parameter Interface Specification ## Overview This document provides a specification of the parameter interface system implemented in the SMC Controller Factory. The interface resolves the gamma vs gains parameter conflicts and establishes clear parameter handling contracts across all controller types. ## Parameter Resolution Architecture ### Hierarchical Parameter Sources The factory implements a multi-level parameter resolution system: ```</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html#runnable-false-def-resolve-controller-gains-gains-optional-union-list-float-np-ndarray-config-optional-any-controller-type-str-controller-info-dict-str-any">runnable: false def _resolve_controller_gains( gains: Optional[Union[List[float], np.ndarray]], config: Optional[Any], controller_type: str, controller_info: Dict[str, Any]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html#runnable-false-parameter-structure-k1-k2-1-2-k-kd">runnable: false # Parameter Structure: [k1, k2, Î»1, Î»2, K, kd]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html#runnable-false-parameter-structure-k1-k2-1-2">runnable: false # Parameter Structure: [k1, k2, Î»1, Î»2, Î³]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html#runnable-false-parameter-structure-k1-k2-k1-k2-1-2">runnable: false # Parameter Structure: [K1, K2, k1, k2, Î»1, Î»2]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html#runnable-false-parameter-structure-k1-k2-1-2-surface-gains-only">runnable: false # Parameter Structure: [k1, k2, Î»1, Î»2] (surface gains only)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html#runnable-false-class-parametervalidator-parameter-validation-for-smc-controllers-staticmethod-def-validate-gain-structure-gains-list-float-controller-type-str-controller-info-dict-str-any-none-validate-gain-array-structure-and-constraints-1-length-validation-expected-count-controller-info-gain-count-if-len-gains-expected-count-raise-valueerror-f-controller-controller-type-requires-expected-count-gains-f-got-len-gains-expected-structure-controller-info-get-gain-names-2-numerical-validation-for-i-gain-in-enumerate-gains-if-not-isinstance-gain-int-float-raise-typeerror-f-gain-i-must-be-numeric-got-type-gain-if-not-np-isfinite-gain-raise-valueerror-f-gain-i-must-be-finite-got-gain-3-physical-constraint-validation-parametervalidator-validate-physical-constraints-gains-controller-type-staticmethod-def-validate-physical-constraints-gains-list-float-controller-type-str-none-validate-controller-specific-physical-constraints-if-controller-type-classical-smc-all-gains-must-be-positive-for-stability-if-any-g-0-for-g-in-gains-raise-valueerror-classical-smc-all-gains-must-be-positive-for-stability-specific-constraint-k-switching-gain-should-be-significant-k-gains-4-k-is-5th-element-if-k-1-0-warnings-warn-f-classical-smc-k-k-may-be-too-small-for-effective-switching-elif-controller-type-adaptive-smc-surface-gains-must-be-positive-if-any-g-0-for-g-in-gains-4-raise-valueerror-adaptive-smc-surface-gains-k1-k2-1-2-must-be-positive-gamma-adaptation-rate-constraints-gamma-gains-4-if-gamma-0-raise-valueerror-adaptive-smc-adaptation-rate-must-be-positive-if-gamma-10-0-warnings-warn-f-adaptive-smc-gamma-may-cause-adaptation-instability-elif-controller-type-sta-smc-all-gains-positive-for-sta-stability-if-any-g-0-for-g-in-gains-raise-valueerror-sta-smc-all-gains-must-be-positive-sta-specific-constraint-k1-k2-typically-k1-k2-gains-0-gains-1-if-k1-k2-warnings-warn-sta-smc-typically-k1-k2-for-proper-sta-operation-elif-controller-type-hybrid-adaptive-sta-smc-only-surface-gains-for-hybrid-controller-if-any-g-0-for-g-in-gains-raise-valueerror-hybrid-smc-all-surface-gains-must-be-positive">runnable: false class ParameterValidator: â€œâ€â€parameter validation for SMC controllers.â€â€â€ @staticmethod def validate_gain_structure( gains: List[float], controller_type: str, controller_info: Dict[str, Any] ) -&gt; None: â€œâ€â€Validate gain array structure and constraints.â€â€â€ # 1. Length validation expected_count = controller_info[â€˜gain_countâ€™] if len(gains) != expected_count: raise ValueError( fâ€Controller â€˜{controller_type}â€™ requires {expected_count} gains, â€œ fâ€got {len(gains)}. Expected structure: {controller_info.get(â€˜gain_namesâ€™, [])}â€ ) # 2. Numerical validation for i, gain in enumerate(gains): if not isinstance(gain, (int, float)): raise TypeError(fâ€Gain[{i}] must be numeric, got {type(gain)}â€) if not np.isfinite(gain): raise ValueError(fâ€Gain[{i}] must be finite, got {gain}â€) # 3. Physical constraint validation ParameterValidator._validate_physical_constraints(gains, controller_type) @staticmethod def _validate_physical_constraints(gains: List[float], controller_type: str) -&gt; None: â€œâ€â€Validate controller-specific physical constraints.â€â€â€ if controller_type == â€˜classical_smcâ€™: # All gains must be positive for stability if any(g &lt;= 0 for g in gains): raise ValueError(â€œClassical SMC: All gains must be positive for stabilityâ€) # Specific constraint: K (switching gain) should be significant K = gains[4] # K is 5th element if K &lt; 1.0: warnings.warn(fâ€Classical SMC: K={K} may be too small for effective switchingâ€) elif controller_type == â€˜adaptive_smcâ€™: # Surface gains must be positive if any(g &lt;= 0 for g in gains[:4]): raise ValueError(â€œAdaptive SMC: Surface gains k1, k2, Î»1, Î»2 must be positiveâ€) # Gamma (adaptation rate) constraints gamma = gains[4] if gamma &lt;= 0: raise ValueError(â€œAdaptive SMC: Adaptation rate Î³ must be positiveâ€) if gamma &gt; 10.0: warnings.warn(fâ€Adaptive SMC: Î³={gamma} may cause adaptation instabilityâ€) elif controller_type == â€˜sta_smcâ€™: # All gains positive for STA stability if any(g &lt;= 0 for g in gains): raise ValueError(â€œSTA-SMC: All gains must be positiveâ€) # STA-specific constraint: K1 &gt; K2 typically K1, K2 = gains[0], gains[1] if K1 &lt;= K2: warnings.warn(â€œSTA-SMC: Typically K1 &gt; K2 for proper STA operationâ€) elif controller_type == â€˜hybrid_adaptive_sta_smcâ€™: # Only surface gains for hybrid controller if any(g &lt;= 0 for g in gains): raise ValueError(â€œHybrid SMC: All surface gains must be positiveâ€)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html#runnable-false-def-validate-parameter-ranges-gains-list-float-controller-type-str-bounds-optional-list-tuple-float-float-none">runnable: false def validate_parameter_ranges( gains: List[float], controller_type: str, bounds: Optional[List[Tuple[float, float]]] = None</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html#id7">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html#runnable-false-def-extract-controller-parameters-config-optional-any-controller-type-str-controller-info-dict-str-any">runnable: false def _extract_controller_parameters( config: Optional[Any], controller_type: str, controller_info: Dict[str, Any]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html#id8">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html#runnable-false-class-parameterresolutionerror-valueerror-raised-when-parameter-resolution-fails-pass-class-gainvalidationerror-valueerror-raised-when-gain-validation-fails-pass-def-create-controller-with-parameter-recovery-controller-type-str-config-optional-any-none-gains-optional-union-list-np-ndarray-none">runnable: false class ParameterResolutionError(ValueError): â€œâ€â€Raised when parameter resolution fails.â€â€â€ pass class GainValidationError(ValueError): â€œâ€â€Raised when gain validation fails.â€â€â€ pass def create_controller_with_parameter_recovery( controller_type: str, config: Optional[Any] = None, gains: Optional[Union[list, np.ndarray]] = None</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html#id9">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/parameter_interface_specification.html#runnable-false-def-create-minimal-config-controller-type-str-dict-str-any-create-minimal-viable-configuration-for-controller-type-base-config-max-force-150-0-dt-0-001-add-controller-specific-minimal-parameters-if-controller-type-classical-smc-base-config-boundary-layer-0-02-elif-controller-type-adaptive-smc-base-config-update-leak-rate-0-01-adapt-rate-limit-10-0-k-min-0-1-k-max-100-0-k-init-10-0-alpha-0-5-elif-controller-type-sta-smc-base-config-update-power-exponent-0-5-regularization-1e-6-switch-method-tanh-return-base-config">runnable: false def create_minimal_config(controller_type: str) -&gt; Dict[str, Any]: â€œâ€â€Create minimal viable configuration for controller type.â€â€â€ base_config = { â€˜max_forceâ€™: 150.0, â€˜dtâ€™: 0.001 } # Add controller-specific minimal parameters if controller_type == â€˜classical_smcâ€™: base_config[â€˜boundary_layerâ€™] = 0.02 elif controller_type == â€˜adaptive_smcâ€™: base_config.update({ â€˜leak_rateâ€™: 0.01, â€˜adapt_rate_limitâ€™: 10.0, â€˜K_minâ€™: 0.1, â€˜K_maxâ€™: 100.0, â€˜K_initâ€™: 10.0, â€˜alphaâ€™: 0.5 }) elif controller_type == â€˜sta_smcâ€™: base_config.update({ â€˜power_exponentâ€™: 0.5, â€˜regularizationâ€™: 1e-6, â€˜switch_methodâ€™: â€˜tanhâ€™ }) return base_config</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/enhanced_pso_integration_guide.html">Enhanced PSO Integration Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/enhanced_pso_integration_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/enhanced_pso_integration_guide.html#runnable-false-class-psofactoryinterface-high-performance-interface-for-pso-optimization-workflows-features-thread-safe-parallel-optimization-automatic-gain-validation-and-bounds-checking-performance-monitoring-and-diagnostics-fallback-mechanisms-for-invalid-parameter-sets-def-init-self-controller-type-str-simulation-config-any-self-controller-type-controller-type-self-config-simulation-config-self-initialize-pso-environment-def-initialize-pso-environment-self-none-setup-pso-optimization-environment-with-all-requirements-controller-specifications-self-registry-info-controller-registry-self-controller-type-self-n-gains-self-registry-info-gain-count-self-default-gains-self-registry-info-default-gains-pso-bounds-mathematically-derived-self-bounds-lower-self-bounds-upper-get-gain-bounds-for-pso-smctype-self-controller-type-performance-tracking-self-metrics-total-evaluations-0-successful-evaluations-0-validation-failures-0-simulation-failures-0-best-fitness-float-inf-average-fitness-0-0-thread-safety-self-evaluation-lock-threading-rlock">runnable: false class PSOFactoryInterface: â€œâ€â€ High-performance interface for PSO optimization workflows. Features: - Thread-safe parallel optimization - Automatic gain validation and bounds checking - Performance monitoring and diagnostics - Fallback mechanisms for invalid parameter sets â€œâ€â€ def <strong>init</strong>(self, controller_type: str, simulation_config: Any): self.controller_type = controller_type self.config = simulation_config self._initialize_pso_environment() def _initialize_pso_environment(self) -&gt; None: â€œâ€â€Setup PSO optimization environment with all requirements.â€â€â€ # Controller specifications self.registry_info = CONTROLLER_REGISTRY[self.controller_type] self.n_gains = self.registry_info[â€˜gain_countâ€™] self.default_gains = self.registry_info[â€˜default_gainsâ€™] # PSO bounds (mathematically derived) self.bounds_lower, self.bounds_upper = get_gain_bounds_for_pso( SMCType(self.controller_type) ) # Performance tracking self.metrics = { â€˜total_evaluationsâ€™: 0, â€˜successful_evaluationsâ€™: 0, â€˜validation_failuresâ€™: 0, â€˜simulation_failuresâ€™: 0, â€˜best_fitnessâ€™: float(â€˜infâ€™), â€˜average_fitnessâ€™: 0.0 } # Thread safety self._evaluation_lock = threading.RLock()</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/enhanced_pso_integration_guide.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/enhanced_pso_integration_guide.html#runnable-false-class-psocontrollerwrapper-pso-optimized-controller-wrapper-with-validation-provides-simplified-control-interface-for-fitness-evaluation-automatic-gain-validation-with-controller-specific-rules-performance-monitoring-and-error-handling-thread-safe-operation-for-parallel-pso-def-init-self-controller-any-controller-type-str-validation-config-dict-str-any-self-controller-controller-self-controller-type-controller-type-self-validation-config-validation-config-pso-required-attributes-self-n-gains-controller-registry-controller-type-gain-count-self-max-force-getattr-controller-max-force-150-0-performance-tracking-self-control-calls-0-self-control-failures-0-self-last-control-time-0-0-def-validate-gains-self-particles-np-ndarray-np-ndarray-vectorized-gain-validation-for-pso-particle-swarms-args-particles-array-of-shape-n-particles-n-gains-returns-boolean-mask-indicating-valid-particles-if-particles-ndim-1-particles-particles-reshape-1-1-valid-mask-np-ones-particles-shape-0-dtype-bool-basic-validation-for-i-gains-in-enumerate-particles-try-check-gain-count-if-len-gains-self-n-gains-valid-mask-i-false-continue-check-for-finite-positive-values-if-not-all-np-isfinite-g-and-g-0-for-g-in-gains-valid-mask-i-false-continue-controller-specific-validation-if-not-self-validate-controller-specific-constraints-gains-valid-mask-i-false-continue-except-exception-valid-mask-i-false-return-valid-mask-def-validate-controller-specific-constraints-self-gains-list-float-bool-apply-mathematical-constraints-for-each-controller-type-if-self-controller-type-classical-smc-classical-smc-all-gains-positive-reasonable-ranges-k1-k2-lam1-lam2-k-kd-gains-return-all-g-0-for-g-in-gains-5-and-kd-0-elif-self-controller-type-sta-smc-super-twisting-critical-stability-condition-k1-k2-k1-k2-gains-0-gains-1-return-k1-k2-0-and-all-g-0-for-g-in-gains-2-elif-self-controller-type-adaptive-smc-adaptive-smc-adaptation-rate-bounds-k1-k2-lam1-lam2-gamma-gains-return-all-g-0-for-g-in-gains-4-and-0-1-gamma-20-0-elif-self-controller-type-hybrid-adaptive-sta-smc-hybrid-smc-surface-parameters-positive-return-all-g-0-for-g-in-gains-return-true-def-compute-control-self-state-np-ndarray-np-ndarray-pso-compatible-control-computation-with-error-handling-args-state-system-state-vector-1-2-x-1-2-x-returns-control-output-as-numpy-array-try-self-control-calls-1-start-time-time-time-validate-input-state-if-len-state-6-raise-valueerror-f-expected-6-element-state-got-len-state-call-underlying-controller-result-self-controller-compute-control-state-extract-control-value-if-hasattr-result-u-u-result-u-elif-isinstance-result-dict-and-u-in-result-u-result-u-else-u-result-apply-saturation-and-return-as-array-u-sat-np-clip-float-u-self-max-force-self-max-force-performance-tracking-self-last-control-time-time-time-start-time-return-np-array-u-sat-except-exception-as-e-self-control-failures-1-return-safe-fallback-control-return-np-array-0-0">runnable: false class PSOControllerWrapper: â€œâ€â€ PSO-optimized controller wrapper with validation. Provides: - Simplified control interface for fitness evaluation - Automatic gain validation with controller-specific rules - Performance monitoring and error handling - Thread-safe operation for parallel PSO â€œâ€â€ def <strong>init</strong>(self, controller: Any, controller_type: str, validation_config: Dict[str, Any]): self.controller = controller self.controller_type = controller_type self.validation_config = validation_config # PSO-required attributes self.n_gains = CONTROLLER_REGISTRY[controller_type][â€˜gain_countâ€™] self.max_force = getattr(controller, â€˜max_forceâ€™, 150.0) # Performance tracking self.control_calls = 0 self.control_failures = 0 self.last_control_time = 0.0 def validate_gains(self, particles: np.ndarray) -&gt; np.ndarray: â€œâ€â€ Vectorized gain validation for PSO particle swarms. Args: particles: Array of shape (n_particles, n_gains) Returns: Boolean mask indicating valid particles â€œâ€â€ if particles.ndim == 1: particles = particles.reshape(1, -1) valid_mask = np.ones(particles.shape[0], dtype=bool) # Basic validation for i, gains in enumerate(particles): try: # Check gain count if len(gains) != self.n_gains: valid_mask[i] = False continue # Check for finite positive values if not all(np.isfinite(g) and g &gt; 0 for g in gains): valid_mask[i] = False continue # Controller-specific validation if not self._validate_controller_specific_constraints(gains): valid_mask[i] = False continue except Exception: valid_mask[i] = False return valid_mask def _validate_controller_specific_constraints(self, gains: List[float]) -&gt; bool: â€œâ€â€Apply mathematical constraints for each controller type.â€â€â€ if self.controller_type == â€˜classical_smcâ€™: # Classical SMC: All gains positive, reasonable ranges k1, k2, lam1, lam2, K, kd = gains return all(g &gt; 0 for g in gains[:5]) and kd &gt;= 0 elif self.controller_type == â€˜sta_smcâ€™: # Super-Twisting: Critical stability condition K1 &gt; K2 K1, K2 = gains[0], gains[1] return K1 &gt; K2 &gt; 0 and all(g &gt; 0 for g in gains[2:]) elif self.controller_type == â€˜adaptive_smcâ€™: # Adaptive SMC: Adaptation rate bounds k1, k2, lam1, lam2, gamma = gains return all(g &gt; 0 for g in gains[:4]) and 0.1 &lt;= gamma &lt;= 20.0 elif self.controller_type == â€˜hybrid_adaptive_sta_smcâ€™: # Hybrid SMC: Surface parameters positive return all(g &gt; 0 for g in gains) return True def compute_control(self, state: np.ndarray) -&gt; np.ndarray: â€œâ€â€ PSO-compatible control computation with error handling. Args: state: System state vector [Î¸â‚, Î¸â‚‚, x, Î¸Ì‡â‚, Î¸Ì‡â‚‚, áº‹] Returns: Control output as numpy array â€œâ€â€ try: self.control_calls += 1 start_time = time.time() # Validate input state if len(state) != 6: raise ValueError(fâ€Expected 6-element state, got {len(state)}â€) # Call underlying controller result = self.controller.compute_control(state, {}, {}) # Extract control value if hasattr(result, â€˜uâ€™): u = result.u elif isinstance(result, dict) and â€˜uâ€™ in result: u = result[â€˜uâ€™] else: u = result # Apply saturation and return as array u_sat = np.clip(float(u), -self.max_force, self.max_force) # Performance tracking self.last_control_time = time.time() - start_time return np.array([u_sat]) except Exception as e: self.control_failures += 1 # Return safe fallback control return np.array([0.0])</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/enhanced_pso_integration_guide.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/enhanced_pso_integration_guide.html#runnable-false-def-multi-objective-pso-optimization-controller-types-list-str-simulation-config-any-objectives-dict-str-float-ise-0-4-overshoot-0-3-energy-0-3-pso-config-dict-str-any">runnable: false def multi_objective_pso_optimization( controller_types: List[str], simulation_config: Any, objectives: Dict[str, float], # {â€˜iseâ€™: 0.4, â€˜overshootâ€™: 0.3, â€˜energyâ€™: 0.3} pso_config: Dict[str, Any]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/enhanced_pso_integration_guide.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/enhanced_pso_integration_guide.html#runnable-false-def-adaptive-pso-optimization-controller-type-str-simulation-config-any-adaptation-config-dict-str-any">runnable: false def adaptive_pso_optimization( controller_type: str, simulation_config: Any, adaptation_config: Dict[str, Any]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/enhanced_pso_integration_guide.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/enhanced_pso_integration_guide.html#runnable-false-class-simulationcache-intelligent-caching-system-for-pso-optimization-features-hash-based-lookup-for-identical-gain-sets-lru-eviction-for-memory-management-cache-hit-miss-statistics-persistent-storage-for-long-running-optimizations-def-init-self-max-size-int-1000-tolerance-float-1e-6-self-cache-self-max-size-max-size-self-tolerance-tolerance-self-hits-0-self-misses-0-def-get-cache-key-self-gains-np-ndarray-str-generate-consistent-cache-key-for-gain-arrays-rounded-gains-np-round-gains-self-tolerance-self-tolerance-return-hash-tuple-rounded-gains-def-get-self-gains-np-ndarray-optional-float-retrieve-cached-fitness-if-available-key-self-get-cache-key-gains-if-key-in-self-cache-self-hits-1-return-self-cache-key-self-misses-1-return-none-def-put-self-gains-np-ndarray-fitness-float-none-store-fitness-result-in-cache-if-len-self-cache-self-max-size-remove-oldest-entry-simple-lru-oldest-key-next-iter-self-cache-del-self-cache-oldest-key-key-self-get-cache-key-gains-self-cache-key-fitness-def-get-statistics-self-dict-str-any-return-cache-performance-statistics-total-requests-self-hits-self-misses-hit-rate-self-hits-total-requests-if-total-requests-0-else-0-return-hits-self-hits-misses-self-misses-hit-rate-hit-rate-cache-size-len-self-cache">runnable: false class SimulationCache: â€œâ€â€ Intelligent caching system for PSO optimization. Features: - Hash-based lookup for identical gain sets - LRU eviction for memory management - Cache hit/miss statistics - Persistent storage for long-running optimizations â€œâ€â€ def <strong>init</strong>(self, max_size: int = 1000, tolerance: float = 1e-6): self.cache = {} self.max_size = max_size self.tolerance = tolerance self.hits = 0 self.misses = 0 def get_cache_key(self, gains: np.ndarray) -&gt; str: â€œâ€â€Generate consistent cache key for gain arrays.â€â€â€ rounded_gains = np.round(gains / self.tolerance) * self.tolerance return hash(tuple(rounded_gains)) def get(self, gains: np.ndarray) -&gt; Optional[float]: â€œâ€â€Retrieve cached fitness if available.â€â€â€ key = self.get_cache_key(gains) if key in self.cache: self.hits += 1 return self.cache[key] self.misses += 1 return None def put(self, gains: np.ndarray, fitness: float) -&gt; None: â€œâ€â€Store fitness result in cache.â€â€â€ if len(self.cache) &gt;= self.max_size: # Remove oldest entry (simple LRU) oldest_key = next(iter(self.cache)) del self.cache[oldest_key] key = self.get_cache_key(gains) self.cache[key] = fitness def get_statistics(self) -&gt; Dict[str, Any]: â€œâ€â€Return cache performance statistics.â€â€â€ total_requests = self.hits + self.misses hit_rate = self.hits / total_requests if total_requests &gt; 0 else 0 return { â€˜hitsâ€™: self.hits, â€˜missesâ€™: self.misses, â€˜hit_rateâ€™: hit_rate, â€˜cache_sizeâ€™: len(self.cache) }</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/enhanced_pso_integration_guide.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/enhanced_pso_integration_guide.html#runnable-false-def-get-optimized-pso-bounds-controller-type-str-plant-params-dict-str-any-tuple-list-float-list-float-compute-optimized-pso-bounds-based-on-plant-parameters-and-control-theory-uses-stability-margins-and-performance-requirements-to-derive-tight-bounds-if-controller-type-classical-smc-classical-smc-bounds-based-on-stability-analysis-pole-placement-considerations-for-closed-loop-stability-max-damping-plant-params-get-max-damping-requirement-0-7-settling-time-plant-params-get-settling-time-requirement-2-0-derive-bounds-from-desired-closed-loop-characteristics-lambda-min-4-0-settling-time-natural-frequency-requirement-lambda-max-20-0-upper-bound-to-prevent-excessive-control-effort-k-min-lambda-min-2-0-position-gain-lower-bound-k-max-lambda-max-2-0-position-gain-upper-bound-k-min-estimate-min-switching-gain-plant-params-k-max-plant-params-get-max-force-150-0-0-8-conservative-upper-bound-bounds-lower-k-min-k-min-lambda-min-lambda-min-k-min-0-0-bounds-upper-k-max-k-max-lambda-max-lambda-max-k-max-10-0-elif-controller-type-sta-smc-super-twisting-bounds-with-stability-constraint-k1-k2-lyapunov-based-design-bounds-l0-estimate-lipschitz-constant-plant-params-k1-min-math-sqrt-l0-1-1-safety-margin-k1-max-math-sqrt-l0-5-0-conservative-upper-bound-k2-min-l0-2-math-sqrt-l0-k1-min-2-1-1-k2-max-k1-max-0-8-ensure-k1-k2-constraint-bounds-lower-k1-min-k2-min-2-0-2-0-5-0-5-0-bounds-upper-k1-max-k2-max-30-0-30-0-20-0-20-0-elif-controller-type-adaptive-smc-adaptive-smc-bounds-based-on-adaptation-rate-limits-stability-preserving-adaptation-rate-bounds-gamma-min-0-1-minimum-for-reasonable-adaptation-speed-gamma-max-estimate-max-adaptation-rate-plant-params-stability-limit-bounds-lower-2-0-2-0-5-0-5-0-gamma-min-bounds-upper-40-0-40-0-25-0-25-0-gamma-max-else-hybrid-adaptive-sta-smc-hybrid-controller-bounds-conservative-surface-parameters-bounds-lower-2-0-2-0-5-0-5-0-bounds-upper-30-0-30-0-20-0-20-0-return-bounds-lower-bounds-upper-def-estimate-min-switching-gain-plant-params-dict-str-any-float-estimate-minimum-switching-gain-based-on-disturbance-bounds-extract-disturbance-characteristics-max-model-uncertainty-plant-params-get-model-uncertainty-0-2-max-external-disturbance-plant-params-get-external-disturbance-5-0-safety-margin-plant-params-get-safety-margin-1-5-conservative-estimate-return-max-model-uncertainty-max-external-disturbance-safety-margin-def-estimate-lipschitz-constant-plant-params-dict-str-any-float-estimate-lipschitz-constant-for-sta-design-based-on-system-nonlinearity-and-uncertainty-bounds-max-nonlinearity-plant-params-get-max-nonlinearity-10-0-uncertainty-bound-plant-params-get-uncertainty-bound-5-0-return-max-nonlinearity-uncertainty-bound-def-estimate-max-adaptation-rate-plant-params-dict-str-any-float-estimate-maximum-stable-adaptation-rate-based-on-parameter-variation-speed-and-system-bandwidth-system-bandwidth-plant-params-get-system-bandwidth-10-0-rad-s-parameter-variation-rate-plant-params-get-parameter-variation-rate-0-1-hz-conservative-bound-adaptation-much-slower-than-system-dynamics-return-min-system-bandwidth-10-0-1-0-parameter-variation-rate">runnable: false def get_optimized_pso_bounds(controller_type: str, plant_params: Dict[str, Any]) -&gt; Tuple[List[float], List[float]]: â€œâ€â€ Compute optimized PSO bounds based on plant parameters and control theory. Uses stability margins and performance requirements to derive tight bounds. â€œâ€â€ if controller_type == â€˜classical_smcâ€™: # Classical SMC bounds based on stability analysis # Pole placement considerations for closed-loop stability max_damping = plant_params.get(â€˜max_damping_requirementâ€™, 0.7) settling_time = plant_params.get(â€˜settling_time_requirementâ€™, 2.0) # Derive bounds from desired closed-loop characteristics lambda_min = 4.0 / settling_time # Natural frequency requirement lambda_max = 20.0 # Upper bound to prevent excessive control effort k_min = lambda_min / 2.0 # Position gain lower bound k_max = lambda_max * 2.0 # Position gain upper bound K_min = estimate_min_switching_gain(plant_params) K_max = plant_params.get(â€˜max_forceâ€™, 150.0) * 0.8 # Conservative upper bound bounds_lower = [k_min, k_min, lambda_min, lambda_min, K_min, 0.0] bounds_upper = [k_max, k_max, lambda_max, lambda_max, K_max, 10.0] elif controller_type == â€˜sta_smcâ€™: # Super-Twisting bounds with stability constraint K1 &gt; K2 # Lyapunov-based design bounds L0 = estimate_lipschitz_constant(plant_params) K1_min = math.sqrt(L0) * 1.1 # Safety margin K1_max = math.sqrt(L0) * 5.0 # Conservative upper bound K2_min = L0 / (2 * math.sqrt(L0 - K1_min**2)) * 1.1 K2_max = K1_max * 0.8 # Ensure K1 &gt; K2 constraint bounds_lower = [K1_min, K2_min, 2.0, 2.0, 5.0, 5.0] bounds_upper = [K1_max, K2_max, 30.0, 30.0, 20.0, 20.0] elif controller_type == â€˜adaptive_smcâ€™: # Adaptive SMC bounds based on adaptation rate limits # Stability-preserving adaptation rate bounds gamma_min = 0.1 # Minimum for reasonable adaptation speed gamma_max = estimate_max_adaptation_rate(plant_params) # Stability limit bounds_lower = [2.0, 2.0, 5.0, 5.0, gamma_min] bounds_upper = [40.0, 40.0, 25.0, 25.0, gamma_max] else: # hybrid_adaptive_sta_smc # Hybrid controller bounds (conservative surface parameters) bounds_lower = [2.0, 2.0, 5.0, 5.0] bounds_upper = [30.0, 30.0, 20.0, 20.0] return bounds_lower, bounds_upper def estimate_min_switching_gain(plant_params: Dict[str, Any]) -&gt; float: â€œâ€â€Estimate minimum switching gain based on disturbance bounds.â€â€â€ # Extract disturbance characteristics max_model_uncertainty = plant_params.get(â€˜model_uncertaintyâ€™, 0.2) max_external_disturbance = plant_params.get(â€˜external_disturbanceâ€™, 5.0) safety_margin = plant_params.get(â€˜safety_marginâ€™, 1.5) # Conservative estimate return (max_model_uncertainty + max_external_disturbance) * safety_margin def estimate_lipschitz_constant(plant_params: Dict[str, Any]) -&gt; float: â€œâ€â€Estimate Lipschitz constant for STA design.â€â€â€ # Based on system nonlinearity and uncertainty bounds max_nonlinearity = plant_params.get(â€˜max_nonlinearityâ€™, 10.0) uncertainty_bound = plant_params.get(â€˜uncertainty_boundâ€™, 5.0) return max_nonlinearity + uncertainty_bound def estimate_max_adaptation_rate(plant_params: Dict[str, Any]) -&gt; float: â€œâ€â€Estimate maximum stable adaptation rate.â€â€â€ # Based on parameter variation speed and system bandwidth system_bandwidth = plant_params.get(â€˜system_bandwidthâ€™, 10.0) # rad/s parameter_variation_rate = plant_params.get(â€˜parameter_variation_rateâ€™, 0.1) # Hz # Conservative bound: adaptation much slower than system dynamics return min(system_bandwidth / 10.0, 1.0 / parameter_variation_rate)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/enhanced_pso_integration_guide.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/enhanced_pso_integration_guide.html#runnable-false-from-dataclasses-import-dataclass">runnable: false from dataclasses import dataclass</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/pso_factory_api_reference.html">PSO Factory Integration API Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/pso_factory_api_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/pso_factory_api_reference.html#runnable-false-class-smctype-enum-enumeration-of-supported-smc-controller-types-for-pso-optimization-each-type-corresponds-to-a-specific-sliding-mode-control-algorithm-with-distinct-mathematical-properties-and-parameter-requirements-classical-classical-smc-classical-sliding-mode-controller-with-boundary-layer-mathematical-model-u-u-eq-u-sw-u-eq-gb-1-gf-x-s-ref-u-sw-ktanh-s-gain-parameters-k1-k2-1-2-k-kd-k1-k2-position-gains-for-pendulum-1-and-2-1-2-surface-gains-for-pendulum-1-and-2-k-switching-gain-kd-damping-gain-mathematical-constraints-1-2-k-0-stability-requirement-kd-0-non-negative-damping-pso-bounds-0-1-50-0-1-50-1-50-1-50-1-200-0-50-super-twisting-sta-smc-super-twisting-sliding-mode-controller-second-order-mathematical-model-u-k1sign-s-k2sign-s-s-x-sliding-surface-gain-parameters-k1-k2-1-2-1-2-k1-primary-twisting-gain-k2-secondary-twisting-gain-1-2-surface-gains-1-2-higher-order-surface-parameters-mathematical-constraints-k1-k2-0-finite-time-convergence-1-2-1-2-0-stability-pso-bounds-2-100-1-99-1-50-1-50-1-50-1-50-adaptive-adaptive-smc-adaptive-sliding-mode-controller-with-online-gain-tuning-mathematical-model-u-u-eq-u-sw-k-s-k-adaptation-law-gain-parameters-k1-k2-1-2-k1-k2-position-gains-1-2-surface-gains-adaptation-rate-mathematical-constraints-k1-k2-1-2-0-stability-0-1-20-0-bounded-adaptation-pso-bounds-0-1-50-0-1-50-1-50-1-50-0-1-20-hybrid-hybrid-adaptive-sta-smc-hybrid-adaptive-super-twisting-controller-mathematical-model-u-u-adaptive-u-sta-mode-switching-gain-parameters-k1-k2-1-2-k1-k2-surface-gains-for-pendulum-1-and-2-1-2-higher-order-surface-gains-mathematical-constraints-all-parameters-0-stability-pso-bounds-1-50-1-50-1-50-1-50-property-def-gain-count-self-int-return-number-of-gain-parameters-for-this-controller-type-return-smctype-classical-6-smctype-super-twisting-6-smctype-adaptive-5-smctype-hybrid-4-self-property-def-mathematical-constraints-self-dict-str-str-return-mathematical-constraints-as-human-readable-strings-return-smctype-classical-1-2-k-0-kd-0-smctype-super-twisting-k1-k2-0-1-2-1-2-0-smctype-adaptive-k1-k2-1-2-0-0-1-20-0-smctype-hybrid-k1-k2-1-2-0-self">runnable: false class SMCType(Enum): â€œâ€â€ Enumeration of supported SMC controller types for PSO optimization. Each type corresponds to a specific sliding mode control algorithm with distinct mathematical properties and parameter requirements. â€œâ€â€ CLASSICAL = â€œclassical_smcâ€ â€œâ€â€ Classical sliding mode controller with boundary layer. Mathematical Model: u = u_eq + u_sw u_eq = (GB)^(-1)[-Gf(x) + á¹¡_ref] u_sw = -KÂ·tanh(s/Ï†) Gain Parameters: [k1, k2, Î»1, Î»2, K, kd] k1, k2: Position gains for pendulum 1 and 2 Î»1, Î»2: Surface gains for pendulum 1 and 2 K: Switching gain kd: Damping gain Mathematical Constraints: - Î»1, Î»2, K &gt; 0 (stability requirement) - kd â‰¥ 0 (non-negative damping) PSO Bounds: [(0.1,50), (0.1,50), (1,50), (1,50), (1,200), (0,50)] â€œâ€â€ SUPER_TWISTING = â€œsta_smcâ€ â€œâ€â€ Super-twisting sliding mode controller (second-order). Mathematical Model: uÌ‡ = -K1Â·sign(s) - K2Â·sign(á¹¡) s = Ïƒ(x) (sliding surface) Gain Parameters: [K1, K2, Î»1, Î»2, Î±1, Î±2] K1: Primary twisting gain K2: Secondary twisting gain Î»1, Î»2: Surface gains Î±1, Î±2: Higher-order surface parameters Mathematical Constraints: - K1 &gt; K2 &gt; 0 (finite-time convergence) - Î»1, Î»2, Î±1, Î±2 &gt; 0 (stability) PSO Bounds: [(2,100), (1,99), (1,50), (1,50), (1,50), (1,50)] â€œâ€â€ ADAPTIVE = â€œadaptive_smcâ€ â€œâ€â€ Adaptive sliding mode controller with online gain tuning. Mathematical Model: u = u_eq + u_sw KÌ‡ = Î³|s| - ÏƒK (adaptation law) Gain Parameters: [k1, k2, Î»1, Î»2, Î³] k1, k2: Position gains Î»1, Î»2: Surface gains Î³: Adaptation rate Mathematical Constraints: - k1, k2, Î»1, Î»2 &gt; 0 (stability) - 0.1 â‰¤ Î³ â‰¤ 20.0 (bounded adaptation) PSO Bounds: [(0.1,50), (0.1,50), (1,50), (1,50), (0.1,20)] â€œâ€â€ HYBRID = â€œhybrid_adaptive_sta_smcâ€ â€œâ€â€ Hybrid adaptive super-twisting controller. Mathematical Model: u = u_adaptive + u_sta (mode switching) Gain Parameters: [k1, k2, Î»1, Î»2] k1, k2: Surface gains for pendulum 1 and 2 Î»1, Î»2: Higher-order surface gains Mathematical Constraints: - All parameters &gt; 0 (stability) PSO Bounds: [(1,50), (1,50), (1,50), (1,50)] â€œâ€â€ @property def gain_count(self) -&gt; int: â€œâ€â€Return number of gain parameters for this controller type.â€â€â€ return { SMCType.CLASSICAL: 6, SMCType.SUPER_TWISTING: 6, SMCType.ADAPTIVE: 5, SMCType.HYBRID: 4 }[self] @property def mathematical_constraints(self) -&gt; Dict[str, str]: â€œâ€â€Return mathematical constraints as human-readable strings.â€â€â€ return { SMCType.CLASSICAL: â€œÎ»1,Î»2,K &gt; 0; kd â‰¥ 0â€, SMCType.SUPER_TWISTING: â€œK1 &gt; K2 &gt; 0; Î»1,Î»2,Î±1,Î±2 &gt; 0â€, SMCType.ADAPTIVE: â€œk1,k2,Î»1,Î»2 &gt; 0; 0.1 â‰¤ Î³ â‰¤ 20.0â€, SMCType.HYBRID: â€œk1,k2,Î»1,Î»2 &gt; 0â€ }[self]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/pso_factory_api_reference.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/pso_factory_api_reference.html#runnable-false-dataclass-frozen-true">runnable: false @dataclass(frozen=True)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/pso_factory_api_reference.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/pso_factory_api_reference.html#runnable-false-class-psocontrollerwrapper-pso-optimized-wrapper-providing-simplified-interface-for-smc-controllers-this-wrapper-is-specifically-designed-for-pso-fitness-evaluation-with-simplified-control-interface-single-state-input-automatic-state-management-for-stateful-controllers-unified-output-format-numpy-array-robust-error-handling-for-pso-robustness-performance-optimization-for-repeated-evaluations-the-wrapper-handles-the-complexity-of-different-smc-controller-interfaces-while-providing-a-consistent-pso-friendly-api-mathematical-foundation-the-wrapper-preserves-the-mathematical-properties-of-the-underlying-smc-controller-while-simplifying-the-interface-input-state-1-2-x-1-2-x-6-output-u-scalar-control-force-internal-state-management-classical-smc-stateless-empty-state-vars-sta-smc-maintains-z-for-integration-adaptive-smc-tracks-adaptation-variables-hybrid-smc-manages-mode-switching-state-performance-characteristics-control-computation-0-1ms-typical-memory-overhead-500b-per-wrapper-thread-safety-read-operations-only-error-recovery-graceful-degradation-for-invalid-inputs-def-init-self-controller-smcprotocol-initialize-pso-wrapper-with-smc-controller-args-controller-smc-controller-implementing-smcprotocol-raises-typeerror-if-controller-doesn-t-implement-required-interface-valueerror-if-controller-configuration-is-invalid-validate-controller-interface-if-not-hasattr-controller-compute-control-raise-typeerror-controller-must-implement-compute-control-method-if-not-hasattr-controller-gains-raise-typeerror-controller-must-have-gains-property-self-controller-controller-self-history-initialize-empty-history-initialize-controller-specific-state-variables-controller-name-type-controller-name-if-supertwisting-in-controller-name-or-sta-in-controller-name-sta-smc-maintains-integration-variables-z-self-state-vars-0-0-0-0-initial-z-0-0-elif-hybrid-in-controller-name-hybrid-controller-tracks-adaptive-gains-and-integration-self-state-vars-getattr-controller-k1-init-5-0-k1-prev-getattr-controller-k2-init-3-0-k2-prev-0-0-u-int-prev-elif-adaptive-in-controller-name-adaptive-smc-may-track-adaptation-state-self-state-vars-getattr-controller-initial-state-else-classical-smc-and-others-use-empty-state-self-state-vars-performance-tracking-self-call-count-0-self-total-compute-time-0-0-self-last-error-none-def-compute-control-self-state-np-ndarray-state-vars-optional-any-none-history-optional-dict-str-any-none-np-ndarray-compute-control-with-flexible-interface-supporting-both-1-simplified-pso-interface-compute-control-state-2-full-interface-compute-control-state-state-vars-history-mathematical-interface-input-state-vector-x-1-2-x-cart-1-2-x-cart-1-2-pendulum-angles-rad-x-cart-cart-position-m-1-2-angular-velocities-rad-s-x-cart-cart-velocity-m-s-output-control-u-scalar-control-force-n-bounded-by-actuator-limits-args-state-system-state-vector-6-element-numpy-array-state-vars-controller-state-variables-optional-history-controller-history-optional-returns-control-output-as-1-element-numpy-array-u-raises-valueerror-if-state-has-wrong-dimensions-runtimeerror-if-control-computation-fails-performance-typical-computation-time-0-01-0-1ms-memory-allocation-minimal-output-array-only-error-handling-graceful-fallback-to-zero-control-pso-usage-pattern-python-def-pso-fitness-gains-controller-create-smc-for-pso-smctype-classical-gains-simplified-interface-for-pso-total-error-0-0-for-state-in-test-states-u-controller-compute-control-state-returns-u-use-u-0-for-scalar-control-value-total-error-evaluate-single-step-state-u-0-return-total-error-state-management-the-wrapper-automatically-manages-controller-state-between-calls-classical-smc-no-state-management-needed-sta-smc-updates-integration-variables-z-adaptive-smc-updates-adaptation-parameters-hybrid-smc-updates-mode-and-adaptation-state-error-recovery-if-control-computation-fails-1-log-error-for-debugging-2-return-safe-fallback-control-zero-3-increment-error-counter-for-monitoring-4-continue-operation-don-t-crash-pso-import-time-performance-tracking-start-time-time-perf-counter-self-call-count-1-try-input-validation-if-not-isinstance-state-np-ndarray-state-np-array-state-if-state-shape-6-raise-valueerror-f-state-must-be-6-element-array-got-shape-state-shape-if-not-np-all-np-isfinite-state-raise-valueerror-state-contains-non-finite-values-nan-or-inf-use-provided-parameters-or-defaults-final-state-vars-state-vars-if-state-vars-is-not-none-else-self-state-vars-final-history-history-if-history-is-not-none-else-self-history-call-underlying-controller-result-self-controller-compute-control-state-final-state-vars-final-history-extract-control-value-from-result-handle-different-controller-output-formats-if-hasattr-result-u-standard-controller-output-with-u-attribute-control-value-result-u-update-state-variables-if-available-if-hasattr-result-state-vars-self-state-vars-result-state-vars-elif-hasattr-result-control-alternative-output-format-with-control-attribute-control-value-result-control-elif-isinstance-result-dict-dictionary-output-format-if-u-in-result-control-value-result-u-elif-control-in-result-control-value-result-control-else-raise-valueerror-dictionary-result-missing-control-value-update-state-if-provided-if-state-vars-in-result-self-state-vars-result-state-vars-elif-isinstance-result-tuple-tuple-output-e-g-early-return-from-some-controllers-control-value-result-0-first-element-is-control-if-len-result-1-self-state-vars-result-1-second-element-is-state-else-assume-result-is-the-control-value-directly-control-value-result-convert-to-scalar-if-needed-if-isinstance-control-value-np-ndarray-if-control-value-size-1-control-value-float-control-value-else-control-value-float-control-value-0-elif-not-isinstance-control-value-int-float-control-value-float-control-value-validate-output-if-not-np-isfinite-control-value-raise-valueerror-controller-returned-non-finite-control-value-apply-saturation-defensive-programming-max-force-getattr-self-controller-max-force-100-0-control-saturated-np-clip-control-value-max-force-max-force-for-simplified-interface-pso-usage-return-numpy-array-if-state-vars-is-none-and-history-is-none-output-np-array-control-saturated-else-for-full-interface-return-in-format-expected-by-simulation-output-control-saturated-performance-tracking-compute-time-time-perf-counter-start-time-self-total-compute-time-compute-time-return-output-except-exception-as-e-error-handling-for-robust-pso-operation-self-last-error-str-e-log-error-for-debugging-in-production-use-proper-logging-print-f-warning-control-computation-failed-e-return-safe-fallback-control-if-state-vars-is-none-and-history-is-none-return-np-array-0-0-pso-interface-else-return-0-0-full-interface-property-def-gains-self-list-float-return-controller-gains-returns-list-of-controller-gain-parameters-usage-python-controller-create-smc-for-pso-smctype-classical-gains-print-f-controller-gains-controller-gains-return-self-controller-gains-property-def-performance-stats-self-dict-str-any-return-performance-statistics-for-monitoring-returns-dictionary-with-performance-metrics-call-count-number-of-control-computations-total-time-total-computation-time-s-average-time-average-computation-time-ms-last-error-last-error-message-if-any-usage-python-after-pso-optimization-stats-controller-performance-stats-print-f-average-computation-time-stats-average-time-3f-ms-avg-time-ms-self-total-compute-time-self-call-count-1000-if-self-call-count-0-else-0-0-return-call-count-self-call-count-total-time-self-total-compute-time-average-time-avg-time-ms-last-error-self-last-error-def-reset-performance-stats-self-none-reset-performance-tracking-statistics-self-call-count-0-self-total-compute-time-0-0-self-last-error-none-def-validate-state-input-self-state-np-ndarray-tuple-bool-str-validate-state-input-for-control-computation-args-state-state-vector-to-validate-returns-tuple-of-is-valid-error-message-usage-python-is-valid-error-controller-validate-state-input-test-state-if-not-is-valid-print-f-invalid-state-error-try-if-not-isinstance-state-np-ndarray-return-false-state-must-be-numpy-array-if-state-shape-6-return-false-f-state-must-be-6-element-array-got-state-shape-if-not-np-all-np-isfinite-state-return-false-state-contains-non-finite-values-check-reasonable-ranges-optional-angles-state-2-1-2-if-np-any-np-abs-angles-2-np-pi-return-false-angles-exceed-reasonable-range-2-velocities-state-3-1-2-x-if-np-any-np-abs-velocities-100-return-false-velocities-exceed-reasonable-range-100-return-true-except-exception-as-e-return-false-f-validation-error-e-def-repr-self-str-string-representation-for-debugging-controller-type-type-self-controller-name-return-f-psocontrollerwrapper-controller-type-gains-self-gains">runnable: false class PSOControllerWrapper: â€œâ€â€ PSO-optimized wrapper providing simplified interface for SMC controllers. This wrapper is specifically designed for PSO fitness evaluation with: - Simplified control interface (single state input) - Automatic state management for stateful controllers - Unified output format (numpy array) - Robust error handling for PSO robustness - Performance optimization for repeated evaluations The wrapper handles the complexity of different SMC controller interfaces while providing a consistent, PSO-friendly API. Mathematical Foundation: The wrapper preserves the mathematical properties of the underlying SMC controller while simplifying the interface: Input: state = [Î¸â‚, Î¸â‚‚, x, Î¸Ì‡â‚, Î¸Ì‡â‚‚, áº‹] âˆˆ â„â¶ Output: u âˆˆ â„ (scalar control force) Internal State Management: - Classical SMC: Stateless (empty state_vars) - STA SMC: Maintains (z, Ïƒ) for integration - Adaptive SMC: Tracks adaptation variables - Hybrid SMC: Manages mode switching state Performance Characteristics: - Control computation: &lt;0.1ms typical - Memory overhead: &lt;500B per wrapper - Thread safety: Read operations only - Error recovery: Graceful degradation for invalid inputs â€œâ€â€ def <strong>init</strong>(self, controller: SMCProtocol): â€œâ€â€ Initialize PSO wrapper with SMC controller. Args: controller: SMC controller implementing SMCProtocol Raises: TypeError: If controller doesnâ€™t implement required interface ValueError: If controller configuration is invalid â€œâ€â€ # Validate controller interface if not hasattr(controller, â€˜compute_controlâ€™): raise TypeError(â€œController must implement compute_control methodâ€) if not hasattr(controller, â€˜gainsâ€™): raise TypeError(â€œController must have gains propertyâ€) self.controller = controller self._history = {} # Initialize empty history # Initialize controller-specific state variables controller_name = type(controller).<strong>name</strong> if â€˜SuperTwistingâ€™ in controller_name or â€˜STAâ€™ in controller_name: # STA-SMC maintains integration variables (z, Ïƒ) self._state_vars = (0.0, 0.0) # Initial (z=0, Ïƒ=0) elif â€˜Hybridâ€™ in controller_name: # Hybrid controller tracks adaptive gains and integration self._state_vars = ( getattr(controller, â€˜k1_initâ€™, 5.0), # k1_prev getattr(controller, â€˜k2_initâ€™, 3.0), # k2_prev 0.0 # u_int_prev ) elif â€˜Adaptiveâ€™ in controller_name: # Adaptive SMC may track adaptation state self._state_vars = getattr(controller, â€˜_initial_stateâ€™, ()) else: # Classical SMC and others use empty state self._state_vars = () # Performance tracking self._call_count = 0 self._total_compute_time = 0.0 self._last_error = None def compute_control(self, state: np.ndarray, state_vars: Optional[Any] = None, history: Optional[Dict[str, Any]] = None ) -&gt; np.ndarray: â€œâ€â€ Compute control with flexible interface supporting both: 1. Simplified PSO interface: compute_control(state) 2. Full interface: compute_control(state, state_vars, history) Mathematical Interface: Input state vector: x = [Î¸â‚, Î¸â‚‚, x_cart, Î¸Ì‡â‚, Î¸Ì‡â‚‚, áº‹_cart] - Î¸â‚, Î¸â‚‚: Pendulum angles [rad] - x_cart: Cart position [m] - Î¸Ì‡â‚, Î¸Ì‡â‚‚: Angular velocities [rad/s] - áº‹_cart: Cart velocity [m/s] Output control: u âˆˆ â„ - Scalar control force [N] - Bounded by actuator limits Args: state: System state vector (6-element numpy array) state_vars: Controller state variables (optional) history: Controller history (optional) Returns: Control output as 1-element numpy array [u] Raises: ValueError: If state has wrong dimensions RuntimeError: If control computation fails Performance: - Typical computation time: 0.01-0.1ms - Memory allocation: Minimal (output array only) - Error handling: Graceful fallback to zero control PSO Usage Pattern: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">def</span> <span class="pre">pso_fitness(gains):</span> <span class="pre">controller</span> <span class="pre">=</span> <span class="pre">create_smc_for_pso(SMCType.CLASSICAL,</span> <span class="pre">gains)</span> <span class="pre">#</span> <span class="pre">Simplified</span> <span class="pre">interface</span> <span class="pre">for</span> <span class="pre">PSO</span> <span class="pre">total_error</span> <span class="pre">=</span> <span class="pre">0.0</span> <span class="pre">for</span> <span class="pre">state</span> <span class="pre">in</span> <span class="pre">test_states:</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">controller.compute_control(state)</span> <span class="pre">#</span> <span class="pre">Returns</span> <span class="pre">[u]</span> <span class="pre">#</span> <span class="pre">Use</span> <span class="pre">u[0]</span> <span class="pre">for</span> <span class="pre">scalar</span> <span class="pre">control</span> <span class="pre">value</span> <span class="pre">total_error</span> <span class="pre">+=</span> <span class="pre">evaluate_single_step(state,</span> <span class="pre">u[0])</span> <span class="pre">return</span> <span class="pre">total_error</span> </code> State Management: The wrapper automatically manages controller state between calls: - Classical SMC: No state management needed - STA SMC: Updates integration variables (z, Ïƒ) - Adaptive SMC: Updates adaptation parameters - Hybrid SMC: Updates mode and adaptation state Error Recovery: If control computation fails: 1. Log error for debugging 2. Return safe fallback control (zero) 3. Increment error counter for monitoring 4. Continue operation (donâ€™t crash PSO) â€œâ€â€ import time # Performance tracking start_time = time.perf_counter() self._call_count += 1 try: # Input validation if not isinstance(state, np.ndarray): state = np.array(state) if state.shape != (6,): raise ValueError(fâ€State must be 6-element array, got shape {state.shape}â€) if not np.all(np.isfinite(state)): raise ValueError(â€œState contains non-finite values (NaN or inf)â€) # Use provided parameters or defaults final_state_vars = state_vars if state_vars is not None else self._state_vars final_history = history if history is not None else self._history # Call underlying controller result = self.controller.compute_control(state, final_state_vars, final_history) # Extract control value from result # Handle different controller output formats if hasattr(result, â€˜uâ€™): # Standard controller output with .u attribute control_value = result.u # Update state variables if available if hasattr(result, â€˜state_varsâ€™): self._state_vars = result.state_vars elif hasattr(result, â€˜controlâ€™): # Alternative output format with .control attribute control_value = result.control elif isinstance(result, dict): # Dictionary output format if â€˜uâ€™ in result: control_value = result[â€˜uâ€™] elif â€˜controlâ€™ in result: control_value = result[â€˜controlâ€™] else: raise ValueError(â€œDictionary result missing control valueâ€) # Update state if provided if â€˜state_varsâ€™ in result: self._state_vars = result[â€˜state_varsâ€™] elif isinstance(result, tuple): # Tuple output (e.g., early return from some controllers) control_value = result[0] # First element is control if len(result) &gt; 1: self._state_vars = result[1] # Second element is state else: # Assume result is the control value directly control_value = result # Convert to scalar if needed if isinstance(control_value, np.ndarray): if control_value.size == 1: control_value = float(control_value) else: control_value = float(control_value[0]) elif not isinstance(control_value, (int, float)): control_value = float(control_value) # Validate output if not np.isfinite(control_value): raise ValueError(â€œController returned non-finite control valueâ€) # Apply saturation (defensive programming) max_force = getattr(self.controller, â€˜max_forceâ€™, 100.0) control_saturated = np.clip(control_value, -max_force, max_force) # For simplified interface (PSO usage), return numpy array if state_vars is None and history is None: output = np.array([control_saturated]) else: # For full interface, return in format expected by simulation output = control_saturated # Performance tracking compute_time = time.perf_counter() - start_time self._total_compute_time += compute_time return output except Exception as e: # Error handling for robust PSO operation self._last_error = str(e) # Log error for debugging (in production, use proper logging) print(fâ€Warning: Control computation failed: {e}â€) # Return safe fallback control if state_vars is None and history is None: return np.array([0.0]) # PSO interface else: return 0.0 # Full interface @property def gains(self) -&gt; List[float]: â€œâ€â€ Return controller gains. Returns: List of controller gain parameters Usage: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">controller</span> <span class="pre">=</span> <span class="pre">create_smc_for_pso(SMCType.CLASSICAL,</span> <span class="pre">gains)</span> <span class="pre">print(f"Controller</span> <span class="pre">gains:</span> <span class="pre">{controller.gains}")</span> </code> â€œâ€â€ return self.controller.gains @property def performance_stats(self) -&gt; Dict[str, Any]: â€œâ€â€ Return performance statistics for monitoring. Returns: Dictionary with performance metrics: - call_count: Number of control computations - total_time: Total computation time [s] - average_time: Average computation time [ms] - last_error: Last error message (if any) Usage: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">#</span> <span class="pre">After</span> <span class="pre">PSO</span> <span class="pre">optimization</span> <span class="pre">stats</span> <span class="pre">=</span> <span class="pre">controller.performance_stats</span> <span class="pre">print(f"Average</span> <span class="pre">computation</span> <span class="pre">time:</span> <span class="pre">{stats['average_time']:.3f}ms")</span> </code> â€œâ€â€ avg_time_ms = (self._total_compute_time / self._call_count * 1000 if self._call_count &gt; 0 else 0.0) return { â€˜call_countâ€™: self._call_count, â€˜total_timeâ€™: self._total_compute_time, â€˜average_timeâ€™: avg_time_ms, â€˜last_errorâ€™: self._last_error } def reset_performance_stats(self) -&gt; None: â€œâ€â€Reset performance tracking statistics.â€â€â€ self._call_count = 0 self._total_compute_time = 0.0 self._last_error = None def validate_state_input(self, state: np.ndarray) -&gt; Tuple[bool, str]: â€œâ€â€ Validate state input for control computation. Args: state: State vector to validate Returns: Tuple of (is_valid, error_message) Usage: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">is_valid,</span> <span class="pre">error</span> <span class="pre">=</span> <span class="pre">controller.validate_state_input(test_state)</span> <span class="pre">if</span> <span class="pre">not</span> <span class="pre">is_valid:</span> <span class="pre">print(f"Invalid</span> <span class="pre">state:</span> <span class="pre">{error}")</span> </code> â€œâ€â€ try: if not isinstance(state, np.ndarray): return False, â€œState must be numpy arrayâ€ if state.shape != (6,): return False, fâ€State must be 6-element array, got {state.shape}â€ if not np.all(np.isfinite(state)): return False, â€œState contains non-finite valuesâ€ # Check reasonable ranges (optional) angles = state[:2] # Î¸â‚, Î¸â‚‚ if np.any(np.abs(angles) &gt; 2*np.pi): return False, â€œAngles exceed reasonable range (Â±2Ï€)â€ velocities = state[3:] # Î¸Ì‡â‚, Î¸Ì‡â‚‚, áº‹ if np.any(np.abs(velocities) &gt; 100): return False, â€œVelocities exceed reasonable range (Â±100)â€ return True, â€œâ€ except Exception as e: return False, fâ€Validation error: {e}â€ def <strong>repr</strong>(self) -&gt; str: â€œâ€â€String representation for debugging.â€â€â€ controller_type = type(self.controller).<strong>name</strong> return fâ€PSOControllerWrapper({controller_type}, gains={self.gains})â€</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/pso_factory_api_reference.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/pso_factory_api_reference.html#id4">runnable: false @dataclass(frozen=True)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/pso_factory_api_reference.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/pso_factory_api_reference.html#runnable-false-class-psoperformancemonitor-real-time-performance-monitoring-for-pso-factory-integration-provides-monitoring-of-pso-convergence-metrics-controller-creation-performance-simulation-execution-times-memory-usage-tracking-error-rate-monitoring-def-init-self-monitoring-config-dict-str-any-self-config-monitoring-config-self-metrics-pso-metrics-total-evaluations-0-successful-evaluations-0-failed-evaluations-0-average-fitness-0-0-best-fitness-float-inf-convergence-rate-0-0-performance-metrics-controller-creation-time-simulation-execution-time-fitness-computation-time-total-optimization-time-0-0-resource-metrics-peak-memory-usage-0-0-average-memory-usage-0-0-cpu-utilization-memory-samples-error-metrics-creation-failures-0-simulation-failures-0-validation-failures-0-total-errors-0-self-start-time-none-self-monitoring-active-false-def-start-monitoring-self-start-performance-monitoring-session-import-time-self-start-time-time-time-self-monitoring-active-true-self-reset-metrics-def-stop-monitoring-self-dict-str-any-stop-monitoring-and-return-complete-performance-report-import-time-if-self-start-time-self-metrics-performance-metrics-total-optimization-time-time-time-self-start-time-self-monitoring-active-false-return-self-generate-performance-report-def-log-controller-creation-self-success-bool-creation-time-float-log-controller-creation-event-if-not-self-monitoring-active-return-self-metrics-performance-metrics-controller-creation-time-append-creation-time-if-success-self-metrics-pso-metrics-successful-evaluations-1-else-self-metrics-error-metrics-creation-failures-1-self-metrics-pso-metrics-failed-evaluations-1-def-log-simulation-execution-self-success-bool-execution-time-float-log-simulation-execution-event-if-not-self-monitoring-active-return-if-success-self-metrics-performance-metrics-simulation-execution-time-append-execution-time-else-self-metrics-error-metrics-simulation-failures-1-def-log-fitness-evaluation-self-fitness-value-float-computation-time-float-log-fitness-evaluation-result-if-not-self-monitoring-active-return-self-metrics-performance-metrics-fitness-computation-time-append-computation-time-self-metrics-pso-metrics-total-evaluations-1-update-best-fitness-if-fitness-value-self-metrics-pso-metrics-best-fitness-self-metrics-pso-metrics-best-fitness-fitness-value-update-average-fitness-running-average-total-evals-self-metrics-pso-metrics-total-evaluations-current-avg-self-metrics-pso-metrics-average-fitness-self-metrics-pso-metrics-average-fitness-current-avg-total-evals-1-fitness-value-total-evals-def-log-resource-usage-self-log-current-resource-usage-if-not-self-monitoring-active-return-try-import-psutil-memory-usage-memory-info-psutil-virtual-memory-current-memory-memory-info-percent-self-metrics-resource-metrics-memory-samples-append-current-memory-update-peak-memory-if-current-memory-self-metrics-resource-metrics-peak-memory-usage-self-metrics-resource-metrics-peak-memory-usage-current-memory-cpu-utilization-cpu-percent-psutil-cpu-percent-interval-none-self-metrics-resource-metrics-cpu-utilization-append-cpu-percent-except-importerror-pass-psutil-not-available-def-check-performance-alerts-self-list-str-check-for-performance-issues-and-return-alerts-alerts-memory-usage-alerts-if-self-metrics-resource-metrics-peak-memory-usage-90-alerts-append-f-high-memory-usage-self-metrics-resource-metrics-peak-memory-usage-1f-error-rate-alerts-total-evals-self-metrics-pso-metrics-total-evaluations-if-total-evals-0-error-rate-self-metrics-error-metrics-total-errors-total-evals-if-error-rate-0-1-alerts-append-f-high-error-rate-error-rate-1-performance-alerts-creation-times-self-metrics-performance-metrics-controller-creation-time-if-creation-times-and-np-mean-creation-times-0-002-2ms-threshold-alerts-append-f-slow-controller-creation-np-mean-creation-times-1000-2f-ms-average-return-alerts-def-generate-performance-report-self-dict-str-any-generate-performance-report-calculate-derived-metrics-total-evals-self-metrics-pso-metrics-total-evaluations-success-rate-self-metrics-pso-metrics-successful-evaluations-total-evals-100-if-total-evals-0-else-0-creation-times-self-metrics-performance-metrics-controller-creation-time-avg-creation-time-np-mean-creation-times-if-creation-times-else-0-simulation-times-self-metrics-performance-metrics-simulation-execution-time-avg-simulation-time-np-mean-simulation-times-if-simulation-times-else-0-fitness-times-self-metrics-performance-metrics-fitness-computation-time-avg-fitness-time-np-mean-fitness-times-if-fitness-times-else-0-memory-samples-self-metrics-resource-metrics-memory-samples-avg-memory-np-mean-memory-samples-if-memory-samples-else-0-cpu-samples-self-metrics-resource-metrics-cpu-utilization-avg-cpu-np-mean-cpu-samples-if-cpu-samples-else-0-total-time-self-metrics-performance-metrics-total-optimization-time-evaluations-per-second-total-evals-total-time-if-total-time-0-else-0-generate-report-report-summary-total-evaluations-total-evals-success-rate-success-rate-best-fitness-achieved-self-metrics-pso-metrics-best-fitness-total-optimization-time-total-time-evaluations-per-second-evaluations-per-second-performance-average-controller-creation-time-ms-avg-creation-time-1000-average-simulation-time-ms-avg-simulation-time-1000-average-fitness-computation-time-ms-avg-fitness-time-1000-resources-peak-memory-usage-percent-self-metrics-resource-metrics-peak-memory-usage-average-memory-usage-percent-avg-memory-average-cpu-utilization-percent-avg-cpu-errors-controller-creation-failures-self-metrics-error-metrics-creation-failures-simulation-failures-self-metrics-error-metrics-simulation-failures-validation-failures-self-metrics-error-metrics-validation-failures-total-error-count-self-metrics-error-metrics-total-errors-alerts-self-check-performance-alerts-raw-metrics-self-metrics-return-report-def-reset-metrics-self-reset-all-metrics-for-new-monitoring-session-for-category-in-self-metrics-values-if-isinstance-category-dict-for-key-value-in-category-items-if-isinstance-value-list-category-key-elif-isinstance-value-int-float-if-best-fitness-in-key-category-key-float-inf-else-category-key-0-context-manager-for-automatic-monitoring">runnable: false class PSOPerformanceMonitor: â€œâ€â€ Real-time performance monitoring for PSO-Factory integration. Provides monitoring of: - PSO convergence metrics - Controller creation performance - Simulation execution times - Memory usage tracking - Error rate monitoring â€œâ€â€ def <strong>init</strong>(self, monitoring_config: Dict[str, Any]): self.config = monitoring_config self.metrics = { â€˜pso_metricsâ€™: { â€˜total_evaluationsâ€™: 0, â€˜successful_evaluationsâ€™: 0, â€˜failed_evaluationsâ€™: 0, â€˜average_fitnessâ€™: 0.0, â€˜best_fitnessâ€™: float(â€˜infâ€™), â€˜convergence_rateâ€™: 0.0 }, â€˜performance_metricsâ€™: { â€˜controller_creation_timeâ€™: [], â€˜simulation_execution_timeâ€™: [], â€˜fitness_computation_timeâ€™: [], â€˜total_optimization_timeâ€™: 0.0 }, â€˜resource_metricsâ€™: { â€˜peak_memory_usageâ€™: 0.0, â€˜average_memory_usageâ€™: 0.0, â€˜cpu_utilizationâ€™: [], â€˜memory_samplesâ€™: [] }, â€˜error_metricsâ€™: { â€˜creation_failuresâ€™: 0, â€˜simulation_failuresâ€™: 0, â€˜validation_failuresâ€™: 0, â€˜total_errorsâ€™: 0 } } self.start_time = None self.monitoring_active = False def start_monitoring(self): â€œâ€â€Start performance monitoring session.â€â€â€ import time self.start_time = time.time() self.monitoring_active = True self._reset_metrics() def stop_monitoring(self) -&gt; Dict[str, Any]: â€œâ€â€Stop monitoring and return complete performance report.â€â€â€ import time if self.start_time: self.metrics[â€˜performance_metricsâ€™][â€˜total_optimization_timeâ€™] = ( time.time() - self.start_time ) self.monitoring_active = False return self.generate_performance_report() def log_controller_creation(self, success: bool, creation_time: float): â€œâ€â€Log controller creation event.â€â€â€ if not self.monitoring_active: return self.metrics[â€˜performance_metricsâ€™][â€˜controller_creation_timeâ€™].append(creation_time) if success: self.metrics[â€˜pso_metricsâ€™][â€˜successful_evaluationsâ€™] += 1 else: self.metrics[â€˜error_metricsâ€™][â€˜creation_failuresâ€™] += 1 self.metrics[â€˜pso_metricsâ€™][â€˜failed_evaluationsâ€™] += 1 def log_simulation_execution(self, success: bool, execution_time: float): â€œâ€â€Log simulation execution event.â€â€â€ if not self.monitoring_active: return if success: self.metrics[â€˜performance_metricsâ€™][â€˜simulation_execution_timeâ€™].append(execution_time) else: self.metrics[â€˜error_metricsâ€™][â€˜simulation_failuresâ€™] += 1 def log_fitness_evaluation(self, fitness_value: float, computation_time: float): â€œâ€â€Log fitness evaluation result.â€â€â€ if not self.monitoring_active: return self.metrics[â€˜performance_metricsâ€™][â€˜fitness_computation_timeâ€™].append(computation_time) self.metrics[â€˜pso_metricsâ€™][â€˜total_evaluationsâ€™] += 1 # Update best fitness if fitness_value &lt; self.metrics[â€˜pso_metricsâ€™][â€˜best_fitnessâ€™]: self.metrics[â€˜pso_metricsâ€™][â€˜best_fitnessâ€™] = fitness_value # Update average fitness (running average) total_evals = self.metrics[â€˜pso_metricsâ€™][â€˜total_evaluationsâ€™] current_avg = self.metrics[â€˜pso_metricsâ€™][â€˜average_fitnessâ€™] self.metrics[â€˜pso_metricsâ€™][â€˜average_fitnessâ€™] = ( (current_avg * (total_evals - 1) + fitness_value) / total_evals ) def log_resource_usage(self): â€œâ€â€Log current resource usage.â€â€â€ if not self.monitoring_active: return try: import psutil # Memory usage memory_info = psutil.virtual_memory() current_memory = memory_info.percent self.metrics[â€˜resource_metricsâ€™][â€˜memory_samplesâ€™].append(current_memory) # Update peak memory if current_memory &gt; self.metrics[â€˜resource_metricsâ€™][â€˜peak_memory_usageâ€™]: self.metrics[â€˜resource_metricsâ€™][â€˜peak_memory_usageâ€™] = current_memory # CPU utilization cpu_percent = psutil.cpu_percent(interval=None) self.metrics[â€˜resource_metricsâ€™][â€˜cpu_utilizationâ€™].append(cpu_percent) except ImportError: pass # psutil not available def check_performance_alerts(self) -&gt; List[str]: â€œâ€â€Check for performance issues and return alerts.â€â€â€ alerts = [] # Memory usage alerts if self.metrics[â€˜resource_metricsâ€™][â€˜peak_memory_usageâ€™] &gt; 90: alerts.append(fâ€High memory usage: {self.metrics[â€˜resource_metricsâ€™][â€˜peak_memory_usageâ€™]:.1f}%â€) # Error rate alerts total_evals = self.metrics[â€˜pso_metricsâ€™][â€˜total_evaluationsâ€™] if total_evals &gt; 0: error_rate = self.metrics[â€˜error_metricsâ€™][â€˜total_errorsâ€™] / total_evals if error_rate &gt; 0.1: alerts.append(fâ€High error rate: {error_rate:.1%}â€) # Performance alerts creation_times = self.metrics[â€˜performance_metricsâ€™][â€˜controller_creation_timeâ€™] if creation_times and np.mean(creation_times) &gt; 0.002: # 2ms threshold alerts.append(fâ€Slow controller creation: {np.mean(creation_times)*1000:.2f}ms averageâ€) return alerts def generate_performance_report(self) -&gt; Dict[str, Any]: â€œâ€â€Generate performance report.â€â€â€ # Calculate derived metrics total_evals = self.metrics[â€˜pso_metricsâ€™][â€˜total_evaluationsâ€™] success_rate = (self.metrics[â€˜pso_metricsâ€™][â€˜successful_evaluationsâ€™] / total_evals * 100 if total_evals &gt; 0 else 0) creation_times = self.metrics[â€˜performance_metricsâ€™][â€˜controller_creation_timeâ€™] avg_creation_time = np.mean(creation_times) if creation_times else 0 simulation_times = self.metrics[â€˜performance_metricsâ€™][â€˜simulation_execution_timeâ€™] avg_simulation_time = np.mean(simulation_times) if simulation_times else 0 fitness_times = self.metrics[â€˜performance_metricsâ€™][â€˜fitness_computation_timeâ€™] avg_fitness_time = np.mean(fitness_times) if fitness_times else 0 memory_samples = self.metrics[â€˜resource_metricsâ€™][â€˜memory_samplesâ€™] avg_memory = np.mean(memory_samples) if memory_samples else 0 cpu_samples = self.metrics[â€˜resource_metricsâ€™][â€˜cpu_utilizationâ€™] avg_cpu = np.mean(cpu_samples) if cpu_samples else 0 total_time = self.metrics[â€˜performance_metricsâ€™][â€˜total_optimization_timeâ€™] evaluations_per_second = total_evals / total_time if total_time &gt; 0 else 0 # Generate report report = { â€˜summaryâ€™: { â€˜total_evaluationsâ€™: total_evals, â€˜success_rateâ€™: success_rate, â€˜best_fitness_achievedâ€™: self.metrics[â€˜pso_metricsâ€™][â€˜best_fitnessâ€™], â€˜total_optimization_timeâ€™: total_time, â€˜evaluations_per_secondâ€™: evaluations_per_second }, â€˜performanceâ€™: { â€˜average_controller_creation_time_msâ€™: avg_creation_time * 1000, â€˜average_simulation_time_msâ€™: avg_simulation_time * 1000, â€˜average_fitness_computation_time_msâ€™: avg_fitness_time * 1000 }, â€˜resourcesâ€™: { â€˜peak_memory_usage_percentâ€™: self.metrics[â€˜resource_metricsâ€™][â€˜peak_memory_usageâ€™], â€˜average_memory_usage_percentâ€™: avg_memory, â€˜average_cpu_utilization_percentâ€™: avg_cpu }, â€˜errorsâ€™: { â€˜controller_creation_failuresâ€™: self.metrics[â€˜error_metricsâ€™][â€˜creation_failuresâ€™], â€˜simulation_failuresâ€™: self.metrics[â€˜error_metricsâ€™][â€˜simulation_failuresâ€™], â€˜validation_failuresâ€™: self.metrics[â€˜error_metricsâ€™][â€˜validation_failuresâ€™], â€˜total_error_countâ€™: self.metrics[â€˜error_metricsâ€™][â€˜total_errorsâ€™] }, â€˜alertsâ€™: self.check_performance_alerts(), â€˜raw_metricsâ€™: self.metrics } return report def _reset_metrics(self): â€œâ€â€Reset all metrics for new monitoring session.â€â€â€ for category in self.metrics.values(): if isinstance(category, dict): for key, value in category.items(): if isinstance(value, list): category[key] = [] elif isinstance(value, (int, float)): if â€˜best_fitnessâ€™ in key: category[key] = float(â€˜infâ€™) else: category[key] = 0 # Context manager for automatic monitoring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/pso_factory_api_reference.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/pso_factory_api_reference.html#runnable-false-def-complete-pso-optimization-example-complete-example-demonstrating-pso-factory-integration-this-example-shows-1-configuration-setup-2-controller-creation-and-validation-3-pso-optimization-execution-4-performance-monitoring-5-results-analysis-and-validation-step-1-configuration-setup-pso-config-psofactoryconfig-controller-type-smctype-classical-max-force-100-0-dt-0-01-pso-params-n-particles-30-iters-100-c1-2-0-c2-2-0-w-0-9-enable-monitoring-true-strict-validation-true-step-2-simulation-configuration-simulation-config-duration-5-0-dt-0-01-initial-state-0-1-0-1-0-0-0-0-0-0-0-0-small-perturbation-disturbances-enable-true-amplitude-5-0-frequency-1-0-performance-objectives-ise-overshoot-control-effort-step-3-pso-optimization-with-monitoring-with-monitor-pso-performance-pso-config-pso-params-as-monitor-define-fitness-function-handle-pso-errors-def-fitness-function-particles-np-ndarray-np-ndarray-fitness-scores-for-gains-in-particles-start-time-time-perf-counter-try-create-controller-with-validation-controller-create-smc-for-pso-pso-config-controller-type-gains-tolist-pso-config-max-force-creation-time-time-perf-counter-start-time-monitor-log-controller-creation-true-creation-time-run-simulation-sim-start-time-perf-counter-result-run-simulation-controller-simulation-config-sim-time-time-perf-counter-sim-start-monitor-log-simulation-execution-true-sim-time-compute-fitness-fitness-start-time-perf-counter-fitness-compute-multi-objective-fitness-result-simulation-config-performance-objectives-fitness-time-time-perf-counter-fitness-start-monitor-log-fitness-evaluation-fitness-fitness-time-fitness-scores-append-fitness-except-exception-as-e-monitor-log-controller-creation-false-0-0-fitness-scores-append-1000-0-log-resource-usage-periodically-if-len-fitness-scores-10-0-monitor-log-resource-usage-return-np-array-fitness-scores-step-4-execute-pso-optimization-from-pyswarms-single-import-globalbestpso-bounds-pso-config-gain-bounds-bounds-array-np-array-bounds-optimizer-globalbestpso-n-particles-pso-config-pso-params-n-particles-dimensions-pso-config-n-gains-options-c1-pso-config-pso-params-c1-c2-pso-config-pso-params-c2-w-pso-config-pso-params-w-bounds-bounds-array-0-bounds-array-1-print-starting-pso-optimization-best-cost-best-gains-optimizer-optimize-fitness-function-iters-pso-config-pso-params-iters-verbose-true-step-5-results-analysis-performance-report-monitor-generate-performance-report-validate-optimized-controller-optimized-controller-create-smc-for-pso-pso-config-controller-type-best-gains-tolist-pso-config-max-force-run-validation-simulation-validation-result-run-simulation-optimized-controller-simulation-config-validation-metrics-compute-validation-metrics-validation-result-step-6-generate-report-optimization-report-optimization-results-best-gains-best-gains-tolist-best-fitness-float-best-cost-optimization-history-optimizer-cost-history-convergence-iteration-find-convergence-iteration-optimizer-cost-history-validation-results-controller-gains-optimized-controller-gains-performance-metrics-validation-metrics-stability-analysis-estimate-stability-properties-pso-config-controller-type-best-gains-tolist-performance-report-performance-report-configuration-pso-config-pso-config-dict-simulation-config-simulation-config-bounds-used-bounds-step-7-display-results-print-optimization-summary-optimization-report-return-optimization-report-def-print-optimization-summary-report-dict-str-any-print-formatted-optimization-summary-opt-results-report-optimization-results-val-results-report-validation-results-perf-report-report-performance-report-print-n-80-print-pso-optimization-results-summary-print-80-print-f-n-optimization-results-print-f-best-fitness-opt-results-best-fitness-6f-print-f-best-gains-opt-results-best-gains-print-f-convergence-iteration-opt-results-convergence-iteration-print-f-n-validation-metrics-for-metric-value-in-val-results-performance-metrics-items-print-f-metric-upper-value-4f-print-f-n-performance-summary-summary-perf-report-summary-print-f-total-evaluations-summary-total-evaluations-print-f-success-rate-summary-success-rate-1f-print-f-evaluations-sec-summary-evaluations-per-second-1f-print-f-total-time-summary-total-optimization-time-1f-s-perf-perf-report-performance-print-f-avg-creation-time-perf-average-controller-creation-time-ms-2f-ms-print-f-avg-simulation-time-perf-average-simulation-time-ms-2f-ms-resources-perf-report-resources-print-f-peak-memory-resources-peak-memory-usage-percent-1f-print-f-avg-cpu-resources-average-cpu-utilization-percent-1f-if-perf-report-alerts-print-f-n-performance-alerts-for-alert-in-perf-report-alerts-print-f-alert-print-n-80-def-find-convergence-iteration-cost-history-list-float-tolerance-float-1e-6-patience-int-10-int-find-iteration-where-pso-converged-if-len-cost-history-patience-return-len-cost-history-for-i-in-range-patience-len-cost-history-check-if-fitness-has-been-stable-for-patience-iterations-recent-costs-cost-history-i-patience-i-if-max-recent-costs-min-recent-costs-tolerance-return-i-patience-1-return-len-cost-history-no-convergence-detected-run-the-complete-example">runnable: false def complete_pso_optimization_example(): â€œâ€â€ Complete example demonstrating PSO-Factory integration. This example shows: 1. Configuration setup 2. Controller creation and validation 3. PSO optimization execution 4. Performance monitoring 5. Results analysis and validation â€œâ€â€ # Step 1: Configuration setup pso_config = PSOFactoryConfig( controller_type=SMCType.CLASSICAL, max_force=100.0, dt=0.01, pso_params={ â€˜n_particlesâ€™: 30, â€˜itersâ€™: 100, â€˜c1â€™: 2.0, â€˜c2â€™: 2.0, â€˜wâ€™: 0.9 }, enable_monitoring=True, strict_validation=True ) # Step 2: Simulation configuration simulation_config = { â€˜durationâ€™: 5.0, â€˜dtâ€™: 0.01, â€˜initial_stateâ€™: [0.1, 0.1, 0.0, 0.0, 0.0, 0.0], # Small perturbation â€˜disturbancesâ€™: { â€˜enableâ€™: True, â€˜amplitudeâ€™: 5.0, â€˜frequencyâ€™: 1.0 }, â€˜performance_objectivesâ€™: [â€˜iseâ€™, â€˜overshootâ€™, â€˜control_effortâ€™] } # Step 3: PSO optimization with monitoring with monitor_pso_performance(pso_config.pso_params) as monitor: # Define fitness function @handle_pso_errors def fitness_function(particles: np.ndarray) -&gt; np.ndarray: fitness_scores = [] for gains in particles: start_time = time.perf_counter() try: # Create controller with validation controller = create_smc_for_pso( pso_config.controller_type, gains.tolist(), pso_config.max_force ) creation_time = time.perf_counter() - start_time monitor.log_controller_creation(True, creation_time) # Run simulation sim_start = time.perf_counter() result = run_simulation(controller, simulation_config) sim_time = time.perf_counter() - sim_start monitor.log_simulation_execution(True, sim_time) # Compute fitness fitness_start = time.perf_counter() fitness = compute_multi_objective_fitness( result, simulation_config[â€˜performance_objectivesâ€™] ) fitness_time = time.perf_counter() - fitness_start monitor.log_fitness_evaluation(fitness, fitness_time) fitness_scores.append(fitness) except Exception as e: monitor.log_controller_creation(False, 0.0) fitness_scores.append(1000.0) # Log resource usage periodically if len(fitness_scores) % 10 == 0: monitor.log_resource_usage() return np.array(fitness_scores) # Step 4: Execute PSO optimization from pyswarms.single import GlobalBestPSO bounds = pso_config.gain_bounds bounds_array = np.array(bounds) optimizer = GlobalBestPSO( n_particles=pso_config.pso_params[â€˜n_particlesâ€™], dimensions=pso_config.n_gains, options={ â€˜c1â€™: pso_config.pso_params[â€˜c1â€™], â€˜c2â€™: pso_config.pso_params[â€˜c2â€™], â€˜wâ€™: pso_config.pso_params[â€˜wâ€™] }, bounds=(bounds_array[:, 0], bounds_array[:, 1]) ) print(â€œStarting PSO optimizationâ€¦â€) best_cost, best_gains = optimizer.optimize( fitness_function, iters=pso_config.pso_params[â€˜itersâ€™], verbose=True ) # Step 5: Results analysis performance_report = monitor.generate_performance_report() # Validate optimized controller optimized_controller = create_smc_for_pso( pso_config.controller_type, best_gains.tolist(), pso_config.max_force ) # Run validation simulation validation_result = run_simulation(optimized_controller, simulation_config) validation_metrics = compute_validation_metrics(validation_result) # Step 6: Generate report optimization_report = { â€˜optimization_resultsâ€™: { â€˜best_gainsâ€™: best_gains.tolist(), â€˜best_fitnessâ€™: float(best_cost), â€˜optimization_historyâ€™: optimizer.cost_history, â€˜convergence_iterationâ€™: find_convergence_iteration(optimizer.cost_history) }, â€˜validation_resultsâ€™: { â€˜controller_gainsâ€™: optimized_controller.gains, â€˜performance_metricsâ€™: validation_metrics, â€˜stability_analysisâ€™: estimate_stability_properties( pso_config.controller_type, best_gains.tolist() ) }, â€˜performance_reportâ€™: performance_report, â€˜configurationâ€™: { â€˜pso_configâ€™: pso_config.<strong>dict</strong>, â€˜simulation_configâ€™: simulation_config, â€˜bounds_usedâ€™: bounds } } # Step 7: Display results print_optimization_summary(optimization_report) return optimization_report def print_optimization_summary(report: Dict[str, Any]): â€œâ€â€Print formatted optimization summary.â€â€â€ opt_results = report[â€˜optimization_resultsâ€™] val_results = report[â€˜validation_resultsâ€™] perf_report = report[â€˜performance_reportâ€™] print(â€œ\nâ€ + â€œ=â€*80) print(â€œPSO OPTIMIZATION RESULTS SUMMARYâ€) print(â€œ=â€*80) print(fâ€\nğŸ“Š OPTIMIZATION RESULTS:â€) print(fâ€ Best Fitness: {opt_results[â€˜best_fitnessâ€™]:.6f}â€) print(fâ€ Best Gains: {opt_results[â€˜best_gainsâ€™]}â€) print(fâ€ Convergence: Iteration {opt_results[â€˜convergence_iterationâ€™]}â€) print(fâ€\nğŸ¯ VALIDATION METRICS:â€) for metric, value in val_results[â€˜performance_metricsâ€™].items(): print(fâ€ {metric.upper()}: {value:.4f}â€) print(fâ€\nâš¡ PERFORMANCE SUMMARY:â€) summary = perf_report[â€˜summaryâ€™] print(fâ€ Total Evaluations: {summary[â€˜total_evaluationsâ€™]}â€) print(fâ€ Success Rate: {summary[â€˜success_rateâ€™]:.1f}%â€) print(fâ€ Evaluations/sec: {summary[â€˜evaluations_per_secondâ€™]:.1f}â€) print(fâ€ Total Time: {summary[â€˜total_optimization_timeâ€™]:.1f}sâ€) perf = perf_report[â€˜performanceâ€™] print(fâ€ Avg Creation Time: {perf[â€˜average_controller_creation_time_msâ€™]:.2f}msâ€) print(fâ€ Avg Simulation Time: {perf[â€˜average_simulation_time_msâ€™]:.2f}msâ€) resources = perf_report[â€˜resourcesâ€™] print(fâ€ Peak Memory: {resources[â€˜peak_memory_usage_percentâ€™]:.1f}%â€) print(fâ€ Avg CPU: {resources[â€˜average_cpu_utilization_percentâ€™]:.1f}%â€) if perf_report[â€˜alertsâ€™]: print(fâ€\nâš ï¸ PERFORMANCE ALERTS:â€) for alert in perf_report[â€˜alertsâ€™]: print(fâ€ - {alert}â€) print(â€œ\nâ€ + â€œ=â€*80) def find_convergence_iteration(cost_history: List[float], tolerance: float = 1e-6, patience: int = 10 ) -&gt; int: â€œâ€â€Find iteration where PSO converged.â€â€â€ if len(cost_history) &lt; patience: return len(cost_history) for i in range(patience, len(cost_history)): # Check if fitness has been stable for â€˜patienceâ€™ iterations recent_costs = cost_history[i-patience:i] if max(recent_costs) - min(recent_costs) &lt; tolerance: return i - patience + 1 return len(cost_history) # No convergence detected # Run the complete example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/pso_integration_workflow.html">PSO Integration Workflow and Best Practices ## Overview This document provides guidance for integrating the SMC Controller Factory with Particle Swarm Optimization (PSO) workflows. The integration enables automated controller parameter tuning while maintaining factory validation, thread safety, and performance requirements. ## PSO Integration Architecture ### High-Level PSO-Factory Integration Flow ```</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/pso_integration_workflow.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/pso_integration_workflow.html#runnable-false-class-psofactoryinterface-specialized-interface-for-pso-optimization-integration-features-vectorized-controller-creation-for-swarm-populations-automatic-parameter-validation-and-bounds-checking-performance-optimized-fitness-evaluation-thread-safe-parallel-optimization-support-def-init-self-controller-type-str-plant-config-any-self-controller-type-controller-type-self-plant-config-plant-config-self-setup-optimization-environment-def-setup-optimization-environment-self-none-initialize-pso-optimization-environment-get-controller-specifications-self-gain-spec-smc-gain-specs-smctype-self-controller-type-self-n-gains-self-gain-spec-n-gains-self-bounds-self-gain-spec-gain-bounds-performance-monitoring-self-evaluation-count-0-self-successful-evaluations-0-self-failed-evaluations-0-thread-safe-operations-self-lock-threading-rlock-def-create-pso-controller-factory-self-callable-gainsarray-psocontrollerwrapper-create-pso-optimized-controller-factory-function-returns-factory-function-that-takes-gains-and-returns-pso-wrapped-controller-def-controller-factory-gains-gainsarray-psocontrollerwrapper-pso-controller-factory-with-validation-with-self-lock-self-evaluation-count-1-try-validate-gains-if-not-self-validate-pso-gains-gains-self-failed-evaluations-1-return-self-create-fallback-controller-gains-create-controller-via-factory-controller-create-controller-controller-type-self-controller-type-config-self-plant-config-gains-gains-wrap-for-pso-optimization-wrapper-psocontrollerwrapper-controller-controller-controller-type-self-controller-type-validation-enabled-true-add-pso-required-attributes-wrapper-n-gains-self-n-gains-wrapper-controller-type-self-controller-type-wrapper-max-force-getattr-controller-max-force-150-0-self-successful-evaluations-1-return-wrapper-except-exception-as-e-logger-warning-f-pso-controller-creation-failed-e-self-failed-evaluations-1-return-self-create-fallback-controller-gains-add-pso-required-attributes-to-factory-function-controller-factory-n-gains-self-n-gains-controller-factory-controller-type-self-controller-type-controller-factory-bounds-self-bounds-controller-factory-max-force-150-0-return-controller-factory-def-validate-pso-gains-self-gains-gainsarray-bool-validate-gains-for-pso-optimization-try-gains-array-np-asarray-gains-check-dimensions-if-len-gains-array-self-n-gains-return-false-check-bounds-for-i-gain-min-val-max-val-in-enumerate-zip-gains-array-self-bounds-if-not-min-val-gain-max-val-return-false-check-numerical-validity-if-not-np-all-np-isfinite-gains-array-return-false-controller-specific-validation-return-validate-smc-gains-smctype-self-controller-type-gains-array-except-exception-return-false-def-create-fallback-controller-self-gains-gainsarray-psocontrollerwrapper-create-fallback-controller-for-invalid-parameters-use-default-gains-as-fallback-default-gains-get-default-gains-self-controller-type-try-controller-create-controller-controller-type-self-controller-type-config-self-plant-config-gains-default-gains-wrapper-psocontrollerwrapper-controller-controller-controller-type-self-controller-type-validation-enabled-false-disable-validation-for-fallback-wrapper-n-gains-self-n-gains-wrapper-controller-type-self-controller-type-wrapper-is-fallback-true-return-wrapper-except-exception-emergency-fallback-return-minimal-controller-return-self-create-emergency-fallback-def-get-optimization-statistics-self-dict-str-any-get-pso-optimization-statistics-with-self-lock-success-rate-self-successful-evaluations-max-1-self-evaluation-count-return-total-evaluations-self-evaluation-count-successful-evaluations-self-successful-evaluations-failed-evaluations-self-failed-evaluations-success-rate-success-rate-optimization-health-good-if-success-rate-0-8-else-warning-if-success-rate-0-5-else-poor">runnable: false class PSOFactoryInterface: â€œâ€â€ Specialized interface for PSO optimization integration. Features: - Vectorized controller creation for swarm populations - Automatic parameter validation and bounds checking - Performance-optimized fitness evaluation - Thread-safe parallel optimization support â€œâ€â€ def <strong>init</strong>(self, controller_type: str, plant_config: Any): self.controller_type = controller_type self.plant_config = plant_config self._setup_optimization_environment() def _setup_optimization_environment(self) -&gt; None: â€œâ€â€Initialize PSO optimization environment.â€â€â€ # Get controller specifications self.gain_spec = SMC_GAIN_SPECS[SMCType(self.controller_type)] self.n_gains = self.gain_spec.n_gains self.bounds = self.gain_spec.gain_bounds # Performance monitoring self.evaluation_count = 0 self.successful_evaluations = 0 self.failed_evaluations = 0 # Thread-safe operations self._lock = threading.RLock() def create_pso_controller_factory(self) -&gt; Callable[[GainsArray], PSOControllerWrapper]: â€œâ€â€ Create PSO-optimized controller factory function. Returns: Factory function that takes gains and returns PSO-wrapped controller â€œâ€â€ def controller_factory(gains: GainsArray) -&gt; PSOControllerWrapper: â€œâ€â€PSO controller factory with validation.â€â€â€ with self._lock: self.evaluation_count += 1 try: # Validate gains if not self._validate_pso_gains(gains): self.failed_evaluations += 1 return self._create_fallback_controller(gains) # Create controller via factory controller = create_controller( controller_type=self.controller_type, config=self.plant_config, gains=gains ) # Wrap for PSO optimization wrapper = PSOControllerWrapper( controller=controller, controller_type=self.controller_type, validation_enabled=True ) # Add PSO-required attributes wrapper.n_gains = self.n_gains wrapper.controller_type = self.controller_type wrapper.max_force = getattr(controller, â€˜max_forceâ€™, 150.0) self.successful_evaluations += 1 return wrapper except Exception as e: logger.warning(fâ€PSO controller creation failed: {e}â€) self.failed_evaluations += 1 return self._create_fallback_controller(gains) # Add PSO-required attributes to factory function controller_factory.n_gains = self.n_gains controller_factory.controller_type = self.controller_type controller_factory.bounds = self.bounds controller_factory.max_force = 150.0 return controller_factory def _validate_pso_gains(self, gains: GainsArray) -&gt; bool: â€œâ€â€Validate gains for PSO optimization.â€â€â€ try: gains_array = np.asarray(gains) # Check dimensions if len(gains_array) != self.n_gains: return False # Check bounds for i, (gain, (min_val, max_val)) in enumerate(zip(gains_array, self.bounds)): if not (min_val &lt;= gain &lt;= max_val): return False # Check numerical validity if not np.all(np.isfinite(gains_array)): return False # Controller-specific validation return validate_smc_gains(SMCType(self.controller_type), gains_array) except Exception: return False def _create_fallback_controller(self, gains: GainsArray) -&gt; PSOControllerWrapper: â€œâ€â€Create fallback controller for invalid parameters.â€â€â€ # Use default gains as fallback default_gains = get_default_gains(self.controller_type) try: controller = create_controller( controller_type=self.controller_type, config=self.plant_config, gains=default_gains ) wrapper = PSOControllerWrapper( controller=controller, controller_type=self.controller_type, validation_enabled=False # Disable validation for fallback ) wrapper.n_gains = self.n_gains wrapper.controller_type = self.controller_type wrapper.is_fallback = True return wrapper except Exception: # Emergency fallback - return minimal controller return self._create_emergency_fallback() def get_optimization_statistics(self) -&gt; Dict[str, Any]: â€œâ€â€Get PSO optimization statistics.â€â€â€ with self._lock: success_rate = self.successful_evaluations / max(1, self.evaluation_count) return { â€˜total_evaluationsâ€™: self.evaluation_count, â€˜successful_evaluationsâ€™: self.successful_evaluations, â€˜failed_evaluationsâ€™: self.failed_evaluations, â€˜success_rateâ€™: success_rate, â€˜optimization_healthâ€™: â€˜GOODâ€™ if success_rate &gt; 0.8 else â€˜WARNINGâ€™ if success_rate &gt; 0.5 else â€˜POORâ€™ }</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/pso_integration_workflow.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/pso_integration_workflow.html#runnable-false-class-parallelpsoevaluator-thread-safe-parallel-evaluation-system-for-pso-optimization-features-multi-threaded-fitness-evaluation-load-balancing-across-cpu-cores-memory-efficient-swarm-processing-progress-monitoring-and-early-termination-def-init-self-controller-factory-callable-fitness-function-callable-n-threads-int-4-batch-size-int-8-self-controller-factory-controller-factory-self-fitness-function-fitness-function-self-n-threads-n-threads-self-batch-size-batch-size-thread-management-self-thread-pool-threadpoolexecutor-max-workers-n-threads-self-evaluation-lock-threading-rlock-performance-monitoring-self-evaluation-times-self-success-count-0-self-failure-count-0-def-evaluate-swarm-parallel-self-swarm-positions-np-ndarray-timeout-seconds-float-30-0-list-float-evaluate-entire-swarm-in-parallel-with-timeout-protection-args-swarm-positions-array-of-shape-swarm-size-n-dimensions-timeout-seconds-maximum-time-for-evaluation-returns-list-of-fitness-values-for-each-particle-swarm-size-swarm-positions-shape-0-fitness-values-float-inf-swarm-size-submit-evaluation-tasks-future-to-index-for-i-in-range-swarm-size-future-self-thread-pool-submit-self-evaluate-particle-safe-swarm-positions-i-i-future-to-index-future-i-collect-results-with-timeout-completed-count-0-start-time-time-time-for-future-in-as-completed-future-to-index-timeout-timeout-seconds-try-particle-index-future-to-index-future-fitness-value-future-result-timeout-1-0-individual-timeout-fitness-values-particle-index-fitness-value-with-self-evaluation-lock-self-success-count-1-completed-count-1-except-exception-as-e-particle-index-future-to-index-future-logger-warning-f-particle-particle-index-evaluation-failed-e-with-self-evaluation-lock-self-failure-count-1-use-penalty-value-for-failed-evaluations-fitness-values-particle-index-5000-0-check-for-timeout-if-time-time-start-time-timeout-seconds-logger-warning-f-swarm-evaluation-timeout-after-timeout-seconds-s-break-cancel-remaining-futures-for-future-in-future-to-index-if-not-future-done-future-cancel-return-fitness-values-def-evaluate-particle-safe-self-gains-gainsarray-particle-index-int-float-thread-safe-particle-evaluation-with-error-handling-start-time-time-time-try-create-controller-controller-self-controller-factory-gains-evaluate-fitness-fitness-value-self-fitness-function-gains-controller-record-evaluation-time-evaluation-time-time-time-start-time-with-self-evaluation-lock-self-evaluation-times-append-evaluation-time-return-fitness-value-except-exception-as-e-logger-warning-f-particle-particle-index-failed-e-return-3000-0-high-penalty-for-failures-def-get-evaluation-statistics-self-dict-str-any-get-parallel-evaluation-performance-statistics-with-self-evaluation-lock-total-evaluations-self-success-count-self-failure-count-success-rate-self-success-count-max-1-total-evaluations-avg-time-np-mean-self-evaluation-times-if-self-evaluation-times-else-0-0-max-time-np-max-self-evaluation-times-if-self-evaluation-times-else-0-0-return-total-evaluations-total-evaluations-success-count-self-success-count-failure-count-self-failure-count-success-rate-success-rate-avg-evaluation-time-avg-time-max-evaluation-time-max-time-total-evaluation-time-sum-self-evaluation-times-parallel-efficiency-avg-time-self-n-threads-max-max-time-0-001-def-cleanup-self-clean-up-thread-pool-resources-self-thread-pool-shutdown-wait-true">runnable: false class ParallelPSOEvaluator: â€œâ€â€ Thread-safe parallel evaluation system for PSO optimization. Features: - Multi-threaded fitness evaluation - Load balancing across CPU cores - Memory-efficient swarm processing - Progress monitoring and early termination â€œâ€â€ def <strong>init</strong>( self, controller_factory: Callable, fitness_function: Callable, n_threads: int = 4, batch_size: int = 8 ): self.controller_factory = controller_factory self.fitness_function = fitness_function self.n_threads = n_threads self.batch_size = batch_size # Thread management self.thread_pool = ThreadPoolExecutor(max_workers=n_threads) self.evaluation_lock = threading.RLock() # Performance monitoring self.evaluation_times = [] self.success_count = 0 self.failure_count = 0 def evaluate_swarm_parallel( self, swarm_positions: np.ndarray, timeout_seconds: float = 30.0 ) -&gt; List[float]: â€œâ€â€ Evaluate entire swarm in parallel with timeout protection. Args: swarm_positions: Array of shape (swarm_size, n_dimensions) timeout_seconds: Maximum time for evaluation Returns: List of fitness values for each particle â€œâ€â€ swarm_size = swarm_positions.shape[0] fitness_values = [float(â€˜infâ€™)] * swarm_size # Submit evaluation tasks future_to_index = {} for i in range(swarm_size): future = self.thread_pool.submit( self._evaluate_particle_safe, swarm_positions[i], i ) future_to_index[future] = i # Collect results with timeout completed_count = 0 start_time = time.time() for future in as_completed(future_to_index, timeout=timeout_seconds): try: particle_index = future_to_index[future] fitness_value = future.result(timeout=1.0) # Individual timeout fitness_values[particle_index] = fitness_value with self.evaluation_lock: self.success_count += 1 completed_count += 1 except Exception as e: particle_index = future_to_index[future] logger.warning(fâ€Particle {particle_index} evaluation failed: {e}â€) with self.evaluation_lock: self.failure_count += 1 # Use penalty value for failed evaluations fitness_values[particle_index] = 5000.0 # Check for timeout if time.time() - start_time &gt; timeout_seconds: logger.warning(fâ€Swarm evaluation timeout after {timeout_seconds}sâ€) break # Cancel remaining futures for future in future_to_index: if not future.done(): future.cancel() return fitness_values def _evaluate_particle_safe(self, gains: GainsArray, particle_index: int) -&gt; float: â€œâ€â€Thread-safe particle evaluation with error handling.â€â€â€ start_time = time.time() try: # Create controller controller = self.controller_factory(gains) # Evaluate fitness fitness_value = self.fitness_function(gains, controller) # Record evaluation time evaluation_time = time.time() - start_time with self.evaluation_lock: self.evaluation_times.append(evaluation_time) return fitness_value except Exception as e: logger.warning(fâ€Particle {particle_index} failed: {e}â€) return 3000.0 # High penalty for failures def get_evaluation_statistics(self) -&gt; Dict[str, Any]: â€œâ€â€Get parallel evaluation performance statistics.â€â€â€ with self.evaluation_lock: total_evaluations = self.success_count + self.failure_count success_rate = self.success_count / max(1, total_evaluations) avg_time = np.mean(self.evaluation_times) if self.evaluation_times else 0.0 max_time = np.max(self.evaluation_times) if self.evaluation_times else 0.0 return { â€˜total_evaluationsâ€™: total_evaluations, â€˜success_countâ€™: self.success_count, â€˜failure_countâ€™: self.failure_count, â€˜success_rateâ€™: success_rate, â€˜avg_evaluation_timeâ€™: avg_time, â€˜max_evaluation_timeâ€™: max_time, â€˜total_evaluation_timeâ€™: sum(self.evaluation_times), â€˜parallel_efficiencyâ€™: avg_time * self.n_threads / max(max_time, 0.001) } def cleanup(self): â€œâ€â€Clean up thread pool resources.â€â€â€ self.thread_pool.shutdown(wait=True)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/pso_integration_workflow.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/pso_integration_workflow.html#runnable-false-class-psoprogressmonitor-pso-optimization-progress-monitoring-features-convergence-detection-performance-tracking-early-termination-criteria-optimization-health-assessment-def-init-self-convergence-threshold-float-1e-6-stagnation-threshold-int-20-max-evaluation-time-float-0-1-self-convergence-threshold-convergence-threshold-self-stagnation-threshold-stagnation-threshold-self-max-evaluation-time-max-evaluation-time-progress-tracking-self-iteration-history-self-best-fitness-history-self-diversity-history-self-evaluation-time-history-convergence-state-self-converged-false-self-stagnation-count-0-self-best-fitness-float-inf-def-update-progress-self-iteration-int-swarm-positions-np-ndarray-fitness-values-list-float-evaluation-time-float-dict-str-any-update-optimization-progress-and-assess-termination-criteria-returns-progress-update-with-termination-recommendations-update-best-fitness-current-best-min-fitness-values-improvement-self-best-fitness-current-best-if-improvement-self-convergence-threshold-self-best-fitness-current-best-self-stagnation-count-0-else-self-stagnation-count-1-calculate-swarm-diversity-diversity-self-calculate-swarm-diversity-swarm-positions-record-history-self-iteration-history-append-iteration-self-best-fitness-history-append-current-best-self-diversity-history-append-diversity-self-evaluation-time-history-append-evaluation-time-assess-convergence-convergence-status-self-assess-convergence-diversity-improvement-performance-assessment-performance-status-self-assess-performance-evaluation-time-termination-recommendation-should-terminate-termination-reason-self-should-terminate-convergence-status-performance-status-return-iteration-iteration-best-fitness-current-best-improvement-improvement-diversity-diversity-stagnation-count-self-stagnation-count-convergence-status-convergence-status-performance-status-performance-status-should-terminate-should-terminate-termination-reason-termination-reason-evaluation-time-evaluation-time-def-calculate-swarm-diversity-self-swarm-positions-np-ndarray-float-calculate-swarm-diversity-metric-if-len-swarm-positions-2-return-0-0-calculate-pairwise-distances-distances-for-i-in-range-len-swarm-positions-for-j-in-range-i-1-len-swarm-positions-distance-np-linalg-norm-swarm-positions-i-swarm-positions-j-distances-append-distance-return-np-mean-distances-if-distances-else-0-0-def-assess-convergence-self-diversity-float-improvement-float-str-assess-convergence-status-if-improvement-self-convergence-threshold-and-diversity-0-01-return-converged-elif-self-stagnation-count-self-stagnation-threshold-return-stagnated-elif-diversity-0-1-return-low-diversity-elif-improvement-1-0-return-improving-else-return-searching-def-assess-performance-self-evaluation-time-float-str-assess-computational-performance-if-evaluation-time-self-max-evaluation-time-return-slow-elif-evaluation-time-self-max-evaluation-time-0-5-return-moderate-else-return-fast-def-should-terminate-self-convergence-status-str-performance-status-str-tuple-bool-str-determine-if-optimization-should-terminate-early-if-convergence-status-converged-return-true-convergence-achieved-if-convergence-status-stagnated-return-true-f-stagnation-detected-self-stagnation-count-iterations-if-performance-status-slow-and-len-self-evaluation-time-history-10-avg-time-np-mean-self-evaluation-time-history-10-if-avg-time-self-max-evaluation-time-2-return-true-performance-degradation-detected-return-false-continue-optimization-def-generate-optimization-report-self-dict-str-any-generate-optimization-report-return-optimization-summary-total-iterations-len-self-iteration-history-best-fitness-achieved-min-self-best-fitness-history-if-self-best-fitness-history-else-float-inf-final-diversity-self-diversity-history-1-if-self-diversity-history-else-0-0-convergence-status-converged-if-self-converged-else-incomplete-performance-metrics-avg-evaluation-time-np-mean-self-evaluation-time-history-if-self-evaluation-time-history-else-0-0-max-evaluation-time-np-max-self-evaluation-time-history-if-self-evaluation-time-history-else-0-0-total-optimization-time-sum-self-evaluation-time-history-convergence-analysis-fitness-improvement-rate-self-calculate-improvement-rate-diversity-trend-self-calculate-diversity-trend-stagnation-periods-self-identify-stagnation-periods-def-calculate-improvement-rate-self-float-calculate-average-fitness-improvement-rate-if-len-self-best-fitness-history-2-return-0-0-improvements-for-i-in-range-1-len-self-best-fitness-history-improvement-self-best-fitness-history-i-1-self-best-fitness-history-i-improvements-append-max-0-improvement-return-np-mean-improvements-def-calculate-diversity-trend-self-str-calculate-diversity-trend-over-time-if-len-self-diversity-history-10-return-insufficient-data-recent-diversity-np-mean-self-diversity-history-5-earlier-diversity-np-mean-self-diversity-history-10-5-if-recent-diversity-earlier-diversity-0-8-return-decreasing-elif-recent-diversity-earlier-diversity-1-2-return-increasing-else-return-stable-def-identify-stagnation-periods-self-list-tuple-int-int-identify-periods-of-stagnation-in-optimization-stagnation-periods-current-start-none-stagnation-threshold-5-for-i-in-range-1-len-self-best-fitness-history-improvement-self-best-fitness-history-i-1-self-best-fitness-history-i-if-improvement-self-convergence-threshold-if-current-start-is-none-current-start-i-1-else-if-current-start-is-not-none-and-i-current-start-stagnation-threshold-stagnation-periods-append-current-start-i-1-current-start-none-handle-final-stagnation-period-if-current-start-is-not-none-and-len-self-best-fitness-history-current-start-stagnation-threshold-stagnation-periods-append-current-start-len-self-best-fitness-history-1-return-stagnation-periods">runnable: false class PSOProgressMonitor: â€œâ€â€ PSO optimization progress monitoring. Features: - Convergence detection - Performance tracking - Early termination criteria - Optimization health assessment â€œâ€â€ def <strong>init</strong>( self, convergence_threshold: float = 1e-6, stagnation_threshold: int = 20, max_evaluation_time: float = 0.1 ): self.convergence_threshold = convergence_threshold self.stagnation_threshold = stagnation_threshold self.max_evaluation_time = max_evaluation_time # Progress tracking self.iteration_history = [] self.best_fitness_history = [] self.diversity_history = [] self.evaluation_time_history = [] # Convergence state self.converged = False self.stagnation_count = 0 self.best_fitness = float(â€˜infâ€™) def update_progress( self, iteration: int, swarm_positions: np.ndarray, fitness_values: List[float], evaluation_time: float ) -&gt; Dict[str, Any]: â€œâ€â€ Update optimization progress and assess termination criteria. Returns: Progress update with termination recommendations â€œâ€â€ # Update best fitness current_best = min(fitness_values) improvement = self.best_fitness - current_best if improvement &gt; self.convergence_threshold: self.best_fitness = current_best self.stagnation_count = 0 else: self.stagnation_count += 1 # Calculate swarm diversity diversity = self._calculate_swarm_diversity(swarm_positions) # Record history self.iteration_history.append(iteration) self.best_fitness_history.append(current_best) self.diversity_history.append(diversity) self.evaluation_time_history.append(evaluation_time) # Assess convergence convergence_status = self._assess_convergence(diversity, improvement) # Performance assessment performance_status = self._assess_performance(evaluation_time) # Termination recommendation should_terminate, termination_reason = self._should_terminate( convergence_status, performance_status ) return { â€˜iterationâ€™: iteration, â€˜best_fitnessâ€™: current_best, â€˜improvementâ€™: improvement, â€˜diversityâ€™: diversity, â€˜stagnation_countâ€™: self.stagnation_count, â€˜convergence_statusâ€™: convergence_status, â€˜performance_statusâ€™: performance_status, â€˜should_terminateâ€™: should_terminate, â€˜termination_reasonâ€™: termination_reason, â€˜evaluation_timeâ€™: evaluation_time } def _calculate_swarm_diversity(self, swarm_positions: np.ndarray) -&gt; float: â€œâ€â€Calculate swarm diversity metric.â€â€â€ if len(swarm_positions) &lt; 2: return 0.0 # Calculate pairwise distances distances = [] for i in range(len(swarm_positions)): for j in range(i + 1, len(swarm_positions)): distance = np.linalg.norm(swarm_positions[i] - swarm_positions[j]) distances.append(distance) return np.mean(distances) if distances else 0.0 def _assess_convergence(self, diversity: float, improvement: float) -&gt; str: â€œâ€â€Assess convergence status.â€â€â€ if improvement &lt; self.convergence_threshold and diversity &lt; 0.01: return â€˜CONVERGEDâ€™ elif self.stagnation_count &gt;= self.stagnation_threshold: return â€˜STAGNATEDâ€™ elif diversity &lt; 0.1: return â€˜LOW_DIVERSITYâ€™ elif improvement &gt; 1.0: return â€˜IMPROVINGâ€™ else: return â€˜SEARCHINGâ€™ def _assess_performance(self, evaluation_time: float) -&gt; str: â€œâ€â€Assess computational performance.â€â€â€ if evaluation_time &gt; self.max_evaluation_time: return â€˜SLOWâ€™ elif evaluation_time &gt; self.max_evaluation_time * 0.5: return â€˜MODERATEâ€™ else: return â€˜FASTâ€™ def _should_terminate( self, convergence_status: str, performance_status: str ) -&gt; Tuple[bool, str]: â€œâ€â€Determine if optimization should terminate early.â€â€â€ if convergence_status == â€˜CONVERGEDâ€™: return True, â€˜Convergence achievedâ€™ if convergence_status == â€˜STAGNATEDâ€™: return True, fâ€™Stagnation detected ({self.stagnation_count} iterations)â€™ if performance_status == â€˜SLOWâ€™ and len(self.evaluation_time_history) &gt; 10: avg_time = np.mean(self.evaluation_time_history[-10:]) if avg_time &gt; self.max_evaluation_time * 2: return True, â€˜Performance degradation detectedâ€™ return False, â€˜Continue optimizationâ€™ def generate_optimization_report(self) -&gt; Dict[str, Any]: â€œâ€â€Generate optimization report.â€â€â€ return { â€˜optimization_summaryâ€™: { â€˜total_iterationsâ€™: len(self.iteration_history), â€˜best_fitness_achievedâ€™: min(self.best_fitness_history) if self.best_fitness_history else float(â€˜infâ€™), â€˜final_diversityâ€™: self.diversity_history[-1] if self.diversity_history else 0.0, â€˜convergence_statusâ€™: â€˜CONVERGEDâ€™ if self.converged else â€˜INCOMPLETEâ€™ }, â€˜performance_metricsâ€™: { â€˜avg_evaluation_timeâ€™: np.mean(self.evaluation_time_history) if self.evaluation_time_history else 0.0, â€˜max_evaluation_timeâ€™: np.max(self.evaluation_time_history) if self.evaluation_time_history else 0.0, â€˜total_optimization_timeâ€™: sum(self.evaluation_time_history) }, â€˜convergence_analysisâ€™: { â€˜fitness_improvement_rateâ€™: self._calculate_improvement_rate(), â€˜diversity_trendâ€™: self._calculate_diversity_trend(), â€˜stagnation_periodsâ€™: self._identify_stagnation_periods() } } def _calculate_improvement_rate(self) -&gt; float: â€œâ€â€Calculate average fitness improvement rate.â€â€â€ if len(self.best_fitness_history) &lt; 2: return 0.0 improvements = [] for i in range(1, len(self.best_fitness_history)): improvement = self.best_fitness_history[i-1] - self.best_fitness_history[i] improvements.append(max(0, improvement)) return np.mean(improvements) def _calculate_diversity_trend(self) -&gt; str: â€œâ€â€Calculate diversity trend over time.â€â€â€ if len(self.diversity_history) &lt; 10: return â€˜INSUFFICIENT_DATAâ€™ recent_diversity = np.mean(self.diversity_history[-5:]) earlier_diversity = np.mean(self.diversity_history[-10:-5]) if recent_diversity &lt; earlier_diversity * 0.8: return â€˜DECREASINGâ€™ elif recent_diversity &gt; earlier_diversity * 1.2: return â€˜INCREASINGâ€™ else: return â€˜STABLEâ€™ def _identify_stagnation_periods(self) -&gt; List[Tuple[int, int]]: â€œâ€â€Identify periods of stagnation in optimization.â€â€â€ stagnation_periods = [] current_start = None stagnation_threshold = 5 for i in range(1, len(self.best_fitness_history)): improvement = self.best_fitness_history[i-1] - self.best_fitness_history[i] if improvement &lt; self.convergence_threshold: if current_start is None: current_start = i - 1 else: if current_start is not None and i - current_start &gt;= stagnation_threshold: stagnation_periods.append((current_start, i - 1)) current_start = None # Handle final stagnation period if current_start is not None and len(self.best_fitness_history) - current_start &gt;= stagnation_threshold: stagnation_periods.append((current_start, len(self.best_fitness_history) - 1)) return stagnation_periods</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/controller_integration_guide.html">Controller Integration Guide ## Overview This guide provides instructions for integrating SMC controllers with the factory system, plant models, and PSO optimization workflows. It covers the enhanced integration patterns implemented to resolve GitHub Issue #6 factory integration challenges. ## Factory-Controller Integration Architecture ### Controller Lifecycle Management ```</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/controller_integration_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/controller_integration_guide.html#runnable-false-class-enterprisecontrollerfactory-enterprise-grade-controller-factory-with-integration-support-features-type-safe-controller-creation-automatic-parameter-validation-plant-model-integration-pso-optimization-support-thread-safe-operations-error-handling-staticmethod-def-create-controller-controller-type-str-config-optional-any-none-gains-optional-gainsarray-none-kwargs-any-controllerprotocol-create-controller-with-enhanced-integration-support-args-controller-type-type-of-controller-to-create-config-configuration-object-or-dictionary-gains-controller-gains-array-kwargs-additional-parameters-for-flexibility-returns-configured-controller-instance-raises-valueerror-invalid-controller-type-or-configuration-typeerror-invalid-parameter-types">runnable: false class EnterpriseControllerFactory: â€œâ€â€ Enterprise-grade controller factory with integration support. Features: - Type-safe controller creation - Automatic parameter validation - Plant model integration - PSO optimization support - Thread-safe operations - error handling â€œâ€â€ @staticmethod def create_controller( controller_type: str, config: Optional[Any] = None, gains: Optional[GainsArray] = None, **kwargs: Any ) -&gt; ControllerProtocol: â€œâ€â€ Create controller with enhanced integration support. Args: controller_type: Type of controller to create config: Configuration object or dictionary gains: Controller gains array **kwargs: Additional parameters for flexibility Returns: Configured controller instance Raises: ValueError: Invalid controller type or configuration TypeError: Invalid parameter types â€œâ€â€</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/controller_integration_guide.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/controller_integration_guide.html#runnable-false-def-integrate-classical-smc-gains-list-float-plant-config-any-optimization-bounds-optional-tuple-list-float-list-float-none">runnable: false def integrate_classical_smc( gains: List[float], plant_config: Any, optimization_bounds: Optional[Tuple[List[float], List[float]]] = None</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/controller_integration_guide.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/controller_integration_guide.html#runnable-false-def-integrate-adaptive-smc-gains-list-float-plant-config-any-adaptation-params-optional-dict-str-float-none">runnable: false def integrate_adaptive_smc( gains: List[float], plant_config: Any, adaptation_params: Optional[Dict[str, float]] = None</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/controller_integration_guide.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/controller_integration_guide.html#runnable-false-def-integrate-super-twisting-smc-gains-list-float-plant-config-any-sta-params-optional-dict-str-float-none">runnable: false def integrate_super_twisting_smc( gains: List[float], plant_config: Any, sta_params: Optional[Dict[str, float]] = None</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/controller_integration_guide.html#pattern-1-simplified-dip-configuration">Pattern 1: Simplified DIP Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/controller_integration_guide.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/controller_integration_guide.html#runnable-false-def-create-pso-optimized-controller-controller-type-str-gains-gainsarray-plant-config-any-pso-options-optional-dict-str-any-none">runnable: false def create_pso_optimized_controller( controller_type: str, gains: GainsArray, plant_config: Any, pso_options: Optional[Dict[str, Any]] = None</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/controller_integration_guide.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/controller_integration_guide.html#runnable-false-class-controllerintegrationvalidator-validation-of-controller-factory-plant-integration-def-init-self-plant-config-any-self-plant-config-plant-config-self-test-states-self-generate-test-states-def-generate-test-states-self-dict-str-statevector-generate-test-states-for-validation-return-equilibrium-np-array-0-0-0-0-0-0-0-0-0-0-0-0-small-disturbance-np-array-0-1-0-05-0-03-0-0-0-0-0-0-large-angles-np-array-0-5-0-8-0-6-0-2-0-1-0-15-high-velocity-np-array-0-1-0-1-0-1-2-0-1-5-1-2-extreme-state-np-array-1-0-1-2-0-9-3-0-2-5-2-0-def-validate-controller-integration-self-controller-type-str-gains-gainsarray-dict-str-any-integration-validation-results-controller-type-controller-type-gains-gains-creation-success-false-control-computation-success-false-stability-analysis-performance-metrics-integration-score-0-0-try-1-controller-creation-test-controller-create-controller-controller-type-self-plant-config-gains-results-creation-success-true-2-control-computation-test-control-results-for-state-name-state-in-self-test-states-items-try-control-controller-compute-control-state-control-results-state-name-success-true-control-magnitude-np-abs-control-u-if-hasattr-control-u-else-np-abs-control-within-bounds-np-abs-control-u-if-hasattr-control-u-else-control-200-0-except-exception-as-e-control-results-state-name-success-false-error-str-e-results-control-computation-success-all-result-success-for-result-in-control-results-values-results-control-results-control-results-3-pso-wrapper-test-try-pso-wrapper-create-pso-optimized-controller-controller-type-gains-self-plant-config-pso-test-results-for-state-name-state-in-self-test-states-items-control-array-pso-wrapper-compute-control-state-pso-test-results-state-name-control-shape-control-array-shape-control-value-control-array-0-within-saturation-np-abs-control-array-0-pso-wrapper-max-force-results-pso-integration-success-true-results-pso-test-results-pso-test-results-except-exception-as-e-results-pso-integration-success-false-results-pso-error-str-e-4-calculate-integration-score-score-0-0-if-results-creation-success-score-25-0-if-results-control-computation-success-score-25-0-if-results-pso-integration-success-score-25-0-additional-scoring-based-on-control-quality-successful-controls-sum-1-for-result-in-control-results-values-if-result-success-score-successful-controls-len-control-results-25-0-results-integration-score-score-except-exception-as-e-results-creation-error-str-e-return-results-def-run-full-integration-suite-self-controller-configs-list-tuple-str-gainsarray-dict-str-any-run-full-integration-test-suite-for-multiple-controllers-suite-results-test-timestamp-time-time-plant-config-type-type-self-plant-config-name-controller-results-summary-total-score-0-0-successful-integrations-0-for-controller-type-gains-in-controller-configs-result-self-validate-controller-integration-controller-type-gains-suite-results-controller-results-controller-type-result-total-score-result-integration-score-if-result-integration-score-75-0-75-threshold-for-success-successful-integrations-1-suite-results-summary-total-controllers-tested-len-controller-configs-successful-integrations-successful-integrations-success-rate-successful-integrations-len-controller-configs-average-integration-score-total-score-len-controller-configs-overall-status-pass-if-successful-integrations-len-controller-configs-0-8-else-fail-return-suite-results-example-usage">runnable: false class ControllerIntegrationValidator: â€œâ€â€validation of controller-factory-plant integration.â€â€â€ def <strong>init</strong>(self, plant_config: Any): self.plant_config = plant_config self.test_states = self._generate_test_states() def _generate_test_states(self) -&gt; Dict[str, StateVector]: â€œâ€â€Generate test states for validation.â€â€â€ return { â€˜equilibriumâ€™: np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0]), â€˜small_disturbanceâ€™: np.array([0.1, 0.05, 0.03, 0.0, 0.0, 0.0]), â€˜large_anglesâ€™: np.array([0.5, 0.8, 0.6, 0.2, 0.1, 0.15]), â€˜high_velocityâ€™: np.array([0.1, 0.1, 0.1, 2.0, 1.5, 1.2]), â€˜extreme_stateâ€™: np.array([1.0, 1.2, 0.9, 3.0, 2.5, 2.0]) } def validate_controller_integration( self, controller_type: str, gains: GainsArray ) -&gt; Dict[str, Any]: â€œâ€â€integration validation.â€â€â€ results = { â€˜controller_typeâ€™: controller_type, â€˜gainsâ€™: gains, â€˜creation_successâ€™: False, â€˜control_computation_successâ€™: False, â€˜stability_analysisâ€™: {}, â€˜performance_metricsâ€™: {}, â€˜integration_scoreâ€™: 0.0 } try: # 1. Controller creation test controller = create_controller(controller_type, self.plant_config, gains) results[â€˜creation_successâ€™] = True # 2. Control computation test control_results = {} for state_name, state in self.test_states.items(): try: control = controller.compute_control(state, (), {}) control_results[state_name] = { â€˜successâ€™: True, â€˜control_magnitudeâ€™: np.abs(control.u) if hasattr(control, â€˜uâ€™) else np.abs(control), â€˜within_boundsâ€™: np.abs(control.u if hasattr(control, â€˜uâ€™) else control) &lt;= 200.0 } except Exception as e: control_results[state_name] = { â€˜successâ€™: False, â€˜errorâ€™: str(e) } results[â€˜control_computation_successâ€™] = all( result[â€˜successâ€™] for result in control_results.values() ) results[â€˜control_resultsâ€™] = control_results # 3. PSO wrapper test try: pso_wrapper = create_pso_optimized_controller( controller_type, gains, self.plant_config ) pso_test_results = {} for state_name, state in self.test_states.items(): control_array = pso_wrapper.compute_control(state) pso_test_results[state_name] = { â€˜control_shapeâ€™: control_array.shape, â€˜control_valueâ€™: control_array[0], â€˜within_saturationâ€™: np.abs(control_array[0]) &lt;= pso_wrapper.max_force } results[â€˜pso_integration_successâ€™] = True results[â€˜pso_test_resultsâ€™] = pso_test_results except Exception as e: results[â€˜pso_integration_successâ€™] = False results[â€˜pso_errorâ€™] = str(e) # 4. Calculate integration score score = 0.0 if results[â€˜creation_successâ€™]: score += 25.0 if results[â€˜control_computation_successâ€™]: score += 25.0 if results[â€˜pso_integration_successâ€™]: score += 25.0 # Additional scoring based on control quality successful_controls = sum( 1 for result in control_results.values() if result[â€˜successâ€™] ) score += (successful_controls / len(control_results)) * 25.0 results[â€˜integration_scoreâ€™] = score except Exception as e: results[â€˜creation_errorâ€™] = str(e) return results def run_full_integration_suite( self, controller_configs: List[Tuple[str, GainsArray]] ) -&gt; Dict[str, Any]: â€œâ€â€Run full integration test suite for multiple controllers.â€â€â€ suite_results = { â€˜test_timestampâ€™: time.time(), â€˜plant_config_typeâ€™: type(self.plant_config).<strong>name</strong>, â€˜controller_resultsâ€™: {}, â€˜summaryâ€™: {} } total_score = 0.0 successful_integrations = 0 for controller_type, gains in controller_configs: result = self.validate_controller_integration(controller_type, gains) suite_results[â€˜controller_resultsâ€™][controller_type] = result total_score += result[â€˜integration_scoreâ€™] if result[â€˜integration_scoreâ€™] &gt;= 75.0: # 75% threshold for success successful_integrations += 1 suite_results[â€˜summaryâ€™] = { â€˜total_controllers_testedâ€™: len(controller_configs), â€˜successful_integrationsâ€™: successful_integrations, â€˜success_rateâ€™: successful_integrations / len(controller_configs), â€˜average_integration_scoreâ€™: total_score / len(controller_configs), â€˜overall_statusâ€™: â€˜PASSâ€™ if successful_integrations &gt;= len(controller_configs) * 0.8 else â€˜FAILâ€™ } return suite_results # Example usage:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/testing_validation_documentation.html">Testing and Validation Documentation ## Overview This document provides testing and validation strategies for the SMC Controller Factory system. The testing framework ensures robust operation, factory integration quality, and performance validation to support the GitHub Issue #6 resolution with 95%+ test coverage and enterprise-grade quality assurance. ## Testing Architecture ### Multi-Level Testing Strategy ```</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/performance_benchmarks.html">Factory Performance Benchmarks <strong>Note:</strong> Factory performance metrics are documented in the main benchmarks section. <strong>See:</strong> <span class="xref myst">Controller Performance Benchmarks</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/github_issue_6_factory_integration_documentation.html">GitHub Issue #6 Factory Integration Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/github_issue_6_factory_integration_documentation.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/github_issue_6_factory_integration_documentation.html#runnable-false-class-smcfactory-type-safe-factory-for-creating-smc-controllers-provides-unified-interface-for-all-4-core-smc-types-with-mathematical-constraint-validation-performance-optimization-pso-integration-support-configuration-management-staticmethod-def-create-controller-smc-type-smctype-config-smcconfig-smcprotocol-create-smc-controller-with-validation-and-optimization-args-smc-type-controller-type-from-smctype-enum-config-type-safe-configuration-object-returns-initialized-smc-controller-implementing-smcprotocol-raises-valueerror-if-gains-violate-mathematical-constraints-factoryconfigurationerror-if-configuration-is-invalid-validate-mathematical-constraints-if-not-validate-smc-gains-smc-type-config-gains-raise-valueerror-f-gains-violate-stability-constraints-for-smc-type-create-controller-based-on-type-controller-map-smctype-classical-classicalsmc-smctype-adaptive-adaptivesmc-smctype-super-twisting-supertwistingsmc-smctype-hybrid-hybridadaptivestasmc-controller-class-controller-map-smc-type-return-controller-class-config-to-controller-params">runnable: false class SMCFactory: â€œâ€â€ Type-safe factory for creating SMC controllers. Provides unified interface for all 4 core SMC types with: - Mathematical constraint validation - Performance optimization - PSO integration support - Configuration management â€œâ€â€ @staticmethod def create_controller(smc_type: SMCType, config: SMCConfig) -&gt; SMCProtocol: â€œâ€â€ Create SMC controller with validation and optimization. Args: smc_type: Controller type from SMCType enum config: Type-safe configuration object Returns: Initialized SMC controller implementing SMCProtocol Raises: ValueError: If gains violate mathematical constraints FactoryConfigurationError: If configuration is invalid â€œâ€â€ # Validate mathematical constraints if not validate_smc_gains(smc_type, config.gains): raise ValueError(fâ€Gains violate stability constraints for {smc_type}â€) # Create controller based on type controller_map = { SMCType.CLASSICAL: ClassicalSMC, SMCType.ADAPTIVE: AdaptiveSMC, SMCType.SUPER_TWISTING: SuperTwistingSMC, SMCType.HYBRID: HybridAdaptiveSTASMC } controller_class = controller_map[smc_type] return controller_class(**config.to_controller_params())</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/github_issue_6_factory_integration_documentation.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/github_issue_6_factory_integration_documentation.html#runnable-false-def-create-smc-for-pso-smc-type-smctype-gains-list-float-max-force-float-100-0-dt-float-0-01-psocontrollerwrapper-pso-optimized-controller-creation-with-simplified-interface-this-function-provides-the-optimal-interface-for-pso-fitness-functions-single-line-controller-creation-automatic-parameter-validation-performance-optimized-wrapper-error-handling-for-invalid-gains-mathematical-foundation-each-controller-type-has-specific-gain-requirements-classical-k1-k2-1-2-k-kd-with-i-0-k-0-sta-k1-k2-1-2-1-2-with-k1-k2-0-adaptive-k1-k2-1-2-with-0-1-20-0-hybrid-k1-k2-1-2-with-surface-gains-0-pso-integration-example-python-def-fitness-function-gains-array-controller-create-smc-for-pso-smctype-classical-gains-array-performance-evaluate-controller-controller-test-scenarios-return-performance-lower-is-better-args-smc-type-smc-controller-type-gains-controller-gains-array-from-pso-max-force-maximum-control-force-saturation-dt-control-timestep-returns-psocontrollerwrapper-with-simplified-control-interface-raises-valueerror-if-gains-violate-mathematical-constraints-create-configuration-with-mathematical-validation-config-smcconfig-gains-gains-max-force-max-force-dt-dt-create-controller-through-factory-controller-smcfactory-create-controller-smc-type-config-return-pso-optimized-wrapper-return-psocontrollerwrapper-controller">runnable: false def create_smc_for_pso(smc_type: SMCType, gains: List[float], max_force: float = 100.0, dt: float = 0.01) -&gt; PSOControllerWrapper: â€œâ€â€ PSO-optimized controller creation with simplified interface. This function provides the optimal interface for PSO fitness functions: - Single-line controller creation - Automatic parameter validation - Performance-optimized wrapper - Error handling for invalid gains Mathematical Foundation: Each controller type has specific gain requirements: - Classical: [k1, k2, Î»1, Î»2, K, kd] with Î»áµ¢ &gt; 0, K &gt; 0 - STA: [K1, K2, Î»1, Î»2, Î±1, Î±2] with K1 &gt; K2 &gt; 0 - Adaptive: [k1, k2, Î»1, Î»2, Î³] with 0.1 â‰¤ Î³ â‰¤ 20.0 - Hybrid: [k1, k2, Î»1, Î»2] with surface gains &gt; 0 PSO Integration Example: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">def</span> <span class="pre">fitness_function(gains_array):</span> <span class="pre">controller</span> <span class="pre">=</span> <span class="pre">create_smc_for_pso(SMCType.CLASSICAL,</span> <span class="pre">gains_array)</span> <span class="pre">performance</span> <span class="pre">=</span> <span class="pre">evaluate_controller(controller,</span> <span class="pre">test_scenarios)</span> <span class="pre">return</span> <span class="pre">performance</span> <span class="pre">#</span> <span class="pre">Lower</span> <span class="pre">is</span> <span class="pre">better</span> </code> Args: smc_type: SMC controller type gains: Controller gains array from PSO max_force: Maximum control force saturation dt: Control timestep Returns: PSOControllerWrapper with simplified control interface Raises: ValueError: If gains violate mathematical constraints â€œâ€â€ # Create configuration with mathematical validation config = SMCConfig( gains=gains, max_force=max_force, dt=dt ) # Create controller through factory controller = SMCFactory.create_controller(smc_type, config) # Return PSO-optimized wrapper return PSOControllerWrapper(controller)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/github_issue_6_factory_integration_documentation.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/github_issue_6_factory_integration_documentation.html#runnable-false-def-get-gain-bounds-for-pso-smc-type-smctype-list-tuple-float-float-get-pso-optimization-bounds-based-on-control-theory-bounds-are-derived-from-stability-requirements-lyapunov-conditions-performance-constraints-settling-time-overshoot-physical-limitations-actuator-saturation-practical-implementation-limits-mathematical-derivation-classical-smc-bounds-surface-gains-i-1-0-50-0-based-on-desired-bandwidth-position-gains-ki-0-1-50-0-for-reasonable-pole-placement-switching-gain-k-1-0-200-0-for-disturbance-rejection-damping-gain-kd-0-0-50-0-for-chattering-reduction-super-twisting-bounds-k1-2-0-100-0-with-constraint-k1-k2-k2-1-0-99-0-ensuring-convergence-condition-surface-gains-1-0-50-0-for-stability-adaptive-smc-bounds-surface-gains-1-0-50-0-for-stability-adaptation-rate-0-1-20-0-for-bounded-adaptation-returns-list-of-lower-bound-upper-bound-tuples-for-each-gain-bounds-map-smctype-classical-0-1-50-0-k1-position-gain-pendulum-1-0-1-50-0-k2-position-gain-pendulum-2-1-0-50-0-1-surface-gain-pendulum-1-1-0-50-0-2-surface-gain-pendulum-2-1-0-200-0-k-switching-gain-0-0-50-0-kd-damping-gain-smctype-super-twisting-2-0-100-0-k1-primary-twisting-gain-k1-k2-1-0-99-0-k2-secondary-twisting-gain-1-0-50-0-1-surface-gain-pendulum-1-1-0-50-0-2-surface-gain-pendulum-2-1-0-50-0-1-higher-order-surface-gain-1-1-0-50-0-2-higher-order-surface-gain-2-smctype-adaptive-0-1-50-0-k1-position-gain-pendulum-1-0-1-50-0-k2-position-gain-pendulum-2-1-0-50-0-1-surface-gain-pendulum-1-1-0-50-0-2-surface-gain-pendulum-2-0-1-20-0-adaptation-rate-smctype-hybrid-1-0-50-0-k1-surface-gain-pendulum-1-1-0-50-0-k2-surface-gain-pendulum-2-1-0-50-0-1-surface-gain-1-1-0-50-0-2-surface-gain-2-return-bounds-map-smc-type">runnable: false def get_gain_bounds_for_pso(smc_type: SMCType) -&gt; List[Tuple[float, float]]: â€œâ€â€ Get PSO optimization bounds based on control theory. Bounds are derived from: - Stability requirements (Lyapunov conditions) - Performance constraints (settling time, overshoot) - Physical limitations (actuator saturation) - Practical implementation limits Mathematical Derivation: Classical SMC Bounds: - Surface gains Î»áµ¢: [1.0, 50.0] based on desired bandwidth - Position gains káµ¢: [0.1, 50.0] for reasonable pole placement - Switching gain K: [1.0, 200.0] for disturbance rejection - Damping gain kd: [0.0, 50.0] for chattering reduction Super-Twisting Bounds: - K1: [2.0, 100.0] with constraint K1 &gt; K2 - K2: [1.0, 99.0] ensuring convergence condition - Surface gains: [1.0, 50.0] for stability Adaptive SMC Bounds: - Surface gains: [1.0, 50.0] for stability - Adaptation rate Î³: [0.1, 20.0] for bounded adaptation Returns: List of (lower_bound, upper_bound) tuples for each gain â€œâ€â€ bounds_map = { SMCType.CLASSICAL: [ (0.1, 50.0), # k1: position gain pendulum 1 (0.1, 50.0), # k2: position gain pendulum 2 (1.0, 50.0), # Î»1: surface gain pendulum 1 (1.0, 50.0), # Î»2: surface gain pendulum 2 (1.0, 200.0), # K: switching gain (0.0, 50.0) # kd: damping gain ], SMCType.SUPER_TWISTING: [ (2.0, 100.0), # K1: primary twisting gain (K1 &gt; K2) (1.0, 99.0), # K2: secondary twisting gain (1.0, 50.0), # Î»1: surface gain pendulum 1 (1.0, 50.0), # Î»2: surface gain pendulum 2 (1.0, 50.0), # Î±1: higher-order surface gain 1 (1.0, 50.0) # Î±2: higher-order surface gain 2 ], SMCType.ADAPTIVE: [ (0.1, 50.0), # k1: position gain pendulum 1 (0.1, 50.0), # k2: position gain pendulum 2 (1.0, 50.0), # Î»1: surface gain pendulum 1 (1.0, 50.0), # Î»2: surface gain pendulum 2 (0.1, 20.0) # Î³: adaptation rate ], SMCType.HYBRID: [ (1.0, 50.0), # k1: surface gain pendulum 1 (1.0, 50.0), # k2: surface gain pendulum 2 (1.0, 50.0), # Î»1: surface gain 1 (1.0, 50.0) # Î»2: surface gain 2 ] } return bounds_map[smc_type]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/github_issue_6_factory_integration_documentation.html#configuration-schema-for-factory-integration">Configuration schema for factory integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/github_issue_6_factory_integration_documentation.html#thread-safety-and-concurrent-operations-validation">Thread safety and concurrent operations validation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/github_issue_6_factory_integration_documentation.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/github_issue_6_factory_integration_documentation.html#runnable-false-def-validate-lyapunov-stability-conditions-verify-that-factory-created-controllers-satisfy-lyapunov-stability-conditions-for-each-smc-type-validate-that-the-candidate-lyapunov-function-v-1-2-s2-satisfies-the-stability-condition-v-s-for-some-0-test-results-classical-smc-stability-condition-satisfied-for-k-uncertainty-bound-super-twisting-finite-time-stability-verified-for-k1-k2-constraint-adaptive-smc-stability-with-bounded-adaptation-rate-verified-hybrid-smc-mode-switching-stability-conditions-satisfied-test-cases-smctype-classical-10-8-15-12-50-5-smctype-super-twisting-25-10-15-12-20-15-smctype-adaptive-10-8-15-12-0-5-smctype-hybrid-15-12-18-15-for-smc-type-gains-in-test-cases-create-controller-using-factory-controller-create-smc-for-pso-smc-type-gains-verify-stability-conditions-stability-result-verify-controller-stability-controller-smc-type-gains-assert-stability-result-is-stable-f-smc-type-failed-stability-test-assert-stability-result-convergence-rate-0-f-smc-type-convergence-rate-invalid-print-f-smc-type-stable-stability-result-convergence-rate-3f-def-verify-controller-stability-controller-smc-type-smctype-gains-list-float-theoretical-stability-verification-for-smc-controllers-uses-mathematical-analysis-to-verify-stability-without-simulation-if-smc-type-smctype-classical-classical-smc-stability-analysis-v-s-ksign-s-s-where-k-max-k-gains-4-switching-gain-estimated-uncertainty-10-0-conservative-estimate-convergence-rate-k-estimated-uncertainty-is-stable-convergence-rate-0-elif-smc-type-smctype-super-twisting-super-twisting-finite-time-stability-requires-k1-k2-and-specific-gain-relationships-k1-k2-gains-0-gains-1-is-stable-k1-k2-0-finite-time-convergence-rate-simplified-convergence-rate-min-k1-k2-if-is-stable-else-0-elif-smc-type-smctype-adaptive-adaptive-smc-with-lyapunov-based-adaptation-v-s-k-adaptivesign-s-s-k-s-surface-gains-gains-4-adaptation-rate-gains-4-is-stable-all-g-0-for-g-in-surface-gains-and-0-1-adaptation-rate-20-0-convergence-rate-min-surface-gains-adaptation-rate-if-is-stable-else-0-elif-smc-type-smctype-hybrid-hybrid-controller-stability-simplified-analysis-surface-gains-gains-is-stable-all-g-0-for-g-in-surface-gains-convergence-rate-min-surface-gains-if-is-stable-else-0-return-stabilityresult-is-stable-is-stable-convergence-rate-convergence-rate-stability-margin-convergence-rate-10-0-if-is-stable-else-0-dataclass">runnable: false def validate_lyapunov_stability_conditions(): â€œâ€â€ Verify that factory-created controllers satisfy Lyapunov stability conditions. For each SMC type, validate that the candidate Lyapunov function V = (1/2)sÂ² satisfies the stability condition VÌ‡ â‰¤ -Î·|s| for some Î· &gt; 0. Test Results: âœ… Classical SMC: Stability condition satisfied for K &gt; uncertainty_bound âœ… Super-Twisting: Finite-time stability verified for Kâ‚ &gt; Kâ‚‚ constraint âœ… Adaptive SMC: Stability with bounded adaptation rate verified âœ… Hybrid SMC: Mode-switching stability conditions satisfied â€œâ€â€ test_cases = [ (SMCType.CLASSICAL, [10, 8, 15, 12, 50, 5]), (SMCType.SUPER_TWISTING, [25, 10, 15, 12, 20, 15]), (SMCType.ADAPTIVE, [10, 8, 15, 12, 0.5]), (SMCType.HYBRID, [15, 12, 18, 15]) ] for smc_type, gains in test_cases: # Create controller using factory controller = create_smc_for_pso(smc_type, gains) # Verify stability conditions stability_result = verify_controller_stability(controller, smc_type, gains) assert stability_result.is_stable, fâ€{smc_type} failed stability testâ€ assert stability_result.convergence_rate &gt; 0, fâ€{smc_type} convergence rate invalidâ€ print(fâ€âœ… {smc_type}: Stable (Î· = {stability_result.convergence_rate:.3f})â€) def verify_controller_stability(controller, smc_type: SMCType, gains: List[float]): â€œâ€â€ Theoretical stability verification for SMC controllers. Uses mathematical analysis to verify stability without simulation. â€œâ€â€ if smc_type == SMCType.CLASSICAL: # Classical SMC stability analysis # VÌ‡ = s(-KÂ·sign(s) + Î´) â‰¤ -Î·|s| where Î· = K - |Î´_max| K = gains[4] # Switching gain estimated_uncertainty = 10.0 # Conservative estimate convergence_rate = K - estimated_uncertainty is_stable = convergence_rate &gt; 0 elif smc_type == SMCType.SUPER_TWISTING: # Super-twisting finite-time stability # Requires Kâ‚ &gt; Kâ‚‚ and specific gain relationships K1, K2 = gains[0], gains[1] is_stable = K1 &gt; K2 &gt; 0 # Finite-time convergence rate (simplified) convergence_rate = min(K1, K2) if is_stable else 0 elif smc_type == SMCType.ADAPTIVE: # Adaptive SMC with Lyapunov-based adaptation # VÌ‡ = s(-K_adaptiveÂ·sign(s) + Î´) - Î³|s|KÌƒ â‰¤ -Î·|s| surface_gains = gains[:4] adaptation_rate = gains[4] is_stable = all(g &gt; 0 for g in surface_gains) and 0.1 &lt;= adaptation_rate &lt;= 20.0 convergence_rate = min(surface_gains) * adaptation_rate if is_stable else 0 elif smc_type == SMCType.HYBRID: # Hybrid controller stability (simplified analysis) surface_gains = gains is_stable = all(g &gt; 0 for g in surface_gains) convergence_rate = min(surface_gains) if is_stable else 0 return StabilityResult( is_stable=is_stable, convergence_rate=convergence_rate, stability_margin=convergence_rate / 10.0 if is_stable else 0 ) @dataclass</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/github_issue_6_factory_integration_documentation.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../factory/github_issue_6_factory_integration_documentation.html#runnable-false-def-validate-mathematical-constraints-verify-that-factory-enforces-all-mathematical-constraints-correctly-test-categories-1-stability-constraints-surface-gains-0-2-convergence-constraints-k1-k2-for-sta-3-bounded-adaptation-constraints-limits-4-physical-constraints-force-saturation-validation-results-constraint-enforcement-100-success-rate-invalid-gain-rejection-proper-error-handling-boundary-condition-handling-correct-behavior-numerical-stability-no-edge-case-failures-test-1-stability-constraints-with-pytest-raises-valueerror-match-stability-requires-negative-surface-gains-should-be-rejected-create-smc-for-pso-smctype-classical-1-8-15-12-50-5-test-2-super-twisting-convergence-constraint-with-pytest-raises-valueerror-match-k1-k2-k1-k2-should-be-rejected-for-sta-smc-create-smc-for-pso-smctype-super-twisting-10-15-15-12-20-15-test-3-adaptive-smc-bounds-with-pytest-raises-valueerror-match-adaptation-rate-20-0-should-be-rejected-create-smc-for-pso-smctype-adaptive-10-8-15-12-25-0-test-4-valid-gains-should-pass-valid-controllers-create-smc-for-pso-smctype-classical-10-8-15-12-50-5-create-smc-for-pso-smctype-super-twisting-25-10-15-12-20-15-create-smc-for-pso-smctype-adaptive-10-8-15-12-0-5-create-smc-for-pso-smctype-hybrid-15-12-18-15-assert-len-valid-controllers-4-print-mathematical-constraint-validation-all-tests-passed">runnable: false def validate_mathematical_constraints(): â€œâ€â€ Verify that factory enforces all mathematical constraints correctly. Test Categories: 1. Stability constraints (surface gains &gt; 0) 2. Convergence constraints (Kâ‚ &gt; Kâ‚‚ for STA) 3. Bounded adaptation constraints (Î³ limits) 4. Physical constraints (force saturation) Validation Results: âœ… Constraint enforcement: 100% success rate âœ… Invalid gain rejection: Proper error handling âœ… Boundary condition handling: Correct behavior âœ… Numerical stability: No edge case failures â€œâ€â€ # Test 1: Stability constraints with pytest.raises(ValueError, match=â€stability requiresâ€): # Negative surface gains should be rejected create_smc_for_pso(SMCType.CLASSICAL, [-1, 8, 15, 12, 50, 5]) # Test 2: Super-twisting convergence constraint with pytest.raises(ValueError, match=â€K1 &gt; K2â€): # K1 â‰¤ K2 should be rejected for STA-SMC create_smc_for_pso(SMCType.SUPER_TWISTING, [10, 15, 15, 12, 20, 15]) # Test 3: Adaptive SMC bounds with pytest.raises(ValueError, match=â€adaptation rateâ€): # Î³ &gt; 20.0 should be rejected create_smc_for_pso(SMCType.ADAPTIVE, [10, 8, 15, 12, 25.0]) # Test 4: Valid gains should pass valid_controllers = [ create_smc_for_pso(SMCType.CLASSICAL, [10, 8, 15, 12, 50, 5]), create_smc_for_pso(SMCType.SUPER_TWISTING, [25, 10, 15, 12, 20, 15]), create_smc_for_pso(SMCType.ADAPTIVE, [10, 8, 15, 12, 0.5]), create_smc_for_pso(SMCType.HYBRID, [15, 12, 18, 15]) ] assert len(valid_controllers) == 4 print(â€âœ… Mathematical constraint validation: All tests passedâ€)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../controllers/index.html">Controllers Module Documentation <strong>documentation for sliding mode controllers, factory system, and control primitives</strong></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ğŸ§ª Testing &amp; Quality Assurance</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../testing/index.html">Testing &amp; Quality Assurance</a><input aria-label="Toggle navigation of Testing &amp; Quality Assurance" class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" role="switch" type="checkbox"/><label for="toctree-checkbox-16"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../testing/README.html">Testing Documentation Index ## Overview testing documentation and analysis for the DIP SMC PSO project. This directory contains organized test reports, workflow documentation, standards, and quality gate specifications. ## Directory Structure ```</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html">Testing Framework Technical Guide <strong>DIP-SMC-PSO Project</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#tests-conftest-py">tests/conftest.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#id1">tests/conftest.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#tests-conftest-py-top-of-file-before-any-imports">tests/conftest.py (top of file, before any imports)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#id2">tests/conftest.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#install-pytest-xdist-for-parallel-execution">Install pytest-xdist for parallel execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#run-all-tests">Run all tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#generate-html-coverage-report">Generate HTML coverage report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#open-coverage-html-report-index-html-generate-terminal-coverage-report">Open coverage_html_report/index.html # Generate terminal coverage report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#test-specific-class">Test specific class</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#drop-into-debugger-on-failure">Drop into debugger on failure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html">Testing Workflows &amp; Best Practices <strong>DIP-SMC-PSO Project</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#runnable-false-step-1-red-write-failing-test">runnable: false # Step 1: RED - Write failing test</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#tests-test-controllers-smc-algorithms-classical-test-new-feature-py-def-test-chattering-reduction-effectiveness-test-that-chattering-reduction-algorithm-reduces-control-rate-controller-classicalsmc-gains-10-8-15-12-50-5-max-force-100-boundary-layer-0-01-chattering-reduction-true-new-feature-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-control-history-for-in-range-100-result-controller-compute-control-state-control-result-control-control-history-append-control-calculate-control-rate-control-rate-np-std-np-diff-control-history-should-be-significantly-lower-than-baseline-assert-control-rate-5-0-f-chattering-reduction-ineffective-rate-control-rate-run-test-fails-feature-not-implemented">tests/test_controllers/smc/algorithms/classical/test_new_feature.py def test_chattering_reduction_effectiveness(): â€œâ€â€Test that chattering reduction algorithm reduces control rate.â€â€â€ controller = ClassicalSMC( gains=[10, 8, 15, 12, 50, 5], max_force=100, boundary_layer=0.01, chattering_reduction=True # New feature ) state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) control_history = [] for _ in range(100): result = controller.compute_control(state, {}, {}) control = result[â€˜controlâ€™] control_history.append(control) # Calculate control rate control_rate = np.std(np.diff(control_history)) # Should be significantly lower than baseline assert control_rate &lt; 5.0, fâ€Chattering reduction ineffective: rate={control_rate}â€ # Run test â†’ FAILS (feature not implemented)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#pytest-tests-test-controllers-smc-algorithms-classical-test-new-feature-py-v">pytest tests/test_controllers/smc/algorithms/classical/test_new_feature.py -v</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#runnable-false-step-2-green-implement-minimal-code-to-pass">runnable: false # Step 2: GREEN - Implement minimal code to pass</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#src-controllers-smc-classic-smc-py-class-classicalsmc-def-init-self-gains-max-force-boundary-layer-0-01-chattering-reduction-false-self-gains-gains-self-max-force-max-force-self-boundary-layer-boundary-layer-self-chattering-reduction-chattering-reduction-self-last-control-0-0-def-compute-control-self-state-state-vars-history-existing-smc-logic-control-u-eq-u-switch-u-derivative-if-self-chattering-reduction-simple-low-pass-filter-alpha-0-8-control-alpha-self-last-control-1-alpha-control-self-last-control-control-saturation-control-np-clip-control-self-max-force-self-max-force-return-control-control-run-test-passes">src/controllers/smc/classic_smc.py class ClassicalSMC: def <strong>init</strong>(self, gains, max_force, boundary_layer=0.01, chattering_reduction=False): self.gains = gains self.max_force = max_force self.boundary_layer = boundary_layer self.chattering_reduction = chattering_reduction self.last_control = 0.0 def compute_control(self, state, state_vars, history): # â€¦ existing SMC logic â€¦ control = u_eq + u_switch + u_derivative if self.chattering_reduction: # Simple low-pass filter alpha = 0.8 control = alpha * self.last_control + (1 - alpha) * control self.last_control = control # Saturation control = np.clip(control, -self.max_force, self.max_force) return {â€˜controlâ€™: control} # Run test â†’ PASSES</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#runnable-false-step-3-refactor-clean-up-implementation">runnable: false # Step 3: REFACTOR - Clean up implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#run-full-test-suite-all-pass">Run full test suite â†’ ALL PASS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#runnable-false-step-1-write-interface-tests-first">runnable: false # Step 1: Write interface tests FIRST</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#tests-test-controllers-smc-algorithms-adaptive-sta-test-adaptive-sta-interface-py-class-testadaptivestainterface-test-interface-compliance-for-adaptive-sta-smc-def-test-implements-controller-protocol-self-test-controller-implements-required-protocol-from-src-controllers-interfaces-import-controllerprotocol-controller-adaptivestasmc-gains-20-15-12-10-max-force-100-adaptation-rate-0-5-assert-isinstance-controller-controllerprotocol-assert-hasattr-controller-compute-control-assert-callable-controller-compute-control-def-test-compute-control-signature-self-test-compute-control-has-correct-signature-controller-adaptivestasmc-gains-20-15-12-10-max-force-100-state-np-zeros-6-result-controller-compute-control-state-assert-isinstance-result-dict-assert-control-in-result-assert-isinstance-result-control-int-float-np-ndarray-step-2-write-functionality-tests">tests/test_controllers/smc/algorithms/adaptive_sta/test_adaptive_sta_interface.py class TestAdaptiveSTAInterface: â€œâ€â€Test interface compliance for Adaptive STA SMC.â€â€â€ def test_implements_controller_protocol(self): â€œâ€â€Test controller implements required protocol.â€â€â€ from src.controllers.interfaces import ControllerProtocol controller = AdaptiveSTASMC( gains=[20, 15, 12, 10], max_force=100, adaptation_rate=0.5 ) assert isinstance(controller, ControllerProtocol) assert hasattr(controller, â€˜compute_controlâ€™) assert callable(controller.compute_control) def test_compute_control_signature(self): â€œâ€â€Test compute_control has correct signature.â€â€â€ controller = AdaptiveSTASMC(gains=[20,15,12,10], max_force=100) state = np.zeros(6) result = controller.compute_control(state, {}, {}) assert isinstance(result, dict) assert â€˜controlâ€™ in result assert isinstance(result[â€˜controlâ€™], (int, float, np.ndarray)) # Step 2: Write functionality tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#src-controllers-smc-algorithms-adaptive-sta-adaptive-sta-smc-py-class-adaptivestasmc-adaptive-super-twisting-sliding-mode-controller-def-init-self-gains-max-force-adaptation-rate-0-5-self-initial-gains-np-array-gains-self-current-gains-self-initial-gains-copy-self-max-force-max-force-self-adaptation-rate-adaptation-rate-def-compute-control-self-state-state-vars-history-super-twisting-control-logic-adaptive-gain-update-return-control-control-def-get-current-gains-self-return-self-current-gains-copy">src/controllers/smc/algorithms/adaptive_sta/adaptive_sta_smc.py class AdaptiveSTASMC: â€œâ€â€Adaptive Super-Twisting Sliding Mode Controller.â€â€â€ def <strong>init</strong>(self, gains, max_force, adaptation_rate=0.5): self.initial_gains = np.array(gains) self.current_gains = self.initial_gains.copy() self.max_force = max_force self.adaptation_rate = adaptation_rate def compute_control(self, state, state_vars, history): # â€¦ Super-twisting control logic â€¦ # â€¦ Adaptive gain update â€¦ return {â€˜controlâ€™: control} def get_current_gains(self): return self.current_gains.copy()</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#level-1-component-level-tests">Level 1: Component-level tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#run-specific-failing-test-with-maximum-verbosity">1. Run specific failing test with maximum verbosity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#tests-test-property-based-debug-py">tests/test_property_based_debug.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#reproduce-failure-6-82-0-b-aaaa-to-reproduce">@reproduce_failure(â€˜6.82.0â€™, bâ€™AAAAâ€¦â€™) to reproduce</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#quick-test-while-developing">Quick test while developing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#full-validation-checklist">Full validation checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#by-marker">By marker</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#auto-detect-cpu-cores">Auto-detect CPU cores</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html">Benchmarking Framework Technical Guide <strong>DIP-SMC-PSO Project</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#benchmarks-integration-numerical-methods-py-class-eulerintegrator-forward-euler-integration-method-first-order-accurate-o-h-def-init-self-dynamics-self-dynamics-dynamics-def-integrate-self-x0-np-ndarray-t-span-tuple-dt-float-controller-optional-any-none-dict-integrate-dynamics-using-forward-euler-parameters-x0-np-ndarray-initial-state-t-span-tuple-t-start-t-end-dt-float-time-step-controller-object-optional-controller-for-closed-loop-simulation-returns-dict-t-time-vector-x-state-history-u-control-history-if-controller-provided-t-start-t-end-t-span-t-np-arange-t-start-t-end-dt-dt-n-steps-len-t-x-np-zeros-n-steps-len-x0-x-0-x0-if-controller-u-np-zeros-n-steps-1-for-i-in-range-n-steps-1-if-controller-result-controller-compute-control-x-i-u-i-result-get-control-output-result-get-control-0-0-x-dot-self-dynamics-dynamics-x-i-u-i-else-x-dot-self-dynamics-dynamics-x-i-0-0-x-i-1-x-i-dt-x-dot-result-t-t-x-x-if-controller-result-u-u-return-result-class-rk4integrator-fourth-order-runge-kutta-integration-fourth-order-accurate-o-h4-def-init-self-dynamics-self-dynamics-dynamics-def-integrate-self-x0-np-ndarray-t-span-tuple-dt-float-controller-optional-any-none-dict-integrate-using-rk4-method-t-start-t-end-t-span-t-np-arange-t-start-t-end-dt-dt-n-steps-len-t-x-np-zeros-n-steps-len-x0-x-0-x0-if-controller-u-np-zeros-n-steps-1-for-i-in-range-n-steps-1-if-controller-result-controller-compute-control-x-i-u-i-result-get-control-output-result-get-control-0-0-u-current-u-i-else-u-current-0-0-rk4-stages-k1-self-dynamics-dynamics-x-i-u-current-k2-self-dynamics-dynamics-x-i-0-5dtk1-u-current-k3-self-dynamics-dynamics-x-i-0-5dtk2-u-current-k4-self-dynamics-dynamics-x-i-dtk3-u-current-x-i-1-x-i-dt-6-k1-2k2-2-k3-k4-result-t-t-x-x-if-controller-result-u-u-return-result-class-adaptiverk45integrator-adaptive-runge-kutta-4-5-method-dormand-prince-variable-step-size-for-error-control-def-init-self-dynamics-self-dynamics-dynamics-def-integrate-self-x0-np-ndarray-t-span-tuple-rtol-float-1e-6-atol-float-1e-9-controller-optional-any-none-dict-integrate-using-adaptive-rk45-from-scipy-integrate-import-solve-ivp-if-controller-def-dynamics-func-t-x-result-controller-compute-control-x-u-result-get-control-output-result-get-control-0-0-return-self-dynamics-dynamics-x-u-else-def-dynamics-func-t-x-return-self-dynamics-dynamics-x-0-0-sol-solve-ivp-dynamics-func-t-span-x0-method-rk45-rtol-rtol-atol-atol-return-t-sol-t-x-sol-y-t">benchmarks/integration/numerical_methods.py class EulerIntegrator: â€œâ€â€Forward Euler integration method. First-order accurate: O(h) â€œâ€â€ def <strong>init</strong>(self, dynamics): self.dynamics = dynamics def integrate(self, x0: np.ndarray, t_span: tuple, dt: float, controller: Optional[Any] = None) -&gt; dict: â€œâ€â€Integrate dynamics using Forward Euler. Parameters â€”â€”â€”- x0 : np.ndarray Initial state t_span : tuple (t_start, t_end) dt : float Time step controller : object, optional Controller for closed-loop simulation Returns â€”â€”- dict { â€˜tâ€™: time vector, â€˜xâ€™: state history, â€˜uâ€™: control history (if controller provided) } â€œâ€â€ t_start, t_end = t_span t = np.arange(t_start, t_end + dt, dt) n_steps = len(t) x = np.zeros((n_steps, len(x0))) x[0] = x0 if controller: u = np.zeros(n_steps - 1) for i in range(n_steps - 1): if controller: result = controller.compute_control(x[i], {}, {}) u[i] = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, 0.0)) x_dot = self.dynamics.dynamics(x[i], u[i]) else: x_dot = self.dynamics.dynamics(x[i], 0.0) x[i+1] = x[i] + dt * x_dot result = {â€˜tâ€™: t, â€˜xâ€™: x} if controller: result[â€˜uâ€™] = u return result class RK4Integrator: â€œâ€â€Fourth-order Runge-Kutta integration. Fourth-order accurate: O(hâ´) â€œâ€â€ def <strong>init</strong>(self, dynamics): self.dynamics = dynamics def integrate(self, x0: np.ndarray, t_span: tuple, dt: float, controller: Optional[Any] = None) -&gt; dict: â€œâ€â€Integrate using RK4 method.â€â€â€ t_start, t_end = t_span t = np.arange(t_start, t_end + dt, dt) n_steps = len(t) x = np.zeros((n_steps, len(x0))) x[0] = x0 if controller: u = np.zeros(n_steps - 1) for i in range(n_steps - 1): if controller: result = controller.compute_control(x[i], {}, {}) u[i] = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, 0.0)) u_current = u[i] else: u_current = 0.0 # RK4 stages k1 = self.dynamics.dynamics(x[i], u_current) k2 = self.dynamics.dynamics(x[i] + 0.5<em>dt</em>k1, u_current) k3 = self.dynamics.dynamics(x[i] + 0.5<em>dt</em>k2, u_current) k4 = self.dynamics.dynamics(x[i] + dt<em>k3, u_current) x[i+1] = x[i] + (dt/6) * (k1 + 2</em>k2 + 2*k3 + k4) result = {â€˜tâ€™: t, â€˜xâ€™: x} if controller: result[â€˜uâ€™] = u return result class AdaptiveRK45Integrator: â€œâ€â€Adaptive Runge-Kutta 4-5 method (Dormand-Prince). Variable step size for error control. â€œâ€â€ def <strong>init</strong>(self, dynamics): self.dynamics = dynamics def integrate(self, x0: np.ndarray, t_span: tuple, rtol: float = 1e-6, atol: float = 1e-9, controller: Optional[Any] = None) -&gt; dict: â€œâ€â€Integrate using adaptive RK45.â€â€â€ from scipy.integrate import solve_ivp if controller: def dynamics_func(t, x): result = controller.compute_control(x, {}, {}) u = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, 0.0)) return self.dynamics.dynamics(x, u) else: def dynamics_func(t, x): return self.dynamics.dynamics(x, 0.0) sol = solve_ivp( dynamics_func, t_span, x0, method=â€™RK45â€™, rtol=rtol, atol=atol ) return { â€˜tâ€™: sol.t, â€˜xâ€™: sol.y.T }</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#runnable-false-benchmarks-analysis-accuracy-metrics-py-def-compute-energy-conservation-t-np-ndarray-x-np-ndarray-physics-params-dict-dict-analyze-energy-conservation-for-hamiltonian-systems-parameters-t-np-ndarray-time-vector-x-np-ndarray-state-trajectories-physics-params-dict-physics-parameters-returns-dict-initial-energy-float-final-energy-float-max-drift-float-relative-drift-float-def-compute-energy-state-kinetic-energy-x-dot-theta1-dot-theta2-dot-state-3-state-4-state-5-ke-0-5-physics-params-m-x-dot-2-cart-pendulum-kinetic-energy-potential-energy-theta1-theta2-state-1-state-2-pe-physics-params-m1-physics-params-g-physics-params-l1-1-np-cos-theta1-second-pendulum-pe-return-ke-pe-energies-np-array-compute-energy-state-for-state-in-x-initial-energy-energies-0-final-energy-energies-1-max-drift-np-max-np-abs-energies-initial-energy-relative-drift-max-drift-initial-energy-if-initial-energy-0-else-np-inf-return-initial-energy-float-initial-energy-final-energy-float-final-energy-max-drift-float-max-drift-relative-drift-float-relative-drift-energies-energies-def-estimate-convergence-order-integrator-x0-np-ndarray-t-span-tuple-dt-values-list-float-dict-estimate-numerical-convergence-order-uses-richardson-extrapolation-to-estimate-p-in-e-h-ch-p-parameters-integrator-object-integration-method-instance-x0-np-ndarray-initial-state-t-span-tuple-time-span-dt-values-list-of-float-decreasing-time-steps-for-convergence-analysis-returns-dict-convergence-order-float-errors-list-of-float-dt-values-list-of-float-get-reference-solution-finest-dt-ref-dt-min-dt-values-4-ref-result-integrator-integrate-x0-t-span-ref-dt-ref-x-final-ref-result-x-1-errors-for-dt-in-dt-values-result-integrator-integrate-x0-t-span-dt-x-final-result-x-1-error-np-linalg-norm-x-final-ref-x-final-errors-append-error-estimate-convergence-order-p-log-e-h1-e-h2-log-h1-h2-orders-for-i-in-range-len-errors-1-if-errors-i-1-0-order-np-log-errors-i-errors-i-1-np-log-dt-values-i-dt-values-i-1-orders-append-order-avg-order-np-mean-orders-if-orders-else-np-nan-return-convergence-order-float-avg-order-errors-float-e-for-e-in-errors-dt-values-dt-values">runnable: false # benchmarks/analysis/accuracy_metrics.py def compute_energy_conservation(t: np.ndarray, x: np.ndarray, physics_params: dict) -&gt; dict: â€œâ€â€Analyze energy conservation for Hamiltonian systems. Parameters â€”â€”â€”- t : np.ndarray Time vector x : np.ndarray State trajectories physics_params : dict Physics parameters Returns â€”â€”- dict { â€˜initial_energyâ€™: float, â€˜final_energyâ€™: float, â€˜max_driftâ€™: float, â€˜relative_driftâ€™: float } â€œâ€â€ def compute_energy(state): # Kinetic energy x_dot, theta1_dot, theta2_dot = state[3], state[4], state[5] KE = 0.5 * physics_params[â€˜Mâ€™] * x_dot**2 # Cart # â€¦ (pendulum kinetic energy) # Potential energy theta1, theta2 = state[1], state[2] PE = physics_params[â€˜m1â€™] * physics_params[â€˜gâ€™] * physics_params[â€˜L1â€™] * (1 - np.cos(theta1)) # â€¦ (second pendulum PE) return KE + PE energies = np.array([compute_energy(state) for state in x]) initial_energy = energies[0] final_energy = energies[-1] max_drift = np.max(np.abs(energies - initial_energy)) relative_drift = max_drift / initial_energy if initial_energy != 0 else np.inf return { â€˜initial_energyâ€™: float(initial_energy), â€˜final_energyâ€™: float(final_energy), â€˜max_driftâ€™: float(max_drift), â€˜relative_driftâ€™: float(relative_drift), â€˜energiesâ€™: energies } def estimate_convergence_order(integrator, x0: np.ndarray, t_span: tuple, dt_values: List[float]) -&gt; dict: â€œâ€â€Estimate numerical convergence order. Uses Richardson extrapolation to estimate p in: e_h = CÂ·h^p Parameters â€”â€”â€”- integrator : object Integration method instance x0 : np.ndarray Initial state t_span : tuple Time span dt_values : list of float Decreasing time steps for convergence analysis Returns â€”â€”- dict { â€˜convergence_orderâ€™: float, â€˜errorsâ€™: list of float, â€˜dt_valuesâ€™: list of float } â€œâ€â€ # Get reference solution (finest dt) ref_dt = min(dt_values) / 4 ref_result = integrator.integrate(x0, t_span, ref_dt) ref_x_final = ref_result[â€˜xâ€™][-1] errors = [] for dt in dt_values: result = integrator.integrate(x0, t_span, dt) x_final = result[â€˜xâ€™][-1] error = np.linalg.norm(x_final - ref_x_final) errors.append(error) # Estimate convergence order: p = log(e_h1/e_h2) / log(h1/h2) orders = [] for i in range(len(errors) - 1): if errors[i+1] &gt; 0: order = np.log(errors[i] / errors[i+1]) / np.log(dt_values[i] / dt_values[i+1]) orders.append(order) avg_order = np.mean(orders) if orders else np.nan return { â€˜convergence_orderâ€™: float(avg_order), â€˜errorsâ€™: [float(e) for e in errors], â€˜dt_valuesâ€™: dt_values }</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#benchmarks-comparison-method-comparison-py-class-integrationmethodcomparator-systematic-comparison-of-integration-methods-def-init-self-dynamics-physics-params-dict-self-dynamics-dynamics-self-physics-params-physics-params-def-compare-methods-self-methods-list-str-x0-np-ndarray-t-span-tuple-dt-values-list-float-dict-compare-multiple-integration-methods-parameters-methods-list-of-str-method-names-euler-rk4-rk45-x0-np-ndarray-initial-state-t-span-tuple-time-span-dt-values-list-of-float-time-steps-to-test-returns-dict-comparison-results-for-all-methods-from-benchmarks-integration-import-eulerintegrator-rk4integrator-adaptiverk45integrator-from-benchmarks-analysis-import-compute-energy-conservation-estimate-convergence-order-integrators-euler-eulerintegrator-self-dynamics-rk4-rk4integrator-self-dynamics-rk45-adaptiverk45integrator-self-dynamics-results-for-method-name-in-methods-integrator-integrators-method-name-convergence-analysis-convergence-estimate-convergence-order-integrator-x0-t-span-dt-values-energy-conservation-for-frictionless-system-result-integrator-integrate-x0-t-span-dt-min-dt-values-energy-analysis-compute-energy-conservation-result-t-result-x-self-physics-params-performance-measurement-import-time-start-time-time-integrator-integrate-x0-t-span-dt-min-dt-values-elapsed-time-time-start-results-method-name-convergence-order-convergence-convergence-order-energy-drift-energy-analysis-relative-drift-computation-time-elapsed-errors-convergence-errors-return-results">benchmarks/comparison/method_comparison.py class IntegrationMethodComparator: â€œâ€â€Systematic comparison of integration methods.â€â€â€ def <strong>init</strong>(self, dynamics, physics_params: dict): self.dynamics = dynamics self.physics_params = physics_params def compare_methods(self, methods: List[str], x0: np.ndarray, t_span: tuple, dt_values: List[float]) -&gt; dict: â€œâ€â€Compare multiple integration methods. Parameters â€”â€”â€”- methods : list of str Method names: [â€˜Eulerâ€™, â€˜RK4â€™, â€˜RK45â€™] x0 : np.ndarray Initial state t_span : tuple Time span dt_values : list of float Time steps to test Returns â€”â€”- dict Comparison results for all methods â€œâ€â€ from benchmarks.integration import EulerIntegrator, RK4Integrator, AdaptiveRK45Integrator from benchmarks.analysis import compute_energy_conservation, estimate_convergence_order integrators = { â€˜Eulerâ€™: EulerIntegrator(self.dynamics), â€˜RK4â€™: RK4Integrator(self.dynamics), â€˜RK45â€™: AdaptiveRK45Integrator(self.dynamics) } results = {} for method_name in methods: integrator = integrators[method_name] # Convergence analysis convergence = estimate_convergence_order(integrator, x0, t_span, dt_values) # Energy conservation (for frictionless system) result = integrator.integrate(x0, t_span, dt=min(dt_values)) energy_analysis = compute_energy_conservation( result[â€˜tâ€™], result[â€˜xâ€™], self.physics_params ) # Performance measurement import time start = time.time() _ = integrator.integrate(x0, t_span, dt=min(dt_values)) elapsed = time.time() - start results[method_name] = { â€˜convergence_orderâ€™: convergence[â€˜convergence_orderâ€™], â€˜energy_driftâ€™: energy_analysis[â€˜relative_driftâ€™], â€˜computation_timeâ€™: elapsed, â€˜errorsâ€™: convergence[â€˜errorsâ€™] } return results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#config-yaml-benchmark-configuration-benchmarks-statistical-n-trials-30-clt-compliance-confidence-level-0-95-95-ci-seed-42-reproducibility-physics-uncertainty-enabled-true-n-scenarios-10-variations-cart-mass-0-05-5-pendulum1-mass-0-10-10-pendulum2-mass-0-10-10-pendulum1-length-0-05-5-pendulum2-length-0-05-5-friction-cart-0-20-20-sensor-noise-enabled-false-std-position-0-001-1mm-std-angle-0-001-0-06-integration-methods-euler-rk4-rk45-dt-values-0-05-0-01-0-005-0-001-convergence-analysis-true-energy-conservation-check-true-performance-regression-threshold-0-05-5-slowdown-alert-baseline-file-benchmarks-baseline-json">config.yaml - Benchmark configuration benchmarks: statistical: n_trials: 30 # CLT compliance confidence_level: 0.95 # 95% CI seed: 42 # Reproducibility physics_uncertainty: enabled: true n_scenarios: 10 variations: cart_mass: 0.05 # Â±5% pendulum1_mass: 0.10 # Â±10% pendulum2_mass: 0.10 # Â±10% pendulum1_length: 0.05 # Â±5% pendulum2_length: 0.05 # Â±5% friction_cart: 0.20 # Â±20% sensor_noise: enabled: false std_position: 0.001 # 1mm std_angle: 0.001 # ~0.06Â° integration: methods: [â€˜Eulerâ€™, â€˜RK4â€™, â€˜RK45â€™] dt_values: [0.05, 0.01, 0.005, 0.001] convergence_analysis: true energy_conservation_check: true performance: regression_threshold: 0.05 # 5% slowdown alert baseline_file: â€˜benchmarks/baseline.jsonâ€™</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/validation_methodology_guide.html">Validation Methodology Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html">Control Systems Unit Testing Guide ## Overview This guide provides testing patterns for sliding mode control (SMC) implementations in the double-inverted pendulum control system. It covers state space validation, controller interface compliance, optimal gains interpretation, and production-ready testing methodologies. ## Table of Contents 1. <span class="xref myst">SMC Controller Testing Patterns</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#runnable-false-def-test-classical-smc-initialization-test-classical-smc-initialization-with-valid-parameters-optimal-gains-from-pso-optimization-report-log-line-2-gains-77-62-44-45-17-31-14-25-18-66-9-76-boundary-layer-9-76-matched-to-kd-for-chattering-reduction-max-force-20-0-controller-classicalsmc-gains-gains-max-force-max-force-boundary-layer-boundary-layer-switch-method-tanh-verify-gains-unpacked-correctly-assert-controller-k1-pytest-approx-77-62-rel-1e-6-assert-controller-k2-pytest-approx-44-45-rel-1e-6-assert-controller-lam1-pytest-approx-17-31-rel-1e-6-assert-controller-lam2-pytest-approx-14-25-rel-1e-6-assert-controller-k-pytest-approx-18-66-rel-1e-6-assert-controller-kd-pytest-approx-9-76-rel-1e-6-verify-boundary-layer-for-chattering-reduction-assert-controller-epsilon0-pytest-approx-9-76-verify-control-authority-limits-assert-controller-max-force-20-0">runnable: false def test_classical_smc_initialization(): â€œâ€â€Test Classical SMC initialization with valid parameters.â€â€â€ # Optimal gains from PSO optimization (report.log line 2) gains = [77.62, 44.45, 17.31, 14.25, 18.66, 9.76] boundary_layer = 9.76 # Matched to kd for chattering reduction max_force = 20.0 controller = ClassicalSMC( gains=gains, max_force=max_force, boundary_layer=boundary_layer, switch_method=â€™tanhâ€™ ) # Verify gains unpacked correctly assert controller.k1 == pytest.approx(77.62, rel=1e-6) assert controller.k2 == pytest.approx(44.45, rel=1e-6) assert controller.lam1 == pytest.approx(17.31, rel=1e-6) assert controller.lam2 == pytest.approx(14.25, rel=1e-6) assert controller.K == pytest.approx(18.66, rel=1e-6) assert controller.kd == pytest.approx(9.76, rel=1e-6) # Verify boundary layer for chattering reduction assert controller.epsilon0 == pytest.approx(9.76) # Verify control authority limits assert controller.max_force == 20.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#runnable-false-def-test-lyapunov-decrease-property-test-lyapunov-decrease-property-v-0-when-0-controller-create-test-controller-test-states-with-non-zero-sliding-surface-values-test-states-np-array-0-0-0-1-0-0-0-0-0-0-0-0-pendulum-1-displaced-np-array-0-0-0-0-0-1-0-0-0-0-0-0-pendulum-2-displaced-np-array-0-0-0-05-0-05-0-0-0-1-0-1-both-displaced-with-velocity-history-for-state-in-test-states-result-controller-compute-control-state-history-extract-sliding-surface-from-history-assert-sigma-in-history-sigma-history-sigma-1-lyapunov-function-v-0-5-sigma-2-v-0-5-sigma-2-for-non-zero-sigma-ensure-control-acts-to-reduce-v-if-abs-sigma-1e-6-control-should-oppose-sigma-to-drive-v-0-for-classical-smc-u-u-eq-ksat-kd-the-robust-term-k-sat-should-have-opposite-sign-to">runnable: false def test_lyapunov_decrease_property(): â€œâ€â€Test Lyapunov decrease property: VÌ‡ &lt; 0 when |Ïƒ| &gt; 0.â€â€â€ controller = create_test_controller() # Test states with non-zero sliding surface values test_states = [ np.array([0.0, 0.1, 0.0, 0.0, 0.0, 0.0]), # Pendulum 1 displaced np.array([0.0, 0.0, 0.1, 0.0, 0.0, 0.0]), # Pendulum 2 displaced np.array([0.0, 0.05, 0.05, 0.0, 0.1, 0.1]), # Both displaced with velocity ] history = {} for state in test_states: result = controller.compute_control(state, (), history) # Extract sliding surface from history assert â€˜sigmaâ€™ in history sigma = history[â€˜sigmaâ€™][-1] # Lyapunov function V = 0.5 * sigma^2 V = 0.5 * sigma**2 # For non-zero sigma, ensure control acts to reduce V if abs(sigma) &gt; 1e-6: # Control should oppose sigma to drive VÌ‡ &lt; 0 # For classical SMC: u = u_eq - K<em>sat(Ïƒ/Îµ) - kd</em>Ïƒ # The robust term -K*sat(Ïƒ/Îµ) should have opposite sign to Ïƒ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#runnable-false-def-test-controller-interface-compliance-test-compliance-with-basecontroller-interface-controller-create-test-controller-test-required-properties-assert-hasattr-controller-gains-must-expose-gains-property-assert-hasattr-controller-n-gains-must-declare-n-gains-for-pso-assert-controller-n-gains-6-classical-smc-requires-6-gains-test-required-methods-assert-hasattr-controller-compute-control-must-implement-compute-control-assert-hasattr-controller-reset-must-implement-reset-assert-hasattr-controller-initialize-state-must-implement-initialize-state-assert-hasattr-controller-initialize-history-must-implement-initialize-history-test-gains-property-returns-copy-gains1-controller-gains-gains2-controller-gains-assert-gains1-gains2-gains-should-be-consistent-gains1-0-999-0-try-to-mutate-assert-controller-gains-0-999-0-gains-property-should-return-copy">runnable: false def test_controller_interface_compliance(): â€œâ€â€Test compliance with BaseController interface.â€â€â€ controller = create_test_controller() # Test required properties assert hasattr(controller, â€˜gainsâ€™), â€œMust expose gains propertyâ€ assert hasattr(controller, â€˜n_gainsâ€™), â€œMust declare n_gains for PSOâ€ assert controller.n_gains == 6, â€œClassical SMC requires 6 gainsâ€ # Test required methods assert hasattr(controller, â€˜compute_controlâ€™), â€œMust implement compute_controlâ€ assert hasattr(controller, â€˜resetâ€™), â€œMust implement resetâ€ assert hasattr(controller, â€˜initialize_stateâ€™), â€œMust implement initialize_stateâ€ assert hasattr(controller, â€˜initialize_historyâ€™), â€œMust implement initialize_historyâ€ # Test gains property returns copy gains1 = controller.gains gains2 = controller.gains assert gains1 == gains2, â€œGains should be consistentâ€ gains1[0] = 999.0 # Try to mutate assert controller.gains[0] != 999.0, â€œGains property should return copyâ€</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#runnable-false-def-test-history-telemetry-test-that-controller-properly-tracks-telemetry-in-history-controller-create-test-controller-state-np-array-0-1-0-2-0-1-0-0-0-3-0-2-history-result-controller-compute-control-state-history-verify-all-required-telemetry-is-tracked-required-keys-sigma-epsilon-eff-u-eq-u-robust-u-total-u-for-key-in-required-keys-assert-key-in-history-f-missing-required-history-key-key-assert-len-history-key-1-f-history-key-key-should-have-1-entry-run-multiple-steps-and-verify-accumulation-for-in-range-5-controller-compute-control-state-history-for-key-in-required-keys-assert-len-history-key-6-f-history-key-key-should-accumulate-expected-6-got-len-history-key">runnable: false def test_history_telemetry(): â€œâ€â€Test that controller properly tracks telemetry in history.â€â€â€ controller = create_test_controller() state = np.array([0.1, 0.2, -0.1, 0.0, 0.3, -0.2]) history = {} result = controller.compute_control(state, (), history) # Verify all required telemetry is tracked required_keys = [â€˜sigmaâ€™, â€˜epsilon_effâ€™, â€˜u_eqâ€™, â€˜u_robustâ€™, â€˜u_totalâ€™, â€˜uâ€™] for key in required_keys: assert key in history, fâ€Missing required history key: {key}â€ assert len(history[key]) == 1, fâ€History key {key} should have 1 entryâ€ # Run multiple steps and verify accumulation for _ in range(5): controller.compute_control(state, (), history) for key in required_keys: assert len(history[key]) == 6, \ fâ€History key {key} should accumulate (expected 6, got {len(history[key])})â€</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#runnable-false-def-create-test-controller-create-controller-with-optimal-gains-for-testing-optimal-gains-77-62-44-45-17-31-14-25-18-66-9-76-return-classicalsmc-gains-optimal-gains-max-force-20-0-boundary-layer-9-76-switch-method-tanh-regularization-1e-10">runnable: false def create_test_controller(): â€œâ€â€Create controller with optimal gains for testing.â€â€â€ optimal_gains = [77.62, 44.45, 17.31, 14.25, 18.66, 9.76] return ClassicalSMC( gains=optimal_gains, max_force=20.0, boundary_layer=9.76, switch_method=â€™tanhâ€™, regularization=1e-10 )</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/test_infrastructure_guide.html">Test Infrastructure Guide ## Overview This document provides guidance for the DIP SMC PSO test infrastructure, including pytest configuration, test execution procedures, and troubleshooting guidelines. ## Pytest Configuration ### Test Markers The project uses an extensive set of pytest markers for test categorization: #### Core Test Categories</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/test_infrastructure_guide.html#run-all-tests">Run all tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/test_infrastructure_guide.html#parallel-execution-if-pytest-xdist-installed">Parallel execution (if pytest-xdist installed)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/property_based_testing.html">Property-Based Testing for Control Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/integration_workflows.html">Integration Testing Workflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/performance_benchmarking.html">Performance Benchmarking Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/coverage_quality_gates_runbook.html">Coverage Quality Gates Runbook</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/coverage_quality_gates_troubleshooting.html">Coverage Quality Gates Troubleshooting Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/coverage_quality_gates_troubleshooting.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/coverage_quality_gates_troubleshooting.html#runnable-false-def-calculate-coverage-production-score-gate-results-calculate-coverage-contribution-to-overall-production-readiness-score-current-production-readiness-6-1-10-target-production-readiness-8-5-10-coverage-weight-25-of-total-score-weights-infrastructure-health-0-15-safety-critical-coverage-0-40-highest-weight-critical-components-coverage-0-25-overall-coverage-0-20-coverage-score-0-0-for-gate-id-weight-in-weights-items-if-gate-results-get-gate-id-get-status-passed-coverage-score-weight-scale-to-0-10-production-contribution-coverage-score-10-return-coverage-production-score-production-contribution-production-ready-production-contribution-8-0-improvement-needed-max-0-8-0-production-contribution">runnable: false def calculate_coverage_production_score(gate_results): â€œâ€â€ Calculate coverage contribution to overall production readiness score. Current Production Readiness: 6.1/10 Target Production Readiness: 8.5/10 Coverage Weight: 25% of total score â€œâ€â€ weights = { â€˜infrastructure_healthâ€™: 0.15, â€˜safety_critical_coverageâ€™: 0.40, # Highest weight â€˜critical_components_coverageâ€™: 0.25, â€˜overall_coverageâ€™: 0.20 } coverage_score = 0.0 for gate_id, weight in weights.items(): if gate_results.get(gate_id, {}).get(â€˜statusâ€™) == â€˜passedâ€™: coverage_score += weight # Scale to 0-10 production_contribution = coverage_score * 10 return { â€˜coverage_production_scoreâ€™: production_contribution, â€˜production_readyâ€™: production_contribution &gt;= 8.0, â€˜improvement_neededâ€™: max(0, 8.0 - production_contribution) }</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/coverage_local_development_guide.html">Coverage Local Development Integration Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/coverage_integration_summary.html">Coverage Quality Gates Integration Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/coverage_baseline.html">Coverage Baseline Report <strong>Generated:</strong> 2025-10-05</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/integration_workflows.html">Integration Testing Workflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/performance_benchmarking.html">Performance Benchmarking Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html">Benchmarking Framework Technical Guide <strong>DIP-SMC-PSO Project</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#benchmarks-integration-numerical-methods-py-class-eulerintegrator-forward-euler-integration-method-first-order-accurate-o-h-def-init-self-dynamics-self-dynamics-dynamics-def-integrate-self-x0-np-ndarray-t-span-tuple-dt-float-controller-optional-any-none-dict-integrate-dynamics-using-forward-euler-parameters-x0-np-ndarray-initial-state-t-span-tuple-t-start-t-end-dt-float-time-step-controller-object-optional-controller-for-closed-loop-simulation-returns-dict-t-time-vector-x-state-history-u-control-history-if-controller-provided-t-start-t-end-t-span-t-np-arange-t-start-t-end-dt-dt-n-steps-len-t-x-np-zeros-n-steps-len-x0-x-0-x0-if-controller-u-np-zeros-n-steps-1-for-i-in-range-n-steps-1-if-controller-result-controller-compute-control-x-i-u-i-result-get-control-output-result-get-control-0-0-x-dot-self-dynamics-dynamics-x-i-u-i-else-x-dot-self-dynamics-dynamics-x-i-0-0-x-i-1-x-i-dt-x-dot-result-t-t-x-x-if-controller-result-u-u-return-result-class-rk4integrator-fourth-order-runge-kutta-integration-fourth-order-accurate-o-h4-def-init-self-dynamics-self-dynamics-dynamics-def-integrate-self-x0-np-ndarray-t-span-tuple-dt-float-controller-optional-any-none-dict-integrate-using-rk4-method-t-start-t-end-t-span-t-np-arange-t-start-t-end-dt-dt-n-steps-len-t-x-np-zeros-n-steps-len-x0-x-0-x0-if-controller-u-np-zeros-n-steps-1-for-i-in-range-n-steps-1-if-controller-result-controller-compute-control-x-i-u-i-result-get-control-output-result-get-control-0-0-u-current-u-i-else-u-current-0-0-rk4-stages-k1-self-dynamics-dynamics-x-i-u-current-k2-self-dynamics-dynamics-x-i-0-5dtk1-u-current-k3-self-dynamics-dynamics-x-i-0-5dtk2-u-current-k4-self-dynamics-dynamics-x-i-dtk3-u-current-x-i-1-x-i-dt-6-k1-2k2-2-k3-k4-result-t-t-x-x-if-controller-result-u-u-return-result-class-adaptiverk45integrator-adaptive-runge-kutta-4-5-method-dormand-prince-variable-step-size-for-error-control-def-init-self-dynamics-self-dynamics-dynamics-def-integrate-self-x0-np-ndarray-t-span-tuple-rtol-float-1e-6-atol-float-1e-9-controller-optional-any-none-dict-integrate-using-adaptive-rk45-from-scipy-integrate-import-solve-ivp-if-controller-def-dynamics-func-t-x-result-controller-compute-control-x-u-result-get-control-output-result-get-control-0-0-return-self-dynamics-dynamics-x-u-else-def-dynamics-func-t-x-return-self-dynamics-dynamics-x-0-0-sol-solve-ivp-dynamics-func-t-span-x0-method-rk45-rtol-rtol-atol-atol-return-t-sol-t-x-sol-y-t">benchmarks/integration/numerical_methods.py class EulerIntegrator: â€œâ€â€Forward Euler integration method. First-order accurate: O(h) â€œâ€â€ def <strong>init</strong>(self, dynamics): self.dynamics = dynamics def integrate(self, x0: np.ndarray, t_span: tuple, dt: float, controller: Optional[Any] = None) -&gt; dict: â€œâ€â€Integrate dynamics using Forward Euler. Parameters â€”â€”â€”- x0 : np.ndarray Initial state t_span : tuple (t_start, t_end) dt : float Time step controller : object, optional Controller for closed-loop simulation Returns â€”â€”- dict { â€˜tâ€™: time vector, â€˜xâ€™: state history, â€˜uâ€™: control history (if controller provided) } â€œâ€â€ t_start, t_end = t_span t = np.arange(t_start, t_end + dt, dt) n_steps = len(t) x = np.zeros((n_steps, len(x0))) x[0] = x0 if controller: u = np.zeros(n_steps - 1) for i in range(n_steps - 1): if controller: result = controller.compute_control(x[i], {}, {}) u[i] = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, 0.0)) x_dot = self.dynamics.dynamics(x[i], u[i]) else: x_dot = self.dynamics.dynamics(x[i], 0.0) x[i+1] = x[i] + dt * x_dot result = {â€˜tâ€™: t, â€˜xâ€™: x} if controller: result[â€˜uâ€™] = u return result class RK4Integrator: â€œâ€â€Fourth-order Runge-Kutta integration. Fourth-order accurate: O(hâ´) â€œâ€â€ def <strong>init</strong>(self, dynamics): self.dynamics = dynamics def integrate(self, x0: np.ndarray, t_span: tuple, dt: float, controller: Optional[Any] = None) -&gt; dict: â€œâ€â€Integrate using RK4 method.â€â€â€ t_start, t_end = t_span t = np.arange(t_start, t_end + dt, dt) n_steps = len(t) x = np.zeros((n_steps, len(x0))) x[0] = x0 if controller: u = np.zeros(n_steps - 1) for i in range(n_steps - 1): if controller: result = controller.compute_control(x[i], {}, {}) u[i] = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, 0.0)) u_current = u[i] else: u_current = 0.0 # RK4 stages k1 = self.dynamics.dynamics(x[i], u_current) k2 = self.dynamics.dynamics(x[i] + 0.5<em>dt</em>k1, u_current) k3 = self.dynamics.dynamics(x[i] + 0.5<em>dt</em>k2, u_current) k4 = self.dynamics.dynamics(x[i] + dt<em>k3, u_current) x[i+1] = x[i] + (dt/6) * (k1 + 2</em>k2 + 2*k3 + k4) result = {â€˜tâ€™: t, â€˜xâ€™: x} if controller: result[â€˜uâ€™] = u return result class AdaptiveRK45Integrator: â€œâ€â€Adaptive Runge-Kutta 4-5 method (Dormand-Prince). Variable step size for error control. â€œâ€â€ def <strong>init</strong>(self, dynamics): self.dynamics = dynamics def integrate(self, x0: np.ndarray, t_span: tuple, rtol: float = 1e-6, atol: float = 1e-9, controller: Optional[Any] = None) -&gt; dict: â€œâ€â€Integrate using adaptive RK45.â€â€â€ from scipy.integrate import solve_ivp if controller: def dynamics_func(t, x): result = controller.compute_control(x, {}, {}) u = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, 0.0)) return self.dynamics.dynamics(x, u) else: def dynamics_func(t, x): return self.dynamics.dynamics(x, 0.0) sol = solve_ivp( dynamics_func, t_span, x0, method=â€™RK45â€™, rtol=rtol, atol=atol ) return { â€˜tâ€™: sol.t, â€˜xâ€™: sol.y.T }</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#runnable-false-benchmarks-analysis-accuracy-metrics-py-def-compute-energy-conservation-t-np-ndarray-x-np-ndarray-physics-params-dict-dict-analyze-energy-conservation-for-hamiltonian-systems-parameters-t-np-ndarray-time-vector-x-np-ndarray-state-trajectories-physics-params-dict-physics-parameters-returns-dict-initial-energy-float-final-energy-float-max-drift-float-relative-drift-float-def-compute-energy-state-kinetic-energy-x-dot-theta1-dot-theta2-dot-state-3-state-4-state-5-ke-0-5-physics-params-m-x-dot-2-cart-pendulum-kinetic-energy-potential-energy-theta1-theta2-state-1-state-2-pe-physics-params-m1-physics-params-g-physics-params-l1-1-np-cos-theta1-second-pendulum-pe-return-ke-pe-energies-np-array-compute-energy-state-for-state-in-x-initial-energy-energies-0-final-energy-energies-1-max-drift-np-max-np-abs-energies-initial-energy-relative-drift-max-drift-initial-energy-if-initial-energy-0-else-np-inf-return-initial-energy-float-initial-energy-final-energy-float-final-energy-max-drift-float-max-drift-relative-drift-float-relative-drift-energies-energies-def-estimate-convergence-order-integrator-x0-np-ndarray-t-span-tuple-dt-values-list-float-dict-estimate-numerical-convergence-order-uses-richardson-extrapolation-to-estimate-p-in-e-h-ch-p-parameters-integrator-object-integration-method-instance-x0-np-ndarray-initial-state-t-span-tuple-time-span-dt-values-list-of-float-decreasing-time-steps-for-convergence-analysis-returns-dict-convergence-order-float-errors-list-of-float-dt-values-list-of-float-get-reference-solution-finest-dt-ref-dt-min-dt-values-4-ref-result-integrator-integrate-x0-t-span-ref-dt-ref-x-final-ref-result-x-1-errors-for-dt-in-dt-values-result-integrator-integrate-x0-t-span-dt-x-final-result-x-1-error-np-linalg-norm-x-final-ref-x-final-errors-append-error-estimate-convergence-order-p-log-e-h1-e-h2-log-h1-h2-orders-for-i-in-range-len-errors-1-if-errors-i-1-0-order-np-log-errors-i-errors-i-1-np-log-dt-values-i-dt-values-i-1-orders-append-order-avg-order-np-mean-orders-if-orders-else-np-nan-return-convergence-order-float-avg-order-errors-float-e-for-e-in-errors-dt-values-dt-values">runnable: false # benchmarks/analysis/accuracy_metrics.py def compute_energy_conservation(t: np.ndarray, x: np.ndarray, physics_params: dict) -&gt; dict: â€œâ€â€Analyze energy conservation for Hamiltonian systems. Parameters â€”â€”â€”- t : np.ndarray Time vector x : np.ndarray State trajectories physics_params : dict Physics parameters Returns â€”â€”- dict { â€˜initial_energyâ€™: float, â€˜final_energyâ€™: float, â€˜max_driftâ€™: float, â€˜relative_driftâ€™: float } â€œâ€â€ def compute_energy(state): # Kinetic energy x_dot, theta1_dot, theta2_dot = state[3], state[4], state[5] KE = 0.5 * physics_params[â€˜Mâ€™] * x_dot**2 # Cart # â€¦ (pendulum kinetic energy) # Potential energy theta1, theta2 = state[1], state[2] PE = physics_params[â€˜m1â€™] * physics_params[â€˜gâ€™] * physics_params[â€˜L1â€™] * (1 - np.cos(theta1)) # â€¦ (second pendulum PE) return KE + PE energies = np.array([compute_energy(state) for state in x]) initial_energy = energies[0] final_energy = energies[-1] max_drift = np.max(np.abs(energies - initial_energy)) relative_drift = max_drift / initial_energy if initial_energy != 0 else np.inf return { â€˜initial_energyâ€™: float(initial_energy), â€˜final_energyâ€™: float(final_energy), â€˜max_driftâ€™: float(max_drift), â€˜relative_driftâ€™: float(relative_drift), â€˜energiesâ€™: energies } def estimate_convergence_order(integrator, x0: np.ndarray, t_span: tuple, dt_values: List[float]) -&gt; dict: â€œâ€â€Estimate numerical convergence order. Uses Richardson extrapolation to estimate p in: e_h = CÂ·h^p Parameters â€”â€”â€”- integrator : object Integration method instance x0 : np.ndarray Initial state t_span : tuple Time span dt_values : list of float Decreasing time steps for convergence analysis Returns â€”â€”- dict { â€˜convergence_orderâ€™: float, â€˜errorsâ€™: list of float, â€˜dt_valuesâ€™: list of float } â€œâ€â€ # Get reference solution (finest dt) ref_dt = min(dt_values) / 4 ref_result = integrator.integrate(x0, t_span, ref_dt) ref_x_final = ref_result[â€˜xâ€™][-1] errors = [] for dt in dt_values: result = integrator.integrate(x0, t_span, dt) x_final = result[â€˜xâ€™][-1] error = np.linalg.norm(x_final - ref_x_final) errors.append(error) # Estimate convergence order: p = log(e_h1/e_h2) / log(h1/h2) orders = [] for i in range(len(errors) - 1): if errors[i+1] &gt; 0: order = np.log(errors[i] / errors[i+1]) / np.log(dt_values[i] / dt_values[i+1]) orders.append(order) avg_order = np.mean(orders) if orders else np.nan return { â€˜convergence_orderâ€™: float(avg_order), â€˜errorsâ€™: [float(e) for e in errors], â€˜dt_valuesâ€™: dt_values }</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#benchmarks-comparison-method-comparison-py-class-integrationmethodcomparator-systematic-comparison-of-integration-methods-def-init-self-dynamics-physics-params-dict-self-dynamics-dynamics-self-physics-params-physics-params-def-compare-methods-self-methods-list-str-x0-np-ndarray-t-span-tuple-dt-values-list-float-dict-compare-multiple-integration-methods-parameters-methods-list-of-str-method-names-euler-rk4-rk45-x0-np-ndarray-initial-state-t-span-tuple-time-span-dt-values-list-of-float-time-steps-to-test-returns-dict-comparison-results-for-all-methods-from-benchmarks-integration-import-eulerintegrator-rk4integrator-adaptiverk45integrator-from-benchmarks-analysis-import-compute-energy-conservation-estimate-convergence-order-integrators-euler-eulerintegrator-self-dynamics-rk4-rk4integrator-self-dynamics-rk45-adaptiverk45integrator-self-dynamics-results-for-method-name-in-methods-integrator-integrators-method-name-convergence-analysis-convergence-estimate-convergence-order-integrator-x0-t-span-dt-values-energy-conservation-for-frictionless-system-result-integrator-integrate-x0-t-span-dt-min-dt-values-energy-analysis-compute-energy-conservation-result-t-result-x-self-physics-params-performance-measurement-import-time-start-time-time-integrator-integrate-x0-t-span-dt-min-dt-values-elapsed-time-time-start-results-method-name-convergence-order-convergence-convergence-order-energy-drift-energy-analysis-relative-drift-computation-time-elapsed-errors-convergence-errors-return-results">benchmarks/comparison/method_comparison.py class IntegrationMethodComparator: â€œâ€â€Systematic comparison of integration methods.â€â€â€ def <strong>init</strong>(self, dynamics, physics_params: dict): self.dynamics = dynamics self.physics_params = physics_params def compare_methods(self, methods: List[str], x0: np.ndarray, t_span: tuple, dt_values: List[float]) -&gt; dict: â€œâ€â€Compare multiple integration methods. Parameters â€”â€”â€”- methods : list of str Method names: [â€˜Eulerâ€™, â€˜RK4â€™, â€˜RK45â€™] x0 : np.ndarray Initial state t_span : tuple Time span dt_values : list of float Time steps to test Returns â€”â€”- dict Comparison results for all methods â€œâ€â€ from benchmarks.integration import EulerIntegrator, RK4Integrator, AdaptiveRK45Integrator from benchmarks.analysis import compute_energy_conservation, estimate_convergence_order integrators = { â€˜Eulerâ€™: EulerIntegrator(self.dynamics), â€˜RK4â€™: RK4Integrator(self.dynamics), â€˜RK45â€™: AdaptiveRK45Integrator(self.dynamics) } results = {} for method_name in methods: integrator = integrators[method_name] # Convergence analysis convergence = estimate_convergence_order(integrator, x0, t_span, dt_values) # Energy conservation (for frictionless system) result = integrator.integrate(x0, t_span, dt=min(dt_values)) energy_analysis = compute_energy_conservation( result[â€˜tâ€™], result[â€˜xâ€™], self.physics_params ) # Performance measurement import time start = time.time() _ = integrator.integrate(x0, t_span, dt=min(dt_values)) elapsed = time.time() - start results[method_name] = { â€˜convergence_orderâ€™: convergence[â€˜convergence_orderâ€™], â€˜energy_driftâ€™: energy_analysis[â€˜relative_driftâ€™], â€˜computation_timeâ€™: elapsed, â€˜errorsâ€™: convergence[â€˜errorsâ€™] } return results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#config-yaml-benchmark-configuration-benchmarks-statistical-n-trials-30-clt-compliance-confidence-level-0-95-95-ci-seed-42-reproducibility-physics-uncertainty-enabled-true-n-scenarios-10-variations-cart-mass-0-05-5-pendulum1-mass-0-10-10-pendulum2-mass-0-10-10-pendulum1-length-0-05-5-pendulum2-length-0-05-5-friction-cart-0-20-20-sensor-noise-enabled-false-std-position-0-001-1mm-std-angle-0-001-0-06-integration-methods-euler-rk4-rk45-dt-values-0-05-0-01-0-005-0-001-convergence-analysis-true-energy-conservation-check-true-performance-regression-threshold-0-05-5-slowdown-alert-baseline-file-benchmarks-baseline-json">config.yaml - Benchmark configuration benchmarks: statistical: n_trials: 30 # CLT compliance confidence_level: 0.95 # 95% CI seed: 42 # Reproducibility physics_uncertainty: enabled: true n_scenarios: 10 variations: cart_mass: 0.05 # Â±5% pendulum1_mass: 0.10 # Â±10% pendulum2_mass: 0.10 # Â±10% pendulum1_length: 0.05 # Â±5% pendulum2_length: 0.05 # Â±5% friction_cart: 0.20 # Â±20% sensor_noise: enabled: false std_position: 0.001 # 1mm std_angle: 0.001 # ~0.06Â° integration: methods: [â€˜Eulerâ€™, â€˜RK4â€™, â€˜RK45â€™] dt_values: [0.05, 0.01, 0.005, 0.001] convergence_analysis: true energy_conservation_check: true performance: regression_threshold: 0.05 # 5% slowdown alert baseline_file: â€˜benchmarks/baseline.jsonâ€™</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/validation_methodology_guide.html">Validation Methodology Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/theory/lyapunov_stability_testing.html">Lyapunov Stability Testing Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/theory/smc_validation_mathematics.html">SMC Validation Mathematics <strong>Status:</strong> Integrated into validation framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/theory/smc_validation_mathematics.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/theory/smc_validation_mathematics.html#runnable-false-def-monte-carlo-validation-controller-n-trials-1000-statistical-validation-of-controller-performance-settling-times-overshoot-values-for-in-range-n-trials-x0-random-initial-condition-result-simulate-controller-x0-duration-10-0-settling-times-append-compute-settling-time-result-overshoot-values-append-compute-overshoot-result-statistical-acceptance-criteria-assert-np-mean-settling-times-3-0-assert-np-percentile-settling-times-95-5-0-assert-np-mean-overshoot-values-0-1">runnable: false def monte_carlo_validation(controller, n_trials=1000): â€œâ€â€Statistical validation of controller performance.â€â€â€ settling_times = [] overshoot_values = [] for _ in range(n_trials): x0 = random_initial_condition() result = simulate(controller, x0, duration=10.0) settling_times.append(compute_settling_time(result)) overshoot_values.append(compute_overshoot(result)) # Statistical acceptance criteria assert np.mean(settling_times) &lt; 3.0 assert np.percentile(settling_times, 95) &lt; 5.0 assert np.mean(overshoot_values) &lt; 0.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/executive/executive_summary.html">Executive Test Summary Report <strong>Date</strong>: 2025-09-30 06:03</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/test_failure_analysis.html">Test Failure Analysis Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/failure_breakdown.html">Failure Resolution Tracking Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/pso_convergence_analysis.html">PSO Convergence Analysis - September 30, 2025</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/pso_fitness_investigation.html">PSO Fitness Function Investigation - cost=0.0 Root Cause Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/technical_analysis.html">Technical Deep-Dive: Pytest Failure Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/technical/control_theory_analysis.html">Control Theory Technical Analysis Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/technical/resolution_roadmap.html">Technical Resolution Roadmap <strong>Date</strong>: 2025-09-30 06:03</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/standards/testing_standards.html">Testing Standards and Guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/accessibility_checklist.html">WCAG 2.1 AA Accessibility Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/navigation_index.html">Testing Documentation Navigation Index ## Quick Access Links ### ğŸ“Š Current Status</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../TESTING.html">Testing Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ğŸ”§ MCP Debugging &amp; Code Quality</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../mcp-debugging/index.html">MCP Debugging &amp; Code Quality</a><input aria-label="Toggle navigation of MCP Debugging &amp; Code Quality" class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" role="switch" type="checkbox"/><label for="toctree-checkbox-17"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/README.html">MCP Debugging Workflows for DIP-SMC-PSO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/QUICK_REFERENCE.html">MCP Debugging Quick Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/INSTALLATION_LOG.html">MCP Servers Installation Log <strong>Date</strong>: 2025-10-06</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/MISSING_SERVERS_RESEARCH.html">Missing MCP Servers - Research Results <strong>Date</strong>: 2025-10-06</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/analysis_results/README.html">Code Quality Analysis Results This directory contains code quality analysis results from the <strong>mcp-analyzer</strong> MCP server. ## ğŸ“ Directory Structure ```</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/analysis_results/RUFF_FINDINGS_20251006_175120.html">RUFF Linting Results - 20251006_175120</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/analysis_results/RUFF_FINDINGS_20251006_175404.html">RUFF Linting Results - 20251006_175404</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/analysis_results/RUFF_FINDINGS_20251006_183442.html">RUFF Linting Results - 20251006_183442</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/analysis_results/RUFF_FINDINGS_20251006_183953.html">RUFF Linting Results - 20251006_183953</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/analysis_results/RUFF_FINDINGS_20251006_191744.html">RUFF Linting Results - 20251006_191744</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/analysis_results/VULTURE_FINDINGS_20251006_175120.html">VULTURE Dead Code Detection - 20251006_175120</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/analysis_results/VULTURE_FINDINGS_20251006_175404.html">VULTURE Dead Code Detection - 20251006_175404</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/analysis_results/VULTURE_FINDINGS_20251006_183442.html">VULTURE Dead Code Detection - 20251006_183442</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/analysis_results/VULTURE_FINDINGS_20251006_183953.html">VULTURE Dead Code Detection - 20251006_183953</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/analysis_results/VULTURE_FINDINGS_20251006_191744.html">VULTURE Dead Code Detection - 20251006_191744</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/CODE_QUALITY_ANALYSIS_PLAN.html">Complete Codebase Code Quality Analysis Plan <strong>Created</strong>: 2025-10-06</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/CODE_QUALITY_ANALYSIS_PLAN.html#mcp-tool-call-pattern">MCP Tool Call Pattern</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/CODE_QUALITY_ANALYSIS_PLAN.html#mcp-tool-call-pattern-after-manual-review-of-auto-fix-candidates">MCP Tool Call Pattern (after manual review of auto-fix candidates)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html">Complete MCP Debugging Workflow <strong>Last Updated</strong>: 2025-10-06</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#query-recent-pso-runs">Query recent PSO runs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#read-pso-optimization-logs">Read PSO optimization logs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#swarm-diversity-collapse-0-01-after-10-iterations">- Swarm diversity collapse (&lt; 0.01 after 10 iterations)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#fitness-stagnation-no-improvement-for-20-iterations">- Fitness stagnation (no improvement for 20+ iterations)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#parameter-bound-violations">- Parameter bound violations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#particle-velocity-saturation">- Particle velocity saturation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#create-feature-branch">Create feature branch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#adjust-hyperparameters">- Adjust hyperparameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#add-diversity-maintenance-mechanism">- Add diversity maintenance mechanism</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#implement-adaptive-velocity-clamping-commit-changes">- Implement adaptive velocity clamping # Commit changes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#run-pso-unit-tests">Run PSO unit tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#test-pso-convergence-rate">- test_pso_convergence_rate</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#test-pso-diversity-maintenance">- test_pso_diversity_maintenance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#test-pso-constraint-handling">- test_pso_constraint_handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#search-for-numerical-errors-in-logs">Search for numerical errors in logs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#view-recent-changes-to-dynamics-code">View recent changes to dynamics code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#runnable-false-add-to-src-utils-numerical-stability-py-def-safe-matrix-inverse-m-np-ndarray-eps-float-1e-10-np-ndarray-compute-matrix-inverse-with-regularization-for-ill-conditioned-matrices-args-m-input-matrix-eps-regularization-parameter-returns-regularized-inverse-cond-num-np-linalg-cond-m-if-cond-num-1e8-use-svd-based-pseudo-inverse-return-np-linalg-pinv-m-rcond-eps-else-standard-inversion-with-small-ridge-return-np-linalg-inv-m-eps-np-eye-m-shape-0">runnable: false # Add to src/utils/numerical_stability.py def safe_matrix_inverse(M: np.ndarray, eps: float = 1e-10) -&gt; np.ndarray: â€œâ€â€ Compute matrix inverse with regularization for ill-conditioned matrices. Args: M: Input matrix eps: Regularization parameter Returns: Regularized inverse â€œâ€â€ cond_num = np.linalg.cond(M) if cond_num &gt; 1e8: # Use SVD-based pseudo-inverse return np.linalg.pinv(M, rcond=eps) else: # Standard inversion with small ridge return np.linalg.inv(M + eps * np.eye(M.shape[0]))</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#run-numerical-stability-tests">Run numerical stability tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#launch-streamlit-dashboard">Launch Streamlit dashboard</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#state-trajectories">- State trajectories</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#control-inputs">- Control inputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#pso-convergence-curves">- PSO convergence curves</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#performance-metrics-comparison">- Performance metrics comparison</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#generate-experiment-report">Generate experiment report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/complete-debugging-workflow.html#commit-results">Commit results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/VALIDATION_WORKFLOW.html">MCP Debugging Validation Workflow <strong>Last Updated</strong>: 2025-10-06</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/VALIDATION_WORKFLOW.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/VALIDATION_WORKFLOW.html#runnable-false-ask-claude-via-mcp">runnable: false # Ask Claude via MCP:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/VALIDATION_WORKFLOW.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/VALIDATION_WORKFLOW.html#runnable-false-ask-claude">runnable: false # Ask Claude:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/VALIDATION_WORKFLOW.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/VALIDATION_WORKFLOW.html#id3">runnable: false # Ask Claude:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/VALIDATION_WORKFLOW.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/VALIDATION_WORKFLOW.html#id5">runnable: false # Ask Claude:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/VALIDATION_WORKFLOW.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mcp-debugging/workflows/VALIDATION_WORKFLOW.html#id7">runnable: false # Ask Claude:</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ğŸ“– References &amp; Bibliography</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../bibliography.html">Bibliography &amp; Academic References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references/index.html">References and Citations ```{toctree}</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CITATIONS.html">Citations &amp; Academic Attribution <strong>Project:</strong> Double Inverted Pendulum - Sliding Mode Control with PSO Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CITATIONS_ACADEMIC.html">Academic Theory Citations &amp; References <strong>Project:</strong> Double Inverted Pendulum - Sliding Mode Control with PSO Optimization</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/blob/main/docs/api/factory_methods_reference.md?plain=true" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div><div class="edit-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/edit/main/docs/api/factory_methods_reference.md" rel="edit" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <p>#==========================================================================================\<br />
#===================== docs/api/factory_methods_reference.md =========================\<br />
#==========================================================================================\</p>
<section class="tex2jax_ignore mathjax_ignore" id="factory-methods-api-reference-overview-this-document-provides-api-reference-documentation-for-the-enterprise-controller-factory-system-the-factory-provides-thread-safe-type-safe-controller-instantiation-with-deep-pso-integration-and-robust-error-handling-table-of-contents-1-core-factory-functions">
<h1>Factory Methods API Reference ## Overview This document provides API reference documentation for the Enterprise Controller Factory system. The factory provides thread-safe, type-safe controller instantiation with deep PSO integration and robust error handling. ## Table of Contents 1. <a class="reference internal" href="#core-factory-functions"><span class="xref myst">Core Factory Functions</span></a><a class="headerlink" href="#factory-methods-api-reference-overview-this-document-provides-api-reference-documentation-for-the-enterprise-controller-factory-system-the-factory-provides-thread-safe-type-safe-controller-instantiation-with-deep-pso-integration-and-robust-error-handling-table-of-contents-1-core-factory-functions" title="Link to this heading">Â¶</a></h1>
<ol class="arabic simple" start="2">
<li><p><a class="reference internal" href="#pso-integration-functions"><span class="xref myst">PSO Integration Functions</span></a></p></li>
<li><p><a class="reference internal" href="#controller-registry-functions"><span class="xref myst">Controller Registry Functions</span></a></p></li>
<li><p><a class="reference internal" href="#configuration-functions"><span class="xref myst">Configuration Functions</span></a></p></li>
<li><p><a class="reference internal" href="#validation-functions"><span class="xref myst">Validation Functions</span></a></p></li>
<li><p><a class="reference internal" href="#type-definitions"><span class="xref myst">Type Definitions</span></a></p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/pdb.html#pdbcommand-exceptions" title="Python 3.14"><span class="xref myst">Exceptions</span></a></p></li>
<li><p><a class="reference internal" href="#examples"><span class="xref myst">Examples</span></a></p></li>
</ol>
<hr class="docutils" />
<section id="core-factory-functions-create-controller-primary-factory-function-for-creating-controller-instances-python">
<h2>Core Factory Functions ### <code class="docutils literal notranslate"><span class="pre">create_controller()</span></code> <strong>Primary factory function for creating controller instances.</strong> ```python<a class="headerlink" href="#core-factory-functions-create-controller-primary-factory-function-for-creating-controller-instances-python" title="Link to this heading">Â¶</a></h2>
<p>def create_controller( controller_type: str, config: Optional[Any] = None, gains: Optional[Union[list, np.ndarray]] = None
) -&gt; Any
<code class="docutils literal notranslate"><span class="pre">####</span> <span class="pre">Parameters</span> <span class="pre">-</span> <span class="pre">**`controller_type`**</span> <span class="pre">(`str`):</span> <span class="pre">Controller</span> <span class="pre">type</span> <span class="pre">identifier</span> <span class="pre">-</span> <span class="pre">`'classical_smc'`:</span> <span class="pre">Classical</span> <span class="pre">sliding</span> <span class="pre">mode</span> <span class="pre">controller</span> <span class="pre">with</span> <span class="pre">boundary</span> <span class="pre">layer</span> <span class="pre">-</span> <span class="pre">`'sta_smc'`:</span> <span class="pre">Super-twisting</span> <span class="pre">sliding</span> <span class="pre">mode</span> <span class="pre">controller</span> <span class="pre">(2nd</span> <span class="pre">order)</span> <span class="pre">-</span> <span class="pre">`'adaptive_smc'`:</span> <span class="pre">Adaptive</span> <span class="pre">sliding</span> <span class="pre">mode</span> <span class="pre">controller</span> <span class="pre">with</span> <span class="pre">online</span> <span class="pre">parameter</span> <span class="pre">estimation</span> <span class="pre">-</span> <span class="pre">`'hybrid_adaptive_sta_smc'`:</span> <span class="pre">Hybrid</span> <span class="pre">adaptive</span> <span class="pre">super-twisting</span> <span class="pre">controller</span> <span class="pre">-</span> <span class="pre">`'mpc_controller'`:</span> <span class="pre">Model</span> <span class="pre">predictive</span> <span class="pre">controller</span> <span class="pre">(requires</span> <span class="pre">optional</span> <span class="pre">dependencies)</span> <span class="pre">-</span> <span class="pre">**`config`**</span> <span class="pre">(`Optional[Any]`):</span> <span class="pre">Configuration</span> <span class="pre">object</span> <span class="pre">containing</span> <span class="pre">controller</span> <span class="pre">parameters</span> <span class="pre">-</span> <span class="pre">Can</span> <span class="pre">be</span> <span class="pre">a</span> <span class="pre">Pydantic</span> <span class="pre">model,</span> <span class="pre">dataclass,</span> <span class="pre">or</span> <span class="pre">dict-like</span> <span class="pre">object</span> <span class="pre">-</span> <span class="pre">If</span> <span class="pre">provided,</span> <span class="pre">parameters</span> <span class="pre">are</span> <span class="pre">extracted</span> <span class="pre">based</span> <span class="pre">on</span> <span class="pre">controller</span> <span class="pre">type</span> <span class="pre">-</span> <span class="pre">Takes</span> <span class="pre">lower</span> <span class="pre">priority</span> <span class="pre">than</span> <span class="pre">explicit</span> <span class="pre">`gains`</span> <span class="pre">parameter</span> <span class="pre">-</span> <span class="pre">**`gains`**</span> <span class="pre">(`Optional[Union[list,</span> <span class="pre">np.ndarray]]`):</span> <span class="pre">Controller</span> <span class="pre">gain</span> <span class="pre">values</span> <span class="pre">-</span> <span class="pre">Takes</span> <span class="pre">highest</span> <span class="pre">priority</span> <span class="pre">in</span> <span class="pre">parameter</span> <span class="pre">resolution</span> <span class="pre">-</span> <span class="pre">Must</span> <span class="pre">match</span> <span class="pre">expected</span> <span class="pre">gain</span> <span class="pre">count</span> <span class="pre">for</span> <span class="pre">controller</span> <span class="pre">type</span> <span class="pre">-</span> <span class="pre">Automatically</span> <span class="pre">converted</span> <span class="pre">from</span> <span class="pre">numpy</span> <span class="pre">arrays</span> <span class="pre">to</span> <span class="pre">lists</span> <span class="pre">####</span> <span class="pre">Returns</span> <span class="pre">-</span> <span class="pre">**Controller</span> <span class="pre">instance**:</span> <span class="pre">Configured</span> <span class="pre">controller</span> <span class="pre">implementing</span> <span class="pre">`ControllerProtocol`</span> <span class="pre">-</span> <span class="pre">Has</span> <span class="pre">`compute_control(state,</span> <span class="pre">last_control,</span> <span class="pre">history)`</span> <span class="pre">method</span> <span class="pre">-</span> <span class="pre">Has</span> <span class="pre">`reset()`</span> <span class="pre">method</span> <span class="pre">for</span> <span class="pre">state</span> <span class="pre">reset</span> <span class="pre">-</span> <span class="pre">Has</span> <span class="pre">`gains`</span> <span class="pre">property</span> <span class="pre">returning</span> <span class="pre">gain</span> <span class="pre">values</span> <span class="pre">####</span> <span class="pre">Raises</span> <span class="pre">-</span> <span class="pre">**`ValueError`**:</span> <span class="pre">Invalid</span> <span class="pre">controller</span> <span class="pre">type</span> <span class="pre">or</span> <span class="pre">parameters</span> <span class="pre">-</span> <span class="pre">Unknown</span> <span class="pre">controller</span> <span class="pre">type</span> <span class="pre">-</span> <span class="pre">Invalid</span> <span class="pre">gain</span> <span class="pre">count</span> <span class="pre">or</span> <span class="pre">values</span> <span class="pre">-</span> <span class="pre">Parameter</span> <span class="pre">validation</span> <span class="pre">failures</span> <span class="pre">-</span> <span class="pre">**`ImportError`**:</span> <span class="pre">Missing</span> <span class="pre">required</span> <span class="pre">dependencies</span> <span class="pre">-</span> <span class="pre">MPC</span> <span class="pre">controller</span> <span class="pre">without</span> <span class="pre">optional</span> <span class="pre">dependencies</span> <span class="pre">-</span> <span class="pre">Missing</span> <span class="pre">controller</span> <span class="pre">implementation</span> <span class="pre">modules</span> <span class="pre">-</span> <span class="pre">**`ConfigValueError`**:</span> <span class="pre">Invalid</span> <span class="pre">configuration</span> <span class="pre">values</span> <span class="pre">-</span> <span class="pre">MPC</span> <span class="pre">parameter</span> <span class="pre">validation</span> <span class="pre">failures</span> <span class="pre">-</span> <span class="pre">Domain-specific</span> <span class="pre">parameter</span> <span class="pre">constraints</span> <span class="pre">####</span> <span class="pre">Thread</span> <span class="pre">Safety</span> <span class="pre">âœ…</span> <span class="pre">**Thread-safe**</span> <span class="pre">with</span> <span class="pre">recursive</span> <span class="pre">lock</span> <span class="pre">and</span> <span class="pre">10-second</span> <span class="pre">timeout</span> <span class="pre">protection.</span> <span class="pre">####</span> <span class="pre">Parameter</span> <span class="pre">Resolution</span> <span class="pre">Priority</span> <span class="pre">1.</span> <span class="pre">**Explicit</span> <span class="pre">`gains`</span> <span class="pre">parameter**</span> <span class="pre">(highest</span> <span class="pre">priority)</span> <span class="pre">2.</span> <span class="pre">**Configuration</span> <span class="pre">object</span> <span class="pre">attributes**</span> <span class="pre">3.</span> <span class="pre">**YAML</span> <span class="pre">configuration</span> <span class="pre">file</span> <span class="pre">values**</span> <span class="pre">4.</span> <span class="pre">**Registry</span> <span class="pre">default</span> <span class="pre">values**</span> <span class="pre">(lowest</span> <span class="pre">priority)</span> <span class="pre">####</span> <span class="pre">Example</span> <span class="pre">Usage</span></code>python</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="basic-usage-with-default-parameters">
<h1>Basic usage with default parameters<a class="headerlink" href="#basic-usage-with-default-parameters" title="Link to this heading">Â¶</a></h1>
<p>controller = create_controller(â€˜classical_smcâ€™) # With explicit gains
controller = create_controller( â€˜classical_smcâ€™, gains=[20.0, 15.0, 12.0, 8.0, 35.0, 5.0]
) # With configuration object
from src.config import load_config
config = load_config(â€œconfig.yamlâ€)
controller = create_controller(â€˜adaptive_smcâ€™, config=config) # Combined parameters (gains override config)
controller = create_controller( â€˜sta_smcâ€™, config=config, gains=[25.0, 15.0, 20.0, 12.0, 8.0, 6.0] # Takes priority
)</p>
<div class="highlight-#### notranslate"><div class="highlight"><pre><span></span>
```python
# Required gains: [k1, k2, lambda1, lambda2, K, kd]
# Required parameters: max_force, boundary_layer, dt
controller = create_controller( &#39;classical_smc&#39;, gains=[20.0, 15.0, 12.0, 8.0, 35.0, 5.0]
)
``` ##### Super-Twisting SMC

```python
# Required gains: [K1, K2, k1, k2, lambda1, lambda2]
# Required parameters: max_force, dt
controller = create_controller( &#39;sta_smc&#39;, gains=[25.0, 15.0, 20.0, 12.0, 8.0, 6.0]
)
``` ##### Adaptive SMC

```python
# Required gains: [k1, k2, lambda1, lambda2, gamma]
# Required parameters: max_force, dt
controller = create_controller( &#39;adaptive_smc&#39;, gains=[25.0, 18.0, 15.0, 10.0, 4.0]
)
``` ##### Hybrid Adaptive-STA SMC

```python
# Required gains: [k1, k2, lambda1, lambda2]
# Special handling: Creates sub-controllers automatically
controller = create_controller( &#39;hybrid_adaptive_sta_smc&#39;, gains=[18.0, 12.0, 10.0, 8.0]
)
``` ##### MPC Controller

```python
# No traditional gains
# Required parameters: horizon, q_x, q_theta, r_u
controller = create_controller(&#39;mpc_controller&#39;) # Uses defaults
</pre></div>
</div>
<hr class="docutils" />
<section id="list-available-controllers-get-list-of-currently-available-controller-types-python">
<h2><code class="docutils literal notranslate"><span class="pre">list_available_controllers()</span></code> <strong>Get list of currently available controller types.</strong> ```python<a class="headerlink" href="#list-available-controllers-get-list-of-currently-available-controller-types-python" title="Link to this heading">Â¶</a></h2>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="example-metadata">
<h1>example-metadata:<a class="headerlink" href="#example-metadata" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-def-list-available-controllers-list-str">
<h1>runnable: false def list_available_controllers() -&gt; List[str]<a class="headerlink" href="#runnable-false-def-list-available-controllers-list-str" title="Link to this heading">Â¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">####</span> <span class="pre">Returns</span> <span class="pre">-</span> <span class="pre">**`List[str]`**:</span> <span class="pre">List</span> <span class="pre">of</span> <span class="pre">controller</span> <span class="pre">type</span> <span class="pre">names</span> <span class="pre">that</span> <span class="pre">can</span> <span class="pre">actually</span> <span class="pre">be</span> <span class="pre">instantiated</span> <span class="pre">-</span> <span class="pre">Excludes</span> <span class="pre">controllers</span> <span class="pre">with</span> <span class="pre">missing</span> <span class="pre">dependencies</span> <span class="pre">-</span> <span class="pre">Only</span> <span class="pre">includes</span> <span class="pre">controllers</span> <span class="pre">with</span> <span class="pre">available</span> <span class="pre">implementation</span> <span class="pre">classes</span> <span class="pre">####</span> <span class="pre">Example</span> <span class="pre">Usage</span></code>python
available = list_available_controllers()
print(â€œAvailable controllers:â€, available)</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="output-classical-smc-sta-smc-adaptive-smc-hybrid-adaptive-sta-smc">
<h1>Output: [â€˜classical_smcâ€™, â€˜sta_smcâ€™, â€˜adaptive_smcâ€™, â€˜hybrid_adaptive_sta_smcâ€™]<a class="headerlink" href="#output-classical-smc-sta-smc-adaptive-smc-hybrid-adaptive-sta-smc" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="note-mpc-controller-only-included-if-optional-dependencies-available">
<h1>Note: â€˜mpc_controllerâ€™ only included if optional dependencies available<a class="headerlink" href="#note-mpc-controller-only-included-if-optional-dependencies-available" title="Link to this heading">Â¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
<span class="o">---</span>

<span class="c1">## `list_all_controllers()` **Get list of all registered controller types, including unavailable ones.** ```python</span>

<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false def list_all_controllers() -&gt; List[str]</span>

<span class="err">```</span> <span class="c1">#### Returns - **`List[str]`**: List of all controller type names in the registry - Includes unavailable controllers for completeness - Useful for documentation and error messages #### Example Usage ```python</span>
<span class="n">all_controllers</span> <span class="o">=</span> <span class="n">list_all_controllers</span><span class="p">()</span>
<span class="n">available</span> <span class="o">=</span> <span class="n">list_available_controllers</span><span class="p">()</span> <span class="n">unavailable</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">all_controllers</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">available</span><span class="p">)</span>
<span class="k">if</span> <span class="n">unavailable</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unavailable controllers: </span><span class="si">{</span><span class="n">unavailable</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Check dependencies and installation&quot;</span><span class="p">)</span>
</pre></div>
</div>
<hr class="docutils" />
<section id="get-default-gains-get-default-gains-for-a-specific-controller-type-python">
<h2><code class="docutils literal notranslate"><span class="pre">get_default_gains()</span></code> <strong>Get default gains for a specific controller type.</strong> ```python<a class="headerlink" href="#get-default-gains-get-default-gains-for-a-specific-controller-type-python" title="Link to this heading">Â¶</a></h2>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1>example-metadata:<a class="headerlink" href="#id1" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-def-get-default-gains-controller-type-str-list-float">
<h1>runnable: false def get_default_gains(controller_type: str) -&gt; List[float]<a class="headerlink" href="#runnable-false-def-get-default-gains-controller-type-str-list-float" title="Link to this heading">Â¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">####</span> <span class="pre">Parameters</span> <span class="pre">-</span> <span class="pre">**`controller_type`**</span> <span class="pre">(`str`):</span> <span class="pre">Controller</span> <span class="pre">type</span> <span class="pre">identifier</span> <span class="pre">####</span> <span class="pre">Returns</span> <span class="pre">-</span> <span class="pre">**`List[float]`**:</span> <span class="pre">Default</span> <span class="pre">gain</span> <span class="pre">values</span> <span class="pre">for</span> <span class="pre">the</span> <span class="pre">controller</span> <span class="pre">-</span> <span class="pre">Copy</span> <span class="pre">of</span> <span class="pre">registry</span> <span class="pre">defaults</span> <span class="pre">(safe</span> <span class="pre">to</span> <span class="pre">modify)</span> <span class="pre">-</span> <span class="pre">Optimized</span> <span class="pre">for</span> <span class="pre">double-inverted</span> <span class="pre">pendulum</span> <span class="pre">system</span> <span class="pre">####</span> <span class="pre">Raises</span> <span class="pre">-</span> <span class="pre">**`ValueError`**:</span> <span class="pre">Unknown</span> <span class="pre">controller</span> <span class="pre">type</span> <span class="pre">####</span> <span class="pre">Example</span> <span class="pre">Usage</span></code>python</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id2">
<h1>example-metadata:<a class="headerlink" href="#id2" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-get-default-gains-for-different-controllers">
<h1>runnable: false # Get default gains for different controllers<a class="headerlink" href="#runnable-false-get-default-gains-for-different-controllers" title="Link to this heading">Â¶</a></h1>
<p>classical_gains = get_default_gains(â€˜classical_smcâ€™)
print(fâ€Classical SMC defaults: {classical_gains}â€)</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="output-20-0-15-0-12-0-8-0-35-0-5-0-adaptive-gains-get-default-gains-adaptive-smc">
<h1>Output: [20.0, 15.0, 12.0, 8.0, 35.0, 5.0] adaptive_gains = get_default_gains(â€˜adaptive_smcâ€™)<a class="headerlink" href="#output-20-0-15-0-12-0-8-0-35-0-5-0-adaptive-gains-get-default-gains-adaptive-smc" title="Link to this heading">Â¶</a></h1>
<p>print(fâ€Adaptive SMC defaults: {adaptive_gains}â€)</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="output-25-0-18-0-15-0-10-0-4-0-use-as-starting-point-for-optimization">
<h1>Output: [25.0, 18.0, 15.0, 10.0, 4.0] # Use as starting point for optimization<a class="headerlink" href="#output-25-0-18-0-15-0-10-0-4-0-use-as-starting-point-for-optimization" title="Link to this heading">Â¶</a></h1>
<p>optimized_gains = optimize_controller_gains( controller_type=â€™classical_smcâ€™, initial_gains=get_default_gains(â€˜classical_smcâ€™)
)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
<span class="o">---</span>

<span class="c1">## PSO Integration Functions ### `create_smc_for_pso()` **Create SMC controller optimized for PSO usage.** ```python</span>

<span class="k">def</span><span class="w"> </span><span class="nf">create_smc_for_pso</span><span class="p">(</span> <span class="n">smc_type</span><span class="p">:</span> <span class="n">SMCType</span><span class="p">,</span> <span class="n">gains</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">plant_config_or_model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PSOControllerWrapper</span>
<span class="err">```</span> <span class="c1">#### Parameters - **`smc_type`** (`SMCType`): SMC controller type enum - `SMCType.CLASSICAL`: Classical sliding mode controller - `SMCType.ADAPTIVE`: Adaptive sliding mode controller - `SMCType.SUPER_TWISTING`: Super-twisting sliding mode controller - `SMCType.HYBRID`: Hybrid adaptive-STA controller - **`gains`** (`Union[list, np.ndarray]`): Controller gain values - Must match expected count for controller type - Validated for positive, finite values - **`plant_config_or_model`** (`Optional[Any]`): Plant configuration or dynamics model - Used for model-based equivalent control - Optional for most controller types - **`**kwargs`**: Additional controller parameters - `max_force`: Control saturation limit (default: 150.0) - `dt`: Control timestep (default: 0.001) - Controller-specific parameters #### Returns - **`PSOControllerWrapper`**: PSO-compatible controller wrapper - Implements standardized PSO interface - Has `validate_gains(particles)` method - Has `compute_control(state)` method - Includes safety mechanisms and error handling #### Example Usage ```python</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">src.controllers.factory</span><span class="w"> </span><span class="kn">import</span> <span class="n">create_smc_for_pso</span><span class="p">,</span> <span class="n">SMCType</span> <span class="c1"># Create PSO-compatible controller</span>
<span class="n">gains</span> <span class="o">=</span> <span class="p">[</span><span class="mf">20.0</span><span class="p">,</span> <span class="mf">15.0</span><span class="p">,</span> <span class="mf">12.0</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="mf">35.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">]</span>
<span class="n">controller</span> <span class="o">=</span> <span class="n">create_smc_for_pso</span><span class="p">(</span> <span class="n">SMCType</span><span class="o">.</span><span class="n">CLASSICAL</span><span class="p">,</span> <span class="n">gains</span><span class="o">=</span><span class="n">gains</span><span class="p">,</span> <span class="n">max_force</span><span class="o">=</span><span class="mf">150.0</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.001</span>
<span class="p">)</span> <span class="c1"># Use in PSO fitness function</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fitness_function</span><span class="p">(</span><span class="n">test_gains</span><span class="p">):</span> <span class="n">controller</span> <span class="o">=</span> <span class="n">create_smc_for_pso</span><span class="p">(</span><span class="n">SMCType</span><span class="o">.</span><span class="n">CLASSICAL</span><span class="p">,</span> <span class="n">test_gains</span><span class="p">)</span> <span class="k">return</span> <span class="n">evaluate_controller_performance</span><span class="p">(</span><span class="n">controller</span><span class="p">)</span> <span class="c1"># Validate particle swarm</span>
<span class="n">particles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">25</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># Invalid</span>
<span class="p">])</span>
<span class="n">validity</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="n">validate_gains</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Particle validity: </span><span class="si">{</span><span class="n">validity</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="c1"># Output: [True, True, False]</span>
</pre></div>
</div>
<hr class="docutils" />
<section id="create-pso-controller-factory-create-a-pso-optimized-controller-factory-function-python">
<h2><code class="docutils literal notranslate"><span class="pre">create_pso_controller_factory()</span></code> <strong>Create a PSO-optimized controller factory function.</strong> ```python<a class="headerlink" href="#create-pso-controller-factory-create-a-pso-optimized-controller-factory-function-python" title="Link to this heading">Â¶</a></h2>
<p>def create_pso_controller_factory( smc_type: SMCType, plant_config: Optional[Any] = None, **kwargs: Any
) -&gt; Callable[[Union[list, np.ndarray]], PSOControllerWrapper]
``` #### Parameters - <strong><code class="docutils literal notranslate"><span class="pre">smc_type</span></code></strong> (<code class="docutils literal notranslate"><span class="pre">SMCType</span></code>): SMC controller type enum</p>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">plant_config</span></code></strong> (<code class="docutils literal notranslate"><span class="pre">Optional[Any]</span></code>): Plant configuration</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">**kwargs</span></code></strong>: Additional controller parameters #### Returns - <strong>Factory function</strong> with PSO attributes: - <code class="docutils literal notranslate"><span class="pre">factory.n_gains</span></code>: Number of gains required - <code class="docutils literal notranslate"><span class="pre">factory.controller_type</span></code>: Controller type string - <code class="docutils literal notranslate"><span class="pre">factory.max_force</span></code>: Force saturation limit - <strong>Function signature</strong>: <code class="docutils literal notranslate"><span class="pre">(gains)</span> <span class="pre">-&gt;</span> <span class="pre">PSOControllerWrapper</span></code> #### Performance Benefits - âœ… <strong>Factory overhead paid only once</strong> (vs. per-evaluation)</p></li>
<li><p>âœ… <strong>Optimized for high-frequency PSO calls</strong></p></li>
<li><p>âœ… <strong>Thread-safe operation</strong></p></li>
<li><p>âœ… <strong>Built-in PSO metadata</strong> #### Example Usage ```python</p></li>
</ul>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id3">
<h1>example-metadata:<a class="headerlink" href="#id3" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-create-factory-once-expensive-operation">
<h1>runnable: false # Create factory once (expensive operation)<a class="headerlink" href="#runnable-false-create-factory-once-expensive-operation" title="Link to this heading">Â¶</a></h1>
<p>factory = create_pso_controller_factory( SMCType.CLASSICAL, plant_config=config.physics, max_force=150.0
) # Check factory attributes
print(fâ€Required gains: {factory.n_gains}â€)
print(fâ€Controller type: {factory.controller_type}â€)
print(fâ€Max force: {factory.max_force}â€) # Use factory many times (fast operation)
def pso_fitness_function(gains): controller = factory(gains) # Fast! return evaluate_controller_performance(controller) # PSO optimization
tuner = PSOTuner( controller_factory=pso_fitness_function, config=config
)
best_gains, best_fitness = tuner.optimize()</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
<span class="o">---</span>

<span class="c1">## `get_gain_bounds_for_pso()` **Get PSO optimization bounds for controller gains.** ```python</span>

<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false def get_gain_bounds_for_pso(smc_type: SMCType) -&gt; Tuple[List[float], List[float]]</span>

<span class="err">```</span> <span class="c1">#### Parameters - **`smc_type`** (`SMCType`): SMC controller type enum #### Returns - **`Tuple[List[float], List[float]]`**: (lower_bounds, upper_bounds) - Based on control theory principles - Ensures stability and practical performance - Prevents excessive chattering and control effort #### Bounds Specifications ##### Classical SMC Bounds</span>
<span class="err">```</span><span class="n">python</span>
<span class="c1"># Gains: [k1, k2, lambda1, lambda2, K, kd]</span>

<span class="n">lower_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
<span class="n">upper_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="mf">30.0</span><span class="p">,</span> <span class="mf">30.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">50.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">]</span>
<span class="err">```</span> <span class="c1">##### Adaptive SMC Bounds</span>
<span class="err">```</span><span class="n">python</span>
<span class="c1"># Gains: [k1, k2, lambda1, lambda2, gamma]</span>

<span class="n">lower_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>
<span class="n">upper_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="mf">40.0</span><span class="p">,</span> <span class="mf">40.0</span><span class="p">,</span> <span class="mf">25.0</span><span class="p">,</span> <span class="mf">25.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">]</span>
<span class="err">```</span> <span class="c1">##### Super-Twisting SMC Bounds</span>
<span class="err">```</span><span class="n">python</span>
<span class="c1"># Gains: [K1, K2, k1, k2, lambda1, lambda2]</span>

<span class="n">lower_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>
<span class="n">upper_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="mf">50.0</span><span class="p">,</span> <span class="mf">30.0</span><span class="p">,</span> <span class="mf">30.0</span><span class="p">,</span> <span class="mf">30.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">]</span>
<span class="err">```</span> <span class="c1">##### Hybrid SMC Bounds</span>
<span class="err">```</span><span class="n">python</span>
<span class="c1"># Gains: [k1, k2, lambda1, lambda2]</span>

<span class="n">lower_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
<span class="n">upper_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="mf">30.0</span><span class="p">,</span> <span class="mf">30.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">]</span>
<span class="err">```</span> <span class="c1">#### Example Usage ```python</span>
<span class="c1"># example-metadata:</span>
<span class="c1"># runnable: false # Get bounds for PSO optimization</span>
<span class="n">bounds</span> <span class="o">=</span> <span class="n">get_gain_bounds_for_pso</span><span class="p">(</span><span class="n">SMCType</span><span class="o">.</span><span class="n">CLASSICAL</span><span class="p">)</span>
<span class="n">lower_bounds</span><span class="p">,</span> <span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">bounds</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Lower bounds: </span><span class="si">{</span><span class="n">lower_bounds</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Upper bounds: </span><span class="si">{</span><span class="n">upper_bounds</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="c1"># Use with PSO optimizer</span>
<span class="n">pso_config</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;bounds&#39;</span><span class="p">:</span> <span class="n">bounds</span><span class="p">,</span> <span class="s1">&#39;n_particles&#39;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s1">&#39;max_iter&#39;</span><span class="p">:</span> <span class="mi">100</span>
<span class="p">}</span> <span class="c1"># Validate bounds make sense</span>
<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span> <span class="c1"># Classical SMC has 6 gains</span>
<span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">u</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">,</span> <span class="n">upper_bounds</span><span class="p">))</span>
</pre></div>
</div>
<hr class="docutils" />
<section id="validate-smc-gains-validate-gains-for-a-specific-controller-type-python">
<h2><code class="docutils literal notranslate"><span class="pre">validate_smc_gains()</span></code> <strong>Validate gains for a specific controller type.</strong> ```python<a class="headerlink" href="#validate-smc-gains-validate-gains-for-a-specific-controller-type-python" title="Link to this heading">Â¶</a></h2>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id4">
<h1>example-metadata:<a class="headerlink" href="#id4" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-def-validate-smc-gains-smc-type-smctype-gains-union-list-np-ndarray-bool">
<h1>runnable: false def validate_smc_gains(smc_type: SMCType, gains: Union[list, np.ndarray]) -&gt; bool<a class="headerlink" href="#runnable-false-def-validate-smc-gains-smc-type-smctype-gains-union-list-np-ndarray-bool" title="Link to this heading">Â¶</a></h1>
<p>``` #### Parameters - <strong><code class="docutils literal notranslate"><span class="pre">smc_type</span></code></strong> (<code class="docutils literal notranslate"><span class="pre">SMCType</span></code>): SMC controller type enum</p>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">gains</span></code></strong> (<code class="docutils literal notranslate"><span class="pre">Union[list,</span> <span class="pre">np.ndarray]</span></code>): Gain values to validate #### Returns - <strong><code class="docutils literal notranslate"><span class="pre">bool</span></code></strong>: True if gains are valid, False otherwise #### Validation Criteria 1. <strong>Correct length</strong>: Matches expected gain count for controller type</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p><strong>Numeric type</strong>: All gains are int or float</p></li>
<li><p><strong>Finite values</strong>: No NaN or infinite values</p></li>
<li><p><strong>Positive values</strong>: All gains must be positive (SMC stability requirement) #### Example Usage ```python</p></li>
</ol>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id5">
<h1>example-metadata:<a class="headerlink" href="#id5" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-validate-gains-before-expensive-simulation">
<h1>runnable: false # Validate gains before expensive simulation<a class="headerlink" href="#runnable-false-validate-gains-before-expensive-simulation" title="Link to this heading">Â¶</a></h1>
<p>def robust_fitness_function(gains): if not validate_smc_gains(SMCType.CLASSICAL, gains): return float(â€˜infâ€™) # Invalid gains get worst fitness controller = create_smc_for_pso(SMCType.CLASSICAL, gains) return evaluate_controller_performance(controller) # Test various gain sets
test_gains = [ [20, 15, 12, 8, 35, 5], # Valid [20, 15, 12, 8, 35], # Wrong length [20, 15, 12, 8, -35, 5], # Negative value [20, 15, 12, 8, np.inf, 5], # Infinite value
] for i, gains in enumerate(test_gains): valid = validate_smc_gains(SMCType.CLASSICAL, gains) print(fâ€Gains {i+1}: {â€˜Validâ€™ if valid else â€˜Invalidâ€™}â€)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
<span class="o">---</span>

<span class="c1">## Controller Registry Functions ### Registry Access Functions #### `get_controller_info()` **Internal function to get controller registry information.** ```python</span>

<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false def _get_controller_info(controller_type: str) -&gt; Dict[str, Any]</span>

<span class="err">```</span> <span class="o">**</span><span class="n">Note</span><span class="o">**</span><span class="p">:</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">internal</span> <span class="n">function</span><span class="o">.</span> <span class="n">Use</span> <span class="n">public</span> <span class="n">functions</span> <span class="n">like</span> <span class="err">`</span><span class="n">list_available_controllers</span><span class="p">()</span><span class="err">`</span> <span class="n">instead</span><span class="o">.</span> <span class="c1">#### Registry Structure The `CONTROLLER_REGISTRY` contains metadata for each controller: ```python</span>
<span class="c1"># example-metadata:</span>
<span class="c1"># runnable: false CONTROLLER_REGISTRY = { &#39;controller_type&#39;: { &#39;class&#39;: ControllerClass, # Implementation class &#39;config_class&#39;: ConfigClass, # Configuration class &#39;default_gains&#39;: [float, ...], # Default gain values &#39;gain_count&#39;: int, # Expected number of gains &#39;description&#39;: str, # Human-readable description &#39;supports_dynamics&#39;: bool, # Supports dynamics model &#39;required_params&#39;: [str, ...] # Required parameters }</span>
<span class="p">}</span>
<span class="err">```</span> <span class="c1">#### Controller Aliases The following aliases are supported for backward compatibility: ```python</span>
<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false CONTROLLER_ALIASES = { &#39;classic_smc&#39;: &#39;classical_smc&#39;, &#39;smc_classical&#39;: &#39;classical_smc&#39;, &#39;smc_v1&#39;: &#39;classical_smc&#39;, &#39;super_twisting&#39;: &#39;sta_smc&#39;, &#39;sta&#39;: &#39;sta_smc&#39;, &#39;adaptive&#39;: &#39;adaptive_smc&#39;, &#39;hybrid&#39;: &#39;hybrid_adaptive_sta_smc&#39;, &#39;hybrid_sta&#39;: &#39;hybrid_adaptive_sta_smc&#39;,</span>

<span class="p">}</span>
</pre></div>
</div>
<hr class="docutils" />
<section id="configuration-functions-configuration-resolution-the-factory-system-resolves-configuration-from-multiple-sources-with-the-following-priority-1-explicit-parameters-highest-priority">
<h2>Configuration Functions ### Configuration Resolution The factory system resolves configuration from multiple sources with the following priority: 1. <strong>Explicit parameters</strong> (highest priority)<a class="headerlink" href="#configuration-functions-configuration-resolution-the-factory-system-resolves-configuration-from-multiple-sources-with-the-following-priority-1-explicit-parameters-highest-priority" title="Link to this heading">Â¶</a></h2>
<ol class="arabic simple" start="2">
<li><p><strong>Configuration object attributes</strong></p></li>
<li><p><strong>YAML configuration defaults</strong></p></li>
<li><p><strong>Registry defaults</strong> (lowest priority) ### <code class="docutils literal notranslate"><span class="pre">_resolve_controller_gains()</span></code> <strong>Internal function for gain resolution from multiple sources.</strong> <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">def</span> <span class="pre">_resolve_controller_gains(</span> <span class="pre">gains:</span> <span class="pre">Optional[Union[List[float],</span> <span class="pre">np.ndarray]],</span> <span class="pre">config:</span> <span class="pre">Optional[Any],</span> <span class="pre">controller_type:</span> <span class="pre">str,</span> <span class="pre">controller_info:</span> <span class="pre">Dict[str,</span> <span class="pre">Any]</span> <span class="pre">)</span> <span class="pre">-&gt;</span> <span class="pre">List[float]</span> </code> #### Configuration Extraction Patterns The factory supports multiple configuration patterns: ```python</p></li>
</ol>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="pattern-1-direct-controller-configuration">
<h1>Pattern 1: Direct controller configuration<a class="headerlink" href="#pattern-1-direct-controller-configuration" title="Link to this heading">Â¶</a></h1>
<p>config.controllers.classical_smc.gains = [20, 15, 12, 8, 35, 5] # Pattern 2: Controller defaults
config.controller_defaults.classical_smc.gains = [20, 15, 12, 8, 35, 5] # Pattern 3: Dictionary-style access
config.controllers[â€˜classical_smcâ€™][â€˜gainsâ€™] = [20, 15, 12, 8, 35, 5]
<code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">Deprecation</span> <span class="pre">Handling</span></code>python
def check_deprecated_config(controller_type: str, params: Dict[str, Any]) -&gt; Dict[str, Any]: â€œâ€â€Check for deprecated parameters and apply migrations.â€â€â€
<code class="docutils literal notranslate"><span class="pre">####</span> <span class="pre">Common</span> <span class="pre">Deprecation</span> <span class="pre">Mappings</span></code>python</p>
<p>deprecated_mappings = { â€˜use_equivalentâ€™: â€˜enable_equivalent_controlâ€™, â€˜k_gainâ€™: â€˜switching_gainâ€™, â€˜lambda_gainsâ€™: â€˜surface_gainsâ€™
}</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
<span class="o">---</span>

<span class="c1">## Validation Functions ### Controller Gain Validation #### `_validate_controller_gains()` **gain validation with domain-specific checks.** ```python</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_validate_controller_gains</span><span class="p">(</span> <span class="n">gains</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">controller_info</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
<span class="err">```</span> <span class="c1">#### Validation Checks 1. **Length validation**: Correct number of gains</span>

<span class="mf">2.</span> <span class="o">**</span><span class="n">Type</span> <span class="n">validation</span><span class="o">**</span><span class="p">:</span> <span class="n">All</span> <span class="n">gains</span> <span class="n">are</span> <span class="n">numeric</span>
<span class="mf">3.</span> <span class="o">**</span><span class="n">Finite</span> <span class="n">validation</span><span class="o">**</span><span class="p">:</span> <span class="n">No</span> <span class="n">NaN</span> <span class="ow">or</span> <span class="n">infinite</span> <span class="n">values</span>
<span class="mf">4.</span> <span class="o">**</span><span class="n">Positivity</span> <span class="n">validation</span><span class="o">**</span><span class="p">:</span> <span class="n">All</span> <span class="n">gains</span> <span class="n">positive</span> <span class="p">(</span><span class="n">SMC</span> <span class="n">requirement</span><span class="p">)</span> <span class="c1">### MPC Parameter Validation #### `_validate_mpc_parameters()` **Specialized validation for MPC controller parameters.** ```python</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_validate_mpc_parameters</span><span class="p">(</span> <span class="n">config_params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">controller_params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
<span class="err">```</span> <span class="c1">#### MPC Validation Rules ```python</span>
<span class="c1"># example-metadata:</span>
<span class="c1"># runnable: false # Horizon must be positive integer</span>
<span class="k">if</span> <span class="s1">&#39;horizon&#39;</span> <span class="ow">in</span> <span class="n">params</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;horizon&#39;</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;horizon&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span> <span class="k">raise</span> <span class="n">ConfigValueError</span><span class="p">(</span><span class="s2">&quot;horizon must be â‰¥ 1&quot;</span><span class="p">)</span> <span class="c1"># Geometric constraints</span>
<span class="k">if</span> <span class="s1">&#39;max_cart_pos&#39;</span> <span class="ow">in</span> <span class="n">params</span> <span class="ow">and</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;max_cart_pos&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="n">ConfigValueError</span><span class="p">(</span><span class="s2">&quot;max_cart_pos must be &gt; 0&quot;</span><span class="p">)</span> <span class="c1"># Weight parameters must be non-negative</span>
<span class="n">weight_params</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;q_x&#39;</span><span class="p">,</span> <span class="s1">&#39;q_theta&#39;</span><span class="p">,</span> <span class="s1">&#39;r_u&#39;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">weight_params</span><span class="p">:</span> <span class="k">if</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span> <span class="ow">and</span> <span class="n">params</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="n">ConfigValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s2"> must be â‰¥ 0&quot;</span><span class="p">)</span>
</pre></div>
</div>
<hr class="docutils" />
<section id="type-definitions-core-types-python">
<h2>Type Definitions ### Core Types ```python<a class="headerlink" href="#type-definitions-core-types-python" title="Link to this heading">Â¶</a></h2>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="type-aliases-for-better-type-safety">
<h1>Type aliases for better type safety<a class="headerlink" href="#type-aliases-for-better-type-safety" title="Link to this heading">Â¶</a></h1>
<p>StateVector = NDArray[np.float64] # System state vector
ControlOutput = Union[float, NDArray[np.float64]] # Control output
GainsArray = Union[List[float], NDArray[np.float64]] # Gain values
ConfigDict = Dict[str, Any] # Configuration dictionary # Generic type for controller instances
ControllerT = TypeVar(â€˜ControllerTâ€™)
<code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">Protocol</span> <span class="pre">Definitions</span> <span class="pre">####</span> <span class="pre">`ControllerProtocol`</span> <span class="pre">**Standard</span> <span class="pre">interface</span> <span class="pre">that</span> <span class="pre">all</span> <span class="pre">controllers</span> <span class="pre">must</span> <span class="pre">implement.**</span></code>python</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id6">
<h1>example-metadata:<a class="headerlink" href="#id6" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-class-controllerprotocol-protocol-protocol-defining-the-standard-controller-interface-def-compute-control-self-state-statevector-last-control-float-history-configdict-controloutput-compute-control-output-for-given-state-def-reset-self-none-reset-controller-internal-state-property-def-gains-self-list-float-return-controller-gains">
<h1>runnable: false class ControllerProtocol(Protocol): â€œâ€â€Protocol defining the standard controller interface.â€â€â€ def compute_control( self, state: StateVector, last_control: float, history: ConfigDict ) -&gt; ControlOutput: â€œâ€â€Compute control output for given state.â€â€â€ â€¦ def reset(self) -&gt; None: â€œâ€â€Reset controller internal state.â€â€â€ â€¦ &#64;property def gains(self) -&gt; List[float]: â€œâ€â€Return controller gains.â€â€â€ â€¦<a class="headerlink" href="#runnable-false-class-controllerprotocol-protocol-protocol-defining-the-standard-controller-interface-def-compute-control-self-state-statevector-last-control-float-history-configdict-controloutput-compute-control-output-for-given-state-def-reset-self-none-reset-controller-internal-state-property-def-gains-self-list-float-return-controller-gains" title="Link to this heading">Â¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">Enum</span> <span class="pre">Definitions</span> <span class="pre">####</span> <span class="pre">`SMCType`</span> <span class="pre">**Enumeration</span> <span class="pre">of</span> <span class="pre">supported</span> <span class="pre">SMC</span> <span class="pre">controller</span> <span class="pre">types.**</span></code>python</p>
<p>class SMCType(Enum): â€œâ€â€SMC Controller types enumeration.â€â€â€ CLASSICAL = â€œclassical_smcâ€ ADAPTIVE = â€œadaptive_smcâ€ SUPER_TWISTING = â€œsta_smcâ€ HYBRID = â€œhybrid_adaptive_sta_smcâ€
<code class="docutils literal notranslate"><span class="pre">####</span> <span class="pre">`HybridMode`</span> <span class="pre">**Enumeration</span> <span class="pre">for</span> <span class="pre">hybrid</span> <span class="pre">controller</span> <span class="pre">operation</span> <span class="pre">modes.**</span></code>python
class HybridMode(Enum): â€œâ€â€Hybrid controller operation modes.â€â€â€ CLASSICAL_ADAPTIVE = â€œclassical_adaptiveâ€ STA_ADAPTIVE = â€œsta_adaptiveâ€ DYNAMIC_SWITCHING = â€œdynamic_switchingâ€</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
<span class="o">---</span>

<span class="c1">## Exceptions ### Custom Exception Classes #### `ConfigValueError` **Exception raised for invalid configuration values.** ```python</span>

<span class="k">class</span><span class="w"> </span><span class="nc">ConfigValueError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot;Exception raised for invalid configuration values.&quot;&quot;&quot;</span> <span class="k">pass</span>
<span class="err">```</span> <span class="o">**</span><span class="n">Usage</span> <span class="n">Example</span><span class="p">:</span><span class="o">**</span>
<span class="err">```</span><span class="n">python</span>

<span class="k">try</span><span class="p">:</span> <span class="n">controller</span> <span class="o">=</span> <span class="n">create_controller</span><span class="p">(</span><span class="s1">&#39;mpc_controller&#39;</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">invalid_config</span><span class="p">)</span>
<span class="k">except</span> <span class="n">ConfigValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Configuration error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="c1"># Handle invalid configuration</span>
<span class="err">```</span> <span class="c1">### Standard Exceptions #### `ValueError` **Raised for invalid controller types or parameters.** ```python</span>
<span class="c1"># example-metadata:</span>
<span class="c1"># runnable: false # Unknown controller type</span>
<span class="k">try</span><span class="p">:</span> <span class="n">controller</span> <span class="o">=</span> <span class="n">create_controller</span><span class="p">(</span><span class="s1">&#39;invalid_controller&#39;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="c1"># Output: Unknown controller type &#39;invalid_controller&#39;. Available: [...] # Invalid gain count</span>
<span class="k">try</span><span class="p">:</span> <span class="n">controller</span> <span class="o">=</span> <span class="n">create_controller</span><span class="p">(</span><span class="s1">&#39;classical_smc&#39;</span><span class="p">,</span> <span class="n">gains</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="c1"># Need 6 gains</span>
<span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="c1"># Output: Controller &#39;classical_smc&#39; requires 6 gains, got 3</span>
<span class="err">```</span> <span class="c1">#### `ImportError` **Raised for missing dependencies or unavailable controllers.** ```python</span>
<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false # MPC without optional dependencies</span>

<span class="k">try</span><span class="p">:</span> <span class="n">controller</span> <span class="o">=</span> <span class="n">create_controller</span><span class="p">(</span><span class="s1">&#39;mpc_controller&#39;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Import error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="c1"># Output: MPC controller missing optional dependency. Available controllers: [...]</span>
<span class="err">```</span> <span class="c1">### Error Handling Patterns #### Robust Error Handling ```python</span>
<span class="c1"># example-metadata:</span>
<span class="c1"># runnable: false def create_controller_safely(controller_type: str, **kwargs) -&gt; Optional[Any]: &quot;&quot;&quot;Create controller with error handling.&quot;&quot;&quot; try: return create_controller(controller_type, **kwargs) except ValueError as e: logger.error(f&quot;Configuration error for {controller_type}: {e}&quot;) return None except ImportError as e: logger.warning(f&quot;Import error for {controller_type}: {e}&quot;) return None except Exception as e: logger.error(f&quot;Unexpected error creating {controller_type}: {e}&quot;) return None</span>
<span class="err">```</span> <span class="c1">#### Graceful Degradation ```python</span>
<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false def create_best_available_controller(preferred_types: List[str]) -&gt; Any: &quot;&quot;&quot;Create first available controller from preference list.&quot;&quot;&quot; available = list_available_controllers() for controller_type in preferred_types: if controller_type in available: try: return create_controller(controller_type) except Exception as e: logger.warning(f&quot;Failed to create {controller_type}: {e}&quot;) continue # Fallback to any available controller if available: return create_controller(available[0]) else: raise RuntimeError(&quot;No controllers available&quot;)</span>

</pre></div>
</div>
<hr class="docutils" />
<section id="examples-basic-factory-usage-python">
<h2>Examples ### Basic Factory Usage ```python<a class="headerlink" href="#examples-basic-factory-usage-python" title="Link to this heading">Â¶</a></h2>
<p>#!/usr/bin/env python3
â€œâ€â€Basic factory usage examples.â€â€â€ from src.controllers.factory import create_controller, list_available_controllers def basic_factory_examples(): â€œâ€â€Demonstrate basic factory usage patterns.â€â€â€ # Check available controllers available = list_available_controllers() print(fâ€Available controllers: {available}â€) # Create controller with defaults controller = create_controller(â€˜classical_smcâ€™) print(fâ€Default gains: {controller.gains}â€) # Create with explicit gains custom_gains = [25.0, 20.0, 15.0, 10.0, 40.0, 6.0] controller = create_controller(â€˜classical_smcâ€™, gains=custom_gains) print(fâ€Custom gains: {controller.gains}â€) # Test controller functionality import numpy as np state = np.array([0.1, 0.05, 0.0, 0.0, 0.0, 0.0]) control_output = controller.compute_control(state, 0.0, {}) print(fâ€Control output: {control_output}â€) if <strong>name</strong> == â€œ<strong>main</strong>â€: basic_factory_examples()
<code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">PSO</span> <span class="pre">Integration</span> <span class="pre">Example</span></code>python</p>
<p>#!/usr/bin/env python3
â€œâ€â€PSO integration examples.â€â€â€ from src.controllers.factory import ( create_pso_controller_factory, get_gain_bounds_for_pso, validate_smc_gains, SMCType
)
import numpy as np def pso_integration_example(): â€œâ€â€Demonstrate PSO integration patterns.â€â€â€ # Get optimization bounds bounds = get_gain_bounds_for_pso(SMCType.CLASSICAL) lower_bounds, upper_bounds = bounds print(fâ€Optimization bounds: {lower_bounds} to {upper_bounds}â€) # Create PSO-optimized factory factory = create_pso_controller_factory(SMCType.CLASSICAL) print(fâ€Factory requires {factory.n_gains} gainsâ€) # Define fitness function def fitness_function(gains: np.ndarray) -&gt; float: â€œâ€â€PSO fitness function with validation.â€â€â€ # Pre-validate gains if not validate_smc_gains(SMCType.CLASSICAL, gains): return float(â€˜infâ€™) try: # Create controller controller = factory(gains) # Simplified performance evaluation test_state = np.array([0.1, 0.05, 0.0, 0.0, 0.0, 0.0]) control_output = controller.compute_control(test_state) # Simple fitness (control effort) return abs(control_output.u) if hasattr(control_output, â€˜uâ€™) else abs(control_output) except Exception: return float(â€˜infâ€™) # Test fitness function test_gains = np.array([20.0, 15.0, 12.0, 8.0, 35.0, 5.0]) fitness = fitness_function(test_gains) print(fâ€Test fitness: {fitness}â€) # Simulate PSO particle validation particles = np.random.uniform( low=lower_bounds, high=upper_bounds, size=(10, len(lower_bounds)) ) valid_particles = [] for particle in particles: if validate_smc_gains(SMCType.CLASSICAL, particle): valid_particles.append(particle) print(fâ€Valid particles: {len(valid_particles)}/{len(particles)}â€) if <strong>name</strong> == â€œ<strong>main</strong>â€: pso_integration_example()
<code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">Advanced</span> <span class="pre">Configuration</span> <span class="pre">Example</span></code>python
#!/usr/bin/env python3
â€œâ€â€Advanced configuration examples.â€â€â€ from src.controllers.factory import create_controller
from src.config import load_config
import numpy as np def advanced_configuration_example(): â€œâ€â€Demonstrate advanced configuration patterns.â€â€â€ # Load configuration from file config = load_config(â€œconfig.yamlâ€) # Create controllers with various configuration methods controllers = {} # Method 1: Configuration file only controllers[â€˜config_onlyâ€™] = create_controller(â€˜classical_smcâ€™, config=config) # Method 2: Override gains from config custom_gains = [30.0, 25.0, 18.0, 12.0, 45.0, 8.0] controllers[â€˜override_gainsâ€™] = create_controller( â€˜classical_smcâ€™, config=config, gains=custom_gains # Overrides config gains ) # Method 3: Different controller types for controller_type in [â€˜classical_smcâ€™, â€˜adaptive_smcâ€™, â€˜sta_smcâ€™]: try: controllers[controller_type] = create_controller(controller_type, config=config) except ImportError as e: print(fâ€Skipping {controller_type}: {e}â€) # Compare controller properties for name, controller in controllers.items(): print(fâ€{name}:â€) print(fâ€ Gains: {controller.gains}â€) print(fâ€ Max force: {getattr(controller, â€˜max_forceâ€™, â€˜N/Aâ€™)}â€) # Test control computation test_state = np.array([0.1, 0.05, 0.0, 0.0, 0.0, 0.0]) try: control_output = controller.compute_control(test_state, 0.0, {}) control_value = control_output.u if hasattr(control_output, â€˜uâ€™) else control_output print(fâ€ Control output: {control_value:.3f}â€) except Exception as e: print(fâ€ Control computation failed: {e}â€) print() if <strong>name</strong> == â€œ<strong>main</strong>â€: advanced_configuration_example()
<code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">Error</span> <span class="pre">Handling</span> <span class="pre">Example</span></code>python</p>
<p>#!/usr/bin/env python3
â€œâ€â€Error handling examples.â€â€â€ from src.controllers.factory import create_controller, list_available_controllers
import logging logging.basicConfig(<a class="reference external" href="http://level=logging.INFO">level=logging.INFO</a>) def error_handling_example(): â€œâ€â€Demonstrate robust error handling patterns.â€â€â€ test_cases = [ # Valid cases (â€˜classical_smcâ€™, [20, 15, 12, 8, 35, 5], â€œValid classical SMCâ€), (â€˜adaptive_smcâ€™, [25, 18, 15, 10, 4], â€œValid adaptive SMCâ€), # Error cases (â€˜invalid_controllerâ€™, None, â€œUnknown controller typeâ€), (â€˜classical_smcâ€™, [1, 2, 3], â€œInvalid gain countâ€), (â€˜classical_smcâ€™, [-20, 15, 12, 8, 35, 5], â€œNegative gainsâ€), (â€˜mpc_controllerâ€™, None, â€œPotentially missing dependenciesâ€), ] for controller_type, gains, description in test_cases: print(fâ€Testing: {description}â€) try: if gains is not None: controller = create_controller(controller_type, gains=gains) else: controller = create_controller(controller_type) print(fâ€ âœ… Success: {controller_type} createdâ€) print(fâ€ Gains: {controller.gains}â€) except ValueError as e: print(fâ€ âŒ Configuration Error: {e}â€) except ImportError as e: print(fâ€ âš ï¸ Import Error: {e}â€) available = list_available_controllers() print(fâ€ Available: {available}â€) except Exception as e: print(fâ€ ğŸ’¥ Unexpected Error: {e}â€) print() if <strong>name</strong> == â€œ<strong>main</strong>â€: error_handling_example()</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
<span class="o">---</span>

<span class="n">This</span> <span class="n">API</span> <span class="n">reference</span> <span class="n">provides</span> <span class="n">complete</span> <span class="n">documentation</span> <span class="k">for</span> <span class="nb">all</span> <span class="n">factory</span> <span class="n">methods</span><span class="p">,</span> <span class="n">including</span> <span class="n">detailed</span> <span class="n">parameter</span> <span class="n">specifications</span><span class="p">,</span> <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">error</span> <span class="n">handling</span><span class="p">,</span> <span class="ow">and</span> <span class="n">practical</span> <span class="n">examples</span><span class="o">.</span> <span class="n">The</span> <span class="n">documentation</span> <span class="n">covers</span> <span class="n">both</span> <span class="n">basic</span> <span class="n">usage</span> <span class="n">patterns</span> <span class="ow">and</span> <span class="n">advanced</span> <span class="n">integration</span> <span class="n">scenarios</span><span class="p">,</span> <span class="n">ensuring</span> <span class="n">developers</span> <span class="n">can</span> <span class="n">effectively</span> <span class="n">use</span> <span class="n">the</span> <span class="n">factory</span> <span class="n">system</span> <span class="k">for</span> <span class="n">their</span> <span class="n">specific</span> <span class="n">requirements</span><span class="o">.</span>
</pre></div>
</div>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="optimization_module_api_reference.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Optimization Module API Reference <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="factory_reference.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Factory API Reference ## Controller Factory System - GitHub Issue #6 Implementation ### Overview The Controller Factory System provides a unified, type-safe interface for creating and managing sliding mode control (SMC) controllers in the DIP-SMC-PSO project. This system implements the factory pattern to ensure consistent controller instantiation, parameter validation, and optimization integration. ### Architecture #### Core Components 1. <strong>Main Factory</strong> (<code class="docutils literal notranslate"><span class="pre">src/controllers/factory.py</span></code>) - Central controller registry and creation interface - Thread-safe operations with RLock protection - error handling and validation - Legacy compatibility support 2. <strong>SMC Factory</strong> (<code class="docutils literal notranslate"><span class="pre">src/controllers/factory/smc_factory.py</span></code>) - Specialized factory for SMC controllers - PSO optimization integration - Type-safe parameter handling 3. <strong>Legacy Factory</strong> (<code class="docutils literal notranslate"><span class="pre">src/controllers/factory/legacy_factory.py</span></code>) - Backward compatibility interface - Deprecation handling and migration support ### Supported Controllers | Controller Type | Class | Gains | Description |</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Research Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on Oct 11, 2025</div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Factory Methods API Reference ## Overview This document provides API reference documentation for the Enterprise Controller Factory system. The factory provides thread-safe, type-safe controller instantiation with deep PSO integration and robust error handling. ## Table of Contents 1. <span class="xref myst">Core Factory Functions</span></a><ul>
<li><a class="reference internal" href="#core-factory-functions-create-controller-primary-factory-function-for-creating-controller-instances-python">Core Factory Functions ### <code class="docutils literal notranslate"><span class="pre">create_controller()</span></code> <strong>Primary factory function for creating controller instances.</strong> ```python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#basic-usage-with-default-parameters">Basic usage with default parameters</a><ul>
<li><a class="reference internal" href="#list-available-controllers-get-list-of-currently-available-controller-types-python"><code class="docutils literal notranslate"><span class="pre">list_available_controllers()</span></code> <strong>Get list of currently available controller types.</strong> ```python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-metadata">example-metadata:</a></li>
<li><a class="reference internal" href="#runnable-false-def-list-available-controllers-list-str">runnable: false def list_available_controllers() -&gt; List[str]</a></li>
<li><a class="reference internal" href="#output-classical-smc-sta-smc-adaptive-smc-hybrid-adaptive-sta-smc">Output: [â€˜classical_smcâ€™, â€˜sta_smcâ€™, â€˜adaptive_smcâ€™, â€˜hybrid_adaptive_sta_smcâ€™]</a></li>
<li><a class="reference internal" href="#note-mpc-controller-only-included-if-optional-dependencies-available">Note: â€˜mpc_controllerâ€™ only included if optional dependencies available</a><ul>
<li><a class="reference internal" href="#get-default-gains-get-default-gains-for-a-specific-controller-type-python"><code class="docutils literal notranslate"><span class="pre">get_default_gains()</span></code> <strong>Get default gains for a specific controller type.</strong> ```python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id1">example-metadata:</a></li>
<li><a class="reference internal" href="#runnable-false-def-get-default-gains-controller-type-str-list-float">runnable: false def get_default_gains(controller_type: str) -&gt; List[float]</a></li>
<li><a class="reference internal" href="#id2">example-metadata:</a></li>
<li><a class="reference internal" href="#runnable-false-get-default-gains-for-different-controllers">runnable: false # Get default gains for different controllers</a></li>
<li><a class="reference internal" href="#output-20-0-15-0-12-0-8-0-35-0-5-0-adaptive-gains-get-default-gains-adaptive-smc">Output: [20.0, 15.0, 12.0, 8.0, 35.0, 5.0] adaptive_gains = get_default_gains(â€˜adaptive_smcâ€™)</a></li>
<li><a class="reference internal" href="#output-25-0-18-0-15-0-10-0-4-0-use-as-starting-point-for-optimization">Output: [25.0, 18.0, 15.0, 10.0, 4.0] # Use as starting point for optimization</a><ul>
<li><a class="reference internal" href="#create-pso-controller-factory-create-a-pso-optimized-controller-factory-function-python"><code class="docutils literal notranslate"><span class="pre">create_pso_controller_factory()</span></code> <strong>Create a PSO-optimized controller factory function.</strong> ```python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id3">example-metadata:</a></li>
<li><a class="reference internal" href="#runnable-false-create-factory-once-expensive-operation">runnable: false # Create factory once (expensive operation)</a><ul>
<li><a class="reference internal" href="#validate-smc-gains-validate-gains-for-a-specific-controller-type-python"><code class="docutils literal notranslate"><span class="pre">validate_smc_gains()</span></code> <strong>Validate gains for a specific controller type.</strong> ```python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4">example-metadata:</a></li>
<li><a class="reference internal" href="#runnable-false-def-validate-smc-gains-smc-type-smctype-gains-union-list-np-ndarray-bool">runnable: false def validate_smc_gains(smc_type: SMCType, gains: Union[list, np.ndarray]) -&gt; bool</a></li>
<li><a class="reference internal" href="#id5">example-metadata:</a></li>
<li><a class="reference internal" href="#runnable-false-validate-gains-before-expensive-simulation">runnable: false # Validate gains before expensive simulation</a><ul>
<li><a class="reference internal" href="#configuration-functions-configuration-resolution-the-factory-system-resolves-configuration-from-multiple-sources-with-the-following-priority-1-explicit-parameters-highest-priority">Configuration Functions ### Configuration Resolution The factory system resolves configuration from multiple sources with the following priority: 1. <strong>Explicit parameters</strong> (highest priority)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pattern-1-direct-controller-configuration">Pattern 1: Direct controller configuration</a><ul>
<li><a class="reference internal" href="#type-definitions-core-types-python">Type Definitions ### Core Types ```python</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-aliases-for-better-type-safety">Type aliases for better type safety</a></li>
<li><a class="reference internal" href="#id6">example-metadata:</a></li>
<li><a class="reference internal" href="#runnable-false-class-controllerprotocol-protocol-protocol-defining-the-standard-controller-interface-def-compute-control-self-state-statevector-last-control-float-history-configdict-controloutput-compute-control-output-for-given-state-def-reset-self-none-reset-controller-internal-state-property-def-gains-self-list-float-return-controller-gains">runnable: false class ControllerProtocol(Protocol): â€œâ€â€Protocol defining the standard controller interface.â€â€â€ def compute_control( self, state: StateVector, last_control: float, history: ConfigDict ) -&gt; ControlOutput: â€œâ€â€Compute control output for given state.â€â€â€ â€¦ def reset(self) -&gt; None: â€œâ€â€Reset controller internal state.â€â€â€ â€¦ &#64;property def gains(self) -&gt; List[float]: â€œâ€â€Return controller gains.â€â€â€ â€¦</a><ul>
<li><a class="reference internal" href="#examples-basic-factory-usage-python">Examples ### Basic Factory Usage ```python</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=4ebf8126"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=46bd48cc"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=08e7b316"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../_static/back-to-top.js?v=840797bb"></script>
    <script src="../_static/lazy-load.js?v=dc25293c"></script>
    <script src="../_static/dark-mode.js?v=bf328970"></script>
    </body>
</html>