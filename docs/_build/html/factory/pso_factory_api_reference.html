<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
.chartjs-container {
    margin: 1.5em auto;
    padding: 1em;
    background: #f8f9fa;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.chart-note {
    text-align: center;
    color: #6c757d;
    font-size: 0.9em;
    margin-top: 0.5em;
}
</style>
<link rel="index" title="Index" href="../genindex.html"><link rel="search" title="Search" href="../search.html">

    <!-- Generated with Sphinx 8.2.3 and Furo 2025.09.25 -->
        <title>Complete Documentation for PSO-Optimized Controller Factory ### Table of Contents - DIP_SMC_PSO Documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5349f25f" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=580074bf" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=8dab3a3b" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=8a7e329d" />
    
    


<style>
  body {
    --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">DIP_SMC_PSO Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  <span class="sidebar-brand-text">DIP_SMC_PSO Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">üìö Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Optimal Sliding Mode Control for a Double-Inverted Pendulum via PSO  ## How to validate a ResearchPlan JSON Run the validator locally: ```bash</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory_overview.html">Theory Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../architecture.html">3. System Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plant_model.html">1.x Plant Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hil_quickstart.html">Hardware-in-the-Loop (HIL) Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../streamlit_dashboard_guide.html">Streamlit Dashboard User Guide</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/blob/main/docs/factory/pso_factory_api_reference.md?plain=true" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div><div class="edit-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/edit/main/docs/factory/pso_factory_api_reference.md" rel="edit" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <p>#==========================================================================================\<br />
#================== docs/factory/pso_factory_api_reference.md ================\<br />
#==========================================================================================\ # PSO Factory Integration API Reference</p>
<section id="complete-documentation-for-pso-optimized-controller-factory-table-of-contents">
<h1>Complete Documentation for PSO-Optimized Controller Factory ### Table of Contents<a class="headerlink" href="#complete-documentation-for-pso-optimized-controller-factory-table-of-contents" title="Link to this heading">¬∂</a></h1>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#api-overview"><span class="xref myst">API Overview</span></a></p></li>
<li><p><a class="reference internal" href="#core-pso-integration-classes"><span class="xref myst">Core PSO Integration Classes</span></a></p></li>
<li><p><a class="reference internal" href="#factory-functions-for-pso"><span class="xref myst">Factory Functions for PSO</span></a></p></li>
<li><p><a class="reference internal" href="#pso-controller-wrapper"><span class="xref myst">PSO Controller Wrapper</span></a></p></li>
<li><p><a class="reference internal" href="#mathematical-constraints-api"><span class="xref myst">Mathematical Constraints API</span></a></p></li>
<li><p><a class="reference internal" href="#configuration-schema-api"><span class="xref myst">Configuration Schema API</span></a></p></li>
<li><p><a class="reference internal" href="#performance-monitoring-api"><span class="xref myst">Performance Monitoring API</span></a></p></li>
<li><p><a class="reference internal" href="#advanced-pso-workflows"><span class="xref myst">Advanced PSO Workflows</span></a></p></li>
<li><p><a class="reference internal" href="#error-handling-reference"><span class="xref myst">Error Handling Reference</span></a></p></li>
<li><p><a class="reference internal" href="#usage-examples"><span class="xref myst">Usage Examples</span></a></p></li>
</ol>
<hr class="docutils" />
</section>
<section id="api-overview-the-pso-factory-integration-api-provides-a-framework-for-optimizing-sliding-mode-controllers-using-particle-swarm-optimization-the-api-is-designed-with-the-following-principles-design-philosophy">
<h1>API Overview The PSO Factory Integration API provides a framework for optimizing sliding mode controllers using Particle Swarm Optimization. The API is designed with the following principles: ### Design Philosophy<a class="headerlink" href="#api-overview-the-pso-factory-integration-api-provides-a-framework-for-optimizing-sliding-mode-controllers-using-particle-swarm-optimization-the-api-is-designed-with-the-following-principles-design-philosophy" title="Link to this heading">¬∂</a></h1>
<ul class="simple">
<li><p><strong>Mathematical Rigor</strong>: All functions incorporate control theory constraints</p></li>
<li><p><strong>Type Safety</strong>: Complete type annotations with runtime validation</p></li>
<li><p><strong>Performance</strong>: Optimized for real-time PSO fitness evaluation</p></li>
<li><p><strong>Ease of Use</strong>: Single-function interfaces for common operations</p></li>
<li><p><strong>Extensibility</strong>: Support for custom optimization algorithms ### Import Structure</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Core PSO-Factory integration</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">controllers</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span> <span class="n">SMCType</span><span class="p">,</span> <span class="c1"># Controller type enumeration create_smc_for_pso, # Primary PSO interface get_gain_bounds_for_pso, # Mathematical bounds validate_smc_gains, # Constraint validation PSOControllerWrapper # PSO-optimized wrapper</span>
<span class="p">)</span> <span class="c1"># Advanced PSO workflows</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">controllers.factory</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span> <span class="n">SMCFactory</span><span class="p">,</span> <span class="c1"># Full factory interface SMCConfig, # Type-safe configuration SMCGainSpec # Gain specifications</span>
<span class="p">)</span> <span class="c1"># Performance monitoring</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">controllers.factory.monitoring</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span> <span class="n">PSOPerformanceMonitor</span><span class="p">,</span> <span class="c1"># Real-time monitoring PSOBenchmarkSuite # benchmarking</span>
<span class="p">)</span>
</pre></div>
</div>
<hr class="docutils" />
</section>
<section id="core-pso-integration-classes-smctype-enumeration-python">
<h1>Core PSO Integration Classes ### SMCType Enumeration ```python<a class="headerlink" href="#core-pso-integration-classes-smctype-enumeration-python" title="Link to this heading">¬∂</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="example-metadata">
<h1>example-metadata:<a class="headerlink" href="#example-metadata" title="Link to this heading">¬∂</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-class-smctype-enum-enumeration-of-supported-smc-controller-types-for-pso-optimization-each-type-corresponds-to-a-specific-sliding-mode-control-algorithm-with-distinct-mathematical-properties-and-parameter-requirements-classical-classical-smc-classical-sliding-mode-controller-with-boundary-layer-mathematical-model-u-u-eq-u-sw-u-eq-gb-1-gf-x-s-ref-u-sw-ktanh-s-gain-parameters-k1-k2-1-2-k-kd-k1-k2-position-gains-for-pendulum-1-and-2-1-2-surface-gains-for-pendulum-1-and-2-k-switching-gain-kd-damping-gain-mathematical-constraints-1-2-k-0-stability-requirement-kd-0-non-negative-damping-pso-bounds-0-1-50-0-1-50-1-50-1-50-1-200-0-50-super-twisting-sta-smc-super-twisting-sliding-mode-controller-second-order-mathematical-model-u-k1sign-s-k2sign-s-s-x-sliding-surface-gain-parameters-k1-k2-1-2-1-2-k1-primary-twisting-gain-k2-secondary-twisting-gain-1-2-surface-gains-1-2-higher-order-surface-parameters-mathematical-constraints-k1-k2-0-finite-time-convergence-1-2-1-2-0-stability-pso-bounds-2-100-1-99-1-50-1-50-1-50-1-50-adaptive-adaptive-smc-adaptive-sliding-mode-controller-with-online-gain-tuning-mathematical-model-u-u-eq-u-sw-k-s-k-adaptation-law-gain-parameters-k1-k2-1-2-k1-k2-position-gains-1-2-surface-gains-adaptation-rate-mathematical-constraints-k1-k2-1-2-0-stability-0-1-20-0-bounded-adaptation-pso-bounds-0-1-50-0-1-50-1-50-1-50-0-1-20-hybrid-hybrid-adaptive-sta-smc-hybrid-adaptive-super-twisting-controller-mathematical-model-u-u-adaptive-u-sta-mode-switching-gain-parameters-k1-k2-1-2-k1-k2-surface-gains-for-pendulum-1-and-2-1-2-higher-order-surface-gains-mathematical-constraints-all-parameters-0-stability-pso-bounds-1-50-1-50-1-50-1-50-property-def-gain-count-self-int-return-number-of-gain-parameters-for-this-controller-type-return-smctype-classical-6-smctype-super-twisting-6-smctype-adaptive-5-smctype-hybrid-4-self-property-def-mathematical-constraints-self-dict-str-str-return-mathematical-constraints-as-human-readable-strings-return-smctype-classical-1-2-k-0-kd-0-smctype-super-twisting-k1-k2-0-1-2-1-2-0-smctype-adaptive-k1-k2-1-2-0-0-1-20-0-smctype-hybrid-k1-k2-1-2-0-self">
<h1>runnable: false class SMCType(Enum): ‚Äú‚Äù‚Äù Enumeration of supported SMC controller types for PSO optimization. Each type corresponds to a specific sliding mode control algorithm with distinct mathematical properties and parameter requirements. ‚Äú‚Äù‚Äù CLASSICAL = ‚Äúclassical_smc‚Äù ‚Äú‚Äù‚Äù Classical sliding mode controller with boundary layer. Mathematical Model: u = u_eq + u_sw u_eq = (GB)^(-1)[-Gf(x) + ·π°_ref] u_sw = -K¬∑tanh(s/œÜ) Gain Parameters: [k1, k2, Œª1, Œª2, K, kd] k1, k2: Position gains for pendulum 1 and 2 Œª1, Œª2: Surface gains for pendulum 1 and 2 K: Switching gain kd: Damping gain Mathematical Constraints: - Œª1, Œª2, K &gt; 0 (stability requirement) - kd ‚â• 0 (non-negative damping) PSO Bounds: [(0.1,50), (0.1,50), (1,50), (1,50), (1,200), (0,50)] ‚Äú‚Äù‚Äù SUPER_TWISTING = ‚Äústa_smc‚Äù ‚Äú‚Äù‚Äù Super-twisting sliding mode controller (second-order). Mathematical Model: uÃá = -K1¬∑sign(s) - K2¬∑sign(·π°) s = œÉ(x) (sliding surface) Gain Parameters: [K1, K2, Œª1, Œª2, Œ±1, Œ±2] K1: Primary twisting gain K2: Secondary twisting gain Œª1, Œª2: Surface gains Œ±1, Œ±2: Higher-order surface parameters Mathematical Constraints: - K1 &gt; K2 &gt; 0 (finite-time convergence) - Œª1, Œª2, Œ±1, Œ±2 &gt; 0 (stability) PSO Bounds: [(2,100), (1,99), (1,50), (1,50), (1,50), (1,50)] ‚Äú‚Äù‚Äù ADAPTIVE = ‚Äúadaptive_smc‚Äù ‚Äú‚Äù‚Äù Adaptive sliding mode controller with online gain tuning. Mathematical Model: u = u_eq + u_sw KÃá = Œ≥|s| - œÉK (adaptation law) Gain Parameters: [k1, k2, Œª1, Œª2, Œ≥] k1, k2: Position gains Œª1, Œª2: Surface gains Œ≥: Adaptation rate Mathematical Constraints: - k1, k2, Œª1, Œª2 &gt; 0 (stability) - 0.1 ‚â§ Œ≥ ‚â§ 20.0 (bounded adaptation) PSO Bounds: [(0.1,50), (0.1,50), (1,50), (1,50), (0.1,20)] ‚Äú‚Äù‚Äù HYBRID = ‚Äúhybrid_adaptive_sta_smc‚Äù ‚Äú‚Äù‚Äù Hybrid adaptive super-twisting controller. Mathematical Model: u = u_adaptive + u_sta (mode switching) Gain Parameters: [k1, k2, Œª1, Œª2] k1, k2: Surface gains for pendulum 1 and 2 Œª1, Œª2: Higher-order surface gains Mathematical Constraints: - All parameters &gt; 0 (stability) PSO Bounds: [(1,50), (1,50), (1,50), (1,50)] ‚Äú‚Äù‚Äù &#64;property def gain_count(self) -&gt; int: ‚Äú‚Äù‚ÄùReturn number of gain parameters for this controller type.‚Äù‚Äù‚Äù return { SMCType.CLASSICAL: 6, SMCType.SUPER_TWISTING: 6, SMCType.ADAPTIVE: 5, SMCType.HYBRID: 4 }[self] &#64;property def mathematical_constraints(self) -&gt; Dict[str, str]: ‚Äú‚Äù‚ÄùReturn mathematical constraints as human-readable strings.‚Äù‚Äù‚Äù return { SMCType.CLASSICAL: ‚ÄúŒª1,Œª2,K &gt; 0; kd ‚â• 0‚Äù, SMCType.SUPER_TWISTING: ‚ÄúK1 &gt; K2 &gt; 0; Œª1,Œª2,Œ±1,Œ±2 &gt; 0‚Äù, SMCType.ADAPTIVE: ‚Äúk1,k2,Œª1,Œª2 &gt; 0; 0.1 ‚â§ Œ≥ ‚â§ 20.0‚Äù, SMCType.HYBRID: ‚Äúk1,k2,Œª1,Œª2 &gt; 0‚Äù }[self]<a class="headerlink" href="#runnable-false-class-smctype-enum-enumeration-of-supported-smc-controller-types-for-pso-optimization-each-type-corresponds-to-a-specific-sliding-mode-control-algorithm-with-distinct-mathematical-properties-and-parameter-requirements-classical-classical-smc-classical-sliding-mode-controller-with-boundary-layer-mathematical-model-u-u-eq-u-sw-u-eq-gb-1-gf-x-s-ref-u-sw-ktanh-s-gain-parameters-k1-k2-1-2-k-kd-k1-k2-position-gains-for-pendulum-1-and-2-1-2-surface-gains-for-pendulum-1-and-2-k-switching-gain-kd-damping-gain-mathematical-constraints-1-2-k-0-stability-requirement-kd-0-non-negative-damping-pso-bounds-0-1-50-0-1-50-1-50-1-50-1-200-0-50-super-twisting-sta-smc-super-twisting-sliding-mode-controller-second-order-mathematical-model-u-k1sign-s-k2sign-s-s-x-sliding-surface-gain-parameters-k1-k2-1-2-1-2-k1-primary-twisting-gain-k2-secondary-twisting-gain-1-2-surface-gains-1-2-higher-order-surface-parameters-mathematical-constraints-k1-k2-0-finite-time-convergence-1-2-1-2-0-stability-pso-bounds-2-100-1-99-1-50-1-50-1-50-1-50-adaptive-adaptive-smc-adaptive-sliding-mode-controller-with-online-gain-tuning-mathematical-model-u-u-eq-u-sw-k-s-k-adaptation-law-gain-parameters-k1-k2-1-2-k1-k2-position-gains-1-2-surface-gains-adaptation-rate-mathematical-constraints-k1-k2-1-2-0-stability-0-1-20-0-bounded-adaptation-pso-bounds-0-1-50-0-1-50-1-50-1-50-0-1-20-hybrid-hybrid-adaptive-sta-smc-hybrid-adaptive-super-twisting-controller-mathematical-model-u-u-adaptive-u-sta-mode-switching-gain-parameters-k1-k2-1-2-k1-k2-surface-gains-for-pendulum-1-and-2-1-2-higher-order-surface-gains-mathematical-constraints-all-parameters-0-stability-pso-bounds-1-50-1-50-1-50-1-50-property-def-gain-count-self-int-return-number-of-gain-parameters-for-this-controller-type-return-smctype-classical-6-smctype-super-twisting-6-smctype-adaptive-5-smctype-hybrid-4-self-property-def-mathematical-constraints-self-dict-str-str-return-mathematical-constraints-as-human-readable-strings-return-smctype-classical-1-2-k-0-kd-0-smctype-super-twisting-k1-k2-0-1-2-1-2-0-smctype-adaptive-k1-k2-1-2-0-0-1-20-0-smctype-hybrid-k1-k2-1-2-0-self" title="Link to this heading">¬∂</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">SMCGainSpec</span> <span class="pre">Specification</span> <span class="pre">Class</span></code>python</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1>example-metadata:<a class="headerlink" href="#id1" title="Link to this heading">¬∂</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-dataclass-frozen-true">
<h1>runnable: false &#64;dataclass(frozen=True)<a class="headerlink" href="#runnable-false-dataclass-frozen-true" title="Link to this heading">¬∂</a></h1>
<p>class SMCGainSpec: ‚Äú‚Äù‚Äù Complete specification for SMC controller gains. Provides information about gain parameters including mathematical meaning, constraints, and PSO optimization bounds. ‚Äú‚Äù‚Äù controller_type: SMCType n_gains: int gain_names: List[str] gain_descriptions: List[str] mathematical_constraints: List[str] pso_bounds: List[Tuple[float, float]] default_gains: List[float] &#64;property def gain_info(self) -&gt; List[Dict[str, Any]]: ‚Äú‚Äù‚Äù Return gain information. Returns: List of dictionaries containing: - name: Parameter name - description: Mathematical meaning - constraint: Mathematical constraint - bounds: PSO optimization bounds - default: Default value ‚Äú‚Äù‚Äù return [ { ‚Äòname‚Äô: name, ‚Äòdescription‚Äô: desc, ‚Äòconstraint‚Äô: constraint, ‚Äòbounds‚Äô: bounds, ‚Äòdefault‚Äô: default } for name, desc, constraint, bounds, default in zip( self.gain_names, self.gain_descriptions, self.mathematical_constraints, self.pso_bounds, self.default_gains ) ] def validate_gains(self, gains: List[float]) -&gt; Tuple[bool, List[str]]: ‚Äú‚Äù‚Äù Validate gains against mathematical constraints. Args: gains: Gain values to validate Returns: Tuple of (is_valid, list_of_errors) ‚Äú‚Äù‚Äù errors = [] if len(gains) != self.n_gains: errors.append(f‚ÄùExpected {self.n_gains} gains, got {len(gains)}‚Äù) return False, errors # Controller-specific validation if self.controller_type == SMCType.CLASSICAL: if any(g &lt;= 0 for g in gains[:5]): # k1,k2,Œª1,Œª2,K &gt; 0 errors.append(‚ÄúSurface and switching gains must be positive‚Äù) if gains[5] &lt; 0: # kd ‚â• 0 errors.append(‚ÄúDamping gain must be non-negative‚Äù) elif self.controller_type == SMCType.SUPER_TWISTING: if gains[0] &lt;= gains[1]: # K1 &gt; K2 errors.append(‚ÄúK1 must be greater than K2 for convergence‚Äù) if any(g &lt;= 0 for g in gains): # All gains &gt; 0 errors.append(‚ÄúAll STA gains must be positive‚Äù) elif self.controller_type == SMCType.ADAPTIVE: if any(g &lt;= 0 for g in gains[:4]): # k1,k2,Œª1,Œª2 &gt; 0 errors.append(‚ÄúSurface gains must be positive‚Äù) if not (0.1 &lt;= gains[4] &lt;= 20.0): # Œ≥ bounds errors.append(‚ÄúAdaptation rate must be in [0.1, 20.0]‚Äù) elif self.controller_type == SMCType.HYBRID: if any(g &lt;= 0 for g in gains): # All gains &gt; 0 errors.append(‚ÄúAll hybrid gains must be positive‚Äù) return len(errors) == 0, errors def get_pso_bounds_array(self) -&gt; np.ndarray: ‚Äú‚Äù‚ÄùReturn PSO bounds as numpy array for optimization algorithms.‚Äù‚Äù‚Äù return np.array(self.pso_bounds) def get_random_valid_gains(self, n_samples: int = 1) -&gt; np.ndarray: ‚Äú‚Äù‚Äù Generate random valid gain sets within PSO bounds. Useful for PSO initialization and testing. Args: n_samples: Number of random gain sets to generate Returns: Array of shape (n_samples, n_gains) with valid gain sets ‚Äú‚Äù‚Äù bounds_array = self.get_pso_bounds_array() lower_bounds = bounds_array[:, 0] upper_bounds = bounds_array[:, 1] samples = [] for _ in range(n_samples): while True: # Generate random sample in bounds sample = np.random.uniform(lower_bounds, upper_bounds) # Validate constraints is_valid, _ = self.validate_gains(sample.tolist()) if is_valid: samples.append(sample) break return np.array(samples)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
<span class="o">---</span>

<span class="c1">## Factory Functions for PSO ### create_smc_for_pso ```python</span>

<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false def create_smc_for_pso(smc_type: SMCType, gains: List[float], max_force: float = 100.0, dt: float = 0.01, **kwargs) -&gt; PSOControllerWrapper: &quot;&quot;&quot; Primary function for creating SMC controllers in PSO fitness functions. This function provides the optimal interface for PSO optimization workflows: - Single-line controller creation - Automatic mathematical constraint validation - Performance-optimized wrapper for simplified control interface - error handling for robust PSO evaluation Mathematical Foundation: Each controller type implements specific sliding mode control laws: Classical SMC: u = -(k1¬∑Œ∏1 + k2¬∑Œ∏2) - (Œª1¬∑Œ∏Ãá1 + Œª2¬∑Œ∏Ãá2) - K¬∑tanh(s/œÜ) - kd¬∑·∫ã s = Œª1¬∑e1 + Œª2¬∑e2 + ƒó1 + ƒó2 Super-Twisting SMC: uÃá = -K1¬∑sign(s) - K2¬∑sign(·π°) s = Œª1¬∑e1 + Œª2¬∑e2 + Œ±1¬∑ƒó1 + Œ±2¬∑ƒó2 Adaptive SMC: u = u_eq + u_sw KÃá = Œ≥|s| - œÉK (online adaptation) Hybrid SMC: u = w1¬∑u_adaptive + w2¬∑u_sta (mode switching) Args: smc_type: Controller type from SMCType enumeration gains: Gain array matching controller requirements: - Classical: [k1, k2, Œª1, Œª2, K, kd] (6 parameters) - STA: [K1, K2, Œª1, Œª2, Œ±1, Œ±2] (6 parameters) - Adaptive: [k1, k2, Œª1, Œª2, Œ≥] (5 parameters) - Hybrid: [k1, k2, Œª1, Œª2] (4 parameters) max_force: Control force saturation limit [N] dt: Control timestep [s] **kwargs: Additional controller-specific parameters Returns: PSOControllerWrapper with simplified control interface Raises: ValueError: If gains violate mathematical constraints TypeError: If smc_type is not a valid SMCType ConfigurationError: If controller configuration is invalid Performance: - Creation time: &lt;1ms typical - Memory overhead: &lt;500B per wrapper - Thread-safe: Yes (for read operations) PSO Integration Example: ```python def pso_fitness_function(particle: np.ndarray) -&gt; float: # Create controller (automatic validation) controller = create_smc_for_pso(SMCType.CLASSICAL, particle.tolist()) # Run simulation result = run_simulation(controller, test_scenario) # Compute performance metric return compute_ise(result) # Lower is better ``` Mathematical Validation: The function automatically validates that gains satisfy: - Lyapunov stability conditions - Convergence requirements (for STA-SMC) - Bounded adaptation constraints (for Adaptive-SMC) - Physical implementation limits Error Handling: - Invalid gains return appropriate error messages - NaN/infinite gains are automatically rejected - Out-of-bounds parameters trigger constraint violations - Missing parameters are detected and reported &quot;&quot;&quot; # Validate input types if not isinstance(smc_type, SMCType): raise TypeError(f&quot;smc_type must be SMCType, got {type(smc_type)}&quot;) if not isinstance(gains, (list, np.ndarray)): raise TypeError(f&quot;gains must be list or array, got {type(gains)}&quot;) # Convert to list if numpy array if isinstance(gains, np.ndarray): gains = gains.tolist() # Get gain specification for validation gain_spec = SMC_GAIN_SPECS[smc_type] # Validate gain count if len(gains) != gain_spec.n_gains: raise ValueError( f&quot;{smc_type.value} requires {gain_spec.n_gains} gains, &quot; f&quot;got {len(gains)}&quot; ) # Validate mathematical constraints is_valid, errors = gain_spec.validate_gains(gains) if not is_valid: error_msg = f&quot;Gain validation failed for {smc_type.value}:\n&quot; error_msg += &quot;\n&quot;.join(f&quot; - {error}&quot; for error in errors) error_msg += f&quot;\n\nConstraints: {smc_type.mathematical_constraints}&quot; raise ValueError(error_msg) # Create type-safe configuration config = SMCConfig( gains=gains, max_force=max_force, dt=dt, **kwargs ) # Create controller through factory controller = SMCFactory.create_controller(smc_type, config) # Return PSO-optimized wrapper return PSOControllerWrapper(controller) # Performance optimization: Pre-validate common gain patterns</span>

<span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_validate_gains_cached</span><span class="p">(</span><span class="n">smc_type</span><span class="p">:</span> <span class="n">SMCType</span><span class="p">,</span> <span class="n">gains_tuple</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;Cached validation for common gain patterns.&quot;&quot;&quot;</span> <span class="n">gain_spec</span> <span class="o">=</span> <span class="n">SMC_GAIN_SPECS</span><span class="p">[</span><span class="n">smc_type</span><span class="p">]</span> <span class="n">is_valid</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">gain_spec</span><span class="o">.</span><span class="n">validate_gains</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">gains_tuple</span><span class="p">))</span> <span class="k">return</span> <span class="n">is_valid</span>
<span class="err">```</span> <span class="c1">### get_gain_bounds_for_pso ```python</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_gain_bounds_for_pso</span><span class="p">(</span><span class="n">smc_type</span><span class="p">:</span> <span class="n">SMCType</span><span class="p">,</span> <span class="n">custom_constraints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span> <span class="s2">&quot;&quot;&quot; Get mathematically-derived PSO optimization bounds for SMC controllers. Bounds are derived from rigorous control theory analysis: - Lyapunov stability requirements - Performance specifications (settling time, overshoot) - Physical system constraints (actuator saturation) - Numerical implementation limits Mathematical Derivation: Classical SMC Bounds: k1, k2 ‚àà [0.1, 50]: Position gains for reasonable pole placement - Lower bound: Minimum for controllability - Upper bound: Avoid excessive control action Œª1, Œª2 ‚àà [1, 50]: Surface gains for desired bandwidth - Lower bound: Minimum for stability (Œªi &gt; 0) - Upper bound: Avoid high-frequency dynamics K ‚àà [1, 200]: Switching gain for disturbance rejection - Lower bound: Overcome uncertainty bound - Upper bound: Practical actuator limits kd ‚àà [0, 50]: Damping gain for chattering reduction - Lower bound: Non-negative constraint - Upper bound: Avoid over-damping Super-Twisting Bounds: K1 ‚àà [2, 100]: Primary twisting gain - Must satisfy K1 &gt; K2 constraint - Upper bound from actuator limitations K2 ‚àà [1, 99]: Secondary twisting gain - Must satisfy K2 &lt; K1 constraint - Lower bound for convergence guarantee Œª1, Œª2, Œ±1, Œ±2 ‚àà [1, 50]: Surface parameters - Positive definite requirement - Bandwidth considerations Adaptive SMC Bounds: k1, k2, Œª1, Œª2: Same as classical SMC Œ≥ ‚àà [0.1, 20]: Adaptation rate - Lower bound: Minimum adaptation speed - Upper bound: Stability margin preservation Hybrid SMC Bounds: k1, k2, Œª1, Œª2 ‚àà [1, 50]: Surface gains - Positive definite requirement - Performance considerations Args: smc_type: Controller type for bound derivation custom_constraints: Optional custom constraint overrides Example: {&#39;max_force&#39;: 150.0, &#39;settling_time&#39;: 3.0} Returns: List of (lower_bound, upper_bound) tuples for each gain parameter Raises: ValueError: If smc_type is invalid TypeError: If custom_constraints has wrong format Usage Examples: # Standard bounds bounds = get_gain_bounds_for_pso(SMCType.CLASSICAL) # Custom constraints custom = {&#39;max_force&#39;: 150.0, &#39;settling_time&#39;: 3.0} bounds = get_gain_bounds_for_pso(SMCType.CLASSICAL, custom) # PSO integration from pyswarms.single import GlobalBestPSO bounds_array = np.array(bounds) optimizer = GlobalBestPSO( n_particles=30, dimensions=len(bounds), bounds=(bounds_array[:, 0], bounds_array[:, 1]) ) Mathematical Validation: All bounds are verified to satisfy: 1. Lyapunov stability conditions: VÃá ‚â§ -Œ∑|s| 2. Reachability conditions: ·π°¬∑s ‚â§ -Œ∑|s| 3. Finite-time convergence (STA): Specific gain relationships 4. Bounded adaptation (Adaptive): Parameter drift prevention Performance Considerations: - Tighter bounds lead to faster PSO convergence - Bounds include safety margins for robustness - Physical constraints prevent actuator saturation - Numerical bounds avoid conditioning issues &quot;&quot;&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">smc_type</span><span class="p">,</span> <span class="n">SMCType</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid SMC type: </span><span class="si">{</span><span class="n">smc_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="c1"># Default constraints (can be overridden) constraints = { &#39;max_force&#39;: 100.0, # Maximum actuator force [N] &#39;settling_time&#39;: 2.0, # Desired settling time [s] &#39;overshoot_limit&#39;: 10.0, # Maximum overshoot [%] &#39;bandwidth&#39;: 25.0, # Control bandwidth [rad/s] &#39;uncertainty_bound&#39;: 10.0, # Model uncertainty estimate &#39;noise_level&#39;: 0.01 # Sensor noise level } # Apply custom constraints if provided if custom_constraints: if not isinstance(custom_constraints, dict): raise TypeError(&quot;custom_constraints must be dictionary&quot;) constraints.update(custom_constraints) # Extract constraint values max_force = constraints[&#39;max_force&#39;] settling_time = constraints[&#39;settling_time&#39;] bandwidth = constraints[&#39;bandwidth&#39;] uncertainty = constraints[&#39;uncertainty_bound&#39;] if smc_type == SMCType.CLASSICAL: # Classical SMC bounds with mathematical justification # Position gains: pole placement considerations # Natural frequency: œân = 4/settling_time omega_n = 4.0 / settling_time k_min = omega_n**2 / 100 # Conservative lower bound k_max = omega_n**2 # Upper bound for reasonable response # Surface gains: bandwidth considerations lambda_min = omega_n / 2 # Minimum for stability lambda_max = bandwidth # Maximum for implementability # Switching gain: uncertainty rejection K_min = uncertainty * 1.5 # Safety margin over uncertainty K_max = max_force * 0.8 # Actuator saturation margin # Damping gain: chattering reduction kd_min = 0.0 # Non-negative constraint kd_max = lambda_max / 2 # Avoid over-damping bounds = [ (k_min, k_max), # k1 (k_min, k_max), # k2 (lambda_min, lambda_max), # Œª1 (lambda_min, lambda_max), # Œª2 (K_min, K_max), # K (kd_min, kd_max) # kd ] elif smc_type == SMCType.SUPER_TWISTING: # Super-twisting bounds with convergence constraints # Estimate Lipschitz constant for convergence analysis L = uncertainty + bandwidth # Conservative estimate # K1 bounds: finite-time convergence requirement K1_min = math.sqrt(L) * 1.2 # Safety margin K1_max = math.sqrt(max_force * L) # Physical limit # K2 bounds: must satisfy K2 &lt; K1 K2_min = L / (2 * math.sqrt(L)) * 1.1 # Convergence requirement K2_max = K1_max * 0.9 # Ensure K1 &gt; K2 # Surface parameters: similar to classical lambda_min = 2.0 / settling_time lambda_max = bandwidth / 2 bounds = [ (K1_min, K1_max), # K1 (K2_min, K2_max), # K2 (lambda_min, lambda_max), # Œª1 (lambda_min, lambda_max), # Œª2 (lambda_min, lambda_max), # Œ±1 (lambda_min, lambda_max) # Œ±2 ] elif smc_type == SMCType.ADAPTIVE: # Adaptive SMC bounds with adaptation constraints # Surface gains: same analysis as classical omega_n = 4.0 / settling_time k_min = omega_n**2 / 100 k_max = omega_n**2 lambda_min = omega_n / 2 lambda_max = bandwidth # Adaptation rate: stability-preserving bounds gamma_min = 0.1 # Minimum adaptation speed gamma_max = bandwidth / 5 # Stability margin preservation gamma_max = min(gamma_max, 20.0) # Practical upper limit bounds = [ (k_min, k_max), # k1 (k_min, k_max), # k2 (lambda_min, lambda_max), # Œª1 (lambda_min, lambda_max), # Œª2 (gamma_min, gamma_max) # Œ≥ ] elif smc_type == SMCType.HYBRID: # Hybrid controller bounds (conservative) # Surface gains: conservative bounds for mode switching gain_min = 2.0 / settling_time gain_max = bandwidth / 3 # Conservative for hybrid operation bounds = [ (gain_min, gain_max), # k1 (gain_min, gain_max), # k2 (gain_min, gain_max), # Œª1 (gain_min, gain_max) # Œª2 ] else: raise ValueError(f&quot;Unsupported SMC type: {smc_type}&quot;) # Validate bounds consistency for i, (lower, upper) in enumerate(bounds): if lower &gt;= upper: raise ValueError(f&quot;Invalid bounds for parameter {i}: [{lower}, {upper}]&quot;) if lower &lt; 0 and smc_type != SMCType.CLASSICAL: # Only kd can be 0 raise ValueError(f&quot;Negative lower bound for parameter {i}: {lower}&quot;) # Apply constraint-specific adjustments if &#39;force_limit&#39; in constraints: # Adjust switching/twisting gains for force constraints force_limit = constraints[&#39;force_limit&#39;] if smc_type == SMCType.CLASSICAL: bounds[4] = (bounds[4][0], min(bounds[4][1], force_limit * 0.8)) elif smc_type == SMCType.SUPER_TWISTING: bounds[0] = (bounds[0][0], min(bounds[0][1], force_limit * 0.8)) bounds[1] = (bounds[1][0], min(bounds[1][1], force_limit * 0.8)) return bounds</span>
<span class="err">```</span> <span class="c1">### validate_smc_gains ```python</span>
<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false def validate_smc_gains(smc_type: SMCType, gains: List[float], strict: bool = True, return_details: bool = False ) -&gt; Union[bool, Tuple[bool, Dict[str, Any]]]: &quot;&quot;&quot; validation of SMC gains against mathematical constraints. Performs multi-level validation: 1. Basic constraints (positivity, bounds checking) 2. Mathematical constraints (stability, convergence) 3. Physical constraints (actuator limits, bandwidth) 4. Numerical constraints (conditioning, finite values) Mathematical Validation Framework: Classical SMC Validation: 1. Stability: Œª1, Œª2, K &gt; 0 (Lyapunov condition VÃá ‚â§ -Œ∑|s|) 2. Reachability: K &gt; |d_max| (uncertainty bound) 3. Performance: Pole placement within stability region 4. Saturation: K¬∑œÜ ‚â§ max_force (actuator limits) Super-Twisting Validation: 1. Convergence: K1 &gt; K2 &gt; 0 (finite-time stability) 2. Lyapunov: K1¬≤ &gt; 4LK2 (sufficient condition) 3. Reachability: Gains sufficient for uncertainty rejection 4. Bandwidth: Avoid high-frequency content Adaptive SMC Validation: 1. Stability: Base gains satisfy classical constraints 2. Adaptation: 0.1 ‚â§ Œ≥ ‚â§ 20 (bounded adaptation) 3. Convergence: Adaptation rate vs system bandwidth 4. Robustness: Parameter drift prevention Hybrid SMC Validation: 1. Mode stability: Each mode individually stable 2. Switching stability: No instability during transitions 3. Performance: Smooth mode transitions 4. Robustness: Consistent performance across modes Args: smc_type: Controller type for validation gains: Gain array to validate strict: strict mathematical validation return_details: Return detailed validation information Returns: If return_details=False: Boolean validation result If return_details=True: Tuple of (is_valid, validation_details) Validation Details Dictionary: { &#39;is_valid&#39;: bool, &#39;errors&#39;: List[str], # Constraint violations &#39;warnings&#39;: List[str], # Potential issues &#39;stability_analysis&#39;: { &#39;lyapunov_stable&#39;: bool, &#39;convergence_rate&#39;: float, &#39;stability_margin&#39;: float }, &#39;performance_analysis&#39;: { &#39;estimated_settling_time&#39;: float, &#39;estimated_overshoot&#39;: float, &#39;bandwidth_estimate&#39;: float }, &#39;constraint_details&#39;: { &#39;basic_constraints&#39;: Dict, &#39;mathematical_constraints&#39;: Dict, &#39;physical_constraints&#39;: Dict } } Usage Examples: # Basic validation is_valid = validate_smc_gains(SMCType.CLASSICAL, [10,8,15,12,50,5]) # Detailed validation is_valid, details = validate_smc_gains( SMCType.CLASSICAL, gains, return_details=True ) print(f&quot;Stability margin: {details[&#39;stability_analysis&#39;][&#39;stability_margin&#39;]}&quot;) # PSO integration with validation def pso_fitness_with_validation(gains): if not validate_smc_gains(SMCType.CLASSICAL, gains): return 1000.0 # Penalty for invalid gains return evaluate_controller_performance(gains) Raises: ValueError: If basic validation fails (wrong gain count, NaN values) TypeError: If inputs have wrong types &quot;&quot;&quot; # Input validation if not isinstance(smc_type, SMCType): raise TypeError(f&quot;smc_type must be SMCType, got {type(smc_type)}&quot;) if not isinstance(gains, (list, np.ndarray)): raise TypeError(f&quot;gains must be list or array, got {type(gains)}&quot;) # Convert to list if numpy array if isinstance(gains, np.ndarray): gains = gains.tolist() # Initialize validation results errors = [] warnings = [] stability_analysis = {} performance_analysis = {} constraint_details = { &#39;basic_constraints&#39;: {}, &#39;mathematical_constraints&#39;: {}, &#39;physical_constraints&#39;: {} } # Get gain specification gain_spec = SMC_GAIN_SPECS[smc_type] # Basic validation if len(gains) != gain_spec.n_gains: errors.append(f&quot;Expected {gain_spec.n_gains} gains, got {len(gains)}&quot;) if return_details: return False, { &#39;is_valid&#39;: False, &#39;errors&#39;: errors, &#39;warnings&#39;: warnings, &#39;stability_analysis&#39;: {}, &#39;performance_analysis&#39;: {}, &#39;constraint_details&#39;: constraint_details } return False # Check for finite values if not all(np.isfinite(g) for g in gains): errors.append(&quot;All gains must be finite (no NaN or infinite values)&quot;) # Check for reasonable magnitudes if any(abs(g) &gt; 1e6 for g in gains): warnings.append(&quot;Some gains are very large (&gt;1e6), may cause numerical issues&quot;) if any(abs(g) &lt; 1e-8 for g in gains[:-1]): # Exclude kd for classical warnings.append(&quot;Some gains are very small (&lt;1e-8), may affect performance&quot;) # Controller-specific mathematical validation if smc_type == SMCType.CLASSICAL: k1, k2, lam1, lam2, K, kd = gains # Basic constraints constraint_details[&#39;basic_constraints&#39;] = { &#39;k1_positive&#39;: k1 &gt; 0, &#39;k2_positive&#39;: k2 &gt; 0, &#39;lambda1_positive&#39;: lam1 &gt; 0, &#39;lambda2_positive&#39;: lam2 &gt; 0, &#39;K_positive&#39;: K &gt; 0, &#39;kd_nonnegative&#39;: kd &gt;= 0 } # Check positivity constraints if any(g &lt;= 0 for g in gains[:5]): errors.append(&quot;Surface gains (k1,k2,Œª1,Œª2) and switching gain (K) must be positive&quot;) if kd &lt; 0: errors.append(&quot;Damping gain (kd) must be non-negative&quot;) # Mathematical constraints (strict mode) if strict: # Estimate stability properties # Simplified stability analysis min_surface_gain = min(lam1, lam2) estimated_bandwidth = min_surface_gain estimated_uncertainty = 10.0 # Conservative estimate constraint_details[&#39;mathematical_constraints&#39;] = { &#39;switching_gain_adequate&#39;: K &gt; estimated_uncertainty, &#39;surface_gains_adequate&#39;: min_surface_gain &gt; 1.0, &#39;damping_reasonable&#39;: kd &lt;= min_surface_gain } if K &lt;= estimated_uncertainty: warnings.append(f&quot;Switching gain K={K:.2f} may be too small for uncertainty rejection&quot;) # Stability analysis stability_margin = K - estimated_uncertainty convergence_rate = min(min_surface_gain, stability_margin) if stability_margin &gt; 0 else 0 stability_analysis = { &#39;lyapunov_stable&#39;: stability_margin &gt; 0, &#39;convergence_rate&#39;: convergence_rate, &#39;stability_margin&#39;: stability_margin / K if K &gt; 0 else 0 } # Performance estimates estimated_settling_time = 4.0 / min_surface_gain if min_surface_gain &gt; 0 else float(&#39;inf&#39;) estimated_overshoot = max(0, (k1 + k2) / (lam1 + lam2) - 1) * 100 if (lam1 + lam2) &gt; 0 else 100 performance_analysis = { &#39;estimated_settling_time&#39;: estimated_settling_time, &#39;estimated_overshoot&#39;: estimated_overshoot, &#39;bandwidth_estimate&#39;: estimated_bandwidth } # Physical constraints max_force_estimate = 100.0 # Default actuator limit constraint_details[&#39;physical_constraints&#39;] = { &#39;force_saturation_check&#39;: K &lt;= max_force_estimate, &#39;bandwidth_feasible&#39;: max(lam1, lam2) &lt;= 50.0 } if K &gt; max_force_estimate: warnings.append(f&quot;Switching gain K={K:.1f} may exceed actuator limits&quot;) elif smc_type == SMCType.SUPER_TWISTING: K1, K2, lam1, lam2, alpha1, alpha2 = gains # Basic constraints constraint_details[&#39;basic_constraints&#39;] = { &#39;K1_positive&#39;: K1 &gt; 0, &#39;K2_positive&#39;: K2 &gt; 0, &#39;K1_greater_K2&#39;: K1 &gt; K2, &#39;lambda1_positive&#39;: lam1 &gt; 0, &#39;lambda2_positive&#39;: lam2 &gt; 0, &#39;alpha1_positive&#39;: alpha1 &gt; 0, &#39;alpha2_positive&#39;: alpha2 &gt; 0 } # Critical convergence constraint if K1 &lt;= K2: errors.append(&quot;K1 must be greater than K2 for finite-time convergence&quot;) if any(g &lt;= 0 for g in gains): errors.append(&quot;All STA gains must be positive&quot;) # Mathematical constraints (strict mode) if strict: # Finite-time convergence analysis L_estimate = 15.0 # Conservative Lipschitz constant estimate convergence_condition = K1**2 &gt; 4 * L_estimate * K2 constraint_details[&#39;mathematical_constraints&#39;] = { &#39;finite_time_convergence&#39;: convergence_condition, &#39;gains_well_separated&#39;: K1 &gt; K2 * 1.1, &#39;lipschitz_condition&#39;: K1**2 &gt; 4 * L_estimate * K2 } if not convergence_condition: warnings.append(&quot;May not satisfy sufficient condition for finite-time convergence&quot;) # Stability analysis convergence_rate = min(K1, K2) if K1 &gt; K2 else 0 stability_margin = (K1 - K2) / K1 if K1 &gt; 0 else 0 stability_analysis = { &#39;lyapunov_stable&#39;: K1 &gt; K2 &gt; 0, &#39;convergence_rate&#39;: convergence_rate, &#39;stability_margin&#39;: stability_margin } elif smc_type == SMCType.ADAPTIVE: k1, k2, lam1, lam2, gamma = gains # Basic constraints constraint_details[&#39;basic_constraints&#39;] = { &#39;k1_positive&#39;: k1 &gt; 0, &#39;k2_positive&#39;: k2 &gt; 0, &#39;lambda1_positive&#39;: lam1 &gt; 0, &#39;lambda2_positive&#39;: lam2 &gt; 0, &#39;gamma_in_bounds&#39;: 0.1 &lt;= gamma &lt;= 20.0 } # Check positivity and adaptation bounds if any(g &lt;= 0 for g in gains[:4]): errors.append(&quot;Surface gains must be positive&quot;) if not (0.1 &lt;= gamma &lt;= 20.0): errors.append(&quot;Adaptation rate Œ≥ must be in [0.1, 20.0]&quot;) # Mathematical constraints (strict mode) if strict: # Adaptation stability analysis system_bandwidth = min(lam1, lam2) adaptation_bandwidth = gamma * system_bandwidth constraint_details[&#39;mathematical_constraints&#39;] = { &#39;adaptation_stable&#39;: gamma &lt; 10.0, &#39;adaptation_not_too_slow&#39;: gamma &gt; 0.2, &#39;separation_principle&#39;: adaptation_bandwidth &lt; system_bandwidth } if gamma &gt; 10.0: warnings.append(&quot;High adaptation rate may cause instability&quot;) if gamma &lt; 0.2: warnings.append(&quot;Low adaptation rate may be too slow&quot;) # Stability analysis stability_analysis = { &#39;lyapunov_stable&#39;: True, # Assuming proper design &#39;convergence_rate&#39;: min(system_bandwidth, gamma), &#39;stability_margin&#39;: (20.0 - gamma) / 20.0 } elif smc_type == SMCType.HYBRID: k1, k2, lam1, lam2 = gains # Basic constraints constraint_details[&#39;basic_constraints&#39;] = { &#39;k1_positive&#39;: k1 &gt; 0, &#39;k2_positive&#39;: k2 &gt; 0, &#39;lambda1_positive&#39;: lam1 &gt; 0, &#39;lambda2_positive&#39;: lam2 &gt; 0 } if any(g &lt;= 0 for g in gains): errors.append(&quot;All hybrid gains must be positive&quot;) # Mathematical constraints (strict mode) if strict: # Hybrid stability analysis (simplified) min_gain = min(gains) constraint_details[&#39;mathematical_constraints&#39;] = { &#39;mode_stability&#39;: min_gain &gt; 1.0, &#39;switching_stability&#39;: max(gains) / min_gain &lt; 10.0 } stability_analysis = { &#39;lyapunov_stable&#39;: min_gain &gt; 0, &#39;convergence_rate&#39;: min_gain, &#39;stability_margin&#39;: min_gain / max(gains) if max(gains) &gt; 0 else 0 } # Overall validation result is_valid = len(errors) == 0 if return_details: validation_details = { &#39;is_valid&#39;: is_valid, &#39;errors&#39;: errors, &#39;warnings&#39;: warnings, &#39;stability_analysis&#39;: stability_analysis, &#39;performance_analysis&#39;: performance_analysis, &#39;constraint_details&#39;: constraint_details } return is_valid, validation_details else: return is_valid</span>

</pre></div>
</div>
<hr class="docutils" />
<section id="pso-controller-wrapper-psocontrollerwrapper-class-python">
<h2>PSO Controller Wrapper ### PSOControllerWrapper Class ```python<a class="headerlink" href="#pso-controller-wrapper-psocontrollerwrapper-class-python" title="Link to this heading">¬∂</a></h2>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id2">
<h1>example-metadata:<a class="headerlink" href="#id2" title="Link to this heading">¬∂</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-class-psocontrollerwrapper-pso-optimized-wrapper-providing-simplified-interface-for-smc-controllers-this-wrapper-is-specifically-designed-for-pso-fitness-evaluation-with-simplified-control-interface-single-state-input-automatic-state-management-for-stateful-controllers-unified-output-format-numpy-array-robust-error-handling-for-pso-robustness-performance-optimization-for-repeated-evaluations-the-wrapper-handles-the-complexity-of-different-smc-controller-interfaces-while-providing-a-consistent-pso-friendly-api-mathematical-foundation-the-wrapper-preserves-the-mathematical-properties-of-the-underlying-smc-controller-while-simplifying-the-interface-input-state-1-2-x-1-2-x-6-output-u-scalar-control-force-internal-state-management-classical-smc-stateless-empty-state-vars-sta-smc-maintains-z-for-integration-adaptive-smc-tracks-adaptation-variables-hybrid-smc-manages-mode-switching-state-performance-characteristics-control-computation-0-1ms-typical-memory-overhead-500b-per-wrapper-thread-safety-read-operations-only-error-recovery-graceful-degradation-for-invalid-inputs-def-init-self-controller-smcprotocol-initialize-pso-wrapper-with-smc-controller-args-controller-smc-controller-implementing-smcprotocol-raises-typeerror-if-controller-doesn-t-implement-required-interface-valueerror-if-controller-configuration-is-invalid-validate-controller-interface-if-not-hasattr-controller-compute-control-raise-typeerror-controller-must-implement-compute-control-method-if-not-hasattr-controller-gains-raise-typeerror-controller-must-have-gains-property-self-controller-controller-self-history-initialize-empty-history-initialize-controller-specific-state-variables-controller-name-type-controller-name-if-supertwisting-in-controller-name-or-sta-in-controller-name-sta-smc-maintains-integration-variables-z-self-state-vars-0-0-0-0-initial-z-0-0-elif-hybrid-in-controller-name-hybrid-controller-tracks-adaptive-gains-and-integration-self-state-vars-getattr-controller-k1-init-5-0-k1-prev-getattr-controller-k2-init-3-0-k2-prev-0-0-u-int-prev-elif-adaptive-in-controller-name-adaptive-smc-may-track-adaptation-state-self-state-vars-getattr-controller-initial-state-else-classical-smc-and-others-use-empty-state-self-state-vars-performance-tracking-self-call-count-0-self-total-compute-time-0-0-self-last-error-none-def-compute-control-self-state-np-ndarray-state-vars-optional-any-none-history-optional-dict-str-any-none-np-ndarray-compute-control-with-flexible-interface-supporting-both-1-simplified-pso-interface-compute-control-state-2-full-interface-compute-control-state-state-vars-history-mathematical-interface-input-state-vector-x-1-2-x-cart-1-2-x-cart-1-2-pendulum-angles-rad-x-cart-cart-position-m-1-2-angular-velocities-rad-s-x-cart-cart-velocity-m-s-output-control-u-scalar-control-force-n-bounded-by-actuator-limits-args-state-system-state-vector-6-element-numpy-array-state-vars-controller-state-variables-optional-history-controller-history-optional-returns-control-output-as-1-element-numpy-array-u-raises-valueerror-if-state-has-wrong-dimensions-runtimeerror-if-control-computation-fails-performance-typical-computation-time-0-01-0-1ms-memory-allocation-minimal-output-array-only-error-handling-graceful-fallback-to-zero-control-pso-usage-pattern-python-def-pso-fitness-gains-controller-create-smc-for-pso-smctype-classical-gains-simplified-interface-for-pso-total-error-0-0-for-state-in-test-states-u-controller-compute-control-state-returns-u-use-u-0-for-scalar-control-value-total-error-evaluate-single-step-state-u-0-return-total-error-state-management-the-wrapper-automatically-manages-controller-state-between-calls-classical-smc-no-state-management-needed-sta-smc-updates-integration-variables-z-adaptive-smc-updates-adaptation-parameters-hybrid-smc-updates-mode-and-adaptation-state-error-recovery-if-control-computation-fails-1-log-error-for-debugging-2-return-safe-fallback-control-zero-3-increment-error-counter-for-monitoring-4-continue-operation-don-t-crash-pso-import-time-performance-tracking-start-time-time-perf-counter-self-call-count-1-try-input-validation-if-not-isinstance-state-np-ndarray-state-np-array-state-if-state-shape-6-raise-valueerror-f-state-must-be-6-element-array-got-shape-state-shape-if-not-np-all-np-isfinite-state-raise-valueerror-state-contains-non-finite-values-nan-or-inf-use-provided-parameters-or-defaults-final-state-vars-state-vars-if-state-vars-is-not-none-else-self-state-vars-final-history-history-if-history-is-not-none-else-self-history-call-underlying-controller-result-self-controller-compute-control-state-final-state-vars-final-history-extract-control-value-from-result-handle-different-controller-output-formats-if-hasattr-result-u-standard-controller-output-with-u-attribute-control-value-result-u-update-state-variables-if-available-if-hasattr-result-state-vars-self-state-vars-result-state-vars-elif-hasattr-result-control-alternative-output-format-with-control-attribute-control-value-result-control-elif-isinstance-result-dict-dictionary-output-format-if-u-in-result-control-value-result-u-elif-control-in-result-control-value-result-control-else-raise-valueerror-dictionary-result-missing-control-value-update-state-if-provided-if-state-vars-in-result-self-state-vars-result-state-vars-elif-isinstance-result-tuple-tuple-output-e-g-early-return-from-some-controllers-control-value-result-0-first-element-is-control-if-len-result-1-self-state-vars-result-1-second-element-is-state-else-assume-result-is-the-control-value-directly-control-value-result-convert-to-scalar-if-needed-if-isinstance-control-value-np-ndarray-if-control-value-size-1-control-value-float-control-value-else-control-value-float-control-value-0-elif-not-isinstance-control-value-int-float-control-value-float-control-value-validate-output-if-not-np-isfinite-control-value-raise-valueerror-controller-returned-non-finite-control-value-apply-saturation-defensive-programming-max-force-getattr-self-controller-max-force-100-0-control-saturated-np-clip-control-value-max-force-max-force-for-simplified-interface-pso-usage-return-numpy-array-if-state-vars-is-none-and-history-is-none-output-np-array-control-saturated-else-for-full-interface-return-in-format-expected-by-simulation-output-control-saturated-performance-tracking-compute-time-time-perf-counter-start-time-self-total-compute-time-compute-time-return-output-except-exception-as-e-error-handling-for-robust-pso-operation-self-last-error-str-e-log-error-for-debugging-in-production-use-proper-logging-print-f-warning-control-computation-failed-e-return-safe-fallback-control-if-state-vars-is-none-and-history-is-none-return-np-array-0-0-pso-interface-else-return-0-0-full-interface-property-def-gains-self-list-float-return-controller-gains-returns-list-of-controller-gain-parameters-usage-python-controller-create-smc-for-pso-smctype-classical-gains-print-f-controller-gains-controller-gains-return-self-controller-gains-property-def-performance-stats-self-dict-str-any-return-performance-statistics-for-monitoring-returns-dictionary-with-performance-metrics-call-count-number-of-control-computations-total-time-total-computation-time-s-average-time-average-computation-time-ms-last-error-last-error-message-if-any-usage-python-after-pso-optimization-stats-controller-performance-stats-print-f-average-computation-time-stats-average-time-3f-ms-avg-time-ms-self-total-compute-time-self-call-count-1000-if-self-call-count-0-else-0-0-return-call-count-self-call-count-total-time-self-total-compute-time-average-time-avg-time-ms-last-error-self-last-error-def-reset-performance-stats-self-none-reset-performance-tracking-statistics-self-call-count-0-self-total-compute-time-0-0-self-last-error-none-def-validate-state-input-self-state-np-ndarray-tuple-bool-str-validate-state-input-for-control-computation-args-state-state-vector-to-validate-returns-tuple-of-is-valid-error-message-usage-python-is-valid-error-controller-validate-state-input-test-state-if-not-is-valid-print-f-invalid-state-error-try-if-not-isinstance-state-np-ndarray-return-false-state-must-be-numpy-array-if-state-shape-6-return-false-f-state-must-be-6-element-array-got-state-shape-if-not-np-all-np-isfinite-state-return-false-state-contains-non-finite-values-check-reasonable-ranges-optional-angles-state-2-1-2-if-np-any-np-abs-angles-2-np-pi-return-false-angles-exceed-reasonable-range-2-velocities-state-3-1-2-x-if-np-any-np-abs-velocities-100-return-false-velocities-exceed-reasonable-range-100-return-true-except-exception-as-e-return-false-f-validation-error-e-def-repr-self-str-string-representation-for-debugging-controller-type-type-self-controller-name-return-f-psocontrollerwrapper-controller-type-gains-self-gains">
<h1>runnable: false class PSOControllerWrapper: ‚Äú‚Äù‚Äù PSO-optimized wrapper providing simplified interface for SMC controllers. This wrapper is specifically designed for PSO fitness evaluation with: - Simplified control interface (single state input) - Automatic state management for stateful controllers - Unified output format (numpy array) - Robust error handling for PSO robustness - Performance optimization for repeated evaluations The wrapper handles the complexity of different SMC controller interfaces while providing a consistent, PSO-friendly API. Mathematical Foundation: The wrapper preserves the mathematical properties of the underlying SMC controller while simplifying the interface: Input: state = [Œ∏‚ÇÅ, Œ∏‚ÇÇ, x, Œ∏Ãá‚ÇÅ, Œ∏Ãá‚ÇÇ, ·∫ã] ‚àà ‚Ñù‚Å∂ Output: u ‚àà ‚Ñù (scalar control force) Internal State Management: - Classical SMC: Stateless (empty state_vars) - STA SMC: Maintains (z, œÉ) for integration - Adaptive SMC: Tracks adaptation variables - Hybrid SMC: Manages mode switching state Performance Characteristics: - Control computation: &lt;0.1ms typical - Memory overhead: &lt;500B per wrapper - Thread safety: Read operations only - Error recovery: Graceful degradation for invalid inputs ‚Äú‚Äù‚Äù def <strong>init</strong>(self, controller: SMCProtocol): ‚Äú‚Äù‚Äù Initialize PSO wrapper with SMC controller. Args: controller: SMC controller implementing SMCProtocol Raises: TypeError: If controller doesn‚Äôt implement required interface ValueError: If controller configuration is invalid ‚Äú‚Äù‚Äù # Validate controller interface if not hasattr(controller, ‚Äòcompute_control‚Äô): raise TypeError(‚ÄúController must implement compute_control method‚Äù) if not hasattr(controller, ‚Äògains‚Äô): raise TypeError(‚ÄúController must have gains property‚Äù) self.controller = controller self._history = {} # Initialize empty history # Initialize controller-specific state variables controller_name = type(controller).<strong>name</strong> if ‚ÄòSuperTwisting‚Äô in controller_name or ‚ÄòSTA‚Äô in controller_name: # STA-SMC maintains integration variables (z, œÉ) self._state_vars = (0.0, 0.0) # Initial (z=0, œÉ=0) elif ‚ÄòHybrid‚Äô in controller_name: # Hybrid controller tracks adaptive gains and integration self._state_vars = ( getattr(controller, ‚Äòk1_init‚Äô, 5.0), # k1_prev getattr(controller, ‚Äòk2_init‚Äô, 3.0), # k2_prev 0.0 # u_int_prev ) elif ‚ÄòAdaptive‚Äô in controller_name: # Adaptive SMC may track adaptation state self._state_vars = getattr(controller, ‚Äò_initial_state‚Äô, ()) else: # Classical SMC and others use empty state self._state_vars = () # Performance tracking self._call_count = 0 self._total_compute_time = 0.0 self._last_error = None def compute_control(self, state: np.ndarray, state_vars: Optional[Any] = None, history: Optional[Dict[str, Any]] = None ) -&gt; np.ndarray: ‚Äú‚Äù‚Äù Compute control with flexible interface supporting both: 1. Simplified PSO interface: compute_control(state) 2. Full interface: compute_control(state, state_vars, history) Mathematical Interface: Input state vector: x = [Œ∏‚ÇÅ, Œ∏‚ÇÇ, x_cart, Œ∏Ãá‚ÇÅ, Œ∏Ãá‚ÇÇ, ·∫ã_cart] - Œ∏‚ÇÅ, Œ∏‚ÇÇ: Pendulum angles [rad] - x_cart: Cart position [m] - Œ∏Ãá‚ÇÅ, Œ∏Ãá‚ÇÇ: Angular velocities [rad/s] - ·∫ã_cart: Cart velocity [m/s] Output control: u ‚àà ‚Ñù - Scalar control force [N] - Bounded by actuator limits Args: state: System state vector (6-element numpy array) state_vars: Controller state variables (optional) history: Controller history (optional) Returns: Control output as 1-element numpy array [u] Raises: ValueError: If state has wrong dimensions RuntimeError: If control computation fails Performance: - Typical computation time: 0.01-0.1ms - Memory allocation: Minimal (output array only) - Error handling: Graceful fallback to zero control PSO Usage Pattern: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">def</span> <span class="pre">pso_fitness(gains):</span> <span class="pre">controller</span> <span class="pre">=</span> <span class="pre">create_smc_for_pso(SMCType.CLASSICAL,</span> <span class="pre">gains)</span> <span class="pre">#</span> <span class="pre">Simplified</span> <span class="pre">interface</span> <span class="pre">for</span> <span class="pre">PSO</span> <span class="pre">total_error</span> <span class="pre">=</span> <span class="pre">0.0</span> <span class="pre">for</span> <span class="pre">state</span> <span class="pre">in</span> <span class="pre">test_states:</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">controller.compute_control(state)</span> <span class="pre">#</span> <span class="pre">Returns</span> <span class="pre">[u]</span> <span class="pre">#</span> <span class="pre">Use</span> <span class="pre">u[0]</span> <span class="pre">for</span> <span class="pre">scalar</span> <span class="pre">control</span> <span class="pre">value</span> <span class="pre">total_error</span> <span class="pre">+=</span> <span class="pre">evaluate_single_step(state,</span> <span class="pre">u[0])</span> <span class="pre">return</span> <span class="pre">total_error</span> </code> State Management: The wrapper automatically manages controller state between calls: - Classical SMC: No state management needed - STA SMC: Updates integration variables (z, œÉ) - Adaptive SMC: Updates adaptation parameters - Hybrid SMC: Updates mode and adaptation state Error Recovery: If control computation fails: 1. Log error for debugging 2. Return safe fallback control (zero) 3. Increment error counter for monitoring 4. Continue operation (don‚Äôt crash PSO) ‚Äú‚Äù‚Äù import time # Performance tracking start_time = time.perf_counter() self._call_count += 1 try: # Input validation if not isinstance(state, np.ndarray): state = np.array(state) if state.shape != (6,): raise ValueError(f‚ÄùState must be 6-element array, got shape {state.shape}‚Äù) if not np.all(np.isfinite(state)): raise ValueError(‚ÄúState contains non-finite values (NaN or inf)‚Äù) # Use provided parameters or defaults final_state_vars = state_vars if state_vars is not None else self._state_vars final_history = history if history is not None else self._history # Call underlying controller result = self.controller.compute_control(state, final_state_vars, final_history) # Extract control value from result # Handle different controller output formats if hasattr(result, ‚Äòu‚Äô): # Standard controller output with .u attribute control_value = result.u # Update state variables if available if hasattr(result, ‚Äòstate_vars‚Äô): self._state_vars = result.state_vars elif hasattr(result, ‚Äòcontrol‚Äô): # Alternative output format with .control attribute control_value = result.control elif isinstance(result, dict): # Dictionary output format if ‚Äòu‚Äô in result: control_value = result[‚Äòu‚Äô] elif ‚Äòcontrol‚Äô in result: control_value = result[‚Äòcontrol‚Äô] else: raise ValueError(‚ÄúDictionary result missing control value‚Äù) # Update state if provided if ‚Äòstate_vars‚Äô in result: self._state_vars = result[‚Äòstate_vars‚Äô] elif isinstance(result, tuple): # Tuple output (e.g., early return from some controllers) control_value = result[0] # First element is control if len(result) &gt; 1: self._state_vars = result[1] # Second element is state else: # Assume result is the control value directly control_value = result # Convert to scalar if needed if isinstance(control_value, np.ndarray): if control_value.size == 1: control_value = float(control_value) else: control_value = float(control_value[0]) elif not isinstance(control_value, (int, float)): control_value = float(control_value) # Validate output if not np.isfinite(control_value): raise ValueError(‚ÄúController returned non-finite control value‚Äù) # Apply saturation (defensive programming) max_force = getattr(self.controller, ‚Äòmax_force‚Äô, 100.0) control_saturated = np.clip(control_value, -max_force, max_force) # For simplified interface (PSO usage), return numpy array if state_vars is None and history is None: output = np.array([control_saturated]) else: # For full interface, return in format expected by simulation output = control_saturated # Performance tracking compute_time = time.perf_counter() - start_time self._total_compute_time += compute_time return output except Exception as e: # Error handling for robust PSO operation self._last_error = str(e) # Log error for debugging (in production, use proper logging) print(f‚ÄùWarning: Control computation failed: {e}‚Äù) # Return safe fallback control if state_vars is None and history is None: return np.array([0.0]) # PSO interface else: return 0.0 # Full interface &#64;property def gains(self) -&gt; List[float]: ‚Äú‚Äù‚Äù Return controller gains. Returns: List of controller gain parameters Usage: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">controller</span> <span class="pre">=</span> <span class="pre">create_smc_for_pso(SMCType.CLASSICAL,</span> <span class="pre">gains)</span> <span class="pre">print(f&quot;Controller</span> <span class="pre">gains:</span> <span class="pre">{controller.gains}&quot;)</span> </code> ‚Äú‚Äù‚Äù return self.controller.gains &#64;property def performance_stats(self) -&gt; Dict[str, Any]: ‚Äú‚Äù‚Äù Return performance statistics for monitoring. Returns: Dictionary with performance metrics: - call_count: Number of control computations - total_time: Total computation time [s] - average_time: Average computation time [ms] - last_error: Last error message (if any) Usage: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">#</span> <span class="pre">After</span> <span class="pre">PSO</span> <span class="pre">optimization</span> <span class="pre">stats</span> <span class="pre">=</span> <span class="pre">controller.performance_stats</span> <span class="pre">print(f&quot;Average</span> <span class="pre">computation</span> <span class="pre">time:</span> <span class="pre">{stats['average_time']:.3f}ms&quot;)</span> </code> ‚Äú‚Äù‚Äù avg_time_ms = (self._total_compute_time / self._call_count * 1000 if self._call_count &gt; 0 else 0.0) return { ‚Äòcall_count‚Äô: self._call_count, ‚Äòtotal_time‚Äô: self._total_compute_time, ‚Äòaverage_time‚Äô: avg_time_ms, ‚Äòlast_error‚Äô: self._last_error } def reset_performance_stats(self) -&gt; None: ‚Äú‚Äù‚ÄùReset performance tracking statistics.‚Äù‚Äù‚Äù self._call_count = 0 self._total_compute_time = 0.0 self._last_error = None def validate_state_input(self, state: np.ndarray) -&gt; Tuple[bool, str]: ‚Äú‚Äù‚Äù Validate state input for control computation. Args: state: State vector to validate Returns: Tuple of (is_valid, error_message) Usage: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">is_valid,</span> <span class="pre">error</span> <span class="pre">=</span> <span class="pre">controller.validate_state_input(test_state)</span> <span class="pre">if</span> <span class="pre">not</span> <span class="pre">is_valid:</span> <span class="pre">print(f&quot;Invalid</span> <span class="pre">state:</span> <span class="pre">{error}&quot;)</span> </code> ‚Äú‚Äù‚Äù try: if not isinstance(state, np.ndarray): return False, ‚ÄúState must be numpy array‚Äù if state.shape != (6,): return False, f‚ÄùState must be 6-element array, got {state.shape}‚Äù if not np.all(np.isfinite(state)): return False, ‚ÄúState contains non-finite values‚Äù # Check reasonable ranges (optional) angles = state[:2] # Œ∏‚ÇÅ, Œ∏‚ÇÇ if np.any(np.abs(angles) &gt; 2*np.pi): return False, ‚ÄúAngles exceed reasonable range (¬±2œÄ)‚Äù velocities = state[3:] # Œ∏Ãá‚ÇÅ, Œ∏Ãá‚ÇÇ, ·∫ã if np.any(np.abs(velocities) &gt; 100): return False, ‚ÄúVelocities exceed reasonable range (¬±100)‚Äù return True, ‚Äú‚Äù except Exception as e: return False, f‚ÄùValidation error: {e}‚Äù def <strong>repr</strong>(self) -&gt; str: ‚Äú‚Äù‚ÄùString representation for debugging.‚Äù‚Äù‚Äù controller_type = type(self.controller).<strong>name</strong> return f‚ÄùPSOControllerWrapper({controller_type}, gains={self.gains})‚Äù<a class="headerlink" href="#runnable-false-class-psocontrollerwrapper-pso-optimized-wrapper-providing-simplified-interface-for-smc-controllers-this-wrapper-is-specifically-designed-for-pso-fitness-evaluation-with-simplified-control-interface-single-state-input-automatic-state-management-for-stateful-controllers-unified-output-format-numpy-array-robust-error-handling-for-pso-robustness-performance-optimization-for-repeated-evaluations-the-wrapper-handles-the-complexity-of-different-smc-controller-interfaces-while-providing-a-consistent-pso-friendly-api-mathematical-foundation-the-wrapper-preserves-the-mathematical-properties-of-the-underlying-smc-controller-while-simplifying-the-interface-input-state-1-2-x-1-2-x-6-output-u-scalar-control-force-internal-state-management-classical-smc-stateless-empty-state-vars-sta-smc-maintains-z-for-integration-adaptive-smc-tracks-adaptation-variables-hybrid-smc-manages-mode-switching-state-performance-characteristics-control-computation-0-1ms-typical-memory-overhead-500b-per-wrapper-thread-safety-read-operations-only-error-recovery-graceful-degradation-for-invalid-inputs-def-init-self-controller-smcprotocol-initialize-pso-wrapper-with-smc-controller-args-controller-smc-controller-implementing-smcprotocol-raises-typeerror-if-controller-doesn-t-implement-required-interface-valueerror-if-controller-configuration-is-invalid-validate-controller-interface-if-not-hasattr-controller-compute-control-raise-typeerror-controller-must-implement-compute-control-method-if-not-hasattr-controller-gains-raise-typeerror-controller-must-have-gains-property-self-controller-controller-self-history-initialize-empty-history-initialize-controller-specific-state-variables-controller-name-type-controller-name-if-supertwisting-in-controller-name-or-sta-in-controller-name-sta-smc-maintains-integration-variables-z-self-state-vars-0-0-0-0-initial-z-0-0-elif-hybrid-in-controller-name-hybrid-controller-tracks-adaptive-gains-and-integration-self-state-vars-getattr-controller-k1-init-5-0-k1-prev-getattr-controller-k2-init-3-0-k2-prev-0-0-u-int-prev-elif-adaptive-in-controller-name-adaptive-smc-may-track-adaptation-state-self-state-vars-getattr-controller-initial-state-else-classical-smc-and-others-use-empty-state-self-state-vars-performance-tracking-self-call-count-0-self-total-compute-time-0-0-self-last-error-none-def-compute-control-self-state-np-ndarray-state-vars-optional-any-none-history-optional-dict-str-any-none-np-ndarray-compute-control-with-flexible-interface-supporting-both-1-simplified-pso-interface-compute-control-state-2-full-interface-compute-control-state-state-vars-history-mathematical-interface-input-state-vector-x-1-2-x-cart-1-2-x-cart-1-2-pendulum-angles-rad-x-cart-cart-position-m-1-2-angular-velocities-rad-s-x-cart-cart-velocity-m-s-output-control-u-scalar-control-force-n-bounded-by-actuator-limits-args-state-system-state-vector-6-element-numpy-array-state-vars-controller-state-variables-optional-history-controller-history-optional-returns-control-output-as-1-element-numpy-array-u-raises-valueerror-if-state-has-wrong-dimensions-runtimeerror-if-control-computation-fails-performance-typical-computation-time-0-01-0-1ms-memory-allocation-minimal-output-array-only-error-handling-graceful-fallback-to-zero-control-pso-usage-pattern-python-def-pso-fitness-gains-controller-create-smc-for-pso-smctype-classical-gains-simplified-interface-for-pso-total-error-0-0-for-state-in-test-states-u-controller-compute-control-state-returns-u-use-u-0-for-scalar-control-value-total-error-evaluate-single-step-state-u-0-return-total-error-state-management-the-wrapper-automatically-manages-controller-state-between-calls-classical-smc-no-state-management-needed-sta-smc-updates-integration-variables-z-adaptive-smc-updates-adaptation-parameters-hybrid-smc-updates-mode-and-adaptation-state-error-recovery-if-control-computation-fails-1-log-error-for-debugging-2-return-safe-fallback-control-zero-3-increment-error-counter-for-monitoring-4-continue-operation-don-t-crash-pso-import-time-performance-tracking-start-time-time-perf-counter-self-call-count-1-try-input-validation-if-not-isinstance-state-np-ndarray-state-np-array-state-if-state-shape-6-raise-valueerror-f-state-must-be-6-element-array-got-shape-state-shape-if-not-np-all-np-isfinite-state-raise-valueerror-state-contains-non-finite-values-nan-or-inf-use-provided-parameters-or-defaults-final-state-vars-state-vars-if-state-vars-is-not-none-else-self-state-vars-final-history-history-if-history-is-not-none-else-self-history-call-underlying-controller-result-self-controller-compute-control-state-final-state-vars-final-history-extract-control-value-from-result-handle-different-controller-output-formats-if-hasattr-result-u-standard-controller-output-with-u-attribute-control-value-result-u-update-state-variables-if-available-if-hasattr-result-state-vars-self-state-vars-result-state-vars-elif-hasattr-result-control-alternative-output-format-with-control-attribute-control-value-result-control-elif-isinstance-result-dict-dictionary-output-format-if-u-in-result-control-value-result-u-elif-control-in-result-control-value-result-control-else-raise-valueerror-dictionary-result-missing-control-value-update-state-if-provided-if-state-vars-in-result-self-state-vars-result-state-vars-elif-isinstance-result-tuple-tuple-output-e-g-early-return-from-some-controllers-control-value-result-0-first-element-is-control-if-len-result-1-self-state-vars-result-1-second-element-is-state-else-assume-result-is-the-control-value-directly-control-value-result-convert-to-scalar-if-needed-if-isinstance-control-value-np-ndarray-if-control-value-size-1-control-value-float-control-value-else-control-value-float-control-value-0-elif-not-isinstance-control-value-int-float-control-value-float-control-value-validate-output-if-not-np-isfinite-control-value-raise-valueerror-controller-returned-non-finite-control-value-apply-saturation-defensive-programming-max-force-getattr-self-controller-max-force-100-0-control-saturated-np-clip-control-value-max-force-max-force-for-simplified-interface-pso-usage-return-numpy-array-if-state-vars-is-none-and-history-is-none-output-np-array-control-saturated-else-for-full-interface-return-in-format-expected-by-simulation-output-control-saturated-performance-tracking-compute-time-time-perf-counter-start-time-self-total-compute-time-compute-time-return-output-except-exception-as-e-error-handling-for-robust-pso-operation-self-last-error-str-e-log-error-for-debugging-in-production-use-proper-logging-print-f-warning-control-computation-failed-e-return-safe-fallback-control-if-state-vars-is-none-and-history-is-none-return-np-array-0-0-pso-interface-else-return-0-0-full-interface-property-def-gains-self-list-float-return-controller-gains-returns-list-of-controller-gain-parameters-usage-python-controller-create-smc-for-pso-smctype-classical-gains-print-f-controller-gains-controller-gains-return-self-controller-gains-property-def-performance-stats-self-dict-str-any-return-performance-statistics-for-monitoring-returns-dictionary-with-performance-metrics-call-count-number-of-control-computations-total-time-total-computation-time-s-average-time-average-computation-time-ms-last-error-last-error-message-if-any-usage-python-after-pso-optimization-stats-controller-performance-stats-print-f-average-computation-time-stats-average-time-3f-ms-avg-time-ms-self-total-compute-time-self-call-count-1000-if-self-call-count-0-else-0-0-return-call-count-self-call-count-total-time-self-total-compute-time-average-time-avg-time-ms-last-error-self-last-error-def-reset-performance-stats-self-none-reset-performance-tracking-statistics-self-call-count-0-self-total-compute-time-0-0-self-last-error-none-def-validate-state-input-self-state-np-ndarray-tuple-bool-str-validate-state-input-for-control-computation-args-state-state-vector-to-validate-returns-tuple-of-is-valid-error-message-usage-python-is-valid-error-controller-validate-state-input-test-state-if-not-is-valid-print-f-invalid-state-error-try-if-not-isinstance-state-np-ndarray-return-false-state-must-be-numpy-array-if-state-shape-6-return-false-f-state-must-be-6-element-array-got-state-shape-if-not-np-all-np-isfinite-state-return-false-state-contains-non-finite-values-check-reasonable-ranges-optional-angles-state-2-1-2-if-np-any-np-abs-angles-2-np-pi-return-false-angles-exceed-reasonable-range-2-velocities-state-3-1-2-x-if-np-any-np-abs-velocities-100-return-false-velocities-exceed-reasonable-range-100-return-true-except-exception-as-e-return-false-f-validation-error-e-def-repr-self-str-string-representation-for-debugging-controller-type-type-self-controller-name-return-f-psocontrollerwrapper-controller-type-gains-self-gains" title="Link to this heading">¬∂</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
<span class="o">---</span>

<span class="c1">## Mathematical Constraints API ### SMC_GAIN_SPECS Registry ```python</span>

<span class="c1"># example-metadata:</span>

<span class="c1"># runnable: false # Global registry of SMC gain specifications</span>

<span class="n">SMC_GAIN_SPECS</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">SMCType</span><span class="p">,</span> <span class="n">SMCGainSpec</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">SMCType</span><span class="o">.</span><span class="n">CLASSICAL</span><span class="p">:</span> <span class="n">SMCGainSpec</span><span class="p">(</span> <span class="n">controller_type</span><span class="o">=</span><span class="n">SMCType</span><span class="o">.</span><span class="n">CLASSICAL</span><span class="p">,</span> <span class="n">n_gains</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">gain_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;k1&#39;</span><span class="p">,</span> <span class="s1">&#39;k2&#39;</span><span class="p">,</span> <span class="s1">&#39;Œª1&#39;</span><span class="p">,</span> <span class="s1">&#39;Œª2&#39;</span><span class="p">,</span> <span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="s1">&#39;kd&#39;</span><span class="p">],</span> <span class="n">gain_descriptions</span><span class="o">=</span><span class="p">[</span> <span class="s1">&#39;Position gain for pendulum 1&#39;</span><span class="p">,</span> <span class="s1">&#39;Position gain for pendulum 2&#39;</span><span class="p">,</span> <span class="s1">&#39;Surface gain for pendulum 1&#39;</span><span class="p">,</span> <span class="s1">&#39;Surface gain for pendulum 2&#39;</span><span class="p">,</span> <span class="s1">&#39;Switching gain for robustness&#39;</span><span class="p">,</span> <span class="s1">&#39;Damping gain for chattering reduction&#39;</span> <span class="p">],</span> <span class="n">mathematical_constraints</span><span class="o">=</span><span class="p">[</span> <span class="s1">&#39;k1 &gt; 0 (controllability)&#39;</span><span class="p">,</span> <span class="s1">&#39;k2 &gt; 0 (controllability)&#39;</span><span class="p">,</span> <span class="s1">&#39;Œª1 &gt; 0 (stability)&#39;</span><span class="p">,</span> <span class="s1">&#39;Œª2 &gt; 0 (stability)&#39;</span><span class="p">,</span> <span class="s1">&#39;K &gt; 0 (reachability)&#39;</span><span class="p">,</span> <span class="s1">&#39;kd ‚â• 0 (non-negative damping)&#39;</span> <span class="p">],</span> <span class="n">pso_bounds</span><span class="o">=</span><span class="p">[</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">50.0</span><span class="p">),</span> <span class="c1"># k1 (0.1, 50.0), # k2 (1.0, 50.0), # Œª1 (1.0, 50.0), # Œª2 (1.0, 200.0), # K (0.0, 50.0) # kd ], default_gains=[10.0, 8.0, 15.0, 12.0, 50.0, 5.0] ), SMCType.SUPER_TWISTING: SMCGainSpec( controller_type=SMCType.SUPER_TWISTING, n_gains=6, gain_names=[&#39;K1&#39;, &#39;K2&#39;, &#39;Œª1&#39;, &#39;Œª2&#39;, &#39;Œ±1&#39;, &#39;Œ±2&#39;], gain_descriptions=[ &#39;Primary twisting gain&#39;, &#39;Secondary twisting gain&#39;, &#39;Surface gain for pendulum 1&#39;, &#39;Surface gain for pendulum 2&#39;, &#39;Higher-order surface parameter 1&#39;, &#39;Higher-order surface parameter 2&#39; ], mathematical_constraints=[ &#39;K1 &gt; K2 (finite-time convergence)&#39;, &#39;K2 &gt; 0 (convergence requirement)&#39;, &#39;Œª1 &gt; 0 (stability)&#39;, &#39;Œª2 &gt; 0 (stability)&#39;, &#39;Œ±1 &gt; 0 (higher-order stability)&#39;, &#39;Œ±2 &gt; 0 (higher-order stability)&#39; ], pso_bounds=[ (2.0, 100.0), # K1 (must be &gt; K2) (1.0, 99.0), # K2 (must be &lt; K1) (1.0, 50.0), # Œª1 (1.0, 50.0), # Œª2 (1.0, 50.0), # Œ±1 (1.0, 50.0) # Œ±2 ], default_gains=[25.0, 10.0, 15.0, 12.0, 20.0, 15.0] ), SMCType.ADAPTIVE: SMCGainSpec( controller_type=SMCType.ADAPTIVE, n_gains=5, gain_names=[&#39;k1&#39;, &#39;k2&#39;, &#39;Œª1&#39;, &#39;Œª2&#39;, &#39;Œ≥&#39;], gain_descriptions=[ &#39;Position gain for pendulum 1&#39;, &#39;Position gain for pendulum 2&#39;, &#39;Surface gain for pendulum 1&#39;, &#39;Surface gain for pendulum 2&#39;, &#39;Adaptation rate&#39; ], mathematical_constraints=[ &#39;k1 &gt; 0 (controllability)&#39;, &#39;k2 &gt; 0 (controllability)&#39;, &#39;Œª1 &gt; 0 (stability)&#39;, &#39;Œª2 &gt; 0 (stability)&#39;, &#39;0.1 ‚â§ Œ≥ ‚â§ 20.0 (bounded adaptation)&#39; ], pso_bounds=[ (0.1, 50.0), # k1 (0.1, 50.0), # k2 (1.0, 50.0), # Œª1 (1.0, 50.0), # Œª2 (0.1, 20.0) # Œ≥ ], default_gains=[10.0, 8.0, 15.0, 12.0, 0.5] ), SMCType.HYBRID: SMCGainSpec( controller_type=SMCType.HYBRID, n_gains=4, gain_names=[&#39;k1&#39;, &#39;k2&#39;, &#39;Œª1&#39;, &#39;Œª2&#39;], gain_descriptions=[ &#39;Surface gain for pendulum 1&#39;, &#39;Surface gain for pendulum 2&#39;, &#39;Higher-order surface gain 1&#39;, &#39;Higher-order surface gain 2&#39; ], mathematical_constraints=[ &#39;k1 &gt; 0 (stability)&#39;, &#39;k2 &gt; 0 (stability)&#39;, &#39;Œª1 &gt; 0 (stability)&#39;, &#39;Œª2 &gt; 0 (stability)&#39; ], pso_bounds=[ (1.0, 50.0), # k1 (1.0, 50.0), # k2 (1.0, 50.0), # Œª1 (1.0, 50.0) # Œª2 ], default_gains=[15.0, 12.0, 18.0, 15.0] )</span>
<span class="p">}</span>
<span class="err">```</span> <span class="c1">### Constraint Validation Functions ```python</span>
<span class="c1"># example-metadata:</span>
<span class="c1"># runnable: false def validate_mathematical_constraints(smc_type: SMCType, gains: List[float], tolerance: float = 1e-8 ) -&gt; Tuple[bool, List[str]]: &quot;&quot;&quot; Validate mathematical constraints for SMC gains. Args: smc_type: Controller type gains: Gain values to validate tolerance: Numerical tolerance for constraint checking Returns: Tuple of (is_valid, list_of_constraint_violations) &quot;&quot;&quot; violations = [] if smc_type == SMCType.CLASSICAL: k1, k2, lam1, lam2, K, kd = gains if k1 &lt;= tolerance: violations.append(f&quot;k1 = {k1:.6f} must be &gt; {tolerance}&quot;) if k2 &lt;= tolerance: violations.append(f&quot;k2 = {k2:.6f} must be &gt; {tolerance}&quot;) if lam1 &lt;= tolerance: violations.append(f&quot;Œª1 = {lam1:.6f} must be &gt; {tolerance}&quot;) if lam2 &lt;= tolerance: violations.append(f&quot;Œª2 = {lam2:.6f} must be &gt; {tolerance}&quot;) if K &lt;= tolerance: violations.append(f&quot;K = {K:.6f} must be &gt; {tolerance}&quot;) if kd &lt; -tolerance: violations.append(f&quot;kd = {kd:.6f} must be ‚â• 0&quot;) elif smc_type == SMCType.SUPER_TWISTING: K1, K2, lam1, lam2, alpha1, alpha2 = gains if K1 &lt;= K2 + tolerance: violations.append(f&quot;K1 = {K1:.6f} must be &gt; K2 = {K2:.6f}&quot;) if K2 &lt;= tolerance: violations.append(f&quot;K2 = {K2:.6f} must be &gt; {tolerance}&quot;) if any(g &lt;= tolerance for g in [lam1, lam2, alpha1, alpha2]): violations.append(&quot;All surface parameters must be positive&quot;) elif smc_type == SMCType.ADAPTIVE: k1, k2, lam1, lam2, gamma = gains if any(g &lt;= tolerance for g in [k1, k2, lam1, lam2]): violations.append(&quot;All surface gains must be positive&quot;) if not (0.1 &lt;= gamma &lt;= 20.0): violations.append(f&quot;Œ≥ = {gamma:.6f} must be in [0.1, 20.0]&quot;) elif smc_type == SMCType.HYBRID: if any(g &lt;= tolerance for g in gains): violations.append(&quot;All hybrid gains must be positive&quot;) return len(violations) == 0, violations def estimate_stability_properties(smc_type: SMCType, gains: List[float] ) -&gt; Dict[str, float]: &quot;&quot;&quot; Estimate stability properties from gains. Returns: Dictionary with estimated properties: - convergence_rate: Estimated convergence rate - stability_margin: Stability margin estimate - bandwidth: Estimated closed-loop bandwidth - settling_time: Estimated settling time &quot;&quot;&quot; if smc_type == SMCType.CLASSICAL: k1, k2, lam1, lam2, K, kd = gains min_surface_gain = min(lam1, lam2) convergence_rate = min_surface_gain bandwidth = min_surface_gain settling_time = 4.0 / min_surface_gain if min_surface_gain &gt; 0 else float(&#39;inf&#39;) stability_margin = K / (K + 10.0) # Rough estimate elif smc_type == SMCType.SUPER_TWISTING: K1, K2, lam1, lam2, alpha1, alpha2 = gains convergence_rate = min(K1, K2) bandwidth = min(lam1, lam2) settling_time = 2.0 / convergence_rate if convergence_rate &gt; 0 else float(&#39;inf&#39;) stability_margin = (K1 - K2) / K1 if K1 &gt; 0 else 0 elif smc_type == SMCType.ADAPTIVE: k1, k2, lam1, lam2, gamma = gains surface_bandwidth = min(lam1, lam2) adaptation_bandwidth = gamma convergence_rate = min(surface_bandwidth, adaptation_bandwidth) bandwidth = surface_bandwidth settling_time = 4.0 / convergence_rate if convergence_rate &gt; 0 else float(&#39;inf&#39;) stability_margin = min(1.0, (20.0 - gamma) / 20.0) elif smc_type == SMCType.HYBRID: k1, k2, lam1, lam2 = gains convergence_rate = min(gains) bandwidth = convergence_rate settling_time = 4.0 / convergence_rate if convergence_rate &gt; 0 else float(&#39;inf&#39;) stability_margin = min(gains) / max(gains) if max(gains) &gt; 0 else 0 return { &#39;convergence_rate&#39;: convergence_rate, &#39;stability_margin&#39;: stability_margin, &#39;bandwidth&#39;: bandwidth, &#39;settling_time&#39;: settling_time }</span>
</pre></div>
</div>
<hr class="docutils" />
<section id="configuration-schema-api-factory-configuration-classes-python">
<h2>Configuration Schema API ### Factory Configuration Classes ```python<a class="headerlink" href="#configuration-schema-api-factory-configuration-classes-python" title="Link to this heading">¬∂</a></h2>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id3">
<h1>example-metadata:<a class="headerlink" href="#id3" title="Link to this heading">¬∂</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id4">
<h1>runnable: false &#64;dataclass(frozen=True)<a class="headerlink" href="#id4" title="Link to this heading">¬∂</a></h1>
<p>class PSOFactoryConfig: ‚Äú‚Äù‚Äù Complete configuration for PSO-Factory integration. Provides type-safe configuration with automatic validation and mathematical constraint checking. ‚Äú‚Äù‚Äù # Controller configuration controller_type: SMCType max_force: float = 100.0 dt: float = 0.01 # PSO algorithm parameters pso_params: Dict[str, Any] = field(default_factory=lambda: { ‚Äòn_particles‚Äô: 30, ‚Äòiters‚Äô: 100, ‚Äòc1‚Äô: 2.0, ‚Äòc2‚Äô: 2.0, ‚Äòw‚Äô: 0.9 }) # Performance monitoring enable_monitoring: bool = True enable_caching: bool = True cache_size: int = 1000 # Validation settings strict_validation: bool = True constraint_tolerance: float = 1e-8 # PSO bounds (auto-derived if None) custom_bounds: Optional[List[Tuple[float, float]]] = None def <strong>post_init</strong>(self): ‚Äú‚Äù‚ÄùValidate configuration after initialization.‚Äù‚Äù‚Äù if self.max_force &lt;= 0: raise ValueError(‚Äúmax_force must be positive‚Äù) if self.dt &lt;= 0: raise ValueError(‚Äúdt must be positive‚Äù) if not isinstance(self.controller_type, SMCType): raise TypeError(‚Äúcontroller_type must be SMCType‚Äù) # Validate PSO parameters if self.pso_params[‚Äòn_particles‚Äô] &lt; 10: raise ValueError(‚Äún_particles should be ‚â• 10‚Äù) if self.pso_params[‚Äòiters‚Äô] &lt; 10: raise ValueError(‚Äúiters should be ‚â• 10‚Äù) &#64;property def gain_bounds(self) -&gt; List[Tuple[float, float]]: ‚Äú‚Äù‚ÄùGet PSO bounds (custom or auto-derived).‚Äù‚Äù‚Äù if self.custom_bounds is not None: return self.custom_bounds return get_gain_bounds_for_pso(self.controller_type) &#64;property def n_gains(self) -&gt; int: ‚Äú‚Äù‚ÄùGet number of gain parameters.‚Äù‚Äù‚Äù return self.controller_type.gain_count def load_factory_config(config_dict: Dict[str, Any]) -&gt; PSOFactoryConfig: ‚Äú‚Äù‚Äù Load and validate factory configuration from dictionary. Args: config_dict: Configuration dictionary Returns: Validated PSOFactoryConfig object Raises: ConfigurationError: If validation fails ‚Äú‚Äù‚Äù try: # Convert string controller type to enum if isinstance(config_dict.get(‚Äòcontroller_type‚Äô), str): config_dict[‚Äòcontroller_type‚Äô] = SMCType(config_dict[‚Äòcontroller_type‚Äô]) return PSOFactoryConfig(**config_dict) except (ValueError, TypeError) as e: raise ConfigurationError(f‚ÄùInvalid factory configuration: {e}‚Äù)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
<span class="o">---</span>

<span class="c1">## Advanced PSO Workflows ### Multi-Objective PSO Integration ```python</span>
<span class="c1"># example-metadata:</span>
<span class="c1"># runnable: false def multi_objective_pso_optimization( controller_types: List[SMCType], simulation_config: Dict[str, Any], objectives: Dict[str, float], pso_config: Dict[str, Any]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span> <span class="s2">&quot;&quot;&quot; Multi-objective PSO optimization across multiple controller types. Optimizes multiple SMC controllers simultaneously using weighted multi-objective fitness functions with Pareto front analysis. Args: controller_types: List of SMC types to optimize simulation_config: Simulation parameters objectives: Objective weights {&#39;ise&#39;: 0.4, &#39;overshoot&#39;: 0.3, &#39;energy&#39;: 0.3} pso_config: PSO algorithm configuration Returns: optimization results with Pareto analysis &quot;&quot;&quot;</span> <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span> <span class="n">all_solutions</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">smc_type</span> <span class="ow">in</span> <span class="n">controller_types</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimizing </span><span class="si">{</span><span class="n">smc_type</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span> <span class="c1"># Get PSO bounds for this controller type bounds = get_gain_bounds_for_pso(smc_type) # Create multi-objective fitness function def multi_objective_fitness(particles: np.ndarray) -&gt; np.ndarray: fitness_scores = [] for gains in particles: try: # Create controller with validation controller = create_smc_for_pso(smc_type, gains.tolist()) # Run simulation sim_result = run_simulation(controller, simulation_config) # Compute individual objectives ise = compute_ise(sim_result) overshoot = compute_overshoot(sim_result) energy = compute_control_energy(sim_result) # Weighted combination fitness = (objectives.get(&#39;ise&#39;, 0.0) * ise + objectives.get(&#39;overshoot&#39;, 0.0) * overshoot + objectives.get(&#39;energy&#39;, 0.0) * energy) fitness_scores.append(fitness) # Store solution for Pareto analysis all_solutions.append({ &#39;controller_type&#39;: smc_type, &#39;gains&#39;: gains.tolist(), &#39;fitness&#39;: fitness, &#39;objectives&#39;: {&#39;ise&#39;: ise, &#39;overshoot&#39;: overshoot, &#39;energy&#39;: energy} }) except Exception: fitness_scores.append(1000.0) return np.array(fitness_scores) # Run PSO optimization from pyswarms.single import GlobalBestPSO bounds_array = np.array(bounds) optimizer = GlobalBestPSO( n_particles=pso_config.get(&#39;n_particles&#39;, 30), dimensions=len(bounds), options={ &#39;c1&#39;: pso_config.get(&#39;c1&#39;, 2.0), &#39;c2&#39;: pso_config.get(&#39;c2&#39;, 2.0), &#39;w&#39;: pso_config.get(&#39;w&#39;, 0.9) }, bounds=(bounds_array[:, 0], bounds_array[:, 1]) ) best_cost, best_gains = optimizer.optimize( multi_objective_fitness, iters=pso_config.get(&#39;iters&#39;, 100) ) results[smc_type.value] = { &#39;best_gains&#39;: best_gains.tolist(), &#39;best_fitness&#39;: float(best_cost), &#39;optimization_history&#39;: optimizer.cost_history } # Pareto front analysis pareto_front = compute_pareto_front(all_solutions, objectives) controller_ranking = rank_controllers_by_objectives(results, objectives) return { &#39;individual_results&#39;: results, &#39;pareto_front&#39;: pareto_front, &#39;controller_ranking&#39;: controller_ranking, &#39;best_overall&#39;: select_best_overall_solution(results, objectives) } def compute_pareto_front(solutions: List[Dict[str, Any]], objectives: Dict[str, float] ) -&gt; List[Dict[str, Any]]: &quot;&quot;&quot; Compute Pareto-optimal approaches from multi-objective optimization. Args: solutions: List of solution dictionaries objectives: Objective weights Returns: List of Pareto-optimal approaches &quot;&quot;&quot; pareto_solutions = [] for i, solution_i in enumerate(solutions): is_dominated = False for j, solution_j in enumerate(solutions): if i == j: continue # Check if solution_j dominates solution_i obj_i = solution_i[&#39;objectives&#39;] obj_j = solution_j[&#39;objectives&#39;] dominates = True for obj_name in objectives.keys(): if obj_j[obj_name] &gt;= obj_i[obj_name]: # j is not better in this objective dominates = False break if dominates: is_dominated = True break if not is_dominated: pareto_solutions.append(solution_i) return pareto_solutions</span>
<span class="err">```</span> <span class="c1">### Adaptive PSO with Dynamic Bounds ```python</span>

<span class="k">class</span><span class="w"> </span><span class="nc">AdaptivePSOFactory</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot; Adaptive PSO optimization with dynamic parameter adjustment. Features: - Dynamic bounds tightening around promising regions - Adaptive PSO parameter tuning based on convergence - Early stopping with convergence detection - Multi-stage optimization with exploration-exploitation balance &quot;&quot;&quot;</span> <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smc_type</span><span class="p">:</span> <span class="n">SMCType</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]):</span> <span class="bp">self</span><span class="o">.</span><span class="n">smc_type</span> <span class="o">=</span> <span class="n">smc_type</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span> <span class="o">=</span> <span class="n">config</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimization_history</span> <span class="o">=</span> <span class="p">[]</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_history</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Initialize with full bounds self.current_bounds = get_gain_bounds_for_pso(smc_type) self.best_solution = None self.convergence_detector = PSOConvergenceDetector() def optimize_with_adaptation(self, simulation_config: Dict[str, Any], stages: List[Dict[str, Any]] ) -&gt; Dict[str, Any]: &quot;&quot;&quot; Run adaptive PSO optimization with multiple stages. Args: simulation_config: Simulation parameters stages: List of optimization stages with different parameters Returns: Complete optimization results with adaptation history &quot;&quot;&quot; all_results = [] for stage_idx, stage_config in enumerate(stages): print(f&quot;PSO Stage {stage_idx + 1}: {stage_config}&quot;) # Adapt PSO parameters for this stage pso_params = self._adapt_pso_parameters(stage_config, stage_idx) # Adapt bounds based on previous results if stage_idx &gt; 0 and self.best_solution is not None: self.current_bounds = self._adapt_bounds( self.best_solution[&#39;gains&#39;], stage_config.get(&#39;bound_tightening&#39;, 0.5) ) # Create fitness function fitness_function = self._create_adaptive_fitness_function( simulation_config, stage_config ) # Run PSO optimization stage stage_result = self._run_pso_stage( fitness_function, pso_params, stage_config[&#39;iterations&#39;] ) all_results.append(stage_result) # Update best solution if (self.best_solution is None or stage_result[&#39;best_fitness&#39;] &lt; self.best_solution[&#39;fitness&#39;]): self.best_solution = { &#39;gains&#39;: stage_result[&#39;best_gains&#39;], &#39;fitness&#39;: stage_result[&#39;best_fitness&#39;], &#39;stage&#39;: stage_idx } # Check for early convergence if self.convergence_detector.check_convergence(stage_result): print(f&quot;Early convergence detected at stage {stage_idx + 1}&quot;) break # Combine results final_result = self._combine_stage_results(all_results) final_result[&#39;adaptation_history&#39;] = { &#39;bounds_history&#39;: self.bounds_history, &#39;best_solution_history&#39;: self.optimization_history } return final_result def _adapt_pso_parameters(self, stage_config: Dict[str, Any], stage_idx: int ) -&gt; Dict[str, Any]: &quot;&quot;&quot;Adapt PSO parameters based on stage and convergence history.&quot;&quot;&quot; base_params = self.config.get(&#39;pso_params&#39;, {}) # Exploration vs exploitation balance exploration_weight = stage_config.get(&#39;exploration_weight&#39;, 0.5) # Adaptive inertia weight w_max = 0.9 w_min = 0.4 w = w_max - (w_max - w_min) * exploration_weight # Adaptive cognitive/social parameters c1 = 2.5 - exploration_weight # High cognitive for exploration c2 = 0.5 + exploration_weight # High social for exploitation return { &#39;n_particles&#39;: base_params.get(&#39;n_particles&#39;, 30), &#39;c1&#39;: c1, &#39;c2&#39;: c2, &#39;w&#39;: w } def _adapt_bounds(self, best_gains: List[float], tightening_factor: float ) -&gt; List[Tuple[float, float]]: &quot;&quot;&quot;Adapt optimization bounds around best solution.&quot;&quot;&quot; adapted_bounds = [] original_bounds = get_gain_bounds_for_pso(self.smc_type) for i, (gain, (orig_lower, orig_upper)) in enumerate(zip(best_gains, original_bounds)): # Calculate range around best gain range_width = (orig_upper - orig_lower) * tightening_factor # New bounds centered around best gain new_lower = max(orig_lower, gain - range_width / 2) new_upper = min(orig_upper, gain + range_width / 2) adapted_bounds.append((new_lower, new_upper)) self.bounds_history.append(adapted_bounds) return adapted_bounds def _create_adaptive_fitness_function(self, simulation_config: Dict[str, Any], stage_config: Dict[str, Any] ) -&gt; Callable: &quot;&quot;&quot;Create fitness function with adaptive features.&quot;&quot;&quot; def adaptive_fitness(particles: np.ndarray) -&gt; np.ndarray: fitness_scores = [] for gains in particles: try: # Create controller with validation controller = create_smc_for_pso(self.smc_type, gains.tolist()) # Run simulation result = run_simulation(controller, simulation_config) # Compute base fitness base_fitness = compute_control_performance_metrics( result, stage_config.get(&#39;objectives&#39;, [&#39;ise&#39;]) ) # Add adaptive penalties/bonuses adapted_fitness = self._apply_adaptive_adjustments( base_fitness, gains.tolist(), stage_config ) fitness_scores.append(adapted_fitness) except Exception: fitness_scores.append(1000.0) return np.array(fitness_scores) return adaptive_fitness def _apply_adaptive_adjustments(self, base_fitness: float, gains: List[float], stage_config: Dict[str, Any] ) -&gt; float: &quot;&quot;&quot;Apply adaptive adjustments to fitness based on stage configuration.&quot;&quot;&quot; adjusted_fitness = base_fitness # Diversity bonus (encourage exploration in early stages) if stage_config.get(&#39;diversity_bonus&#39;, False) and self.best_solution: distance = np.linalg.norm( np.array(gains) - np.array(self.best_solution[&#39;gains&#39;]) ) diversity_bonus = stage_config.get(&#39;diversity_weight&#39;, 0.1) * distance adjusted_fitness -= diversity_bonus # Stability margin bonus if stage_config.get(&#39;stability_bonus&#39;, True): stability_properties = estimate_stability_properties(self.smc_type, gains) stability_bonus = stability_properties[&#39;stability_margin&#39;] * 0.1 adjusted_fitness -= stability_bonus return adjusted_fitness class PSOConvergenceDetector: &quot;&quot;&quot;Advanced convergence detection for PSO optimization.&quot;&quot;&quot; def __init__(self, patience: int = 20, tolerance: float = 1e-6): self.patience = patience self.tolerance = tolerance self.fitness_history = [] self.best_fitness = float(&#39;inf&#39;) self.stagnation_count = 0 def check_convergence(self, stage_result: Dict[str, Any]) -&gt; bool: &quot;&quot;&quot; Check if PSO has converged based on multiple criteria. Args: stage_result: Results from PSO optimization stage Returns: True if convergence detected, False otherwise &quot;&quot;&quot; current_fitness = stage_result[&#39;best_fitness&#39;] self.fitness_history.append(current_fitness) # Check for improvement if current_fitness &lt; self.best_fitness - self.tolerance: self.best_fitness = current_fitness self.stagnation_count = 0 else: self.stagnation_count += 1 # Multiple convergence criteria return ( self._check_fitness_plateau() or self._check_statistical_convergence() ) def _check_fitness_plateau(self) -&gt; bool: &quot;&quot;&quot;Check if fitness has plateaued.&quot;&quot;&quot; return self.stagnation_count &gt;= self.patience def _check_statistical_convergence(self) -&gt; bool: &quot;&quot;&quot;Check statistical significance of convergence.&quot;&quot;&quot; if len(self.fitness_history) &lt; 30: return False # Test if recent improvements are statistically significant recent_fitness = self.fitness_history[-15:] older_fitness = self.fitness_history[-30:-15] from scipy.stats import ttest_ind try: statistic, p_value = ttest_ind(recent_fitness, older_fitness) return p_value &gt; 0.05 # No significant difference except: return False</span>
</pre></div>
</div>
<hr class="docutils" />
<section id="performance-monitoring-api-real-time-performance-monitoring-python">
<h2>Performance Monitoring API ### Real-Time Performance Monitoring ```python<a class="headerlink" href="#performance-monitoring-api-real-time-performance-monitoring-python" title="Link to this heading">¬∂</a></h2>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id5">
<h1>example-metadata:<a class="headerlink" href="#id5" title="Link to this heading">¬∂</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-class-psoperformancemonitor-real-time-performance-monitoring-for-pso-factory-integration-provides-monitoring-of-pso-convergence-metrics-controller-creation-performance-simulation-execution-times-memory-usage-tracking-error-rate-monitoring-def-init-self-monitoring-config-dict-str-any-self-config-monitoring-config-self-metrics-pso-metrics-total-evaluations-0-successful-evaluations-0-failed-evaluations-0-average-fitness-0-0-best-fitness-float-inf-convergence-rate-0-0-performance-metrics-controller-creation-time-simulation-execution-time-fitness-computation-time-total-optimization-time-0-0-resource-metrics-peak-memory-usage-0-0-average-memory-usage-0-0-cpu-utilization-memory-samples-error-metrics-creation-failures-0-simulation-failures-0-validation-failures-0-total-errors-0-self-start-time-none-self-monitoring-active-false-def-start-monitoring-self-start-performance-monitoring-session-import-time-self-start-time-time-time-self-monitoring-active-true-self-reset-metrics-def-stop-monitoring-self-dict-str-any-stop-monitoring-and-return-complete-performance-report-import-time-if-self-start-time-self-metrics-performance-metrics-total-optimization-time-time-time-self-start-time-self-monitoring-active-false-return-self-generate-performance-report-def-log-controller-creation-self-success-bool-creation-time-float-log-controller-creation-event-if-not-self-monitoring-active-return-self-metrics-performance-metrics-controller-creation-time-append-creation-time-if-success-self-metrics-pso-metrics-successful-evaluations-1-else-self-metrics-error-metrics-creation-failures-1-self-metrics-pso-metrics-failed-evaluations-1-def-log-simulation-execution-self-success-bool-execution-time-float-log-simulation-execution-event-if-not-self-monitoring-active-return-if-success-self-metrics-performance-metrics-simulation-execution-time-append-execution-time-else-self-metrics-error-metrics-simulation-failures-1-def-log-fitness-evaluation-self-fitness-value-float-computation-time-float-log-fitness-evaluation-result-if-not-self-monitoring-active-return-self-metrics-performance-metrics-fitness-computation-time-append-computation-time-self-metrics-pso-metrics-total-evaluations-1-update-best-fitness-if-fitness-value-self-metrics-pso-metrics-best-fitness-self-metrics-pso-metrics-best-fitness-fitness-value-update-average-fitness-running-average-total-evals-self-metrics-pso-metrics-total-evaluations-current-avg-self-metrics-pso-metrics-average-fitness-self-metrics-pso-metrics-average-fitness-current-avg-total-evals-1-fitness-value-total-evals-def-log-resource-usage-self-log-current-resource-usage-if-not-self-monitoring-active-return-try-import-psutil-memory-usage-memory-info-psutil-virtual-memory-current-memory-memory-info-percent-self-metrics-resource-metrics-memory-samples-append-current-memory-update-peak-memory-if-current-memory-self-metrics-resource-metrics-peak-memory-usage-self-metrics-resource-metrics-peak-memory-usage-current-memory-cpu-utilization-cpu-percent-psutil-cpu-percent-interval-none-self-metrics-resource-metrics-cpu-utilization-append-cpu-percent-except-importerror-pass-psutil-not-available-def-check-performance-alerts-self-list-str-check-for-performance-issues-and-return-alerts-alerts-memory-usage-alerts-if-self-metrics-resource-metrics-peak-memory-usage-90-alerts-append-f-high-memory-usage-self-metrics-resource-metrics-peak-memory-usage-1f-error-rate-alerts-total-evals-self-metrics-pso-metrics-total-evaluations-if-total-evals-0-error-rate-self-metrics-error-metrics-total-errors-total-evals-if-error-rate-0-1-alerts-append-f-high-error-rate-error-rate-1-performance-alerts-creation-times-self-metrics-performance-metrics-controller-creation-time-if-creation-times-and-np-mean-creation-times-0-002-2ms-threshold-alerts-append-f-slow-controller-creation-np-mean-creation-times-1000-2f-ms-average-return-alerts-def-generate-performance-report-self-dict-str-any-generate-performance-report-calculate-derived-metrics-total-evals-self-metrics-pso-metrics-total-evaluations-success-rate-self-metrics-pso-metrics-successful-evaluations-total-evals-100-if-total-evals-0-else-0-creation-times-self-metrics-performance-metrics-controller-creation-time-avg-creation-time-np-mean-creation-times-if-creation-times-else-0-simulation-times-self-metrics-performance-metrics-simulation-execution-time-avg-simulation-time-np-mean-simulation-times-if-simulation-times-else-0-fitness-times-self-metrics-performance-metrics-fitness-computation-time-avg-fitness-time-np-mean-fitness-times-if-fitness-times-else-0-memory-samples-self-metrics-resource-metrics-memory-samples-avg-memory-np-mean-memory-samples-if-memory-samples-else-0-cpu-samples-self-metrics-resource-metrics-cpu-utilization-avg-cpu-np-mean-cpu-samples-if-cpu-samples-else-0-total-time-self-metrics-performance-metrics-total-optimization-time-evaluations-per-second-total-evals-total-time-if-total-time-0-else-0-generate-report-report-summary-total-evaluations-total-evals-success-rate-success-rate-best-fitness-achieved-self-metrics-pso-metrics-best-fitness-total-optimization-time-total-time-evaluations-per-second-evaluations-per-second-performance-average-controller-creation-time-ms-avg-creation-time-1000-average-simulation-time-ms-avg-simulation-time-1000-average-fitness-computation-time-ms-avg-fitness-time-1000-resources-peak-memory-usage-percent-self-metrics-resource-metrics-peak-memory-usage-average-memory-usage-percent-avg-memory-average-cpu-utilization-percent-avg-cpu-errors-controller-creation-failures-self-metrics-error-metrics-creation-failures-simulation-failures-self-metrics-error-metrics-simulation-failures-validation-failures-self-metrics-error-metrics-validation-failures-total-error-count-self-metrics-error-metrics-total-errors-alerts-self-check-performance-alerts-raw-metrics-self-metrics-return-report-def-reset-metrics-self-reset-all-metrics-for-new-monitoring-session-for-category-in-self-metrics-values-if-isinstance-category-dict-for-key-value-in-category-items-if-isinstance-value-list-category-key-elif-isinstance-value-int-float-if-best-fitness-in-key-category-key-float-inf-else-category-key-0-context-manager-for-automatic-monitoring">
<h1>runnable: false class PSOPerformanceMonitor: ‚Äú‚Äù‚Äù Real-time performance monitoring for PSO-Factory integration. Provides monitoring of: - PSO convergence metrics - Controller creation performance - Simulation execution times - Memory usage tracking - Error rate monitoring ‚Äú‚Äù‚Äù def <strong>init</strong>(self, monitoring_config: Dict[str, Any]): self.config = monitoring_config self.metrics = { ‚Äòpso_metrics‚Äô: { ‚Äòtotal_evaluations‚Äô: 0, ‚Äòsuccessful_evaluations‚Äô: 0, ‚Äòfailed_evaluations‚Äô: 0, ‚Äòaverage_fitness‚Äô: 0.0, ‚Äòbest_fitness‚Äô: float(‚Äòinf‚Äô), ‚Äòconvergence_rate‚Äô: 0.0 }, ‚Äòperformance_metrics‚Äô: { ‚Äòcontroller_creation_time‚Äô: [], ‚Äòsimulation_execution_time‚Äô: [], ‚Äòfitness_computation_time‚Äô: [], ‚Äòtotal_optimization_time‚Äô: 0.0 }, ‚Äòresource_metrics‚Äô: { ‚Äòpeak_memory_usage‚Äô: 0.0, ‚Äòaverage_memory_usage‚Äô: 0.0, ‚Äòcpu_utilization‚Äô: [], ‚Äòmemory_samples‚Äô: [] }, ‚Äòerror_metrics‚Äô: { ‚Äòcreation_failures‚Äô: 0, ‚Äòsimulation_failures‚Äô: 0, ‚Äòvalidation_failures‚Äô: 0, ‚Äòtotal_errors‚Äô: 0 } } self.start_time = None self.monitoring_active = False def start_monitoring(self): ‚Äú‚Äù‚ÄùStart performance monitoring session.‚Äù‚Äù‚Äù import time self.start_time = time.time() self.monitoring_active = True self._reset_metrics() def stop_monitoring(self) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùStop monitoring and return complete performance report.‚Äù‚Äù‚Äù import time if self.start_time: self.metrics[‚Äòperformance_metrics‚Äô][‚Äòtotal_optimization_time‚Äô] = ( time.time() - self.start_time ) self.monitoring_active = False return self.generate_performance_report() def log_controller_creation(self, success: bool, creation_time: float): ‚Äú‚Äù‚ÄùLog controller creation event.‚Äù‚Äù‚Äù if not self.monitoring_active: return self.metrics[‚Äòperformance_metrics‚Äô][‚Äòcontroller_creation_time‚Äô].append(creation_time) if success: self.metrics[‚Äòpso_metrics‚Äô][‚Äòsuccessful_evaluations‚Äô] += 1 else: self.metrics[‚Äòerror_metrics‚Äô][‚Äòcreation_failures‚Äô] += 1 self.metrics[‚Äòpso_metrics‚Äô][‚Äòfailed_evaluations‚Äô] += 1 def log_simulation_execution(self, success: bool, execution_time: float): ‚Äú‚Äù‚ÄùLog simulation execution event.‚Äù‚Äù‚Äù if not self.monitoring_active: return if success: self.metrics[‚Äòperformance_metrics‚Äô][‚Äòsimulation_execution_time‚Äô].append(execution_time) else: self.metrics[‚Äòerror_metrics‚Äô][‚Äòsimulation_failures‚Äô] += 1 def log_fitness_evaluation(self, fitness_value: float, computation_time: float): ‚Äú‚Äù‚ÄùLog fitness evaluation result.‚Äù‚Äù‚Äù if not self.monitoring_active: return self.metrics[‚Äòperformance_metrics‚Äô][‚Äòfitness_computation_time‚Äô].append(computation_time) self.metrics[‚Äòpso_metrics‚Äô][‚Äòtotal_evaluations‚Äô] += 1 # Update best fitness if fitness_value &lt; self.metrics[‚Äòpso_metrics‚Äô][‚Äòbest_fitness‚Äô]: self.metrics[‚Äòpso_metrics‚Äô][‚Äòbest_fitness‚Äô] = fitness_value # Update average fitness (running average) total_evals = self.metrics[‚Äòpso_metrics‚Äô][‚Äòtotal_evaluations‚Äô] current_avg = self.metrics[‚Äòpso_metrics‚Äô][‚Äòaverage_fitness‚Äô] self.metrics[‚Äòpso_metrics‚Äô][‚Äòaverage_fitness‚Äô] = ( (current_avg * (total_evals - 1) + fitness_value) / total_evals ) def log_resource_usage(self): ‚Äú‚Äù‚ÄùLog current resource usage.‚Äù‚Äù‚Äù if not self.monitoring_active: return try: import psutil # Memory usage memory_info = psutil.virtual_memory() current_memory = memory_info.percent self.metrics[‚Äòresource_metrics‚Äô][‚Äòmemory_samples‚Äô].append(current_memory) # Update peak memory if current_memory &gt; self.metrics[‚Äòresource_metrics‚Äô][‚Äòpeak_memory_usage‚Äô]: self.metrics[‚Äòresource_metrics‚Äô][‚Äòpeak_memory_usage‚Äô] = current_memory # CPU utilization cpu_percent = psutil.cpu_percent(interval=None) self.metrics[‚Äòresource_metrics‚Äô][‚Äòcpu_utilization‚Äô].append(cpu_percent) except ImportError: pass # psutil not available def check_performance_alerts(self) -&gt; List[str]: ‚Äú‚Äù‚ÄùCheck for performance issues and return alerts.‚Äù‚Äù‚Äù alerts = [] # Memory usage alerts if self.metrics[‚Äòresource_metrics‚Äô][‚Äòpeak_memory_usage‚Äô] &gt; 90: alerts.append(f‚ÄùHigh memory usage: {self.metrics[‚Äòresource_metrics‚Äô][‚Äòpeak_memory_usage‚Äô]:.1f}%‚Äù) # Error rate alerts total_evals = self.metrics[‚Äòpso_metrics‚Äô][‚Äòtotal_evaluations‚Äô] if total_evals &gt; 0: error_rate = self.metrics[‚Äòerror_metrics‚Äô][‚Äòtotal_errors‚Äô] / total_evals if error_rate &gt; 0.1: alerts.append(f‚ÄùHigh error rate: {error_rate:.1%}‚Äù) # Performance alerts creation_times = self.metrics[‚Äòperformance_metrics‚Äô][‚Äòcontroller_creation_time‚Äô] if creation_times and np.mean(creation_times) &gt; 0.002: # 2ms threshold alerts.append(f‚ÄùSlow controller creation: {np.mean(creation_times)*1000:.2f}ms average‚Äù) return alerts def generate_performance_report(self) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùGenerate performance report.‚Äù‚Äù‚Äù # Calculate derived metrics total_evals = self.metrics[‚Äòpso_metrics‚Äô][‚Äòtotal_evaluations‚Äô] success_rate = (self.metrics[‚Äòpso_metrics‚Äô][‚Äòsuccessful_evaluations‚Äô] / total_evals * 100 if total_evals &gt; 0 else 0) creation_times = self.metrics[‚Äòperformance_metrics‚Äô][‚Äòcontroller_creation_time‚Äô] avg_creation_time = np.mean(creation_times) if creation_times else 0 simulation_times = self.metrics[‚Äòperformance_metrics‚Äô][‚Äòsimulation_execution_time‚Äô] avg_simulation_time = np.mean(simulation_times) if simulation_times else 0 fitness_times = self.metrics[‚Äòperformance_metrics‚Äô][‚Äòfitness_computation_time‚Äô] avg_fitness_time = np.mean(fitness_times) if fitness_times else 0 memory_samples = self.metrics[‚Äòresource_metrics‚Äô][‚Äòmemory_samples‚Äô] avg_memory = np.mean(memory_samples) if memory_samples else 0 cpu_samples = self.metrics[‚Äòresource_metrics‚Äô][‚Äòcpu_utilization‚Äô] avg_cpu = np.mean(cpu_samples) if cpu_samples else 0 total_time = self.metrics[‚Äòperformance_metrics‚Äô][‚Äòtotal_optimization_time‚Äô] evaluations_per_second = total_evals / total_time if total_time &gt; 0 else 0 # Generate report report = { ‚Äòsummary‚Äô: { ‚Äòtotal_evaluations‚Äô: total_evals, ‚Äòsuccess_rate‚Äô: success_rate, ‚Äòbest_fitness_achieved‚Äô: self.metrics[‚Äòpso_metrics‚Äô][‚Äòbest_fitness‚Äô], ‚Äòtotal_optimization_time‚Äô: total_time, ‚Äòevaluations_per_second‚Äô: evaluations_per_second }, ‚Äòperformance‚Äô: { ‚Äòaverage_controller_creation_time_ms‚Äô: avg_creation_time * 1000, ‚Äòaverage_simulation_time_ms‚Äô: avg_simulation_time * 1000, ‚Äòaverage_fitness_computation_time_ms‚Äô: avg_fitness_time * 1000 }, ‚Äòresources‚Äô: { ‚Äòpeak_memory_usage_percent‚Äô: self.metrics[‚Äòresource_metrics‚Äô][‚Äòpeak_memory_usage‚Äô], ‚Äòaverage_memory_usage_percent‚Äô: avg_memory, ‚Äòaverage_cpu_utilization_percent‚Äô: avg_cpu }, ‚Äòerrors‚Äô: { ‚Äòcontroller_creation_failures‚Äô: self.metrics[‚Äòerror_metrics‚Äô][‚Äòcreation_failures‚Äô], ‚Äòsimulation_failures‚Äô: self.metrics[‚Äòerror_metrics‚Äô][‚Äòsimulation_failures‚Äô], ‚Äòvalidation_failures‚Äô: self.metrics[‚Äòerror_metrics‚Äô][‚Äòvalidation_failures‚Äô], ‚Äòtotal_error_count‚Äô: self.metrics[‚Äòerror_metrics‚Äô][‚Äòtotal_errors‚Äô] }, ‚Äòalerts‚Äô: self.check_performance_alerts(), ‚Äòraw_metrics‚Äô: self.metrics } return report def _reset_metrics(self): ‚Äú‚Äù‚ÄùReset all metrics for new monitoring session.‚Äù‚Äù‚Äù for category in self.metrics.values(): if isinstance(category, dict): for key, value in category.items(): if isinstance(value, list): category[key] = [] elif isinstance(value, (int, float)): if ‚Äòbest_fitness‚Äô in key: category[key] = float(‚Äòinf‚Äô) else: category[key] = 0 # Context manager for automatic monitoring<a class="headerlink" href="#runnable-false-class-psoperformancemonitor-real-time-performance-monitoring-for-pso-factory-integration-provides-monitoring-of-pso-convergence-metrics-controller-creation-performance-simulation-execution-times-memory-usage-tracking-error-rate-monitoring-def-init-self-monitoring-config-dict-str-any-self-config-monitoring-config-self-metrics-pso-metrics-total-evaluations-0-successful-evaluations-0-failed-evaluations-0-average-fitness-0-0-best-fitness-float-inf-convergence-rate-0-0-performance-metrics-controller-creation-time-simulation-execution-time-fitness-computation-time-total-optimization-time-0-0-resource-metrics-peak-memory-usage-0-0-average-memory-usage-0-0-cpu-utilization-memory-samples-error-metrics-creation-failures-0-simulation-failures-0-validation-failures-0-total-errors-0-self-start-time-none-self-monitoring-active-false-def-start-monitoring-self-start-performance-monitoring-session-import-time-self-start-time-time-time-self-monitoring-active-true-self-reset-metrics-def-stop-monitoring-self-dict-str-any-stop-monitoring-and-return-complete-performance-report-import-time-if-self-start-time-self-metrics-performance-metrics-total-optimization-time-time-time-self-start-time-self-monitoring-active-false-return-self-generate-performance-report-def-log-controller-creation-self-success-bool-creation-time-float-log-controller-creation-event-if-not-self-monitoring-active-return-self-metrics-performance-metrics-controller-creation-time-append-creation-time-if-success-self-metrics-pso-metrics-successful-evaluations-1-else-self-metrics-error-metrics-creation-failures-1-self-metrics-pso-metrics-failed-evaluations-1-def-log-simulation-execution-self-success-bool-execution-time-float-log-simulation-execution-event-if-not-self-monitoring-active-return-if-success-self-metrics-performance-metrics-simulation-execution-time-append-execution-time-else-self-metrics-error-metrics-simulation-failures-1-def-log-fitness-evaluation-self-fitness-value-float-computation-time-float-log-fitness-evaluation-result-if-not-self-monitoring-active-return-self-metrics-performance-metrics-fitness-computation-time-append-computation-time-self-metrics-pso-metrics-total-evaluations-1-update-best-fitness-if-fitness-value-self-metrics-pso-metrics-best-fitness-self-metrics-pso-metrics-best-fitness-fitness-value-update-average-fitness-running-average-total-evals-self-metrics-pso-metrics-total-evaluations-current-avg-self-metrics-pso-metrics-average-fitness-self-metrics-pso-metrics-average-fitness-current-avg-total-evals-1-fitness-value-total-evals-def-log-resource-usage-self-log-current-resource-usage-if-not-self-monitoring-active-return-try-import-psutil-memory-usage-memory-info-psutil-virtual-memory-current-memory-memory-info-percent-self-metrics-resource-metrics-memory-samples-append-current-memory-update-peak-memory-if-current-memory-self-metrics-resource-metrics-peak-memory-usage-self-metrics-resource-metrics-peak-memory-usage-current-memory-cpu-utilization-cpu-percent-psutil-cpu-percent-interval-none-self-metrics-resource-metrics-cpu-utilization-append-cpu-percent-except-importerror-pass-psutil-not-available-def-check-performance-alerts-self-list-str-check-for-performance-issues-and-return-alerts-alerts-memory-usage-alerts-if-self-metrics-resource-metrics-peak-memory-usage-90-alerts-append-f-high-memory-usage-self-metrics-resource-metrics-peak-memory-usage-1f-error-rate-alerts-total-evals-self-metrics-pso-metrics-total-evaluations-if-total-evals-0-error-rate-self-metrics-error-metrics-total-errors-total-evals-if-error-rate-0-1-alerts-append-f-high-error-rate-error-rate-1-performance-alerts-creation-times-self-metrics-performance-metrics-controller-creation-time-if-creation-times-and-np-mean-creation-times-0-002-2ms-threshold-alerts-append-f-slow-controller-creation-np-mean-creation-times-1000-2f-ms-average-return-alerts-def-generate-performance-report-self-dict-str-any-generate-performance-report-calculate-derived-metrics-total-evals-self-metrics-pso-metrics-total-evaluations-success-rate-self-metrics-pso-metrics-successful-evaluations-total-evals-100-if-total-evals-0-else-0-creation-times-self-metrics-performance-metrics-controller-creation-time-avg-creation-time-np-mean-creation-times-if-creation-times-else-0-simulation-times-self-metrics-performance-metrics-simulation-execution-time-avg-simulation-time-np-mean-simulation-times-if-simulation-times-else-0-fitness-times-self-metrics-performance-metrics-fitness-computation-time-avg-fitness-time-np-mean-fitness-times-if-fitness-times-else-0-memory-samples-self-metrics-resource-metrics-memory-samples-avg-memory-np-mean-memory-samples-if-memory-samples-else-0-cpu-samples-self-metrics-resource-metrics-cpu-utilization-avg-cpu-np-mean-cpu-samples-if-cpu-samples-else-0-total-time-self-metrics-performance-metrics-total-optimization-time-evaluations-per-second-total-evals-total-time-if-total-time-0-else-0-generate-report-report-summary-total-evaluations-total-evals-success-rate-success-rate-best-fitness-achieved-self-metrics-pso-metrics-best-fitness-total-optimization-time-total-time-evaluations-per-second-evaluations-per-second-performance-average-controller-creation-time-ms-avg-creation-time-1000-average-simulation-time-ms-avg-simulation-time-1000-average-fitness-computation-time-ms-avg-fitness-time-1000-resources-peak-memory-usage-percent-self-metrics-resource-metrics-peak-memory-usage-average-memory-usage-percent-avg-memory-average-cpu-utilization-percent-avg-cpu-errors-controller-creation-failures-self-metrics-error-metrics-creation-failures-simulation-failures-self-metrics-error-metrics-simulation-failures-validation-failures-self-metrics-error-metrics-validation-failures-total-error-count-self-metrics-error-metrics-total-errors-alerts-self-check-performance-alerts-raw-metrics-self-metrics-return-report-def-reset-metrics-self-reset-all-metrics-for-new-monitoring-session-for-category-in-self-metrics-values-if-isinstance-category-dict-for-key-value-in-category-items-if-isinstance-value-list-category-key-elif-isinstance-value-int-float-if-best-fitness-in-key-category-key-float-inf-else-category-key-0-context-manager-for-automatic-monitoring" title="Link to this heading">¬∂</a></h1>
<p>&#64;contextmanager
def monitor_pso_performance(config: Dict[str, Any] = None): ‚Äú‚Äù‚Äù Context manager for automatic PSO performance monitoring. Usage: with monitor_pso_performance() as monitor: # Run PSO optimization result = optimize_controller_with_pso(‚Ä¶) # Get performance report report = monitor.generate_performance_report() ‚Äú‚Äù‚Äù monitor = PSOPerformanceMonitor(config or {}) monitor.start_monitoring() try: yield monitor finally: monitor.stop_monitoring()</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
<span class="o">---</span>

<span class="c1">## Error Handling Reference ### Exception Hierarchy ```python</span>

<span class="k">class</span><span class="w"> </span><span class="nc">PSOFactoryError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot;Base exception for PSO factory integration errors.&quot;&quot;&quot;</span> <span class="k">pass</span> <span class="k">class</span><span class="w"> </span><span class="nc">ControllerCreationError</span><span class="p">(</span><span class="n">PSOFactoryError</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot;Raised when controller creation fails.&quot;&quot;&quot;</span> <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smc_type</span><span class="p">:</span> <span class="n">SMCType</span><span class="p">,</span> <span class="n">gains</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span> <span class="bp">self</span><span class="o">.</span><span class="n">smc_type</span> <span class="o">=</span> <span class="n">smc_type</span> <span class="bp">self</span><span class="o">.</span><span class="n">gains</span> <span class="o">=</span> <span class="n">gains</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to create </span><span class="si">{</span><span class="n">smc_type</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2"> controller: </span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">class</span><span class="w"> </span><span class="nc">GainValidationError</span><span class="p">(</span><span class="n">PSOFactoryError</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot;Raised when gain validation fails.&quot;&quot;&quot;</span> <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">smc_type</span><span class="p">:</span> <span class="n">SMCType</span><span class="p">,</span> <span class="n">gains</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">violations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span> <span class="bp">self</span><span class="o">.</span><span class="n">smc_type</span> <span class="o">=</span> <span class="n">smc_type</span> <span class="bp">self</span><span class="o">.</span><span class="n">gains</span> <span class="o">=</span> <span class="n">gains</span> <span class="bp">self</span><span class="o">.</span><span class="n">violations</span> <span class="o">=</span> <span class="n">violations</span> <span class="n">violation_text</span> <span class="o">=</span> <span class="s2">&quot;; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">violations</span><span class="p">)</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Gain validation failed for </span><span class="si">{</span><span class="n">smc_type</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">violation_text</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">class</span><span class="w"> </span><span class="nc">ConfigurationError</span><span class="p">(</span><span class="n">PSOFactoryError</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot;Raised when configuration is invalid.&quot;&quot;&quot;</span> <span class="k">pass</span> <span class="k">class</span><span class="w"> </span><span class="nc">SimulationError</span><span class="p">(</span><span class="n">PSOFactoryError</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot;Raised when simulation execution fails.&quot;&quot;&quot;</span> <span class="k">pass</span> <span class="c1"># Error handling decorators</span>
<span class="k">def</span><span class="w"> </span><span class="nf">handle_pso_errors</span><span class="p">(</span><span class="n">func</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot;Decorator for robust PSO error handling.&quot;&quot;&quot;</span> <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="k">try</span><span class="p">:</span> <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">except</span> <span class="n">GainValidationError</span><span class="p">:</span> <span class="c1"># For PSO fitness functions, return penalty value return 1000.0 except (ControllerCreationError, SimulationError) as e: # Log error and return penalty print(f&quot;PSO evaluation error: {e}&quot;) return 1000.0 except Exception as e: # Unexpected errors - log and return penalty print(f&quot;Unexpected PSO error: {e}&quot;) return 1000.0 return wrapper # Robust PSO fitness function template</span>
<span class="nd">@handle_pso_errors</span>
<span class="k">def</span><span class="w"> </span><span class="nf">robust_pso_fitness_function</span><span class="p">(</span><span class="n">gains</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">smc_type</span><span class="p">:</span> <span class="n">SMCType</span><span class="p">,</span> <span class="n">simulation_config</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot; Template for robust PSO fitness functions with error handling. Args: gains: Gain array from PSO smc_type: Controller type simulation_config: Simulation parameters Returns: Fitness value (lower is better) &quot;&quot;&quot;</span> <span class="c1"># Create controller with automatic validation controller = create_smc_for_pso(smc_type, gains.tolist()) # Run simulation with error handling result = run_simulation_with_error_handling(controller, simulation_config) # Compute fitness with validation fitness = compute_validated_fitness(result) return fitness def run_simulation_with_error_handling(controller, config: Dict[str, Any]) -&gt; Dict[str, Any]: &quot;&quot;&quot;Run simulation with error handling.&quot;&quot;&quot; try: # Pre-validate simulation configuration validate_simulation_config(config) # Run simulation with timeout with timeout_context(config.get(&#39;timeout&#39;, 30.0)): result = run_simulation(controller, config) # Post-validate simulation results validate_simulation_results(result) return result except TimeoutError: raise SimulationError(&quot;Simulation timeout exceeded&quot;) except ValueError as e: raise SimulationError(f&quot;Simulation parameter error: {e}&quot;) except Exception as e: raise SimulationError(f&quot;Simulation execution failed: {e}&quot;) @contextmanager</span>
<span class="k">def</span><span class="w"> </span><span class="nf">timeout_context</span><span class="p">(</span><span class="n">seconds</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span> <span class="s2">&quot;&quot;&quot;Context manager for simulation timeout.&quot;&quot;&quot;</span> <span class="kn">import</span><span class="w"> </span><span class="nn">signal</span> <span class="k">def</span><span class="w"> </span><span class="nf">timeout_handler</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span> <span class="k">raise</span> <span class="ne">TimeoutError</span><span class="p">(</span><span class="s2">&quot;Operation timed out&quot;</span><span class="p">)</span> <span class="c1"># Set timeout handler old_handler = signal.signal(signal.SIGALRM, timeout_handler) signal.alarm(int(seconds)) try: yield finally: signal.alarm(0) signal.signal(signal.SIGALRM, old_handler)</span>
</pre></div>
</div>
<hr class="docutils" />
<section id="usage-examples-complete-pso-optimization-workflow-python">
<h2>Usage Examples ### Complete PSO Optimization Workflow ```python<a class="headerlink" href="#usage-examples-complete-pso-optimization-workflow-python" title="Link to this heading">¬∂</a></h2>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id6">
<h1>example-metadata:<a class="headerlink" href="#id6" title="Link to this heading">¬∂</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-def-complete-pso-optimization-example-complete-example-demonstrating-pso-factory-integration-this-example-shows-1-configuration-setup-2-controller-creation-and-validation-3-pso-optimization-execution-4-performance-monitoring-5-results-analysis-and-validation-step-1-configuration-setup-pso-config-psofactoryconfig-controller-type-smctype-classical-max-force-100-0-dt-0-01-pso-params-n-particles-30-iters-100-c1-2-0-c2-2-0-w-0-9-enable-monitoring-true-strict-validation-true-step-2-simulation-configuration-simulation-config-duration-5-0-dt-0-01-initial-state-0-1-0-1-0-0-0-0-0-0-0-0-small-perturbation-disturbances-enable-true-amplitude-5-0-frequency-1-0-performance-objectives-ise-overshoot-control-effort-step-3-pso-optimization-with-monitoring-with-monitor-pso-performance-pso-config-pso-params-as-monitor-define-fitness-function-handle-pso-errors-def-fitness-function-particles-np-ndarray-np-ndarray-fitness-scores-for-gains-in-particles-start-time-time-perf-counter-try-create-controller-with-validation-controller-create-smc-for-pso-pso-config-controller-type-gains-tolist-pso-config-max-force-creation-time-time-perf-counter-start-time-monitor-log-controller-creation-true-creation-time-run-simulation-sim-start-time-perf-counter-result-run-simulation-controller-simulation-config-sim-time-time-perf-counter-sim-start-monitor-log-simulation-execution-true-sim-time-compute-fitness-fitness-start-time-perf-counter-fitness-compute-multi-objective-fitness-result-simulation-config-performance-objectives-fitness-time-time-perf-counter-fitness-start-monitor-log-fitness-evaluation-fitness-fitness-time-fitness-scores-append-fitness-except-exception-as-e-monitor-log-controller-creation-false-0-0-fitness-scores-append-1000-0-log-resource-usage-periodically-if-len-fitness-scores-10-0-monitor-log-resource-usage-return-np-array-fitness-scores-step-4-execute-pso-optimization-from-pyswarms-single-import-globalbestpso-bounds-pso-config-gain-bounds-bounds-array-np-array-bounds-optimizer-globalbestpso-n-particles-pso-config-pso-params-n-particles-dimensions-pso-config-n-gains-options-c1-pso-config-pso-params-c1-c2-pso-config-pso-params-c2-w-pso-config-pso-params-w-bounds-bounds-array-0-bounds-array-1-print-starting-pso-optimization-best-cost-best-gains-optimizer-optimize-fitness-function-iters-pso-config-pso-params-iters-verbose-true-step-5-results-analysis-performance-report-monitor-generate-performance-report-validate-optimized-controller-optimized-controller-create-smc-for-pso-pso-config-controller-type-best-gains-tolist-pso-config-max-force-run-validation-simulation-validation-result-run-simulation-optimized-controller-simulation-config-validation-metrics-compute-validation-metrics-validation-result-step-6-generate-report-optimization-report-optimization-results-best-gains-best-gains-tolist-best-fitness-float-best-cost-optimization-history-optimizer-cost-history-convergence-iteration-find-convergence-iteration-optimizer-cost-history-validation-results-controller-gains-optimized-controller-gains-performance-metrics-validation-metrics-stability-analysis-estimate-stability-properties-pso-config-controller-type-best-gains-tolist-performance-report-performance-report-configuration-pso-config-pso-config-dict-simulation-config-simulation-config-bounds-used-bounds-step-7-display-results-print-optimization-summary-optimization-report-return-optimization-report-def-print-optimization-summary-report-dict-str-any-print-formatted-optimization-summary-opt-results-report-optimization-results-val-results-report-validation-results-perf-report-report-performance-report-print-n-80-print-pso-optimization-results-summary-print-80-print-f-n-optimization-results-print-f-best-fitness-opt-results-best-fitness-6f-print-f-best-gains-opt-results-best-gains-print-f-convergence-iteration-opt-results-convergence-iteration-print-f-n-validation-metrics-for-metric-value-in-val-results-performance-metrics-items-print-f-metric-upper-value-4f-print-f-n-performance-summary-summary-perf-report-summary-print-f-total-evaluations-summary-total-evaluations-print-f-success-rate-summary-success-rate-1f-print-f-evaluations-sec-summary-evaluations-per-second-1f-print-f-total-time-summary-total-optimization-time-1f-s-perf-perf-report-performance-print-f-avg-creation-time-perf-average-controller-creation-time-ms-2f-ms-print-f-avg-simulation-time-perf-average-simulation-time-ms-2f-ms-resources-perf-report-resources-print-f-peak-memory-resources-peak-memory-usage-percent-1f-print-f-avg-cpu-resources-average-cpu-utilization-percent-1f-if-perf-report-alerts-print-f-n-performance-alerts-for-alert-in-perf-report-alerts-print-f-alert-print-n-80-def-find-convergence-iteration-cost-history-list-float-tolerance-float-1e-6-patience-int-10-int-find-iteration-where-pso-converged-if-len-cost-history-patience-return-len-cost-history-for-i-in-range-patience-len-cost-history-check-if-fitness-has-been-stable-for-patience-iterations-recent-costs-cost-history-i-patience-i-if-max-recent-costs-min-recent-costs-tolerance-return-i-patience-1-return-len-cost-history-no-convergence-detected-run-the-complete-example">
<h1>runnable: false def complete_pso_optimization_example(): ‚Äú‚Äù‚Äù Complete example demonstrating PSO-Factory integration. This example shows: 1. Configuration setup 2. Controller creation and validation 3. PSO optimization execution 4. Performance monitoring 5. Results analysis and validation ‚Äú‚Äù‚Äù # Step 1: Configuration setup pso_config = PSOFactoryConfig( controller_type=SMCType.CLASSICAL, max_force=100.0, dt=0.01, pso_params={ ‚Äòn_particles‚Äô: 30, ‚Äòiters‚Äô: 100, ‚Äòc1‚Äô: 2.0, ‚Äòc2‚Äô: 2.0, ‚Äòw‚Äô: 0.9 }, enable_monitoring=True, strict_validation=True ) # Step 2: Simulation configuration simulation_config = { ‚Äòduration‚Äô: 5.0, ‚Äòdt‚Äô: 0.01, ‚Äòinitial_state‚Äô: [0.1, 0.1, 0.0, 0.0, 0.0, 0.0], # Small perturbation ‚Äòdisturbances‚Äô: { ‚Äòenable‚Äô: True, ‚Äòamplitude‚Äô: 5.0, ‚Äòfrequency‚Äô: 1.0 }, ‚Äòperformance_objectives‚Äô: [‚Äòise‚Äô, ‚Äòovershoot‚Äô, ‚Äòcontrol_effort‚Äô] } # Step 3: PSO optimization with monitoring with monitor_pso_performance(pso_config.pso_params) as monitor: # Define fitness function &#64;handle_pso_errors def fitness_function(particles: np.ndarray) -&gt; np.ndarray: fitness_scores = [] for gains in particles: start_time = time.perf_counter() try: # Create controller with validation controller = create_smc_for_pso( pso_config.controller_type, gains.tolist(), pso_config.max_force ) creation_time = time.perf_counter() - start_time monitor.log_controller_creation(True, creation_time) # Run simulation sim_start = time.perf_counter() result = run_simulation(controller, simulation_config) sim_time = time.perf_counter() - sim_start monitor.log_simulation_execution(True, sim_time) # Compute fitness fitness_start = time.perf_counter() fitness = compute_multi_objective_fitness( result, simulation_config[‚Äòperformance_objectives‚Äô] ) fitness_time = time.perf_counter() - fitness_start monitor.log_fitness_evaluation(fitness, fitness_time) fitness_scores.append(fitness) except Exception as e: monitor.log_controller_creation(False, 0.0) fitness_scores.append(1000.0) # Log resource usage periodically if len(fitness_scores) % 10 == 0: monitor.log_resource_usage() return np.array(fitness_scores) # Step 4: Execute PSO optimization from pyswarms.single import GlobalBestPSO bounds = pso_config.gain_bounds bounds_array = np.array(bounds) optimizer = GlobalBestPSO( n_particles=pso_config.pso_params[‚Äòn_particles‚Äô], dimensions=pso_config.n_gains, options={ ‚Äòc1‚Äô: pso_config.pso_params[‚Äòc1‚Äô], ‚Äòc2‚Äô: pso_config.pso_params[‚Äòc2‚Äô], ‚Äòw‚Äô: pso_config.pso_params[‚Äòw‚Äô] }, bounds=(bounds_array[:, 0], bounds_array[:, 1]) ) print(‚ÄúStarting PSO optimization‚Ä¶‚Äù) best_cost, best_gains = optimizer.optimize( fitness_function, iters=pso_config.pso_params[‚Äòiters‚Äô], verbose=True ) # Step 5: Results analysis performance_report = monitor.generate_performance_report() # Validate optimized controller optimized_controller = create_smc_for_pso( pso_config.controller_type, best_gains.tolist(), pso_config.max_force ) # Run validation simulation validation_result = run_simulation(optimized_controller, simulation_config) validation_metrics = compute_validation_metrics(validation_result) # Step 6: Generate report optimization_report = { ‚Äòoptimization_results‚Äô: { ‚Äòbest_gains‚Äô: best_gains.tolist(), ‚Äòbest_fitness‚Äô: float(best_cost), ‚Äòoptimization_history‚Äô: optimizer.cost_history, ‚Äòconvergence_iteration‚Äô: find_convergence_iteration(optimizer.cost_history) }, ‚Äòvalidation_results‚Äô: { ‚Äòcontroller_gains‚Äô: optimized_controller.gains, ‚Äòperformance_metrics‚Äô: validation_metrics, ‚Äòstability_analysis‚Äô: estimate_stability_properties( pso_config.controller_type, best_gains.tolist() ) }, ‚Äòperformance_report‚Äô: performance_report, ‚Äòconfiguration‚Äô: { ‚Äòpso_config‚Äô: pso_config.<strong>dict</strong>, ‚Äòsimulation_config‚Äô: simulation_config, ‚Äòbounds_used‚Äô: bounds } } # Step 7: Display results print_optimization_summary(optimization_report) return optimization_report def print_optimization_summary(report: Dict[str, Any]): ‚Äú‚Äù‚ÄùPrint formatted optimization summary.‚Äù‚Äù‚Äù opt_results = report[‚Äòoptimization_results‚Äô] val_results = report[‚Äòvalidation_results‚Äô] perf_report = report[‚Äòperformance_report‚Äô] print(‚Äú\n‚Äù + ‚Äú=‚Äù*80) print(‚ÄúPSO OPTIMIZATION RESULTS SUMMARY‚Äù) print(‚Äú=‚Äù*80) print(f‚Äù\nüìä OPTIMIZATION RESULTS:‚Äù) print(f‚Äù Best Fitness: {opt_results[‚Äòbest_fitness‚Äô]:.6f}‚Äù) print(f‚Äù Best Gains: {opt_results[‚Äòbest_gains‚Äô]}‚Äù) print(f‚Äù Convergence: Iteration {opt_results[‚Äòconvergence_iteration‚Äô]}‚Äù) print(f‚Äù\nüéØ VALIDATION METRICS:‚Äù) for metric, value in val_results[‚Äòperformance_metrics‚Äô].items(): print(f‚Äù {metric.upper()}: {value:.4f}‚Äù) print(f‚Äù\n‚ö° PERFORMANCE SUMMARY:‚Äù) summary = perf_report[‚Äòsummary‚Äô] print(f‚Äù Total Evaluations: {summary[‚Äòtotal_evaluations‚Äô]}‚Äù) print(f‚Äù Success Rate: {summary[‚Äòsuccess_rate‚Äô]:.1f}%‚Äù) print(f‚Äù Evaluations/sec: {summary[‚Äòevaluations_per_second‚Äô]:.1f}‚Äù) print(f‚Äù Total Time: {summary[‚Äòtotal_optimization_time‚Äô]:.1f}s‚Äù) perf = perf_report[‚Äòperformance‚Äô] print(f‚Äù Avg Creation Time: {perf[‚Äòaverage_controller_creation_time_ms‚Äô]:.2f}ms‚Äù) print(f‚Äù Avg Simulation Time: {perf[‚Äòaverage_simulation_time_ms‚Äô]:.2f}ms‚Äù) resources = perf_report[‚Äòresources‚Äô] print(f‚Äù Peak Memory: {resources[‚Äòpeak_memory_usage_percent‚Äô]:.1f}%‚Äù) print(f‚Äù Avg CPU: {resources[‚Äòaverage_cpu_utilization_percent‚Äô]:.1f}%‚Äù) if perf_report[‚Äòalerts‚Äô]: print(f‚Äù\n‚ö†Ô∏è PERFORMANCE ALERTS:‚Äù) for alert in perf_report[‚Äòalerts‚Äô]: print(f‚Äù - {alert}‚Äù) print(‚Äú\n‚Äù + ‚Äú=‚Äù*80) def find_convergence_iteration(cost_history: List[float], tolerance: float = 1e-6, patience: int = 10 ) -&gt; int: ‚Äú‚Äù‚ÄùFind iteration where PSO converged.‚Äù‚Äù‚Äù if len(cost_history) &lt; patience: return len(cost_history) for i in range(patience, len(cost_history)): # Check if fitness has been stable for ‚Äòpatience‚Äô iterations recent_costs = cost_history[i-patience:i] if max(recent_costs) - min(recent_costs) &lt; tolerance: return i - patience + 1 return len(cost_history) # No convergence detected # Run the complete example<a class="headerlink" href="#runnable-false-def-complete-pso-optimization-example-complete-example-demonstrating-pso-factory-integration-this-example-shows-1-configuration-setup-2-controller-creation-and-validation-3-pso-optimization-execution-4-performance-monitoring-5-results-analysis-and-validation-step-1-configuration-setup-pso-config-psofactoryconfig-controller-type-smctype-classical-max-force-100-0-dt-0-01-pso-params-n-particles-30-iters-100-c1-2-0-c2-2-0-w-0-9-enable-monitoring-true-strict-validation-true-step-2-simulation-configuration-simulation-config-duration-5-0-dt-0-01-initial-state-0-1-0-1-0-0-0-0-0-0-0-0-small-perturbation-disturbances-enable-true-amplitude-5-0-frequency-1-0-performance-objectives-ise-overshoot-control-effort-step-3-pso-optimization-with-monitoring-with-monitor-pso-performance-pso-config-pso-params-as-monitor-define-fitness-function-handle-pso-errors-def-fitness-function-particles-np-ndarray-np-ndarray-fitness-scores-for-gains-in-particles-start-time-time-perf-counter-try-create-controller-with-validation-controller-create-smc-for-pso-pso-config-controller-type-gains-tolist-pso-config-max-force-creation-time-time-perf-counter-start-time-monitor-log-controller-creation-true-creation-time-run-simulation-sim-start-time-perf-counter-result-run-simulation-controller-simulation-config-sim-time-time-perf-counter-sim-start-monitor-log-simulation-execution-true-sim-time-compute-fitness-fitness-start-time-perf-counter-fitness-compute-multi-objective-fitness-result-simulation-config-performance-objectives-fitness-time-time-perf-counter-fitness-start-monitor-log-fitness-evaluation-fitness-fitness-time-fitness-scores-append-fitness-except-exception-as-e-monitor-log-controller-creation-false-0-0-fitness-scores-append-1000-0-log-resource-usage-periodically-if-len-fitness-scores-10-0-monitor-log-resource-usage-return-np-array-fitness-scores-step-4-execute-pso-optimization-from-pyswarms-single-import-globalbestpso-bounds-pso-config-gain-bounds-bounds-array-np-array-bounds-optimizer-globalbestpso-n-particles-pso-config-pso-params-n-particles-dimensions-pso-config-n-gains-options-c1-pso-config-pso-params-c1-c2-pso-config-pso-params-c2-w-pso-config-pso-params-w-bounds-bounds-array-0-bounds-array-1-print-starting-pso-optimization-best-cost-best-gains-optimizer-optimize-fitness-function-iters-pso-config-pso-params-iters-verbose-true-step-5-results-analysis-performance-report-monitor-generate-performance-report-validate-optimized-controller-optimized-controller-create-smc-for-pso-pso-config-controller-type-best-gains-tolist-pso-config-max-force-run-validation-simulation-validation-result-run-simulation-optimized-controller-simulation-config-validation-metrics-compute-validation-metrics-validation-result-step-6-generate-report-optimization-report-optimization-results-best-gains-best-gains-tolist-best-fitness-float-best-cost-optimization-history-optimizer-cost-history-convergence-iteration-find-convergence-iteration-optimizer-cost-history-validation-results-controller-gains-optimized-controller-gains-performance-metrics-validation-metrics-stability-analysis-estimate-stability-properties-pso-config-controller-type-best-gains-tolist-performance-report-performance-report-configuration-pso-config-pso-config-dict-simulation-config-simulation-config-bounds-used-bounds-step-7-display-results-print-optimization-summary-optimization-report-return-optimization-report-def-print-optimization-summary-report-dict-str-any-print-formatted-optimization-summary-opt-results-report-optimization-results-val-results-report-validation-results-perf-report-report-performance-report-print-n-80-print-pso-optimization-results-summary-print-80-print-f-n-optimization-results-print-f-best-fitness-opt-results-best-fitness-6f-print-f-best-gains-opt-results-best-gains-print-f-convergence-iteration-opt-results-convergence-iteration-print-f-n-validation-metrics-for-metric-value-in-val-results-performance-metrics-items-print-f-metric-upper-value-4f-print-f-n-performance-summary-summary-perf-report-summary-print-f-total-evaluations-summary-total-evaluations-print-f-success-rate-summary-success-rate-1f-print-f-evaluations-sec-summary-evaluations-per-second-1f-print-f-total-time-summary-total-optimization-time-1f-s-perf-perf-report-performance-print-f-avg-creation-time-perf-average-controller-creation-time-ms-2f-ms-print-f-avg-simulation-time-perf-average-simulation-time-ms-2f-ms-resources-perf-report-resources-print-f-peak-memory-resources-peak-memory-usage-percent-1f-print-f-avg-cpu-resources-average-cpu-utilization-percent-1f-if-perf-report-alerts-print-f-n-performance-alerts-for-alert-in-perf-report-alerts-print-f-alert-print-n-80-def-find-convergence-iteration-cost-history-list-float-tolerance-float-1e-6-patience-int-10-int-find-iteration-where-pso-converged-if-len-cost-history-patience-return-len-cost-history-for-i-in-range-patience-len-cost-history-check-if-fitness-has-been-stable-for-patience-iterations-recent-costs-cost-history-i-patience-i-if-max-recent-costs-min-recent-costs-tolerance-return-i-patience-1-return-len-cost-history-no-convergence-detected-run-the-complete-example" title="Link to this heading">¬∂</a></h1>
<p>if <strong>name</strong> == ‚Äú<strong>main</strong>‚Äù: optimization_report = complete_pso_optimization_example()
<code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">Multi-Controller</span> <span class="pre">Comparison</span> <span class="pre">Example</span></code>python</p>
<p>def multi_controller_comparison_example(): ‚Äú‚Äù‚Äù Example demonstrating comparison of all SMC controller types. Optimizes all 4 controller types and compares their performance across multiple objectives and scenarios. ‚Äú‚Äù‚Äù # Define test scenarios test_scenarios = [ { ‚Äòname‚Äô: ‚Äòsmall_disturbance‚Äô, ‚Äòinitial_state‚Äô: [0.05, 0.05, 0.0, 0.0, 0.0, 0.0], ‚Äòdisturbance_amplitude‚Äô: 2.0 }, { ‚Äòname‚Äô: ‚Äòlarge_disturbance‚Äô, ‚Äòinitial_state‚Äô: [0.2, 0.15, 0.0, 0.0, 0.0, 0.0], ‚Äòdisturbance_amplitude‚Äô: 10.0 }, { ‚Äòname‚Äô: ‚Äòparameter_uncertainty‚Äô, ‚Äòinitial_state‚Äô: [0.1, 0.1, 0.0, 0.0, 0.0, 0.0], ‚Äòparameter_variations‚Äô: {‚Äòmass_uncertainty‚Äô: 0.2} } ] # Define optimization objectives objectives = { ‚Äòcontrol_performance‚Äô: {‚Äòise‚Äô: 0.4, ‚Äòovershoot‚Äô: 0.3, ‚Äòsettling_time‚Äô: 0.3}, ‚Äòenergy_efficiency‚Äô: {‚Äòise‚Äô: 0.3, ‚Äòcontrol_effort‚Äô: 0.5, ‚Äòchattering‚Äô: 0.2}, ‚Äòrobustness‚Äô: {‚Äòise‚Äô: 0.2, ‚Äòdisturbance_rejection‚Äô: 0.4, ‚Äòparameter_sensitivity‚Äô: 0.4} } # PSO configuration for all controllers base_pso_config = { ‚Äòn_particles‚Äô: 25, ‚Äòiters‚Äô: 75, ‚Äòc1‚Äô: 2.0, ‚Äòc2‚Äô: 2.0, ‚Äòw‚Äô: 0.9 } all_results = {} # Optimize each controller type for smc_type in SMCType: print(f‚Äù\n{‚Äò=‚Äô*60}‚Äù) print(f‚ÄùOPTIMIZING {smc_type.value.upper()}‚Äù) print(f‚Äù{‚Äò=‚Äô*60}‚Äù) controller_results = {} # Test each scenario for scenario in test_scenarios: print(f‚Äù\nScenario: {scenario[‚Äòname‚Äô]}‚Äù) scenario_results = {} # Test each objective set for obj_name, obj_weights in objectives.items(): print(f‚Äù Objective: {obj_name}‚Äù) # Create simulation config for this scenario sim_config = { ‚Äòduration‚Äô: 5.0, ‚Äòdt‚Äô: 0.01, ‚Äòinitial_state‚Äô: scenario[‚Äòinitial_state‚Äô], ‚Äòdisturbance_amplitude‚Äô: scenario.get(‚Äòdisturbance_amplitude‚Äô, 0.0), ‚Äòparameter_variations‚Äô: scenario.get(‚Äòparameter_variations‚Äô, {}), ‚Äòobjectives‚Äô: obj_weights } # Run PSO optimization result = optimize_single_controller( smc_type, sim_config, base_pso_config ) scenario_results[obj_name] = result controller_results[scenario[‚Äòname‚Äô]] = scenario_results all_results[smc_type.value] = controller_results # Generate comparison analysis comparison_analysis = analyze_controller_comparison(all_results, test_scenarios, objectives) # Display results display_comparison_results(comparison_analysis) return comparison_analysis def optimize_single_controller(smc_type: SMCType, sim_config: Dict[str, Any], pso_config: Dict[str, Any] ) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùOptimize single controller for given scenario.‚Äù‚Äù‚Äù # Get PSO bounds bounds = get_gain_bounds_for_pso(smc_type) bounds_array = np.array(bounds) # Create fitness function def fitness_function(particles: np.ndarray) -&gt; np.ndarray: fitness_scores = [] for gains in particles: try: controller = create_smc_for_pso(smc_type, gains.tolist()) result = run_simulation(controller, sim_config) fitness = compute_multi_objective_fitness(result, sim_config[‚Äòobjectives‚Äô]) fitness_scores.append(fitness) except: fitness_scores.append(1000.0) return np.array(fitness_scores) # Run PSO from pyswarms.single import GlobalBestPSO optimizer = GlobalBestPSO( n_particles=pso_config[‚Äòn_particles‚Äô], dimensions=len(bounds), options={ ‚Äòc1‚Äô: pso_config[‚Äòc1‚Äô], ‚Äòc2‚Äô: pso_config[‚Äòc2‚Äô], ‚Äòw‚Äô: pso_config[‚Äòw‚Äô] }, bounds=(bounds_array[:, 0], bounds_array[:, 1]) ) best_cost, best_gains = optimizer.optimize( fitness_function, iters=pso_config[‚Äòiters‚Äô], verbose=False ) # Validate result final_controller = create_smc_for_pso(smc_type, best_gains.tolist()) validation_result = run_simulation(final_controller, sim_config) return { ‚Äòbest_gains‚Äô: best_gains.tolist(), ‚Äòbest_fitness‚Äô: float(best_cost), ‚Äòvalidation_metrics‚Äô: compute_validation_metrics(validation_result), ‚Äòoptimization_history‚Äô: optimizer.cost_history } def analyze_controller_comparison(results: Dict[str, Any], scenarios: List[Dict[str, Any]], objectives: Dict[str, Any] ) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùAnalyze comparison results across controllers.‚Äù‚Äù‚Äù analysis = { ‚Äòoverall_ranking‚Äô: {}, ‚Äòscenario_performance‚Äô: {}, ‚Äòobjective_performance‚Äô: {}, ‚Äòrobustness_analysis‚Äô: {}, ‚Äòrecommendations‚Äô: {} } # Rank controllers by overall performance controller_scores = {} for controller_type in results.keys(): total_score = 0 count = 0 for scenario_name in results[controller_type].keys(): for obj_name in results[controller_type][scenario_name].keys(): fitness = results[controller_type][scenario_name][obj_name][‚Äòbest_fitness‚Äô] total_score += fitness count += 1 controller_scores[controller_type] = total_score / count if count &gt; 0 else float(‚Äòinf‚Äô) # Sort by performance (lower is better) analysis[‚Äòoverall_ranking‚Äô] = dict(sorted( controller_scores.items(), key=lambda x: x[1] )) # Analyze performance by scenario for scenario in scenarios: scenario_name = scenario[‚Äòname‚Äô] scenario_scores = {} for controller_type in results.keys(): if scenario_name in results[controller_type]: avg_fitness = np.mean([ results[controller_type][scenario_name][obj][‚Äòbest_fitness‚Äô] for obj in results[controller_type][scenario_name].keys() ]) scenario_scores[controller_type] = avg_fitness analysis[‚Äòscenario_performance‚Äô][scenario_name] = dict(sorted( scenario_scores.items(), key=lambda x: x[1] )) # Analyze performance by objective for obj_name in objectives.keys(): objective_scores = {} for controller_type in results.keys(): obj_scores = [] for scenario_name in results[controller_type].keys(): if obj_name in results[controller_type][scenario_name]: obj_scores.append( results[controller_type][scenario_name][obj_name][‚Äòbest_fitness‚Äô] ) if obj_scores: objective_scores[controller_type] = np.mean(obj_scores) analysis[‚Äòobjective_performance‚Äô][obj_name] = dict(sorted( objective_scores.items(), key=lambda x: x[1] )) # Generate recommendations analysis[‚Äòrecommendations‚Äô] = generate_controller_recommendations(analysis) return analysis def generate_controller_recommendations(analysis: Dict[str, Any]) -&gt; Dict[str, str]: ‚Äú‚Äù‚ÄùGenerate recommendations based on comparison analysis.‚Äù‚Äù‚Äù recommendations = {} # Overall best controller best_overall = list(analysis[‚Äòoverall_ranking‚Äô].keys())[0] recommendations[‚Äòbest_overall‚Äô] = ( f‚Äù{best_overall} shows the best overall performance across ‚Äú f‚Äùall scenarios and objectives.‚Äù ) # Scenario-specific recommendations for scenario, ranking in analysis[‚Äòscenario_performance‚Äô].items(): best_for_scenario = list(ranking.keys())[0] recommendations[f‚Äôbest_for_{scenario}‚Äô] = ( f‚Äù{best_for_scenario} performs best for {scenario} scenarios.‚Äù ) # Objective-specific recommendations for objective, ranking in analysis[‚Äòobjective_performance‚Äô].items(): best_for_objective = list(ranking.keys())[0] recommendations[f‚Äôbest_for_{objective}‚Äô] = ( f‚Äù{best_for_objective} excels at {objective} objectives.‚Äù ) return recommendations def display_comparison_results(analysis: Dict[str, Any]): ‚Äú‚Äù‚ÄùDisplay formatted comparison results.‚Äù‚Äù‚Äù print(‚Äú\n‚Äù + ‚Äú=‚Äù*80) print(‚ÄúMULTI-CONTROLLER COMPARISON RESULTS‚Äù) print(‚Äú=‚Äù*80) print(‚Äú\nüèÜ OVERALL RANKING:‚Äù) for i, (controller, score) in enumerate(analysis[‚Äòoverall_ranking‚Äô].items(), 1): print(f‚Äù {i}. {controller.upper()}: {score:.4f}‚Äù) print(‚Äú\nüìä SCENARIO PERFORMANCE:‚Äù) for scenario, ranking in analysis[‚Äòscenario_performance‚Äô].items(): print(f‚Äù\n {scenario.upper()}:‚Äù) for i, (controller, score) in enumerate(ranking.items(), 1): print(f‚Äù {i}. {controller}: {score:.4f}‚Äù) print(‚Äú\nüéØ OBJECTIVE PERFORMANCE:‚Äù) for objective, ranking in analysis[‚Äòobjective_performance‚Äô].items(): print(f‚Äù\n {objective.upper()}:‚Äù) for i, (controller, score) in enumerate(ranking.items(), 1): print(f‚Äù {i}. {controller}: {score:.4f}‚Äù) print(‚Äú\nüí° RECOMMENDATIONS:‚Äù) for key, recommendation in analysis[‚Äòrecommendations‚Äô].items(): print(f‚Äù ‚Ä¢ {recommendation}‚Äù) print(‚Äú\n‚Äù + ‚Äú=‚Äù*80) # Run the comparison example
if <strong>name</strong> == ‚Äú<strong>main</strong>‚Äù: comparison_results = multi_controller_comparison_example()</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
<span class="o">---</span>

<span class="n">This</span> <span class="n">PSO</span> <span class="n">Factory</span> <span class="n">Integration</span> <span class="n">API</span> <span class="n">Reference</span> <span class="n">provides</span> <span class="n">complete</span> <span class="n">documentation</span> <span class="k">for</span> <span class="nb">all</span> <span class="n">aspects</span> <span class="n">of</span> <span class="n">the</span> <span class="n">factory</span> <span class="n">pattern</span> <span class="n">implementation</span> <span class="ow">and</span> <span class="n">PSO</span> <span class="n">optimization</span> <span class="n">framework</span><span class="o">.</span> <span class="n">The</span> <span class="n">API</span> <span class="ow">is</span> <span class="n">designed</span> <span class="n">to</span> <span class="n">support</span> <span class="n">both</span> <span class="n">simple</span> <span class="n">single</span><span class="o">-</span><span class="n">controller</span> <span class="n">optimization</span> <span class="ow">and</span> <span class="nb">complex</span> <span class="n">multi</span><span class="o">-</span><span class="n">objective</span><span class="p">,</span> <span class="n">multi</span><span class="o">-</span><span class="n">controller</span> <span class="n">research</span> <span class="n">workflows</span> <span class="k">while</span> <span class="n">maintaining</span> <span class="n">mathematical</span> <span class="n">rigor</span> <span class="ow">and</span> <span class="n">production</span><span class="o">-</span><span class="n">quality</span> <span class="n">performance</span><span class="o">.</span>

<span class="o">---</span>

<span class="o">**</span><span class="n">Document</span> <span class="n">Status</span><span class="o">**</span><span class="p">:</span> <span class="n">Complete</span> <span class="n">API</span> <span class="n">Reference</span> <span class="n">Documentation</span>
<span class="o">**</span><span class="n">Last</span> <span class="n">Updated</span><span class="o">**</span><span class="p">:</span> <span class="n">September</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">2024</span>
<span class="o">**</span><span class="n">API</span> <span class="n">Version</span><span class="o">**</span><span class="p">:</span> <span class="n">GitHub</span> <span class="n">Issue</span> <span class="c1">#6 Production Release</span>
<span class="o">**</span><span class="n">Coverage</span><span class="o">**</span><span class="p">:</span> <span class="mi">100</span><span class="o">%</span> <span class="n">Factory</span> <span class="n">Integration</span> <span class="o">+</span> <span class="n">PSO</span> <span class="n">Framework</span>
<span class="o">**</span><span class="n">Validation</span> <span class="n">Level</span><span class="o">**</span><span class="p">:</span> <span class="n">Production</span> <span class="n">Ready</span>
</pre></div>
</div>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Research Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on Oct 10, 2025</div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=4ebf8126"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=46bd48cc"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=08e7b316"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../_static/back-to-top.js?v=840797bb"></script>
    <script src="../_static/lazy-load.js?v=dc25293c"></script>
    <script src="../_static/dark-mode.js?v=bf328970"></script>
    </body>
</html>