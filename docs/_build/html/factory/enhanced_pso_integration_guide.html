<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
.chartjs-container {
    margin: 1.5em auto;
    padding: 1em;
    background: #f8f9fa;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.chart-note {
    text-align: center;
    color: #6c757d;
    font-size: 0.9em;
    margin-top: 0.5em;
}
</style>
<link rel="index" title="Index" href="../genindex.html"><link rel="search" title="Search" href="../search.html">

    <!-- Generated with Sphinx 8.2.3 and Furo 2025.09.25 -->
        <title>Complete Workflow Specifications for Controller Optimization ### Overview This guide documents the complete integration between the Enhanced Controller Factory and Particle Swarm Optimization (PSO) workflows for automated controller parameter tuning. The integration provides validated, thread-safe, mathematically rigorous optimization features for all SMC controller variants. ## PSO Integration Architecture ### System Overview ``` â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ PSO Engine â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ Population â”‚ â”‚ Velocity Update â”‚ â”‚ â”‚ â”‚ Management â”‚ â”‚ &amp; Position â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ Candidate Gains â–¼ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Factory-PSO Bridge â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ Gain â”‚ â”‚ Controller â”‚ â”‚ â”‚ â”‚ Validation â”‚ â”‚ Instantiation â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ Controller Instance â–¼ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Simulation &amp; Evaluation â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ DIP Plant â”‚ â”‚ Performance â”‚ â”‚ â”‚ â”‚ Simulation â”‚ â”‚ Metrics â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ Fitness Score â–¼ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ PSO Update â”‚ â”‚ (Fitness-Guided Search) â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ - DIP_SMC_PSO Documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5349f25f" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=580074bf" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=8dab3a3b" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=8a7e329d" />
    
    


<style>
  body {
    --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">DIP_SMC_PSO Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  <span class="sidebar-brand-text">DIP_SMC_PSO Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">ğŸ“š Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Optimal Sliding Mode Control for a Double-Inverted Pendulum via PSO  ## How to validate a ResearchPlan JSON Run the validator locally: ```bash</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory_overview.html">Theory Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../architecture.html">3. System Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plant_model.html">1.x Plant Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hil_quickstart.html">Hardware-in-the-Loop (HIL) Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../streamlit_dashboard_guide.html">Streamlit Dashboard User Guide</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/blob/main/docs/factory/enhanced_pso_integration_guide.md?plain=true" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div><div class="edit-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/edit/main/docs/factory/enhanced_pso_integration_guide.md" rel="edit" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <p>#==========================================================================================\<br />
#============= docs/factory/enhanced_pso_integration_guide.md =================\<br />
#==========================================================================================\ # Enhanced PSO Integration Guide</p>
<section id="complete-workflow-specifications-for-controller-optimization-overview-this-guide-documents-the-complete-integration-between-the-enhanced-controller-factory-and-particle-swarm-optimization-pso-workflows-for-automated-controller-parameter-tuning-the-integration-provides-validated-thread-safe-mathematically-rigorous-optimization-features-for-all-smc-controller-variants-pso-integration-architecture-system-overview-pso-engine-population-velocity-update-management-position-candidate-gains-factory-pso-bridge-gain-controller-validation-instantiation-controller-instance-simulation-evaluation-dip-plant-performance-simulation-metrics-fitness-score-pso-update-fitness-guided-search">
<h1>Complete Workflow Specifications for Controller Optimization ### Overview This guide documents the complete integration between the Enhanced Controller Factory and Particle Swarm Optimization (PSO) workflows for automated controller parameter tuning. The integration provides validated, thread-safe, mathematically rigorous optimization features for all SMC controller variants. ## PSO Integration Architecture ### System Overview ``` â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ PSO Engine â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ Population â”‚ â”‚ Velocity Update â”‚ â”‚ â”‚ â”‚ Management â”‚ â”‚ &amp; Position â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ Candidate Gains â–¼ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Factory-PSO Bridge â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ Gain â”‚ â”‚ Controller â”‚ â”‚ â”‚ â”‚ Validation â”‚ â”‚ Instantiation â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ Controller Instance â–¼ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Simulation &amp; Evaluation â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ DIP Plant â”‚ â”‚ Performance â”‚ â”‚ â”‚ â”‚ Simulation â”‚ â”‚ Metrics â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ Fitness Score â–¼ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ PSO Update â”‚ â”‚ (Fitness-Guided Search) â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜<a class="headerlink" href="#complete-workflow-specifications-for-controller-optimization-overview-this-guide-documents-the-complete-integration-between-the-enhanced-controller-factory-and-particle-swarm-optimization-pso-workflows-for-automated-controller-parameter-tuning-the-integration-provides-validated-thread-safe-mathematically-rigorous-optimization-features-for-all-smc-controller-variants-pso-integration-architecture-system-overview-pso-engine-population-velocity-update-management-position-candidate-gains-factory-pso-bridge-gain-controller-validation-instantiation-controller-instance-simulation-evaluation-dip-plant-performance-simulation-metrics-fitness-score-pso-update-fitness-guided-search" title="Link to this heading">Â¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">Core</span> <span class="pre">Integration</span> <span class="pre">Components</span> <span class="pre">####</span> <span class="pre">1.</span> <span class="pre">PSOFactoryInterface</span> <span class="pre">**Specialized</span> <span class="pre">interface</span> <span class="pre">providing</span> <span class="pre">PSO-optimized</span> <span class="pre">controller</span> <span class="pre">creation:**</span></code>python</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="example-metadata">
<h1>example-metadata:<a class="headerlink" href="#example-metadata" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-class-psofactoryinterface-high-performance-interface-for-pso-optimization-workflows-features-thread-safe-parallel-optimization-automatic-gain-validation-and-bounds-checking-performance-monitoring-and-diagnostics-fallback-mechanisms-for-invalid-parameter-sets-def-init-self-controller-type-str-simulation-config-any-self-controller-type-controller-type-self-config-simulation-config-self-initialize-pso-environment-def-initialize-pso-environment-self-none-setup-pso-optimization-environment-with-all-requirements-controller-specifications-self-registry-info-controller-registry-self-controller-type-self-n-gains-self-registry-info-gain-count-self-default-gains-self-registry-info-default-gains-pso-bounds-mathematically-derived-self-bounds-lower-self-bounds-upper-get-gain-bounds-for-pso-smctype-self-controller-type-performance-tracking-self-metrics-total-evaluations-0-successful-evaluations-0-validation-failures-0-simulation-failures-0-best-fitness-float-inf-average-fitness-0-0-thread-safety-self-evaluation-lock-threading-rlock">
<h1>runnable: false class PSOFactoryInterface: â€œâ€â€ High-performance interface for PSO optimization workflows. Features: - Thread-safe parallel optimization - Automatic gain validation and bounds checking - Performance monitoring and diagnostics - Fallback mechanisms for invalid parameter sets â€œâ€â€ def <strong>init</strong>(self, controller_type: str, simulation_config: Any): self.controller_type = controller_type self.config = simulation_config self._initialize_pso_environment() def _initialize_pso_environment(self) -&gt; None: â€œâ€â€Setup PSO optimization environment with all requirements.â€â€â€ # Controller specifications self.registry_info = CONTROLLER_REGISTRY[self.controller_type] self.n_gains = self.registry_info[â€˜gain_countâ€™] self.default_gains = self.registry_info[â€˜default_gainsâ€™] # PSO bounds (mathematically derived) self.bounds_lower, self.bounds_upper = get_gain_bounds_for_pso( SMCType(self.controller_type) ) # Performance tracking self.metrics = { â€˜total_evaluationsâ€™: 0, â€˜successful_evaluationsâ€™: 0, â€˜validation_failuresâ€™: 0, â€˜simulation_failuresâ€™: 0, â€˜best_fitnessâ€™: float(â€˜infâ€™), â€˜average_fitnessâ€™: 0.0 } # Thread safety self._evaluation_lock = threading.RLock()<a class="headerlink" href="#runnable-false-class-psofactoryinterface-high-performance-interface-for-pso-optimization-workflows-features-thread-safe-parallel-optimization-automatic-gain-validation-and-bounds-checking-performance-monitoring-and-diagnostics-fallback-mechanisms-for-invalid-parameter-sets-def-init-self-controller-type-str-simulation-config-any-self-controller-type-controller-type-self-config-simulation-config-self-initialize-pso-environment-def-initialize-pso-environment-self-none-setup-pso-optimization-environment-with-all-requirements-controller-specifications-self-registry-info-controller-registry-self-controller-type-self-n-gains-self-registry-info-gain-count-self-default-gains-self-registry-info-default-gains-pso-bounds-mathematically-derived-self-bounds-lower-self-bounds-upper-get-gain-bounds-for-pso-smctype-self-controller-type-performance-tracking-self-metrics-total-evaluations-0-successful-evaluations-0-validation-failures-0-simulation-failures-0-best-fitness-float-inf-average-fitness-0-0-thread-safety-self-evaluation-lock-threading-rlock" title="Link to this heading">Â¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">####</span> <span class="pre">2.</span> <span class="pre">PSO</span> <span class="pre">Controller</span> <span class="pre">Wrapper</span> <span class="pre">**Optimized</span> <span class="pre">wrapper</span> <span class="pre">providing</span> <span class="pre">PSO-compatible</span> <span class="pre">interface:**</span></code>python</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1>example-metadata:<a class="headerlink" href="#id1" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-class-psocontrollerwrapper-pso-optimized-controller-wrapper-with-validation-provides-simplified-control-interface-for-fitness-evaluation-automatic-gain-validation-with-controller-specific-rules-performance-monitoring-and-error-handling-thread-safe-operation-for-parallel-pso-def-init-self-controller-any-controller-type-str-validation-config-dict-str-any-self-controller-controller-self-controller-type-controller-type-self-validation-config-validation-config-pso-required-attributes-self-n-gains-controller-registry-controller-type-gain-count-self-max-force-getattr-controller-max-force-150-0-performance-tracking-self-control-calls-0-self-control-failures-0-self-last-control-time-0-0-def-validate-gains-self-particles-np-ndarray-np-ndarray-vectorized-gain-validation-for-pso-particle-swarms-args-particles-array-of-shape-n-particles-n-gains-returns-boolean-mask-indicating-valid-particles-if-particles-ndim-1-particles-particles-reshape-1-1-valid-mask-np-ones-particles-shape-0-dtype-bool-basic-validation-for-i-gains-in-enumerate-particles-try-check-gain-count-if-len-gains-self-n-gains-valid-mask-i-false-continue-check-for-finite-positive-values-if-not-all-np-isfinite-g-and-g-0-for-g-in-gains-valid-mask-i-false-continue-controller-specific-validation-if-not-self-validate-controller-specific-constraints-gains-valid-mask-i-false-continue-except-exception-valid-mask-i-false-return-valid-mask-def-validate-controller-specific-constraints-self-gains-list-float-bool-apply-mathematical-constraints-for-each-controller-type-if-self-controller-type-classical-smc-classical-smc-all-gains-positive-reasonable-ranges-k1-k2-lam1-lam2-k-kd-gains-return-all-g-0-for-g-in-gains-5-and-kd-0-elif-self-controller-type-sta-smc-super-twisting-critical-stability-condition-k1-k2-k1-k2-gains-0-gains-1-return-k1-k2-0-and-all-g-0-for-g-in-gains-2-elif-self-controller-type-adaptive-smc-adaptive-smc-adaptation-rate-bounds-k1-k2-lam1-lam2-gamma-gains-return-all-g-0-for-g-in-gains-4-and-0-1-gamma-20-0-elif-self-controller-type-hybrid-adaptive-sta-smc-hybrid-smc-surface-parameters-positive-return-all-g-0-for-g-in-gains-return-true-def-compute-control-self-state-np-ndarray-np-ndarray-pso-compatible-control-computation-with-error-handling-args-state-system-state-vector-1-2-x-1-2-x-returns-control-output-as-numpy-array-try-self-control-calls-1-start-time-time-time-validate-input-state-if-len-state-6-raise-valueerror-f-expected-6-element-state-got-len-state-call-underlying-controller-result-self-controller-compute-control-state-extract-control-value-if-hasattr-result-u-u-result-u-elif-isinstance-result-dict-and-u-in-result-u-result-u-else-u-result-apply-saturation-and-return-as-array-u-sat-np-clip-float-u-self-max-force-self-max-force-performance-tracking-self-last-control-time-time-time-start-time-return-np-array-u-sat-except-exception-as-e-self-control-failures-1-return-safe-fallback-control-return-np-array-0-0">
<h1>runnable: false class PSOControllerWrapper: â€œâ€â€ PSO-optimized controller wrapper with validation. Provides: - Simplified control interface for fitness evaluation - Automatic gain validation with controller-specific rules - Performance monitoring and error handling - Thread-safe operation for parallel PSO â€œâ€â€ def <strong>init</strong>(self, controller: Any, controller_type: str, validation_config: Dict[str, Any]): self.controller = controller self.controller_type = controller_type self.validation_config = validation_config # PSO-required attributes self.n_gains = CONTROLLER_REGISTRY[controller_type][â€˜gain_countâ€™] self.max_force = getattr(controller, â€˜max_forceâ€™, 150.0) # Performance tracking self.control_calls = 0 self.control_failures = 0 self.last_control_time = 0.0 def validate_gains(self, particles: np.ndarray) -&gt; np.ndarray: â€œâ€â€ Vectorized gain validation for PSO particle swarms. Args: particles: Array of shape (n_particles, n_gains) Returns: Boolean mask indicating valid particles â€œâ€â€ if particles.ndim == 1: particles = particles.reshape(1, -1) valid_mask = np.ones(particles.shape[0], dtype=bool) # Basic validation for i, gains in enumerate(particles): try: # Check gain count if len(gains) != self.n_gains: valid_mask[i] = False continue # Check for finite positive values if not all(np.isfinite(g) and g &gt; 0 for g in gains): valid_mask[i] = False continue # Controller-specific validation if not self._validate_controller_specific_constraints(gains): valid_mask[i] = False continue except Exception: valid_mask[i] = False return valid_mask def _validate_controller_specific_constraints(self, gains: List[float]) -&gt; bool: â€œâ€â€Apply mathematical constraints for each controller type.â€â€â€ if self.controller_type == â€˜classical_smcâ€™: # Classical SMC: All gains positive, reasonable ranges k1, k2, lam1, lam2, K, kd = gains return all(g &gt; 0 for g in gains[:5]) and kd &gt;= 0 elif self.controller_type == â€˜sta_smcâ€™: # Super-Twisting: Critical stability condition K1 &gt; K2 K1, K2 = gains[0], gains[1] return K1 &gt; K2 &gt; 0 and all(g &gt; 0 for g in gains[2:]) elif self.controller_type == â€˜adaptive_smcâ€™: # Adaptive SMC: Adaptation rate bounds k1, k2, lam1, lam2, gamma = gains return all(g &gt; 0 for g in gains[:4]) and 0.1 &lt;= gamma &lt;= 20.0 elif self.controller_type == â€˜hybrid_adaptive_sta_smcâ€™: # Hybrid SMC: Surface parameters positive return all(g &gt; 0 for g in gains) return True def compute_control(self, state: np.ndarray) -&gt; np.ndarray: â€œâ€â€ PSO-compatible control computation with error handling. Args: state: System state vector [Î¸â‚, Î¸â‚‚, x, Î¸Ì‡â‚, Î¸Ì‡â‚‚, áº‹] Returns: Control output as numpy array â€œâ€â€ try: self.control_calls += 1 start_time = time.time() # Validate input state if len(state) != 6: raise ValueError(fâ€Expected 6-element state, got {len(state)}â€) # Call underlying controller result = self.controller.compute_control(state, {}, {}) # Extract control value if hasattr(result, â€˜uâ€™): u = result.u elif isinstance(result, dict) and â€˜uâ€™ in result: u = result[â€˜uâ€™] else: u = result # Apply saturation and return as array u_sat = np.clip(float(u), -self.max_force, self.max_force) # Performance tracking self.last_control_time = time.time() - start_time return np.array([u_sat]) except Exception as e: self.control_failures += 1 # Return safe fallback control return np.array([0.0])<a class="headerlink" href="#runnable-false-class-psocontrollerwrapper-pso-optimized-controller-wrapper-with-validation-provides-simplified-control-interface-for-fitness-evaluation-automatic-gain-validation-with-controller-specific-rules-performance-monitoring-and-error-handling-thread-safe-operation-for-parallel-pso-def-init-self-controller-any-controller-type-str-validation-config-dict-str-any-self-controller-controller-self-controller-type-controller-type-self-validation-config-validation-config-pso-required-attributes-self-n-gains-controller-registry-controller-type-gain-count-self-max-force-getattr-controller-max-force-150-0-performance-tracking-self-control-calls-0-self-control-failures-0-self-last-control-time-0-0-def-validate-gains-self-particles-np-ndarray-np-ndarray-vectorized-gain-validation-for-pso-particle-swarms-args-particles-array-of-shape-n-particles-n-gains-returns-boolean-mask-indicating-valid-particles-if-particles-ndim-1-particles-particles-reshape-1-1-valid-mask-np-ones-particles-shape-0-dtype-bool-basic-validation-for-i-gains-in-enumerate-particles-try-check-gain-count-if-len-gains-self-n-gains-valid-mask-i-false-continue-check-for-finite-positive-values-if-not-all-np-isfinite-g-and-g-0-for-g-in-gains-valid-mask-i-false-continue-controller-specific-validation-if-not-self-validate-controller-specific-constraints-gains-valid-mask-i-false-continue-except-exception-valid-mask-i-false-return-valid-mask-def-validate-controller-specific-constraints-self-gains-list-float-bool-apply-mathematical-constraints-for-each-controller-type-if-self-controller-type-classical-smc-classical-smc-all-gains-positive-reasonable-ranges-k1-k2-lam1-lam2-k-kd-gains-return-all-g-0-for-g-in-gains-5-and-kd-0-elif-self-controller-type-sta-smc-super-twisting-critical-stability-condition-k1-k2-k1-k2-gains-0-gains-1-return-k1-k2-0-and-all-g-0-for-g-in-gains-2-elif-self-controller-type-adaptive-smc-adaptive-smc-adaptation-rate-bounds-k1-k2-lam1-lam2-gamma-gains-return-all-g-0-for-g-in-gains-4-and-0-1-gamma-20-0-elif-self-controller-type-hybrid-adaptive-sta-smc-hybrid-smc-surface-parameters-positive-return-all-g-0-for-g-in-gains-return-true-def-compute-control-self-state-np-ndarray-np-ndarray-pso-compatible-control-computation-with-error-handling-args-state-system-state-vector-1-2-x-1-2-x-returns-control-output-as-numpy-array-try-self-control-calls-1-start-time-time-time-validate-input-state-if-len-state-6-raise-valueerror-f-expected-6-element-state-got-len-state-call-underlying-controller-result-self-controller-compute-control-state-extract-control-value-if-hasattr-result-u-u-result-u-elif-isinstance-result-dict-and-u-in-result-u-result-u-else-u-result-apply-saturation-and-return-as-array-u-sat-np-clip-float-u-self-max-force-self-max-force-performance-tracking-self-last-control-time-time-time-start-time-return-np-array-u-sat-except-exception-as-e-self-control-failures-1-return-safe-fallback-control-return-np-array-0-0" title="Link to this heading">Â¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">##</span> <span class="pre">PSO</span> <span class="pre">Optimization</span> <span class="pre">Workflows</span> <span class="pre">###</span> <span class="pre">1.</span> <span class="pre">Standard</span> <span class="pre">PSO</span> <span class="pre">Optimization</span> <span class="pre">Workflow</span> <span class="pre">**Complete</span> <span class="pre">workflow</span> <span class="pre">for</span> <span class="pre">single-controller</span> <span class="pre">optimization:**</span></code>python
def optimize_smc_controller_pso( controller_type: str, simulation_config: Any, pso_config: Dict[str, Any], optimization_objectives: List[str]
) -&gt; Dict[str, Any]: â€œâ€â€ Complete PSO optimization workflow for SMC controllers. Args: controller_type: SMC controller type (â€˜classical_smcâ€™, etc.) simulation_config: Plant and simulation parameters pso_config: PSO algorithm parameters optimization_objectives: List of objectives [â€˜iseâ€™, â€˜overshootâ€™, â€˜settling_timeâ€™] Returns: Optimization results with best gains and performance metrics â€œâ€â€ # 1. Initialize PSO-Factory Interface pso_interface = PSOFactoryInterface(controller_type, simulation_config) # 2. Setup PSO Algorithm from pyswarms.single import GlobalBestPSO # PSO parameters with adaptive bounds bounds = ( np.array(pso_interface.bounds_lower), np.array(pso_interface.bounds_upper) ) optimizer = GlobalBestPSO( n_particles=pso_config.get(â€˜n_particlesâ€™, 30), dimensions=pso_interface.n_gains, options={ â€˜c1â€™: pso_config.get(â€˜c1â€™, 2.0), # Cognitive component â€˜c2â€™: pso_config.get(â€˜c2â€™, 2.0), # Social component â€˜wâ€™: pso_config.get(â€˜wâ€™, 0.9) # Inertia weight }, bounds=bounds ) # 3. Define Fitness Function def fitness_function(particles: np.ndarray) -&gt; np.ndarray: â€œâ€â€ Vectorized fitness evaluation for PSO particles. Args: particles: Array of shape (n_particles, n_gains) Returns: Fitness scores for each particle â€œâ€â€ fitness_scores = [] for gains in particles: try: # Create controller with current gains controller_factory = pso_interface.create_pso_controller_factory() controller = controller_factory(gains) # Validate gains if not controller.validate_gains(gains.reshape(1, -1))[0]: fitness_scores.append(1000.0) # Penalty for invalid gains continue # Run simulation simulation_result = run_simulation_with_controller( controller, simulation_config ) # Compute multi-objective fitness fitness = compute_multi_objective_fitness( simulation_result, optimization_objectives ) fitness_scores.append(fitness) except Exception as e: # Penalty for simulation failures fitness_scores.append(1000.0) return np.array(fitness_scores) # 4. Run PSO Optimization best_cost, best_gains = optimizer.optimize( fitness_function, iters=pso_config.get(â€˜itersâ€™, 100), verbose=True ) # 5. Validate and Return Results validation_result = validate_optimization_result( best_gains, best_cost, controller_type, simulation_config ) return { â€˜best_gainsâ€™: best_gains.tolist(), â€˜best_fitnessâ€™: float(best_cost), â€˜controller_typeâ€™: controller_type, â€˜optimization_historyâ€™: optimizer.cost_history, â€˜validation_resultâ€™: validation_result, â€˜pso_metricsâ€™: pso_interface.metrics }
<code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">2.</span> <span class="pre">Multi-Objective</span> <span class="pre">PSO</span> <span class="pre">Optimization</span> <span class="pre">**Advanced</span> <span class="pre">workflow</span> <span class="pre">for</span> <span class="pre">simultaneous</span> <span class="pre">optimization</span> <span class="pre">of</span> <span class="pre">multiple</span> <span class="pre">objectives:**</span></code>python</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id2">
<h1>example-metadata:<a class="headerlink" href="#id2" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-def-multi-objective-pso-optimization-controller-types-list-str-simulation-config-any-objectives-dict-str-float-ise-0-4-overshoot-0-3-energy-0-3-pso-config-dict-str-any">
<h1>runnable: false def multi_objective_pso_optimization( controller_types: List[str], simulation_config: Any, objectives: Dict[str, float], # {â€˜iseâ€™: 0.4, â€˜overshootâ€™: 0.3, â€˜energyâ€™: 0.3} pso_config: Dict[str, Any]<a class="headerlink" href="#runnable-false-def-multi-objective-pso-optimization-controller-types-list-str-simulation-config-any-objectives-dict-str-float-ise-0-4-overshoot-0-3-energy-0-3-pso-config-dict-str-any" title="Link to this heading">Â¶</a></h1>
<p>) -&gt; Dict[str, Any]: â€œâ€â€ Multi-objective PSO optimization across multiple controller types. Features: - Simultaneous optimization of multiple performance metrics - Pareto-optimal solution discovery - Controller comparison and ranking - Robust constraint handling â€œâ€â€ results = {} pareto_solutions = [] for controller_type in controller_types: print(fâ€Optimizing {controller_type}â€¦â€) # Single-objective optimization for baseline single_result = optimize_smc_controller_pso( controller_type, simulation_config, pso_config, list(objectives.keys()) ) results[controller_type] = single_result # Extract Pareto approaches pareto_solutions.extend( extract_pareto_solutions(single_result, objectives) ) # Multi-objective analysis pareto_front = compute_pareto_front(pareto_solutions) controller_ranking = rank_controllers_by_objectives(results, objectives) return { â€˜individual_resultsâ€™: results, â€˜pareto_frontâ€™: pareto_front, â€˜controller_rankingâ€™: controller_ranking, â€˜best_overallâ€™: select_best_overall_solution(results, objectives) }
<code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">3.</span> <span class="pre">Adaptive</span> <span class="pre">PSO</span> <span class="pre">with</span> <span class="pre">Dynamic</span> <span class="pre">Bounds</span> <span class="pre">**Advanced</span> <span class="pre">PSO</span> <span class="pre">with</span> <span class="pre">self-tuning</span> <span class="pre">parameters:**</span></code>python</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id3">
<h1>example-metadata:<a class="headerlink" href="#id3" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-def-adaptive-pso-optimization-controller-type-str-simulation-config-any-adaptation-config-dict-str-any">
<h1>runnable: false def adaptive_pso_optimization( controller_type: str, simulation_config: Any, adaptation_config: Dict[str, Any]<a class="headerlink" href="#runnable-false-def-adaptive-pso-optimization-controller-type-str-simulation-config-any-adaptation-config-dict-str-any" title="Link to this heading">Â¶</a></h1>
<p>) -&gt; Dict[str, Any]: â€œâ€â€ Adaptive PSO with dynamic parameter adjustment. Features: - Dynamic PSO parameter adjustment based on convergence - Adaptive bounds tightening around promising regions - Early stopping with convergence detection - Exploration-exploitation balance optimization â€œâ€â€ # Initialize adaptive PSO adaptive_pso = AdaptivePSOOptimizer( controller_type=controller_type, config=adaptation_config ) # Multi-stage optimization stages = [ {â€˜exploration_weightâ€™: 0.8, â€˜iterationsâ€™: 50}, # Exploration phase {â€˜exploration_weightâ€™: 0.5, â€˜iterationsâ€™: 30}, # Balanced phase {â€˜exploration_weightâ€™: 0.2, â€˜iterationsâ€™: 20} # Exploitation phase ] all_results = [] for stage_idx, stage_config in enumerate(stages): print(fâ€PSO Stage {stage_idx + 1}: {stage_config}â€) # Adjust PSO parameters adaptive_pso.update_parameters(stage_config) # Run optimization stage stage_result = adaptive_pso.optimize_stage( simulation_config, stage_config[â€˜iterationsâ€™] ) all_results.append(stage_result) # Check for early convergence if adaptive_pso.check_convergence(): print(fâ€Converged early at stage {stage_idx + 1}â€) break # Combine results final_result = adaptive_pso.combine_stage_results(all_results) return final_result
<code class="docutils literal notranslate"><span class="pre">##</span> <span class="pre">Performance</span> <span class="pre">Optimization</span> <span class="pre">Strategies</span> <span class="pre">###</span> <span class="pre">1.</span> <span class="pre">Parallel</span> <span class="pre">PSO</span> <span class="pre">Evaluation</span> <span class="pre">**Multi-threaded</span> <span class="pre">fitness</span> <span class="pre">evaluation</span> <span class="pre">for</span> <span class="pre">improved</span> <span class="pre">performance:**</span></code>python</p>
<p>def parallel_fitness_evaluation( particles: np.ndarray, controller_factory: Callable, simulation_config: Any, n_threads: int = 4
) -&gt; np.ndarray: â€œâ€â€ Parallel fitness evaluation using thread pool. Significantly improves PSO performance for expensive simulations. â€œâ€â€ from concurrent.futures import ThreadPoolExecutor, as_completed import time def evaluate_single_particle(gains: np.ndarray) -&gt; float: â€œâ€â€Evaluate fitness for single particle.â€â€â€ try: controller = controller_factory(gains) result = run_simulation_with_controller(controller, simulation_config) return compute_fitness(result) except Exception: return 1000.0 # Penalty for failures # Parallel execution with ThreadPoolExecutor(max_workers=n_threads) as executor: future_to_idx = { executor.submit(evaluate_single_particle, particle): idx for idx, particle in enumerate(particles) } fitness_scores = np.zeros(len(particles)) for future in as_completed(future_to_idx): idx = future_to_idx[future] try: fitness_scores[idx] = future.result() except Exception: fitness_scores[idx] = 1000.0 return fitness_scores
<code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">2.</span> <span class="pre">Cached</span> <span class="pre">Simulation</span> <span class="pre">Results</span> <span class="pre">**Intelligent</span> <span class="pre">caching</span> <span class="pre">to</span> <span class="pre">avoid</span> <span class="pre">redundant</span> <span class="pre">simulations:**</span></code>python</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id4">
<h1>example-metadata:<a class="headerlink" href="#id4" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-class-simulationcache-intelligent-caching-system-for-pso-optimization-features-hash-based-lookup-for-identical-gain-sets-lru-eviction-for-memory-management-cache-hit-miss-statistics-persistent-storage-for-long-running-optimizations-def-init-self-max-size-int-1000-tolerance-float-1e-6-self-cache-self-max-size-max-size-self-tolerance-tolerance-self-hits-0-self-misses-0-def-get-cache-key-self-gains-np-ndarray-str-generate-consistent-cache-key-for-gain-arrays-rounded-gains-np-round-gains-self-tolerance-self-tolerance-return-hash-tuple-rounded-gains-def-get-self-gains-np-ndarray-optional-float-retrieve-cached-fitness-if-available-key-self-get-cache-key-gains-if-key-in-self-cache-self-hits-1-return-self-cache-key-self-misses-1-return-none-def-put-self-gains-np-ndarray-fitness-float-none-store-fitness-result-in-cache-if-len-self-cache-self-max-size-remove-oldest-entry-simple-lru-oldest-key-next-iter-self-cache-del-self-cache-oldest-key-key-self-get-cache-key-gains-self-cache-key-fitness-def-get-statistics-self-dict-str-any-return-cache-performance-statistics-total-requests-self-hits-self-misses-hit-rate-self-hits-total-requests-if-total-requests-0-else-0-return-hits-self-hits-misses-self-misses-hit-rate-hit-rate-cache-size-len-self-cache">
<h1>runnable: false class SimulationCache: â€œâ€â€ Intelligent caching system for PSO optimization. Features: - Hash-based lookup for identical gain sets - LRU eviction for memory management - Cache hit/miss statistics - Persistent storage for long-running optimizations â€œâ€â€ def <strong>init</strong>(self, max_size: int = 1000, tolerance: float = 1e-6): self.cache = {} self.max_size = max_size self.tolerance = tolerance self.hits = 0 self.misses = 0 def get_cache_key(self, gains: np.ndarray) -&gt; str: â€œâ€â€Generate consistent cache key for gain arrays.â€â€â€ rounded_gains = np.round(gains / self.tolerance) * self.tolerance return hash(tuple(rounded_gains)) def get(self, gains: np.ndarray) -&gt; Optional[float]: â€œâ€â€Retrieve cached fitness if available.â€â€â€ key = self.get_cache_key(gains) if key in self.cache: self.hits += 1 return self.cache[key] self.misses += 1 return None def put(self, gains: np.ndarray, fitness: float) -&gt; None: â€œâ€â€Store fitness result in cache.â€â€â€ if len(self.cache) &gt;= self.max_size: # Remove oldest entry (simple LRU) oldest_key = next(iter(self.cache)) del self.cache[oldest_key] key = self.get_cache_key(gains) self.cache[key] = fitness def get_statistics(self) -&gt; Dict[str, Any]: â€œâ€â€Return cache performance statistics.â€â€â€ total_requests = self.hits + self.misses hit_rate = self.hits / total_requests if total_requests &gt; 0 else 0 return { â€˜hitsâ€™: self.hits, â€˜missesâ€™: self.misses, â€˜hit_rateâ€™: hit_rate, â€˜cache_sizeâ€™: len(self.cache) }<a class="headerlink" href="#runnable-false-class-simulationcache-intelligent-caching-system-for-pso-optimization-features-hash-based-lookup-for-identical-gain-sets-lru-eviction-for-memory-management-cache-hit-miss-statistics-persistent-storage-for-long-running-optimizations-def-init-self-max-size-int-1000-tolerance-float-1e-6-self-cache-self-max-size-max-size-self-tolerance-tolerance-self-hits-0-self-misses-0-def-get-cache-key-self-gains-np-ndarray-str-generate-consistent-cache-key-for-gain-arrays-rounded-gains-np-round-gains-self-tolerance-self-tolerance-return-hash-tuple-rounded-gains-def-get-self-gains-np-ndarray-optional-float-retrieve-cached-fitness-if-available-key-self-get-cache-key-gains-if-key-in-self-cache-self-hits-1-return-self-cache-key-self-misses-1-return-none-def-put-self-gains-np-ndarray-fitness-float-none-store-fitness-result-in-cache-if-len-self-cache-self-max-size-remove-oldest-entry-simple-lru-oldest-key-next-iter-self-cache-del-self-cache-oldest-key-key-self-get-cache-key-gains-self-cache-key-fitness-def-get-statistics-self-dict-str-any-return-cache-performance-statistics-total-requests-self-hits-self-misses-hit-rate-self-hits-total-requests-if-total-requests-0-else-0-return-hits-self-hits-misses-self-misses-hit-rate-hit-rate-cache-size-len-self-cache" title="Link to this heading">Â¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">3.</span> <span class="pre">GPU-Accelerated</span> <span class="pre">Simulation</span> <span class="pre">**GPU</span> <span class="pre">acceleration</span> <span class="pre">for</span> <span class="pre">large-scale</span> <span class="pre">PSO</span> <span class="pre">optimization:**</span></code>python</p>
<p>def gpu_accelerated_pso_evaluation( particles: np.ndarray, controller_factory: Callable, simulation_config: Any
) -&gt; np.ndarray: â€œâ€â€ GPU-accelerated fitness evaluation using CuPy/Numba. For very large swarm sizes (&gt;100 particles), GPU acceleration can provide significant speedup. â€œâ€â€ try: import cupy as cp import numba.cuda as cuda # Transfer data to GPU gpu_particles = cp.asarray(particles) # GPU kernel for parallel simulation &#64;cuda.jit def evaluate_particles_kernel(particles, fitness_scores): idx = cuda.grid(1) if idx &lt; particles.shape[0]: # GPU-accelerated simulation logic fitness_scores[idx] = gpu_simulate_controller(particles[idx]) # Allocate GPU memory gpu_fitness = cp.zeros(len(particles)) # Launch GPU kernel threads_per_block = 256 blocks_per_grid = (len(particles) + threads_per_block - 1) // threads_per_block evaluate_particles_kernel[blocks_per_grid, threads_per_block]( gpu_particles, gpu_fitness ) # Transfer results back to CPU return cp.asnumpy(gpu_fitness) except ImportError: # Fallback to CPU evaluation return parallel_fitness_evaluation(particles, controller_factory, simulation_config)
<code class="docutils literal notranslate"><span class="pre">##</span> <span class="pre">Integration</span> <span class="pre">Best</span> <span class="pre">Practices</span> <span class="pre">###</span> <span class="pre">1.</span> <span class="pre">Parameter</span> <span class="pre">Bounds</span> <span class="pre">Specification</span> <span class="pre">**Mathematically-derived</span> <span class="pre">bounds</span> <span class="pre">for</span> <span class="pre">optimal</span> <span class="pre">PSO</span> <span class="pre">performance:**</span></code>python</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id5">
<h1>example-metadata:<a class="headerlink" href="#id5" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-def-get-optimized-pso-bounds-controller-type-str-plant-params-dict-str-any-tuple-list-float-list-float-compute-optimized-pso-bounds-based-on-plant-parameters-and-control-theory-uses-stability-margins-and-performance-requirements-to-derive-tight-bounds-if-controller-type-classical-smc-classical-smc-bounds-based-on-stability-analysis-pole-placement-considerations-for-closed-loop-stability-max-damping-plant-params-get-max-damping-requirement-0-7-settling-time-plant-params-get-settling-time-requirement-2-0-derive-bounds-from-desired-closed-loop-characteristics-lambda-min-4-0-settling-time-natural-frequency-requirement-lambda-max-20-0-upper-bound-to-prevent-excessive-control-effort-k-min-lambda-min-2-0-position-gain-lower-bound-k-max-lambda-max-2-0-position-gain-upper-bound-k-min-estimate-min-switching-gain-plant-params-k-max-plant-params-get-max-force-150-0-0-8-conservative-upper-bound-bounds-lower-k-min-k-min-lambda-min-lambda-min-k-min-0-0-bounds-upper-k-max-k-max-lambda-max-lambda-max-k-max-10-0-elif-controller-type-sta-smc-super-twisting-bounds-with-stability-constraint-k1-k2-lyapunov-based-design-bounds-l0-estimate-lipschitz-constant-plant-params-k1-min-math-sqrt-l0-1-1-safety-margin-k1-max-math-sqrt-l0-5-0-conservative-upper-bound-k2-min-l0-2-math-sqrt-l0-k1-min-2-1-1-k2-max-k1-max-0-8-ensure-k1-k2-constraint-bounds-lower-k1-min-k2-min-2-0-2-0-5-0-5-0-bounds-upper-k1-max-k2-max-30-0-30-0-20-0-20-0-elif-controller-type-adaptive-smc-adaptive-smc-bounds-based-on-adaptation-rate-limits-stability-preserving-adaptation-rate-bounds-gamma-min-0-1-minimum-for-reasonable-adaptation-speed-gamma-max-estimate-max-adaptation-rate-plant-params-stability-limit-bounds-lower-2-0-2-0-5-0-5-0-gamma-min-bounds-upper-40-0-40-0-25-0-25-0-gamma-max-else-hybrid-adaptive-sta-smc-hybrid-controller-bounds-conservative-surface-parameters-bounds-lower-2-0-2-0-5-0-5-0-bounds-upper-30-0-30-0-20-0-20-0-return-bounds-lower-bounds-upper-def-estimate-min-switching-gain-plant-params-dict-str-any-float-estimate-minimum-switching-gain-based-on-disturbance-bounds-extract-disturbance-characteristics-max-model-uncertainty-plant-params-get-model-uncertainty-0-2-max-external-disturbance-plant-params-get-external-disturbance-5-0-safety-margin-plant-params-get-safety-margin-1-5-conservative-estimate-return-max-model-uncertainty-max-external-disturbance-safety-margin-def-estimate-lipschitz-constant-plant-params-dict-str-any-float-estimate-lipschitz-constant-for-sta-design-based-on-system-nonlinearity-and-uncertainty-bounds-max-nonlinearity-plant-params-get-max-nonlinearity-10-0-uncertainty-bound-plant-params-get-uncertainty-bound-5-0-return-max-nonlinearity-uncertainty-bound-def-estimate-max-adaptation-rate-plant-params-dict-str-any-float-estimate-maximum-stable-adaptation-rate-based-on-parameter-variation-speed-and-system-bandwidth-system-bandwidth-plant-params-get-system-bandwidth-10-0-rad-s-parameter-variation-rate-plant-params-get-parameter-variation-rate-0-1-hz-conservative-bound-adaptation-much-slower-than-system-dynamics-return-min-system-bandwidth-10-0-1-0-parameter-variation-rate">
<h1>runnable: false def get_optimized_pso_bounds(controller_type: str, plant_params: Dict[str, Any]) -&gt; Tuple[List[float], List[float]]: â€œâ€â€ Compute optimized PSO bounds based on plant parameters and control theory. Uses stability margins and performance requirements to derive tight bounds. â€œâ€â€ if controller_type == â€˜classical_smcâ€™: # Classical SMC bounds based on stability analysis # Pole placement considerations for closed-loop stability max_damping = plant_params.get(â€˜max_damping_requirementâ€™, 0.7) settling_time = plant_params.get(â€˜settling_time_requirementâ€™, 2.0) # Derive bounds from desired closed-loop characteristics lambda_min = 4.0 / settling_time # Natural frequency requirement lambda_max = 20.0 # Upper bound to prevent excessive control effort k_min = lambda_min / 2.0 # Position gain lower bound k_max = lambda_max * 2.0 # Position gain upper bound K_min = estimate_min_switching_gain(plant_params) K_max = plant_params.get(â€˜max_forceâ€™, 150.0) * 0.8 # Conservative upper bound bounds_lower = [k_min, k_min, lambda_min, lambda_min, K_min, 0.0] bounds_upper = [k_max, k_max, lambda_max, lambda_max, K_max, 10.0] elif controller_type == â€˜sta_smcâ€™: # Super-Twisting bounds with stability constraint K1 &gt; K2 # Lyapunov-based design bounds L0 = estimate_lipschitz_constant(plant_params) K1_min = math.sqrt(L0) * 1.1 # Safety margin K1_max = math.sqrt(L0) * 5.0 # Conservative upper bound K2_min = L0 / (2 * math.sqrt(L0 - K1_min**2)) * 1.1 K2_max = K1_max * 0.8 # Ensure K1 &gt; K2 constraint bounds_lower = [K1_min, K2_min, 2.0, 2.0, 5.0, 5.0] bounds_upper = [K1_max, K2_max, 30.0, 30.0, 20.0, 20.0] elif controller_type == â€˜adaptive_smcâ€™: # Adaptive SMC bounds based on adaptation rate limits # Stability-preserving adaptation rate bounds gamma_min = 0.1 # Minimum for reasonable adaptation speed gamma_max = estimate_max_adaptation_rate(plant_params) # Stability limit bounds_lower = [2.0, 2.0, 5.0, 5.0, gamma_min] bounds_upper = [40.0, 40.0, 25.0, 25.0, gamma_max] else: # hybrid_adaptive_sta_smc # Hybrid controller bounds (conservative surface parameters) bounds_lower = [2.0, 2.0, 5.0, 5.0] bounds_upper = [30.0, 30.0, 20.0, 20.0] return bounds_lower, bounds_upper def estimate_min_switching_gain(plant_params: Dict[str, Any]) -&gt; float: â€œâ€â€Estimate minimum switching gain based on disturbance bounds.â€â€â€ # Extract disturbance characteristics max_model_uncertainty = plant_params.get(â€˜model_uncertaintyâ€™, 0.2) max_external_disturbance = plant_params.get(â€˜external_disturbanceâ€™, 5.0) safety_margin = plant_params.get(â€˜safety_marginâ€™, 1.5) # Conservative estimate return (max_model_uncertainty + max_external_disturbance) * safety_margin def estimate_lipschitz_constant(plant_params: Dict[str, Any]) -&gt; float: â€œâ€â€Estimate Lipschitz constant for STA design.â€â€â€ # Based on system nonlinearity and uncertainty bounds max_nonlinearity = plant_params.get(â€˜max_nonlinearityâ€™, 10.0) uncertainty_bound = plant_params.get(â€˜uncertainty_boundâ€™, 5.0) return max_nonlinearity + uncertainty_bound def estimate_max_adaptation_rate(plant_params: Dict[str, Any]) -&gt; float: â€œâ€â€Estimate maximum stable adaptation rate.â€â€â€ # Based on parameter variation speed and system bandwidth system_bandwidth = plant_params.get(â€˜system_bandwidthâ€™, 10.0) # rad/s parameter_variation_rate = plant_params.get(â€˜parameter_variation_rateâ€™, 0.1) # Hz # Conservative bound: adaptation much slower than system dynamics return min(system_bandwidth / 10.0, 1.0 / parameter_variation_rate)<a class="headerlink" href="#runnable-false-def-get-optimized-pso-bounds-controller-type-str-plant-params-dict-str-any-tuple-list-float-list-float-compute-optimized-pso-bounds-based-on-plant-parameters-and-control-theory-uses-stability-margins-and-performance-requirements-to-derive-tight-bounds-if-controller-type-classical-smc-classical-smc-bounds-based-on-stability-analysis-pole-placement-considerations-for-closed-loop-stability-max-damping-plant-params-get-max-damping-requirement-0-7-settling-time-plant-params-get-settling-time-requirement-2-0-derive-bounds-from-desired-closed-loop-characteristics-lambda-min-4-0-settling-time-natural-frequency-requirement-lambda-max-20-0-upper-bound-to-prevent-excessive-control-effort-k-min-lambda-min-2-0-position-gain-lower-bound-k-max-lambda-max-2-0-position-gain-upper-bound-k-min-estimate-min-switching-gain-plant-params-k-max-plant-params-get-max-force-150-0-0-8-conservative-upper-bound-bounds-lower-k-min-k-min-lambda-min-lambda-min-k-min-0-0-bounds-upper-k-max-k-max-lambda-max-lambda-max-k-max-10-0-elif-controller-type-sta-smc-super-twisting-bounds-with-stability-constraint-k1-k2-lyapunov-based-design-bounds-l0-estimate-lipschitz-constant-plant-params-k1-min-math-sqrt-l0-1-1-safety-margin-k1-max-math-sqrt-l0-5-0-conservative-upper-bound-k2-min-l0-2-math-sqrt-l0-k1-min-2-1-1-k2-max-k1-max-0-8-ensure-k1-k2-constraint-bounds-lower-k1-min-k2-min-2-0-2-0-5-0-5-0-bounds-upper-k1-max-k2-max-30-0-30-0-20-0-20-0-elif-controller-type-adaptive-smc-adaptive-smc-bounds-based-on-adaptation-rate-limits-stability-preserving-adaptation-rate-bounds-gamma-min-0-1-minimum-for-reasonable-adaptation-speed-gamma-max-estimate-max-adaptation-rate-plant-params-stability-limit-bounds-lower-2-0-2-0-5-0-5-0-gamma-min-bounds-upper-40-0-40-0-25-0-25-0-gamma-max-else-hybrid-adaptive-sta-smc-hybrid-controller-bounds-conservative-surface-parameters-bounds-lower-2-0-2-0-5-0-5-0-bounds-upper-30-0-30-0-20-0-20-0-return-bounds-lower-bounds-upper-def-estimate-min-switching-gain-plant-params-dict-str-any-float-estimate-minimum-switching-gain-based-on-disturbance-bounds-extract-disturbance-characteristics-max-model-uncertainty-plant-params-get-model-uncertainty-0-2-max-external-disturbance-plant-params-get-external-disturbance-5-0-safety-margin-plant-params-get-safety-margin-1-5-conservative-estimate-return-max-model-uncertainty-max-external-disturbance-safety-margin-def-estimate-lipschitz-constant-plant-params-dict-str-any-float-estimate-lipschitz-constant-for-sta-design-based-on-system-nonlinearity-and-uncertainty-bounds-max-nonlinearity-plant-params-get-max-nonlinearity-10-0-uncertainty-bound-plant-params-get-uncertainty-bound-5-0-return-max-nonlinearity-uncertainty-bound-def-estimate-max-adaptation-rate-plant-params-dict-str-any-float-estimate-maximum-stable-adaptation-rate-based-on-parameter-variation-speed-and-system-bandwidth-system-bandwidth-plant-params-get-system-bandwidth-10-0-rad-s-parameter-variation-rate-plant-params-get-parameter-variation-rate-0-1-hz-conservative-bound-adaptation-much-slower-than-system-dynamics-return-min-system-bandwidth-10-0-1-0-parameter-variation-rate" title="Link to this heading">Â¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">2.</span> <span class="pre">Convergence</span> <span class="pre">Detection</span> <span class="pre">and</span> <span class="pre">Early</span> <span class="pre">Stopping</span> <span class="pre">**Intelligent</span> <span class="pre">convergence</span> <span class="pre">detection</span> <span class="pre">for</span> <span class="pre">efficient</span> <span class="pre">optimization:**</span></code>python</p>
<p>class PSO_ConvergenceDetector: â€œâ€â€ Advanced convergence detection for PSO optimization. Features: - Multiple convergence criteria - Statistical significance testing - Plateau detection - Diversity monitoring â€œâ€â€ def <strong>init</strong>(self, patience: int = 20, tolerance: float = 1e-6): self.patience = patience self.tolerance = tolerance self.fitness_history = [] self.diversity_history = [] self.best_fitness = float(â€˜infâ€™) self.stagnation_count = 0 def update(self, current_fitness: float, population_diversity: float) -&gt; bool: â€œâ€â€ Update convergence detector with current optimization state. Returns: True if convergence detected, False otherwise â€œâ€â€ self.fitness_history.append(current_fitness) self.diversity_history.append(population_diversity) # Check for improvement if current_fitness &lt; self.best_fitness - self.tolerance: self.best_fitness = current_fitness self.stagnation_count = 0 else: self.stagnation_count += 1 # Multiple convergence criteria return ( self._check_fitness_plateau() or self._check_diversity_collapse() or self._check_statistical_convergence() ) def _check_fitness_plateau(self) -&gt; bool: â€œâ€â€Check if fitness has plateaued.â€â€â€ return self.stagnation_count &gt;= self.patience def _check_diversity_collapse(self) -&gt; bool: â€œâ€â€Check if population diversity has collapsed.â€â€â€ if len(self.diversity_history) &lt; 10: return False recent_diversity = np.mean(self.diversity_history[-10:]) return recent_diversity &lt; 1e-8 # Very low diversity def _check_statistical_convergence(self) -&gt; bool: â€œâ€â€Check statistical significance of convergence.â€â€â€ if len(self.fitness_history) &lt; 30: return False # Test if recent improvements are statistically significant recent_fitness = self.fitness_history[-15:] older_fitness = self.fitness_history[-30:-15] from scipy.stats import ttest_ind statistic, p_value = ttest_ind(recent_fitness, older_fitness) # If no significant difference, consider converged return p_value &gt; 0.05
<code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">3.</span> <span class="pre">Robust</span> <span class="pre">Error</span> <span class="pre">Handling</span> <span class="pre">**error</span> <span class="pre">handling</span> <span class="pre">for</span> <span class="pre">production</span> <span class="pre">PSO</span> <span class="pre">workflows:**</span></code>python
def robust_pso_optimization( controller_type: str, simulation_config: Any, pso_config: Dict[str, Any], error_handling_config: Dict[str, Any]
) -&gt; Dict[str, Any]: â€œâ€â€ Production-ready PSO optimization with error handling. Features: - Graceful degradation for simulation failures - Automatic retry mechanisms - Fallback strategies for numerical instabilities - logging and diagnostics â€œâ€â€ import logging import traceback from contextlib import contextmanager # Setup logging logger = logging.getLogger(â€˜PSO_Optimizationâ€™) &#64;contextmanager def error_context(operation_name: str): â€œâ€â€Context manager for operation-specific error handling.â€â€â€ try: <a class="reference external" href="http://logger.info">logger.info</a>(fâ€Starting {operation_name}â€) yield <a class="reference external" href="http://logger.info">logger.info</a>(fâ€Completed {operation_name}â€) except Exception as e: logger.error(fâ€Error in {operation_name}: {e}â€) logger.debug(traceback.format_exc()) raise try: with error_context(â€œPSO Initializationâ€): # Initialize with validation pso_interface = PSOFactoryInterface(controller_type, simulation_config) # Validate PSO configuration validate_pso_configuration(pso_config, pso_interface.n_gains) with error_context(â€œFitness Function Setupâ€): # Create robust fitness function with fallbacks fitness_function = create_robust_fitness_function( pso_interface, simulation_config, error_handling_config ) with error_context(â€œPSO Executionâ€): # Run PSO with monitoring result = run_monitored_pso_optimization( fitness_function, pso_config, error_handling_config ) with error_context(â€œResult Validationâ€): # Validate optimization results validated_result = validate_and_refine_result( result, controller_type, simulation_config ) return validated_result except Exception as e: logger.error(fâ€PSO optimization failed: {e}â€) # Attempt fallback optimization if error_handling_config.get(â€˜enable_fallbackâ€™, True): <a class="reference external" href="http://logger.info">logger.info</a>(â€œAttempting fallback optimizationâ€) return fallback_optimization_strategy( controller_type, simulation_config, pso_config ) else: raise def create_robust_fitness_function( pso_interface: PSOFactoryInterface, simulation_config: Any, error_config: Dict[str, Any]
) -&gt; Callable: â€œâ€â€Create fitness function with error handling.â€â€â€ max_retries = error_config.get(â€˜max_retriesâ€™, 3) timeout = error_config.get(â€˜simulation_timeoutâ€™, 30.0) def robust_fitness(particles: np.ndarray) -&gt; np.ndarray: â€œâ€â€Robust fitness evaluation with retries and timeouts.â€â€â€ fitness_scores = [] for particle in particles: best_score = float(â€˜infâ€™) for retry in range(max_retries): try: # Create controller with timeout with timeout_context(timeout): controller = pso_interface.create_controller(particle) # Run simulation with monitoring result = run_monitored_simulation(controller, simulation_config) # Compute fitness score = compute_robust_fitness(result, error_config) best_score = min(best_score, score) break # Success, no need to retry except TimeoutError: logger.warning(fâ€Simulation timeout for particle {particle}â€) continue except Exception as e: logger.warning(fâ€Simulation error (retry {retry}): {e}â€) continue fitness_scores.append(best_score) return np.array(fitness_scores) return robust_fitness
<code class="docutils literal notranslate"><span class="pre">##</span> <span class="pre">Production</span> <span class="pre">Deployment</span> <span class="pre">Considerations</span> <span class="pre">###</span> <span class="pre">1.</span> <span class="pre">Performance</span> <span class="pre">Monitoring</span> <span class="pre">**Real-time</span> <span class="pre">monitoring</span> <span class="pre">for</span> <span class="pre">production</span> <span class="pre">PSO</span> <span class="pre">optimization:**</span></code>python</p>
<p>class PSO_ProductionMonitor: â€œâ€â€ Production monitoring system for PSO optimization workflows. Features: - Real-time performance metrics - Resource utilization tracking - Optimization progress visualization - Alert system for anomalies â€œâ€â€ def <strong>init</strong>(self, monitoring_config: Dict[str, Any]): self.config = monitoring_config self.metrics = { â€˜optimization_start_timeâ€™: None, â€˜total_evaluationsâ€™: 0, â€˜successful_evaluationsâ€™: 0, â€˜failed_evaluationsâ€™: 0, â€˜average_evaluation_timeâ€™: 0.0, â€˜peak_memory_usageâ€™: 0.0, â€˜cpu_utilizationâ€™: [], â€˜convergence_rateâ€™: 0.0 } def start_optimization(self): â€œâ€â€Initialize monitoring for new optimization run.â€â€â€ self.metrics[â€˜optimization_start_timeâ€™] = time.time() def log_evaluation(self, success: bool, evaluation_time: float): â€œâ€â€Log individual fitness evaluation.â€â€â€ self.metrics[â€˜total_evaluationsâ€™] += 1 if success: self.metrics[â€˜successful_evaluationsâ€™] += 1 else: self.metrics[â€˜failed_evaluationsâ€™] += 1 # Update average evaluation time total_time = (self.metrics[â€˜average_evaluation_timeâ€™] * (self.metrics[â€˜total_evaluationsâ€™] - 1) + evaluation_time) self.metrics[â€˜average_evaluation_timeâ€™] = total_time / self.metrics[â€˜total_evaluationsâ€™] def check_resource_usage(self): â€œâ€â€Monitor system resource usage.â€â€â€ import psutil # Memory usage memory_info = psutil.virtual_memory() self.metrics[â€˜peak_memory_usageâ€™] = max( self.metrics[â€˜peak_memory_usageâ€™], memory_info.percent ) # CPU utilization cpu_percent = psutil.cpu_percent(interval=1) self.metrics[â€˜cpu_utilizationâ€™].append(cpu_percent) # Check for resource alerts if memory_info.percent &gt; 90: logger.warning(fâ€High memory usage: {memory_info.percent}%â€) if cpu_percent &gt; 95: logger.warning(fâ€High CPU usage: {cpu_percent}%â€) def generate_report(self) -&gt; Dict[str, Any]: â€œâ€â€Generate monitoring report.â€â€â€ if self.metrics[â€˜optimization_start_timeâ€™] is None: return {â€˜statusâ€™: â€˜not_startedâ€™} elapsed_time = time.time() - self.metrics[â€˜optimization_start_timeâ€™] success_rate = (self.metrics[â€˜successful_evaluationsâ€™] / self.metrics[â€˜total_evaluationsâ€™] * 100 if self.metrics[â€˜total_evaluationsâ€™] &gt; 0 else 0) return { â€˜elapsed_timeâ€™: elapsed_time, â€˜total_evaluationsâ€™: self.metrics[â€˜total_evaluationsâ€™], â€˜success_rateâ€™: success_rate, â€˜average_evaluation_timeâ€™: self.metrics[â€˜average_evaluation_timeâ€™], â€˜evaluations_per_secondâ€™: self.metrics[â€˜total_evaluationsâ€™] / elapsed_time, â€˜peak_memory_usageâ€™: self.metrics[â€˜peak_memory_usageâ€™], â€˜average_cpu_usageâ€™: np.mean(self.metrics[â€˜cpu_utilizationâ€™]), â€˜statusâ€™: â€˜runningâ€™ if elapsed_time &gt; 0 else â€˜completedâ€™ }
<code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">2.</span> <span class="pre">Configuration</span> <span class="pre">Management</span> <span class="pre">**Centralized</span> <span class="pre">configuration</span> <span class="pre">system</span> <span class="pre">for</span> <span class="pre">PSO</span> <span class="pre">workflows:**</span></code>python</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id6">
<h1>example-metadata:<a class="headerlink" href="#id6" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-from-dataclasses-import-dataclass">
<h1>runnable: false from dataclasses import dataclass<a class="headerlink" href="#runnable-false-from-dataclasses-import-dataclass" title="Link to this heading">Â¶</a></h1>
<p>from typing import Optional
import yaml &#64;dataclass
class PSO_OptimizationConfig: â€œâ€â€ Complete configuration for PSO optimization workflows. Provides type-safe configuration with validation and defaults. â€œâ€â€ # Controller configuration controller_type: str controller_config: Dict[str, Any] # PSO algorithm parameters n_particles: int = 30 max_iterations: int = 100 c1: float = 2.0 # Cognitive component c2: float = 2.0 # Social component w: float = 0.9 # Inertia weight # Optimization objectives objectives: Dict[str, float] = None # {â€˜iseâ€™: 0.4, â€˜overshootâ€™: 0.3, â€˜energyâ€™: 0.3} # Performance settings enable_parallel_evaluation: bool = True n_threads: int = 4 enable_gpu_acceleration: bool = False # Caching and persistence enable_simulation_cache: bool = True cache_size: int = 1000 save_intermediate_results: bool = True # Error handling max_retries: int = 3 simulation_timeout: float = 30.0 enable_fallback: bool = True # Convergence detection convergence_patience: int = 20 convergence_tolerance: float = 1e-6 enable_early_stopping: bool = True # Monitoring and logging enable_monitoring: bool = True log_level: str = â€˜INFOâ€™ save_optimization_history: bool = True def <strong>post_init</strong>(self): â€œâ€â€Validate configuration after initialization.â€â€â€ # Set default objectives if not provided if self.objectives is None: self.objectives = {â€˜iseâ€™: 0.5, â€˜overshootâ€™: 0.3, â€˜settling_timeâ€™: 0.2} # Validate objectives sum to 1.0 if abs(sum(self.objectives.values()) - 1.0) &gt; 1e-6: raise ValueError(â€œObjective weights must sum to 1.0â€) # Validate PSO parameters if not (0 &lt; self.c1 &lt; 5 and 0 &lt; self.c2 &lt; 5): raise ValueError(â€œPSO cognitive/social parameters must be in (0, 5)â€) if not (0 &lt; self.w &lt; 1): raise ValueError(â€œPSO inertia weight must be in (0, 1)â€) # Validate controller type valid_types = [â€˜classical_smcâ€™, â€˜sta_smcâ€™, â€˜adaptive_smcâ€™, â€˜hybrid_adaptive_sta_smcâ€™] if self.controller_type not in valid_types: raise ValueError(fâ€Controller type must be one of {valid_types}â€) def load_pso_config_from_yaml(config_path: str) -&gt; PSO_OptimizationConfig: â€œâ€â€Load PSO configuration from YAML file with validation.â€â€â€ with open(config_path, â€˜râ€™) as f: config_dict = yaml.safe_load(f) # Extract PSO-specific configuration pso_config = config_dict.get(â€˜pso_optimizationâ€™, {}) return PSO_OptimizationConfig(**pso_config) def save_pso_config_to_yaml(config: PSO_OptimizationConfig, output_path: str) -&gt; None: â€œâ€â€Save PSO configuration to YAML file.â€â€â€ config_dict = { â€˜pso_optimizationâ€™: { â€˜controller_typeâ€™: config.controller_type, â€˜controller_configâ€™: config.controller_config, â€˜n_particlesâ€™: config.n_particles, â€˜max_iterationsâ€™: config.max_iterations, â€˜c1â€™: config.c1, â€˜c2â€™: config.c2, â€˜wâ€™: config.w, â€˜objectivesâ€™: config.objectives, # â€¦ include all configuration fields } } with open(output_path, â€˜wâ€™) as f: yaml.dump(config_dict, f, default_flow_style=False, indent=2)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
<span class="o">---</span>

<span class="o">**</span><span class="n">Document</span> <span class="n">Status</span><span class="o">**</span><span class="p">:</span> <span class="n">Complete</span> <span class="o">-</span> <span class="n">Production</span> <span class="n">Ready</span>
<span class="o">**</span><span class="n">Last</span> <span class="n">Updated</span><span class="o">**</span><span class="p">:</span> <span class="n">September</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">2024</span>
<span class="o">**</span><span class="n">Integration</span> <span class="n">Level</span><span class="o">**</span><span class="p">:</span> <span class="n">Full</span> <span class="n">Factory</span> <span class="o">+</span> <span class="n">PSO</span> <span class="n">Workflow</span> <span class="n">Support</span>
<span class="o">**</span><span class="n">Performance</span><span class="o">**</span><span class="p">:</span> <span class="n">Optimized</span> <span class="k">for</span> <span class="n">Production</span> <span class="n">Deployment</span>
</pre></div>
</div>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Research Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on Oct 10, 2025</div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=4ebf8126"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=46bd48cc"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=08e7b316"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../_static/back-to-top.js?v=840797bb"></script>
    <script src="../_static/lazy-load.js?v=dc25293c"></script>
    <script src="../_static/dark-mode.js?v=bf328970"></script>
    </body>
</html>