<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
.chartjs-container {
    margin: 1.5em auto;
    padding: 1em;
    background: #f8f9fa;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.chart-note {
    text-align: center;
    color: #6c757d;
    font-size: 0.9em;
    margin-top: 0.5em;
}
</style>
<link rel="index" title="Index" href="../genindex.html"><link rel="search" title="Search" href="../search.html">

    <!-- Generated with Sphinx 8.2.3 and Furo 2025.09.25 -->
        <title>GitHub Issue #6 Factory Integration - Scientific Validation Guide ### Overview This document provides the mathematical foundations and scientific validation for configuration migrations in the enhanced factory system. It bridges control theory with implementation details to ensure mathematically sound parameter transformations during migration. ## Mathematical Framework for Parameter Migration ### 1. Classical SMC Parameter Transformation #### Theoretical Foundation Classical Sliding Mode Control uses a sliding surface designed to ensure finite-time convergence to the desired trajectory. The mathematical formulation involves: Sliding Surface Design: - DIP_SMC_PSO Documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5349f25f" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=580074bf" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=8dab3a3b" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=8a7e329d" />
    
    


<style>
  body {
    --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">DIP_SMC_PSO Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  <span class="sidebar-brand-text">DIP_SMC_PSO Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">📚 Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Optimal Sliding Mode Control for a Double-Inverted Pendulum via PSO  ## How to validate a ResearchPlan JSON Run the validator locally: ```bash</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory_overview.html">Theory Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../architecture.html">3. System Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plant_model.html">1.x Plant Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hil_quickstart.html">Hardware-in-the-Loop (HIL) Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../streamlit_dashboard_guide.html">Streamlit Dashboard User Guide</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/blob/main/docs/factory/configuration_migration_mathematical_foundations.md?plain=true" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div><div class="edit-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/edit/main/docs/factory/configuration_migration_mathematical_foundations.md" rel="edit" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <p>#==========================================================================================\<br />
#========= docs/factory/configuration_migration_mathematical_foundations.md ==========\<br />
#==========================================================================================\ # Configuration Migration Mathematical Foundations</p>
<section id="github-issue-6-factory-integration-scientific-validation-guide-overview-this-document-provides-the-mathematical-foundations-and-scientific-validation-for-configuration-migrations-in-the-enhanced-factory-system-it-bridges-control-theory-with-implementation-details-to-ensure-mathematically-sound-parameter-transformations-during-migration-mathematical-framework-for-parameter-migration-1-classical-smc-parameter-transformation-theoretical-foundation-classical-sliding-mode-control-uses-a-sliding-surface-designed-to-ensure-finite-time-convergence-to-the-desired-trajectory-the-mathematical-formulation-involves-sliding-surface-design">
<h1>GitHub Issue #6 Factory Integration - Scientific Validation Guide ### Overview This document provides the mathematical foundations and scientific validation for configuration migrations in the enhanced factory system. It bridges control theory with implementation details to ensure mathematically sound parameter transformations during migration. ## Mathematical Framework for Parameter Migration ### 1. Classical SMC Parameter Transformation #### <strong>Theoretical Foundation</strong> Classical Sliding Mode Control uses a sliding surface designed to ensure finite-time convergence to the desired trajectory. The mathematical formulation involves: <strong>Sliding Surface Design:</strong><a class="headerlink" href="#github-issue-6-factory-integration-scientific-validation-guide-overview-this-document-provides-the-mathematical-foundations-and-scientific-validation-for-configuration-migrations-in-the-enhanced-factory-system-it-bridges-control-theory-with-implementation-details-to-ensure-mathematically-sound-parameter-transformations-during-migration-mathematical-framework-for-parameter-migration-1-classical-smc-parameter-transformation-theoretical-foundation-classical-sliding-mode-control-uses-a-sliding-surface-designed-to-ensure-finite-time-convergence-to-the-desired-trajectory-the-mathematical-formulation-involves-sliding-surface-design" title="Link to this heading">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">λ</span><span class="err">₁</span><span class="n">e</span><span class="err">₁</span> <span class="o">+</span> <span class="n">λ</span><span class="err">₂</span><span class="n">e</span><span class="err">₂</span> <span class="o">+</span> <span class="n">ė</span><span class="err">₁</span> <span class="o">+</span> <span class="n">ė</span><span class="err">₂</span> <span class="o">+</span> <span class="n">γ</span><span class="err">₁∫</span><span class="n">e</span><span class="err">₁</span><span class="n">dt</span> <span class="o">+</span> <span class="n">γ</span><span class="err">₂∫</span><span class="n">e</span><span class="err">₂</span><span class="n">dt</span>
<span class="err">```</span> <span class="n">Where</span><span class="p">:</span>

<span class="o">-</span> <span class="err">`</span><span class="n">e</span><span class="err">₁</span><span class="p">,</span> <span class="n">e</span><span class="err">₂`</span><span class="p">:</span> <span class="n">Angular</span> <span class="n">position</span> <span class="n">errors</span> <span class="k">for</span> <span class="n">pendulums</span> <span class="mi">1</span> <span class="ow">and</span> <span class="mi">2</span>
<span class="o">-</span> <span class="err">`</span><span class="n">ė</span><span class="err">₁</span><span class="p">,</span> <span class="n">ė</span><span class="err">₂`</span><span class="p">:</span> <span class="n">Angular</span> <span class="n">velocity</span> <span class="n">errors</span>
<span class="o">-</span> <span class="err">`</span><span class="n">λ</span><span class="err">₁</span><span class="p">,</span> <span class="n">λ</span><span class="err">₂`</span><span class="p">:</span> <span class="n">Sliding</span> <span class="n">surface</span> <span class="n">coefficients</span> <span class="p">(</span><span class="n">must</span> <span class="n">satisfy</span> <span class="n">stability</span> <span class="n">conditions</span><span class="p">)</span>
<span class="o">-</span> <span class="err">`</span><span class="n">γ</span><span class="err">₁</span><span class="p">,</span> <span class="n">γ</span><span class="err">₂`</span><span class="p">:</span> <span class="n">Integral</span> <span class="n">terms</span> <span class="p">(</span><span class="n">optional</span> <span class="k">for</span> <span class="n">steady</span><span class="o">-</span><span class="n">state</span> <span class="n">error</span> <span class="n">elimination</span><span class="p">)</span> <span class="o">**</span><span class="n">Control</span> <span class="n">Law</span><span class="p">:</span><span class="o">**</span>
</pre></div>
</div>
<p>u = u_eq + u_n = u_eq - K·sign(s)</p>
<div class="highlight-Where: notranslate"><div class="highlight"><pre><span></span>
- `u_eq`: Equivalent control (model-based component)
- `u_n`: Discontinuous control (robustness component)
- `K`: Switching gain magnitude #### **Migration Parameter Mapping** ```python
# example-metadata:

# runnable: false def migrate_classical_smc_parameters_mathematical(old_params: Dict[str, Any]) -&gt; Dict[str, Any]: &quot;&quot;&quot; Mathematically sound migration for Classical SMC parameters. Mathematical Validation: 1. Preserve sliding surface eigenvalues 2. Maintain Lyapunov stability conditions 3. Ensure bounded control effort &quot;&quot;&quot; new_params = {} # Extract old gains structure old_gains = old_params.get(&#39;gains&#39;, []) K_switching = old_params.get(&#39;K_switching&#39;, 0.0) # Mathematical migration: [k1, k2, λ1, λ2, K] → [k1, k2, λ1, λ2, K, kd] if len(old_gains) == 5: k1, k2, lam1, lam2, K_old = old_gains # Validate stability conditions if lam1 &lt;= 0 or lam2 &lt;= 0: raise ValueError(&quot;Sliding surface coefficients λ₁, λ₂ must be positive for stability&quot;) if k1 &lt;= 0 or k2 &lt;= 0: raise ValueError(&quot;Proportional gains k₁, k₂ must be positive&quot;) # Combine switching gains: K_total = max(K_old, K_switching) K_total = max(K_old, K_switching) if K_switching &gt; 0 else K_old # Add derivative gain for chattering reduction kd = old_params.get(&#39;kd&#39;, K_total * 0.1) # 10% of switching gain new_params[&#39;gains&#39;] = [k1, k2, lam1, lam2, K_total, kd] # Validate sliding surface eigenvalues if &#39;gains&#39; in new_params: k1, k2, lam1, lam2, K, kd = new_params[&#39;gains&#39;] # Check sliding surface stability (simplified for double pendulum) eigenvalues = [-lam1/k1, -lam2/k2] # Approximate eigenvalues if any(eig &gt;= 0 for eig in eigenvalues): print(f&quot;Warning: Sliding surface may be unstable. Eigenvalues: {eigenvalues}&quot;) # Migrate deprecated parameters deprecated_mappings = { &#39;switch_function&#39;: &#39;switch_method&#39;, &#39;saturation_limit&#39;: &#39;max_force&#39;, &#39;boundary_thickness&#39;: &#39;boundary_layer&#39; } for old_param, new_param in deprecated_mappings.items(): if old_param in old_params: new_params[new_param] = old_params[old_param] # Ensure required parameters with physically meaningful defaults new_params.setdefault(&#39;max_force&#39;, 150.0) # Reasonable actuator limit [N] new_params.setdefault(&#39;boundary_layer&#39;, 0.02) # 2% of typical angular range new_params.setdefault(&#39;dt&#39;, 0.001) # 1ms sampling time return new_params # Mathematical validation example

old_classical_config = { &#39;gains&#39;: [20.0, 15.0, 12.0, 8.0, 35.0], # [k1, k2, λ1, λ2, K] &#39;K_switching&#39;: 5.0, &#39;switch_function&#39;: &#39;sign&#39;, &#39;saturation_limit&#39;: 100.0
} migrated_config = migrate_classical_smc_parameters_mathematical(old_classical_config)
print(&quot;Migrated Classical SMC config:&quot;, migrated_config)
``` ### 2. Adaptive SMC Parameter Transformation #### **Theoretical Foundation** Adaptive Sliding Mode Control adjusts gains online to handle parametric uncertainties. The mathematical framework includes: **Adaptation Law:**
</pre></div>
</div>
<p>K̇ = γ·|s|·sign(s·û) - σ·K</p>
<div class="highlight-Where: notranslate"><div class="highlight"><pre><span></span>- `γ`: Adaptation rate (positive constant)
- `σ`: Leak rate (prevents drift)
- `û`: Control direction estimate **Lyapunov Stability Condition:**
</pre></div>
</div>
<p>V̇ = s·ṡ + (1/γ)·K̃·K̃̇ ≤ -η·|s| - σ/γ·K̃²</p>
<div class="highlight-Where: notranslate"><div class="highlight"><pre><span></span>- `K̃ = K - K*`: Gain estimation error
- `η &gt; 0`: Convergence rate parameter #### **Migration Parameter Mapping** ```python
# example-metadata:
# runnable: false def migrate_adaptive_smc_parameters_mathematical(old_params: Dict[str, Any]) -&gt; Dict[str, Any]: &quot;&quot;&quot; Mathematically sound migration for Adaptive SMC parameters. Mathematical Validation: 1. Preserve adaptation law stability 2. Maintain Lyapunov convergence conditions 3. Ensure bounded parameter estimates &quot;&quot;&quot; new_params = {} # Extract old parameter structure old_gains = old_params.get(&#39;gains&#39;, []) adaptation_gain = old_params.get(&#39;adaptation_gain&#39;, 0.0) # Mathematical migration: [k1, k2, λ1, λ2] + γ → [k1, k2, λ1, λ2, γ] if len(old_gains) == 4: k1, k2, lam1, lam2 = old_gains # Validate stability conditions if lam1 &lt;= 0 or lam2 &lt;= 0: raise ValueError(&quot;Sliding surface coefficients λ₁, λ₂ must be positive&quot;) if k1 &lt;= 0 or k2 &lt;= 0: raise ValueError(&quot;Proportional gains k₁, k₂ must be positive&quot;) # Use provided adaptation gain or calculate from stability requirements if adaptation_gain &gt; 0: gamma = adaptation_gain else: # Calculate adaptation gain from stability margin # γ should be large enough for fast adaptation but not cause oscillations gamma = min(k1, k2) * 0.5 # Conservative choice # Validate adaptation rate bounds if gamma &lt;= 0: raise ValueError(&quot;Adaptation rate γ must be positive for convergence&quot;) if gamma &gt; 20.0: # Practical upper bound print(f&quot;Warning: High adaptation rate γ={gamma:.2f} may cause oscillations&quot;) new_params[&#39;gains&#39;] = [k1, k2, lam1, lam2, gamma] # Migration of adaptation parameters adaptation_mappings = { &#39;boundary_layer_thickness&#39;: &#39;boundary_layer&#39;, &#39;estimate_bounds&#39;: (&#39;K_min&#39;, &#39;K_max&#39;), # Special case: split parameter &#39;adaptation_law&#39;: &#39;alpha&#39;, &#39;leak_coefficient&#39;: &#39;leak_rate&#39; } for old_param, new_param in adaptation_mappings.items(): if old_param in old_params: if old_param == &#39;estimate_bounds&#39;: # Split bounds into separate parameters bounds = old_params[old_param] if isinstance(bounds, (list, tuple)) and len(bounds) == 2: new_params[&#39;K_min&#39;] = bounds[0] new_params[&#39;K_max&#39;] = bounds[1] # Validate bounds if new_params[&#39;K_min&#39;] &gt;= new_params[&#39;K_max&#39;]: raise ValueError(&quot;K_min must be less than K_max&quot;) if new_params[&#39;K_min&#39;] &lt;= 0: raise ValueError(&quot;K_min must be positive&quot;) else: new_params[new_param] = old_params[old_param] # Ensure required adaptation parameters with theoretical justification new_params.setdefault(&#39;leak_rate&#39;, 0.01) # 1% leak rate prevents drift new_params.setdefault(&#39;K_min&#39;, 0.1) # Minimum for controllability new_params.setdefault(&#39;K_max&#39;, 100.0) # Maximum for actuator limits new_params.setdefault(&#39;adapt_rate_limit&#39;, 10.0) # Prevent excessive adaptation new_params.setdefault(&#39;alpha&#39;, 0.5) # Compromise between speed and stability new_params.setdefault(&#39;dead_zone&#39;, 0.05) # Noise tolerance new_params.setdefault(&#39;boundary_layer&#39;, 0.01) # Smaller for adaptation new_params.setdefault(&#39;smooth_switch&#39;, True) # Reduce chattering # Validate adaptation stability conditions if &#39;gains&#39; in new_params and len(new_params[&#39;gains&#39;]) &gt;= 5: gamma = new_params[&#39;gains&#39;][4] leak_rate = new_params[&#39;leak_rate&#39;] # Check adaptation stability: σ/γ should be small for good tracking stability_ratio = leak_rate / gamma if stability_ratio &gt; 0.1: print(f&quot;Warning: High leak-to-adaptation ratio {stability_ratio:.3f} may degrade performance&quot;) return new_params # Mathematical validation example
old_adaptive_config = { &#39;gains&#39;: [25.0, 18.0, 15.0, 10.0], # [k1, k2, λ1, λ2] &#39;adaptation_gain&#39;: 4.0, &#39;boundary_layer_thickness&#39;: 0.02, &#39;estimate_bounds&#39;: [0.1, 100.0], &#39;adaptation_law&#39;: 0.5
} migrated_config = migrate_adaptive_smc_parameters_mathematical(old_adaptive_config)
print(&quot;Migrated Adaptive SMC config:&quot;, migrated_config)
``` ### 3. Super-Twisting SMC Parameter Transformation #### **Theoretical Foundation** Super-Twisting Algorithm provides finite-time convergence with continuous control. The mathematical formulation: **Super-Twisting Algorithm:**

</pre></div>
</div>
<p>u̇ = -K₂·sign(s)
u = -K₁·|s|^α·sign(s) + ∫u̇dt</p>
<div class="highlight-**Convergence notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<p>K₁ &gt; L/α (for some L &gt; 0)
K₂ &gt; K₁²/(2L) + L</p>
<div class="highlight-Where: notranslate"><div class="highlight"><pre><span></span>
- `α ∈ (0,1)`: Fractional power (typically 0.5)
- `L`: Lipschitz constant of disturbances #### **Migration Parameter Mapping** ```python
# example-metadata:

# runnable: false def migrate_sta_smc_parameters_mathematical(old_params: Dict[str, Any]) -&gt; Dict[str, Any]: &quot;&quot;&quot; Mathematically sound migration for Super-Twisting SMC parameters. Mathematical Validation: 1. Preserve finite-time convergence conditions 2. Maintain super-twisting stability requirements 3. Ensure proper algorithmic gain relationships &quot;&quot;&quot; new_params = {} # Extract separate K1, K2 parameters (old format) K1 = old_params.get(&#39;K1&#39;, 0.0) K2 = old_params.get(&#39;K2&#39;, 0.0) old_gains = old_params.get(&#39;gains&#39;, []) # Mathematical migration: separate K1,K2 + surface gains → unified gains array if K1 &gt; 0 and K2 &gt; 0: # Validate super-twisting convergence conditions alpha = old_params.get(&#39;alpha_power&#39;, 0.5) # Simplified convergence check (assumes L=1 for typical systems) L_estimate = 1.0 min_K1 = L_estimate / alpha min_K2 = K1**2 / (2 * L_estimate) + L_estimate if K1 &lt; min_K1: print(f&quot;Warning: K₁={K1:.2f} may be too small for convergence (min: {min_K1:.2f})&quot;) if K2 &lt; min_K2: print(f&quot;Warning: K₂={K2:.2f} may be too small for convergence (min: {min_K2:.2f})&quot;) # Extract surface gains or use defaults if len(old_gains) &gt;= 4: k1, k2, lam1, lam2 = old_gains[:4] else: # Default surface gains for double pendulum k1, k2, lam1, lam2 = 20.0, 15.0, 12.0, 8.0 # Validate surface gain positivity if any(g &lt;= 0 for g in [k1, k2, lam1, lam2]): raise ValueError(&quot;All surface gains must be positive&quot;) # Create unified gains array: [K1, K2, k1, k2, λ1, λ2] new_params[&#39;gains&#39;] = [K1, K2, k1, k2, lam1, lam2] elif len(old_gains) &gt;= 6: # Already in new format, validate convergence conditions K1, K2, k1, k2, lam1, lam2 = old_gains[:6] # Validate all gains are positive if any(g &lt;= 0 for g in [K1, K2, k1, k2, lam1, lam2]): raise ValueError(&quot;All STA-SMC gains must be positive&quot;) new_params[&#39;gains&#39;] = [K1, K2, k1, k2, lam1, lam2] # Migrate algorithm-specific parameters algorithm_mappings = { &#39;alpha_power&#39;: &#39;power_exponent&#39;, &#39;switching_function_type&#39;: &#39;switch_method&#39;, &#39;regularization_parameter&#39;: &#39;regularization&#39; } for old_param, new_param in algorithm_mappings.items(): if old_param in old_params: new_params[new_param] = old_params[old_param] # Ensure algorithm parameters with mathematical justification power_exp = new_params.get(&#39;power_exponent&#39;, 0.5) if not (0 &lt; power_exp &lt; 1): raise ValueError(f&quot;Power exponent α={power_exp} must be in (0,1) for finite-time convergence&quot;) new_params.setdefault(&#39;power_exponent&#39;, 0.5) # Optimal for most systems new_params.setdefault(&#39;regularization&#39;, 1e-6) # Numerical stability new_params.setdefault(&#39;boundary_layer&#39;, 0.01) # Small boundary for STA new_params.setdefault(&#39;switch_method&#39;, &#39;tanh&#39;) # Smooth switching new_params.setdefault(&#39;damping_gain&#39;, 0.0) # No additional damping by default # Advanced validation: Check Lyapunov function decrease rate if &#39;gains&#39; in new_params and len(new_params[&#39;gains&#39;]) &gt;= 6: K1, K2 = new_params[&#39;gains&#39;][:2] alpha = new_params[&#39;power_exponent&#39;] # Estimate convergence time (simplified analysis) T_convergence = 2 * (1 / (1 - alpha)) * (1 / min(K1, K2)**0.5) if T_convergence &gt; 10.0: # More than 10 seconds print(f&quot;Warning: Estimated convergence time {T_convergence:.2f}s may be too slow&quot;) return new_params # Mathematical validation example

old_sta_config = { &#39;K1&#39;: 35.0, &#39;K2&#39;: 20.0, &#39;gains&#39;: [25.0, 18.0, 12.0, 8.0], # Surface gains &#39;alpha_power&#39;: 0.5, &#39;switching_function_type&#39;: &#39;tanh&#39;, &#39;regularization_parameter&#39;: 1e-6
} migrated_config = migrate_sta_smc_parameters_mathematical(old_sta_config)
print(&quot;Migrated STA-SMC config:&quot;, migrated_config)
``` ### 4. Hybrid SMC Parameter Transformation #### **Theoretical Foundation** Hybrid Adaptive-STA SMC combines the benefits of adaptation and finite-time convergence. The mathematical framework involves: **Mode Switching Logic:**
</pre></div>
</div>
<p>Mode(t) = { Classical-Adaptive if ||e|| &gt; ε₁ STA-Adaptive if ε₂ &lt; ||e|| ≤ ε₁ Pure STA if ||e|| ≤ ε₂
}</p>
<div class="highlight-**Unified notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<p>s = c₁e₁ + λ₁ė₁ + c₂e₂ + λ₂ė₂
<code class="docutils literal notranslate"><span class="pre">Where</span> <span class="pre">the</span> <span class="pre">surface</span> <span class="pre">coefficients</span> <span class="pre">are</span> <span class="pre">shared</span> <span class="pre">across</span> <span class="pre">all</span> <span class="pre">modes</span> <span class="pre">for</span> <span class="pre">switching.</span> <span class="pre">####</span> <span class="pre">**Migration</span> <span class="pre">Parameter</span> <span class="pre">Mapping**</span></code>python</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="example-metadata">
<h1>example-metadata:<a class="headerlink" href="#example-metadata" title="Link to this heading">¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-def-migrate-hybrid-smc-parameters-mathematical-old-params-dict-str-any-dict-str-any-mathematically-sound-migration-for-hybrid-smc-parameters-mathematical-validation-1-preserve-mode-switching-stability-2-maintain-unified-surface-design-3-ensure-sub-controller-compatibility-new-params-extract-surface-gains-shared-across-all-modes-surface-gains-old-params-get-gains-18-0-12-0-10-0-8-0-if-len-surface-gains-4-raise-valueerror-hybrid-smc-requires-exactly-4-surface-gains-c1-1-c2-2-c1-lam1-c2-lam2-surface-gains-validate-surface-stability-if-any-g-0-for-g-in-c1-lam1-c2-lam2-raise-valueerror-all-surface-coefficients-must-be-positive-check-surface-eigenvalue-placement-for-stability-eigen1-lam1-c1-eigen2-lam2-c2-if-eigen1-0-or-eigen2-0-print-f-warning-surface-eigenvalues-eigen1-3f-eigen2-3f-may-indicate-instability-new-params-gains-surface-gains-handle-mode-parameter-migration-mode-mappings-mode-hybrid-mode-switch-threshold-switching-criteria-classical-params-classical-config-adaptive-params-adaptive-config-for-old-param-new-param-in-mode-mappings-items-if-old-param-in-old-params-if-old-param-switch-threshold-convert-scalar-threshold-to-criteria-dict-threshold-old-params-old-param-new-params-switching-criteria-error-threshold-threshold-time-threshold-2-0-default-time-threshold-performance-threshold-0-1-performance-based-switching-else-new-params-new-param-old-params-old-param-handle-sub-controller-gain-migration-if-sub-controller-gains-in-old-params-sub-gains-old-params-sub-controller-gains-if-isinstance-sub-gains-dict-create-proper-sub-controller-configurations-classical-gains-sub-gains-get-classical-20-0-15-0-12-0-8-0-35-0-5-0-adaptive-gains-sub-gains-get-adaptive-25-0-18-0-15-0-10-0-4-0-validate-sub-controller-gains-if-len-classical-gains-6-raise-valueerror-classical-sub-controller-requires-6-gains-if-len-adaptive-gains-5-raise-valueerror-adaptive-sub-controller-requires-5-gains-create-complete-sub-configurations-with-surface-coupling-new-params-classical-config-gains-classical-gains-max-force-old-params-get-max-force-150-0-boundary-layer-0-02-dt-old-params-get-dt-0-001-surface-coupling-true-ensure-surface-consistency-new-params-adaptive-config-gains-adaptive-gains-max-force-old-params-get-max-force-150-0-leak-rate-0-01-adapt-rate-limit-10-0-k-min-0-1-k-max-100-0-dt-old-params-get-dt-0-001-surface-coupling-true-ensure-surface-consistency-set-hybrid-specific-parameters-with-mathematical-justification-new-params-setdefault-hybrid-mode-classical-adaptive-conservative-default-new-params-setdefault-dt-0-001-fast-sampling-for-mode-switching-new-params-setdefault-max-force-150-0-shared-actuator-limit-advanced-hybrid-parameters-new-params-setdefault-mode-hysteresis-0-1-prevent-chattering-in-mode-switching-new-params-setdefault-transition-smoothing-true-smooth-mode-transitions-new-params-setdefault-surface-consistency-check-true-validate-surface-compatibility-validate-hybrid-mode-switching-stability-if-switching-criteria-in-new-params-criteria-new-params-switching-criteria-error-thresh-criteria-get-error-threshold-0-1-time-thresh-criteria-get-time-threshold-2-0-check-switching-frequency-to-prevent-chattering-min-dwell-time-0-1-minimum-time-in-each-mode-if-time-thresh-min-dwell-time-print-f-warning-short-time-threshold-time-thresh-s-may-cause-mode-chattering-return-new-params-mathematical-validation-example">
<h1>runnable: false def migrate_hybrid_smc_parameters_mathematical(old_params: Dict[str, Any]) -&gt; Dict[str, Any]: “”” Mathematically sound migration for Hybrid SMC parameters. Mathematical Validation: 1. Preserve mode switching stability 2. Maintain unified surface design 3. Ensure sub-controller compatibility “”” new_params = {} # Extract surface gains (shared across all modes) surface_gains = old_params.get(‘gains’, [18.0, 12.0, 10.0, 8.0]) if len(surface_gains) != 4: raise ValueError(“Hybrid SMC requires exactly 4 surface gains [c₁, λ₁, c₂, λ₂]”) c1, lam1, c2, lam2 = surface_gains # Validate surface stability if any(g &lt;= 0 for g in [c1, lam1, c2, lam2]): raise ValueError(“All surface coefficients must be positive”) # Check surface eigenvalue placement for stability eigen1 = -lam1 / c1 eigen2 = -lam2 / c2 if eigen1 &gt;= 0 or eigen2 &gt;= 0: print(f”Warning: Surface eigenvalues [{eigen1:.3f}, {eigen2:.3f}] may indicate instability”) new_params[‘gains’] = surface_gains # Handle mode parameter migration mode_mappings = { ‘mode’: ‘hybrid_mode’, ‘switch_threshold’: ‘switching_criteria’, ‘classical_params’: ‘classical_config’, ‘adaptive_params’: ‘adaptive_config’ } for old_param, new_param in mode_mappings.items(): if old_param in old_params: if old_param == ‘switch_threshold’: # Convert scalar threshold to criteria dict threshold = old_params[old_param] new_params[‘switching_criteria’] = { ‘error_threshold’: threshold, ‘time_threshold’: 2.0, # Default time threshold ‘performance_threshold’: 0.1 # Performance-based switching } else: new_params[new_param] = old_params[old_param] # Handle sub-controller gain migration if ‘sub_controller_gains’ in old_params: sub_gains = old_params[‘sub_controller_gains’] if isinstance(sub_gains, dict): # Create proper sub-controller configurations classical_gains = sub_gains.get(‘classical’, [20.0, 15.0, 12.0, 8.0, 35.0, 5.0]) adaptive_gains = sub_gains.get(‘adaptive’, [25.0, 18.0, 15.0, 10.0, 4.0]) # Validate sub-controller gains if len(classical_gains) != 6: raise ValueError(“Classical sub-controller requires 6 gains”) if len(adaptive_gains) != 5: raise ValueError(“Adaptive sub-controller requires 5 gains”) # Create complete sub-configurations with surface coupling new_params[‘classical_config’] = { ‘gains’: classical_gains, ‘max_force’: old_params.get(‘max_force’, 150.0), ‘boundary_layer’: 0.02, ‘dt’: old_params.get(‘dt’, 0.001), ‘surface_coupling’: True # Ensure surface consistency } new_params[‘adaptive_config’] = { ‘gains’: adaptive_gains, ‘max_force’: old_params.get(‘max_force’, 150.0), ‘leak_rate’: 0.01, ‘adapt_rate_limit’: 10.0, ‘K_min’: 0.1, ‘K_max’: 100.0, ‘dt’: old_params.get(‘dt’, 0.001), ‘surface_coupling’: True # Ensure surface consistency } # Set hybrid-specific parameters with mathematical justification new_params.setdefault(‘hybrid_mode’, ‘CLASSICAL_ADAPTIVE’) # Conservative default new_params.setdefault(‘dt’, 0.001) # Fast sampling for mode switching new_params.setdefault(‘max_force’, 150.0) # Shared actuator limit # Advanced hybrid parameters new_params.setdefault(‘mode_hysteresis’, 0.1) # Prevent chattering in mode switching new_params.setdefault(‘transition_smoothing’, True) # Smooth mode transitions new_params.setdefault(‘surface_consistency_check’, True) # Validate surface compatibility # Validate hybrid mode switching stability if ‘switching_criteria’ in new_params: criteria = new_params[‘switching_criteria’] error_thresh = criteria.get(‘error_threshold’, 0.1) time_thresh = criteria.get(‘time_threshold’, 2.0) # Check switching frequency to prevent chattering min_dwell_time = 0.1 # Minimum time in each mode if time_thresh &lt; min_dwell_time: print(f”Warning: Short time threshold {time_thresh}s may cause mode chattering”) return new_params # Mathematical validation example<a class="headerlink" href="#runnable-false-def-migrate-hybrid-smc-parameters-mathematical-old-params-dict-str-any-dict-str-any-mathematically-sound-migration-for-hybrid-smc-parameters-mathematical-validation-1-preserve-mode-switching-stability-2-maintain-unified-surface-design-3-ensure-sub-controller-compatibility-new-params-extract-surface-gains-shared-across-all-modes-surface-gains-old-params-get-gains-18-0-12-0-10-0-8-0-if-len-surface-gains-4-raise-valueerror-hybrid-smc-requires-exactly-4-surface-gains-c1-1-c2-2-c1-lam1-c2-lam2-surface-gains-validate-surface-stability-if-any-g-0-for-g-in-c1-lam1-c2-lam2-raise-valueerror-all-surface-coefficients-must-be-positive-check-surface-eigenvalue-placement-for-stability-eigen1-lam1-c1-eigen2-lam2-c2-if-eigen1-0-or-eigen2-0-print-f-warning-surface-eigenvalues-eigen1-3f-eigen2-3f-may-indicate-instability-new-params-gains-surface-gains-handle-mode-parameter-migration-mode-mappings-mode-hybrid-mode-switch-threshold-switching-criteria-classical-params-classical-config-adaptive-params-adaptive-config-for-old-param-new-param-in-mode-mappings-items-if-old-param-in-old-params-if-old-param-switch-threshold-convert-scalar-threshold-to-criteria-dict-threshold-old-params-old-param-new-params-switching-criteria-error-threshold-threshold-time-threshold-2-0-default-time-threshold-performance-threshold-0-1-performance-based-switching-else-new-params-new-param-old-params-old-param-handle-sub-controller-gain-migration-if-sub-controller-gains-in-old-params-sub-gains-old-params-sub-controller-gains-if-isinstance-sub-gains-dict-create-proper-sub-controller-configurations-classical-gains-sub-gains-get-classical-20-0-15-0-12-0-8-0-35-0-5-0-adaptive-gains-sub-gains-get-adaptive-25-0-18-0-15-0-10-0-4-0-validate-sub-controller-gains-if-len-classical-gains-6-raise-valueerror-classical-sub-controller-requires-6-gains-if-len-adaptive-gains-5-raise-valueerror-adaptive-sub-controller-requires-5-gains-create-complete-sub-configurations-with-surface-coupling-new-params-classical-config-gains-classical-gains-max-force-old-params-get-max-force-150-0-boundary-layer-0-02-dt-old-params-get-dt-0-001-surface-coupling-true-ensure-surface-consistency-new-params-adaptive-config-gains-adaptive-gains-max-force-old-params-get-max-force-150-0-leak-rate-0-01-adapt-rate-limit-10-0-k-min-0-1-k-max-100-0-dt-old-params-get-dt-0-001-surface-coupling-true-ensure-surface-consistency-set-hybrid-specific-parameters-with-mathematical-justification-new-params-setdefault-hybrid-mode-classical-adaptive-conservative-default-new-params-setdefault-dt-0-001-fast-sampling-for-mode-switching-new-params-setdefault-max-force-150-0-shared-actuator-limit-advanced-hybrid-parameters-new-params-setdefault-mode-hysteresis-0-1-prevent-chattering-in-mode-switching-new-params-setdefault-transition-smoothing-true-smooth-mode-transitions-new-params-setdefault-surface-consistency-check-true-validate-surface-compatibility-validate-hybrid-mode-switching-stability-if-switching-criteria-in-new-params-criteria-new-params-switching-criteria-error-thresh-criteria-get-error-threshold-0-1-time-thresh-criteria-get-time-threshold-2-0-check-switching-frequency-to-prevent-chattering-min-dwell-time-0-1-minimum-time-in-each-mode-if-time-thresh-min-dwell-time-print-f-warning-short-time-threshold-time-thresh-s-may-cause-mode-chattering-return-new-params-mathematical-validation-example" title="Link to this heading">¶</a></h1>
<p>old_hybrid_config = { ‘gains’: [18.0, 12.0, 10.0, 8.0], # Surface gains ‘mode’: ‘CLASSICAL_ADAPTIVE’, ‘sub_controller_gains’: { ‘classical’: [20.0, 15.0, 12.0, 8.0, 35.0, 5.0], ‘adaptive’: [25.0, 18.0, 15.0, 10.0, 4.0] }, ‘switch_threshold’: 0.1, ‘max_force’: 150.0
} migrated_config = migrate_hybrid_smc_parameters_mathematical(old_hybrid_config)
print(“Migrated Hybrid SMC config:”, migrated_config)
<code class="docutils literal notranslate"><span class="pre">##</span> <span class="pre">Scientific</span> <span class="pre">Validation</span> <span class="pre">Framework</span> <span class="pre">###</span> <span class="pre">1.</span> <span class="pre">**Stability</span> <span class="pre">Preservation</span> <span class="pre">Validation**</span></code>python</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1>example-metadata:<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-class-stabilityvalidator-validate-stability-preservation-during-parameter-migration-staticmethod-def-validate-classical-smc-stability-gains-list-float-dict-str-any-validate-classical-smc-stability-conditions-if-len-gains-6-return-valid-false-reason-invalid-gain-count-k1-k2-lam1-lam2-k-kd-gains-check-basic-positivity-if-any-g-0-for-g-in-gains-return-valid-false-reason-all-gains-must-be-positive-check-sliding-surface-stability-for-double-pendulum-sliding-surface-eigenvalues-should-be-negative-surface-eigs-lam1-k1-lam2-k2-if-any-eig-0-for-eig-in-surface-eigs-return-valid-false-reason-f-unstable-surface-eigenvalues-surface-eigs-check-actuator-reasonableness-if-k-200-very-high-switching-gain-return-valid-true-warnings-f-high-switching-gain-k-k-may-cause-excessive-chattering-check-derivative-gain-ratio-kd-ratio-kd-k-if-kd-ratio-0-5-derivative-gain-too-large-relative-to-switching-gain-return-valid-true-warnings-f-high-derivative-gain-ratio-kd-ratio-2f-may-degrade-performance-return-valid-true-surface-eigenvalues-surface-eigs-estimated-convergence-rate-min-abs-eig-for-eig-in-surface-eigs-switching-magnitude-k-chattering-reduction-kd-staticmethod-def-validate-adaptive-smc-convergence-gains-list-float-adaptation-params-dict-str-float-dict-str-any-validate-adaptive-smc-convergence-conditions-if-len-gains-5-return-valid-false-reason-invalid-gain-count-k1-k2-lam1-lam2-gamma-gains-check-basic-conditions-if-any-g-0-for-g-in-gains-return-valid-false-reason-all-gains-must-be-positive-check-adaptation-stability-leak-rate-adaptation-params-get-leak-rate-0-01-k-min-adaptation-params-get-k-min-0-1-k-max-adaptation-params-get-k-max-100-0-adaptation-stability-condition-leak-rate-should-be-small-relative-to-adaptation-rate-stability-margin-leak-rate-gamma-if-stability-margin-0-2-return-valid-true-warnings-f-high-leak-to-adaptation-ratio-stability-margin-3f-may-slow-convergence-check-adaptation-bounds-if-k-min-k-max-return-valid-false-reason-k-min-must-be-less-than-k-max-gain-ratio-k-max-k-min-if-gain-ratio-1000-very-wide-adaptation-range-return-valid-true-warnings-f-wide-adaptation-range-ratio-gain-ratio-1f-may-cause-instability-return-valid-true-adaptation-rate-gamma-stability-margin-stability-margin-adaptation-range-k-min-k-max-estimated-settling-time-5-0-min-lam1-k1-lam2-k2-rough-estimate-staticmethod-def-validate-sta-smc-finite-time-convergence-gains-list-float-algorithm-params-dict-str-float-dict-str-any-validate-super-twisting-finite-time-convergence-conditions-if-len-gains-6-return-valid-false-reason-invalid-gain-count-k1-k2-k1-k2-lam1-lam2-gains-check-basic-positivity-if-any-g-0-for-g-in-gains-return-valid-false-reason-all-gains-must-be-positive-check-super-twisting-convergence-conditions-alpha-algorithm-params-get-power-exponent-0-5-if-not-0-alpha-1-return-valid-false-reason-f-power-exponent-alpha-must-be-in-0-1-simplified-convergence-check-assumes-l-1-l-estimate-1-0-min-k1-l-estimate-alpha-min-k2-k1-2-2-l-estimate-l-estimate-warnings-if-k1-min-k1-warnings-append-f-k1-k1-2f-may-be-too-small-for-convergence-recommended-min-k1-2f-if-k2-min-k2-warnings-append-f-k2-k2-2f-may-be-too-small-for-convergence-recommended-min-k2-2f-estimate-finite-time-convergence-convergence-time-2-1-1-alpha-1-min-k1-k2-0-5-return-valid-true-warnings-warnings-algorithmic-gains-k1-k2-surface-gains-k1-k2-lam1-lam2-power-exponent-alpha-estimated-convergence-time-convergence-time-convergence-conditions-met-len-warnings-0-validation-example">
<h1>runnable: false class StabilityValidator: “””Validate stability preservation during parameter migration.””” &#64;staticmethod def validate_classical_smc_stability(gains: List[float]) -&gt; Dict[str, Any]: “””Validate Classical SMC stability conditions.””” if len(gains) != 6: return {‘valid’: False, ‘reason’: ‘Invalid gain count’} k1, k2, lam1, lam2, K, kd = gains # Check basic positivity if any(g &lt;= 0 for g in gains): return {‘valid’: False, ‘reason’: ‘All gains must be positive’} # Check sliding surface stability # For double pendulum: sliding surface eigenvalues should be negative surface_eigs = [-lam1/k1, -lam2/k2] if any(eig &gt;= 0 for eig in surface_eigs): return {‘valid’: False, ‘reason’: f’Unstable surface eigenvalues: {surface_eigs}’} # Check actuator reasonableness if K &gt; 200: # Very high switching gain return { ‘valid’: True, ‘warnings’: [f’High switching gain K={K} may cause excessive chattering’] } # Check derivative gain ratio kd_ratio = kd / K if kd_ratio &gt; 0.5: # Derivative gain too large relative to switching gain return { ‘valid’: True, ‘warnings’: [f’High derivative gain ratio {kd_ratio:.2f} may degrade performance’] } return { ‘valid’: True, ‘surface_eigenvalues’: surface_eigs, ‘estimated_convergence_rate’: min(abs(eig) for eig in surface_eigs), ‘switching_magnitude’: K, ‘chattering_reduction’: kd } &#64;staticmethod def validate_adaptive_smc_convergence(gains: List[float], adaptation_params: Dict[str, float]) -&gt; Dict[str, Any]: “””Validate Adaptive SMC convergence conditions.””” if len(gains) != 5: return {‘valid’: False, ‘reason’: ‘Invalid gain count’} k1, k2, lam1, lam2, gamma = gains # Check basic conditions if any(g &lt;= 0 for g in gains): return {‘valid’: False, ‘reason’: ‘All gains must be positive’} # Check adaptation stability leak_rate = adaptation_params.get(‘leak_rate’, 0.01) K_min = adaptation_params.get(‘K_min’, 0.1) K_max = adaptation_params.get(‘K_max’, 100.0) # Adaptation stability condition: leak rate should be small relative to adaptation rate stability_margin = leak_rate / gamma if stability_margin &gt; 0.2: return { ‘valid’: True, ‘warnings’: [f’High leak-to-adaptation ratio {stability_margin:.3f} may slow convergence’] } # Check adaptation bounds if K_min &gt;= K_max: return {‘valid’: False, ‘reason’: ‘K_min must be less than K_max’} gain_ratio = K_max / K_min if gain_ratio &gt; 1000: # Very wide adaptation range return { ‘valid’: True, ‘warnings’: [f’Wide adaptation range (ratio: {gain_ratio:.1f}) may cause instability’] } return { ‘valid’: True, ‘adaptation_rate’: gamma, ‘stability_margin’: stability_margin, ‘adaptation_range’: [K_min, K_max], ‘estimated_settling_time’: 5.0 / min(lam1/k1, lam2/k2) # Rough estimate } &#64;staticmethod def validate_sta_smc_finite_time_convergence(gains: List[float], algorithm_params: Dict[str, float]) -&gt; Dict[str, Any]: “””Validate Super-Twisting finite-time convergence conditions.””” if len(gains) != 6: return {‘valid’: False, ‘reason’: ‘Invalid gain count’} K1, K2, k1, k2, lam1, lam2 = gains # Check basic positivity if any(g &lt;= 0 for g in gains): return {‘valid’: False, ‘reason’: ‘All gains must be positive’} # Check super-twisting convergence conditions alpha = algorithm_params.get(‘power_exponent’, 0.5) if not (0 &lt; alpha &lt; 1): return {‘valid’: False, ‘reason’: f’Power exponent α={alpha} must be in (0,1)’} # Simplified convergence check (assumes L=1) L_estimate = 1.0 min_K1 = L_estimate / alpha min_K2 = K1**2 / (2 * L_estimate) + L_estimate warnings = [] if K1 &lt; min_K1: warnings.append(f’K₁={K1:.2f} may be too small for convergence (recommended: ≥{min_K1:.2f})’) if K2 &lt; min_K2: warnings.append(f’K₂={K2:.2f} may be too small for convergence (recommended: ≥{min_K2:.2f})’) # Estimate finite-time convergence convergence_time = 2 * (1 / (1 - alpha)) * (1 / min(K1, K2)**0.5) return { ‘valid’: True, ‘warnings’: warnings, ‘algorithmic_gains’: [K1, K2], ‘surface_gains’: [k1, k2, lam1, lam2], ‘power_exponent’: alpha, ‘estimated_convergence_time’: convergence_time, ‘convergence_conditions_met’: len(warnings) == 0 } # Validation example<a class="headerlink" href="#runnable-false-class-stabilityvalidator-validate-stability-preservation-during-parameter-migration-staticmethod-def-validate-classical-smc-stability-gains-list-float-dict-str-any-validate-classical-smc-stability-conditions-if-len-gains-6-return-valid-false-reason-invalid-gain-count-k1-k2-lam1-lam2-k-kd-gains-check-basic-positivity-if-any-g-0-for-g-in-gains-return-valid-false-reason-all-gains-must-be-positive-check-sliding-surface-stability-for-double-pendulum-sliding-surface-eigenvalues-should-be-negative-surface-eigs-lam1-k1-lam2-k2-if-any-eig-0-for-eig-in-surface-eigs-return-valid-false-reason-f-unstable-surface-eigenvalues-surface-eigs-check-actuator-reasonableness-if-k-200-very-high-switching-gain-return-valid-true-warnings-f-high-switching-gain-k-k-may-cause-excessive-chattering-check-derivative-gain-ratio-kd-ratio-kd-k-if-kd-ratio-0-5-derivative-gain-too-large-relative-to-switching-gain-return-valid-true-warnings-f-high-derivative-gain-ratio-kd-ratio-2f-may-degrade-performance-return-valid-true-surface-eigenvalues-surface-eigs-estimated-convergence-rate-min-abs-eig-for-eig-in-surface-eigs-switching-magnitude-k-chattering-reduction-kd-staticmethod-def-validate-adaptive-smc-convergence-gains-list-float-adaptation-params-dict-str-float-dict-str-any-validate-adaptive-smc-convergence-conditions-if-len-gains-5-return-valid-false-reason-invalid-gain-count-k1-k2-lam1-lam2-gamma-gains-check-basic-conditions-if-any-g-0-for-g-in-gains-return-valid-false-reason-all-gains-must-be-positive-check-adaptation-stability-leak-rate-adaptation-params-get-leak-rate-0-01-k-min-adaptation-params-get-k-min-0-1-k-max-adaptation-params-get-k-max-100-0-adaptation-stability-condition-leak-rate-should-be-small-relative-to-adaptation-rate-stability-margin-leak-rate-gamma-if-stability-margin-0-2-return-valid-true-warnings-f-high-leak-to-adaptation-ratio-stability-margin-3f-may-slow-convergence-check-adaptation-bounds-if-k-min-k-max-return-valid-false-reason-k-min-must-be-less-than-k-max-gain-ratio-k-max-k-min-if-gain-ratio-1000-very-wide-adaptation-range-return-valid-true-warnings-f-wide-adaptation-range-ratio-gain-ratio-1f-may-cause-instability-return-valid-true-adaptation-rate-gamma-stability-margin-stability-margin-adaptation-range-k-min-k-max-estimated-settling-time-5-0-min-lam1-k1-lam2-k2-rough-estimate-staticmethod-def-validate-sta-smc-finite-time-convergence-gains-list-float-algorithm-params-dict-str-float-dict-str-any-validate-super-twisting-finite-time-convergence-conditions-if-len-gains-6-return-valid-false-reason-invalid-gain-count-k1-k2-k1-k2-lam1-lam2-gains-check-basic-positivity-if-any-g-0-for-g-in-gains-return-valid-false-reason-all-gains-must-be-positive-check-super-twisting-convergence-conditions-alpha-algorithm-params-get-power-exponent-0-5-if-not-0-alpha-1-return-valid-false-reason-f-power-exponent-alpha-must-be-in-0-1-simplified-convergence-check-assumes-l-1-l-estimate-1-0-min-k1-l-estimate-alpha-min-k2-k1-2-2-l-estimate-l-estimate-warnings-if-k1-min-k1-warnings-append-f-k1-k1-2f-may-be-too-small-for-convergence-recommended-min-k1-2f-if-k2-min-k2-warnings-append-f-k2-k2-2f-may-be-too-small-for-convergence-recommended-min-k2-2f-estimate-finite-time-convergence-convergence-time-2-1-1-alpha-1-min-k1-k2-0-5-return-valid-true-warnings-warnings-algorithmic-gains-k1-k2-surface-gains-k1-k2-lam1-lam2-power-exponent-alpha-estimated-convergence-time-convergence-time-convergence-conditions-met-len-warnings-0-validation-example" title="Link to this heading">¶</a></h1>
<p>gains = [20.0, 15.0, 12.0, 8.0, 35.0, 5.0]
validation = StabilityValidator.validate_classical_smc_stability(gains)
print(“Stability validation:”, validation)
<code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">2.</span> <span class="pre">**Performance</span> <span class="pre">Preservation</span> <span class="pre">Analysis**</span></code>python</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id2">
<h1>example-metadata:<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-class-performanceanalyzer-analyze-performance-preservation-during-migration-staticmethod-def-analyze-control-bandwidth-old-gains-list-float-new-gains-list-float-controller-type-str-dict-str-any-analyze-control-bandwidth-preservation-if-controller-type-classical-smc-if-len-old-gains-4-and-len-new-gains-4-old-bandwidth-min-old-gains-2-old-gains-3-min-1-2-new-bandwidth-min-new-gains-2-new-gains-3-bandwidth-ratio-new-bandwidth-old-bandwidth-return-old-bandwidth-old-bandwidth-new-bandwidth-new-bandwidth-bandwidth-ratio-bandwidth-ratio-performance-preserved-0-8-bandwidth-ratio-1-2-20-tolerance-elif-controller-type-adaptive-smc-if-len-old-gains-4-and-len-new-gains-4-old-adaptation-rate-old-gains-4-if-len-old-gains-4-else-1-0-new-adaptation-rate-new-gains-4-if-len-new-gains-4-else-1-0-adaptation-ratio-new-adaptation-rate-old-adaptation-rate-return-old-adaptation-rate-old-adaptation-rate-new-adaptation-rate-new-adaptation-rate-adaptation-ratio-adaptation-ratio-performance-preserved-0-5-adaptation-ratio-2-0-100-tolerance-return-analysis-not-applicable-controller-type-controller-type-staticmethod-def-estimate-settling-time-change-old-config-dict-str-any-new-config-dict-str-any-dict-str-any-estimate-settling-time-changes-after-migration-old-gains-old-config-get-gains-new-gains-new-config-get-gains-if-len-old-gains-4-and-len-new-gains-4-simplified-settling-time-estimate-based-on-surface-coefficients-old-settling-4-0-min-old-gains-2-old-gains-3-4-min-1-2-new-settling-4-0-min-new-gains-2-new-gains-3-settling-ratio-new-settling-old-settling-return-old-settling-time-old-settling-new-settling-time-new-settling-settling-ratio-settling-ratio-performance-change-improved-if-settling-ratio-1-0-else-degraded-if-settling-ratio-1-1-else-maintained-return-analysis-insufficient-data-performance-analysis-example">
<h1>runnable: false class PerformanceAnalyzer: “””Analyze performance preservation during migration.””” &#64;staticmethod def analyze_control_bandwidth(old_gains: List[float], new_gains: List[float], controller_type: str) -&gt; Dict[str, Any]: “””Analyze control bandwidth preservation.””” if controller_type == ‘classical_smc’: if len(old_gains) &gt;= 4 and len(new_gains) &gt;= 4: old_bandwidth = min(old_gains[2], old_gains[3]) # min(λ1, λ2) new_bandwidth = min(new_gains[2], new_gains[3]) bandwidth_ratio = new_bandwidth / old_bandwidth return { ‘old_bandwidth’: old_bandwidth, ‘new_bandwidth’: new_bandwidth, ‘bandwidth_ratio’: bandwidth_ratio, ‘performance_preserved’: 0.8 &lt;= bandwidth_ratio &lt;= 1.2 # ±20% tolerance } elif controller_type == ‘adaptive_smc’: if len(old_gains) &gt;= 4 and len(new_gains) &gt;= 4: old_adaptation_rate = old_gains[4] if len(old_gains) &gt; 4 else 1.0 new_adaptation_rate = new_gains[4] if len(new_gains) &gt; 4 else 1.0 adaptation_ratio = new_adaptation_rate / old_adaptation_rate return { ‘old_adaptation_rate’: old_adaptation_rate, ‘new_adaptation_rate’: new_adaptation_rate, ‘adaptation_ratio’: adaptation_ratio, ‘performance_preserved’: 0.5 &lt;= adaptation_ratio &lt;= 2.0 # ±100% tolerance } return {‘analysis’: ‘not_applicable’, ‘controller_type’: controller_type} &#64;staticmethod def estimate_settling_time_change(old_config: Dict[str, Any], new_config: Dict[str, Any]) -&gt; Dict[str, Any]: “””Estimate settling time changes after migration.””” old_gains = old_config.get(‘gains’, []) new_gains = new_config.get(‘gains’, []) if len(old_gains) &gt;= 4 and len(new_gains) &gt;= 4: # Simplified settling time estimate based on surface coefficients old_settling = 4.0 / min(old_gains[2], old_gains[3]) # 4/min(λ1, λ2) new_settling = 4.0 / min(new_gains[2], new_gains[3]) settling_ratio = new_settling / old_settling return { ‘old_settling_time’: old_settling, ‘new_settling_time’: new_settling, ‘settling_ratio’: settling_ratio, ‘performance_change’: ‘improved’ if settling_ratio &lt; 1.0 else ‘degraded’ if settling_ratio &gt; 1.1 else ‘maintained’ } return {‘analysis’: ‘insufficient_data’} # Performance analysis example<a class="headerlink" href="#runnable-false-class-performanceanalyzer-analyze-performance-preservation-during-migration-staticmethod-def-analyze-control-bandwidth-old-gains-list-float-new-gains-list-float-controller-type-str-dict-str-any-analyze-control-bandwidth-preservation-if-controller-type-classical-smc-if-len-old-gains-4-and-len-new-gains-4-old-bandwidth-min-old-gains-2-old-gains-3-min-1-2-new-bandwidth-min-new-gains-2-new-gains-3-bandwidth-ratio-new-bandwidth-old-bandwidth-return-old-bandwidth-old-bandwidth-new-bandwidth-new-bandwidth-bandwidth-ratio-bandwidth-ratio-performance-preserved-0-8-bandwidth-ratio-1-2-20-tolerance-elif-controller-type-adaptive-smc-if-len-old-gains-4-and-len-new-gains-4-old-adaptation-rate-old-gains-4-if-len-old-gains-4-else-1-0-new-adaptation-rate-new-gains-4-if-len-new-gains-4-else-1-0-adaptation-ratio-new-adaptation-rate-old-adaptation-rate-return-old-adaptation-rate-old-adaptation-rate-new-adaptation-rate-new-adaptation-rate-adaptation-ratio-adaptation-ratio-performance-preserved-0-5-adaptation-ratio-2-0-100-tolerance-return-analysis-not-applicable-controller-type-controller-type-staticmethod-def-estimate-settling-time-change-old-config-dict-str-any-new-config-dict-str-any-dict-str-any-estimate-settling-time-changes-after-migration-old-gains-old-config-get-gains-new-gains-new-config-get-gains-if-len-old-gains-4-and-len-new-gains-4-simplified-settling-time-estimate-based-on-surface-coefficients-old-settling-4-0-min-old-gains-2-old-gains-3-4-min-1-2-new-settling-4-0-min-new-gains-2-new-gains-3-settling-ratio-new-settling-old-settling-return-old-settling-time-old-settling-new-settling-time-new-settling-settling-ratio-settling-ratio-performance-change-improved-if-settling-ratio-1-0-else-degraded-if-settling-ratio-1-1-else-maintained-return-analysis-insufficient-data-performance-analysis-example" title="Link to this heading">¶</a></h1>
<p>old_config = {‘gains’: [20, 15, 12, 8, 35]}
new_config = {‘gains’: [20, 15, 12, 8, 35, 5]} bandwidth_analysis = PerformanceAnalyzer.analyze_control_bandwidth( old_config[‘gains’], new_config[‘gains’], ‘classical_smc’
)
print(“Bandwidth analysis:”, bandwidth_analysis) settling_analysis = PerformanceAnalyzer.estimate_settling_time_change(old_config, new_config)
print(“Settling time analysis:”, settling_analysis)
<code class="docutils literal notranslate"><span class="pre">##</span> <span class="pre">Migration</span> <span class="pre">Validation</span> <span class="pre">Test</span> <span class="pre">Suite</span> <span class="pre">###</span> <span class="pre">**Migration</span> <span class="pre">Testing**</span></code>python</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id3">
<h1>example-metadata:<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-class-migrationvalidationsuite-test-suite-for-migration-validation-def-init-self-self-test-results-def-run-full-validation-self-old-config-dict-str-any-new-config-dict-str-any-controller-type-str-dict-str-any-run-migration-validation-results-controller-type-controller-type-migration-successful-true-tests-warnings-errors-test-1-parameter-count-validation-results-tests-parameter-count-self-test-parameter-count-old-config-new-config-controller-type-test-2-stability-preservation-results-tests-stability-self-test-stability-preservation-new-config-controller-type-test-3-physical-realizability-results-tests-physical-realizability-self-test-physical-realizability-new-config-controller-type-test-4-performance-preservation-results-tests-performance-self-test-performance-preservation-old-config-new-config-controller-type-test-5-numerical-stability-results-tests-numerical-stability-self-test-numerical-stability-new-config-controller-type-aggregate-results-failed-tests-name-for-name-result-in-results-tests-items-if-not-result-get-passed-false-results-migration-successful-len-failed-tests-0-if-failed-tests-results-errors-extend-f-failed-test-test-for-test-in-failed-tests-return-results-def-test-parameter-count-self-old-config-dict-str-any-new-config-dict-str-any-controller-type-str-dict-str-any-test-parameter-count-migration-expected-counts-classical-smc-6-adaptive-smc-5-sta-smc-6-hybrid-adaptive-sta-smc-4-new-gains-new-config-get-gains-expected-count-expected-counts-get-controller-type-0-passed-len-new-gains-expected-count-return-passed-passed-expected-count-expected-count-actual-count-len-new-gains-gains-new-gains-def-test-stability-preservation-self-new-config-dict-str-any-controller-type-str-dict-str-any-test-stability-preservation-gains-new-config-get-gains-if-controller-type-classical-smc-return-stabilityvalidator-validate-classical-smc-stability-gains-elif-controller-type-adaptive-smc-adaptation-params-leak-rate-new-config-get-leak-rate-0-01-k-min-new-config-get-k-min-0-1-k-max-new-config-get-k-max-100-0-return-stabilityvalidator-validate-adaptive-smc-convergence-gains-adaptation-params-elif-controller-type-sta-smc-algorithm-params-power-exponent-new-config-get-power-exponent-0-5-return-stabilityvalidator-validate-sta-smc-finite-time-convergence-gains-algorithm-params-return-passed-true-reason-no-stability-test-for-this-controller-type-def-test-physical-realizability-self-new-config-dict-str-any-controller-type-str-dict-str-any-test-physical-realizability-of-parameters-gains-new-config-get-gains-max-force-new-config-get-max-force-150-0-dt-new-config-get-dt-0-001-issues-check-gain-magnitudes-if-any-g-1000-for-g-in-gains-issues-append-extremely-high-gains-may-be-unrealistic-check-sampling-time-if-dt-1e-4-less-than-0-1ms-issues-append-f-very-fast-sampling-time-dt-dt-s-may-be-unrealistic-elif-dt-0-1-more-than-100ms-issues-append-f-slow-sampling-time-dt-dt-s-may-degrade-performance-check-actuator-limits-if-max-force-1000-more-than-1kn-issues-append-f-high-force-limit-max-force-n-may-be-unrealistic-elif-max-force-1-less-than-1n-issues-append-f-low-force-limit-max-force-n-may-be-insufficient-return-passed-len-issues-0-issues-issues-parameters-checked-gains-max-force-dt-def-test-performance-preservation-self-old-config-dict-str-any-new-config-dict-str-any-controller-type-str-dict-str-any-test-performance-preservation-bandwidth-analysis-performanceanalyzer-analyze-control-bandwidth-old-config-get-gains-new-config-get-gains-controller-type-settling-analysis-performanceanalyzer-estimate-settling-time-change-old-config-new-config-performance-is-preserved-if-bandwidth-and-settling-time-are-reasonable-bandwidth-ok-bandwidth-analysis-get-performance-preserved-true-settling-ok-settling-analysis-get-performance-change-in-improved-maintained-return-passed-bandwidth-ok-and-settling-ok-bandwidth-analysis-bandwidth-analysis-settling-analysis-settling-analysis-def-test-numerical-stability-self-new-config-dict-str-any-controller-type-str-dict-str-any-test-numerical-stability-of-parameters-gains-new-config-get-gains-dt-new-config-get-dt-0-001-issues-check-condition-numbers-and-numerical-issues-if-controller-type-in-classical-smc-adaptive-smc-sta-smc-if-len-gains-4-k1-k2-lam1-lam2-gains-4-check-gain-ratios-for-numerical-stability-if-lam1-k1-100-or-lam2-k2-100-issues-append-high-k-ratios-may-cause-numerical-instability-if-k1-k2-10-or-k2-k1-10-issues-append-large-k1-k2-ratio-may-indicate-unbalanced-design-check-discrete-time-stability-if-controller-type-in-adaptive-smc-sta-smc-max-gain-max-gains-if-gains-else-0-nyquist-limit-1-0-2-dt-if-max-gain-nyquist-limit-10-rule-of-thumb-issues-append-f-high-gains-relative-to-sampling-rate-may-cause-instability-return-passed-len-issues-0-issues-issues-sampling-time-dt-stability-margins-acceptable-if-len-issues-0-else-marginal-full-validation-example">
<h1>runnable: false class MigrationValidationSuite: “””test suite for migration validation.””” def <strong>init</strong>(self): self.test_results = [] def run_full_validation(self, old_config: Dict[str, Any], new_config: Dict[str, Any], controller_type: str) -&gt; Dict[str, Any]: “””Run migration validation.””” results = { ‘controller_type’: controller_type, ‘migration_successful’: True, ‘tests’: {}, ‘warnings’: [], ‘errors’: [] } # Test 1: Parameter count validation results[‘tests’][‘parameter_count’] = self.test_parameter_count(old_config, new_config, controller_type) # Test 2: Stability preservation results[‘tests’][‘stability’] = self.test_stability_preservation(new_config, controller_type) # Test 3: Physical realizability results[‘tests’][‘physical_realizability’] = self.test_physical_realizability(new_config, controller_type) # Test 4: Performance preservation results[‘tests’][‘performance’] = self.test_performance_preservation(old_config, new_config, controller_type) # Test 5: Numerical stability results[‘tests’][‘numerical_stability’] = self.test_numerical_stability(new_config, controller_type) # Aggregate results failed_tests = [name for name, result in results[‘tests’].items() if not result.get(‘passed’, False)] results[‘migration_successful’] = len(failed_tests) == 0 if failed_tests: results[‘errors’].extend([f”Failed test: {test}” for test in failed_tests]) return results def test_parameter_count(self, old_config: Dict[str, Any], new_config: Dict[str, Any], controller_type: str) -&gt; Dict[str, Any]: “””Test parameter count migration.””” expected_counts = { ‘classical_smc’: 6, ‘adaptive_smc’: 5, ‘sta_smc’: 6, ‘hybrid_adaptive_sta_smc’: 4 } new_gains = new_config.get(‘gains’, []) expected_count = expected_counts.get(controller_type, 0) passed = len(new_gains) == expected_count return { ‘passed’: passed, ‘expected_count’: expected_count, ‘actual_count’: len(new_gains), ‘gains’: new_gains } def test_stability_preservation(self, new_config: Dict[str, Any], controller_type: str) -&gt; Dict[str, Any]: “””Test stability preservation.””” gains = new_config.get(‘gains’, []) if controller_type == ‘classical_smc’: return StabilityValidator.validate_classical_smc_stability(gains) elif controller_type == ‘adaptive_smc’: adaptation_params = { ‘leak_rate’: new_config.get(‘leak_rate’, 0.01), ‘K_min’: new_config.get(‘K_min’, 0.1), ‘K_max’: new_config.get(‘K_max’, 100.0) } return StabilityValidator.validate_adaptive_smc_convergence(gains, adaptation_params) elif controller_type == ‘sta_smc’: algorithm_params = { ‘power_exponent’: new_config.get(‘power_exponent’, 0.5) } return StabilityValidator.validate_sta_smc_finite_time_convergence(gains, algorithm_params) return {‘passed’: True, ‘reason’: ‘No stability test for this controller type’} def test_physical_realizability(self, new_config: Dict[str, Any], controller_type: str) -&gt; Dict[str, Any]: “””Test physical realizability of parameters.””” gains = new_config.get(‘gains’, []) max_force = new_config.get(‘max_force’, 150.0) dt = new_config.get(‘dt’, 0.001) issues = [] # Check gain magnitudes if any(g &gt; 1000 for g in gains): issues.append(“Extremely high gains may be unrealistic”) # Check sampling time if dt &lt; 1e-4: # Less than 0.1ms issues.append(f”Very fast sampling time dt={dt}s may be unrealistic”) elif dt &gt; 0.1: # More than 100ms issues.append(f”Slow sampling time dt={dt}s may degrade performance”) # Check actuator limits if max_force &gt; 1000: # More than 1kN issues.append(f”High force limit {max_force}N may be unrealistic”) elif max_force &lt; 1: # Less than 1N issues.append(f”Low force limit {max_force}N may be insufficient”) return { ‘passed’: len(issues) == 0, ‘issues’: issues, ‘parameters_checked’: [‘gains’, ‘max_force’, ‘dt’] } def test_performance_preservation(self, old_config: Dict[str, Any], new_config: Dict[str, Any], controller_type: str) -&gt; Dict[str, Any]: “””Test performance preservation.””” bandwidth_analysis = PerformanceAnalyzer.analyze_control_bandwidth( old_config.get(‘gains’, []), new_config.get(‘gains’, []), controller_type ) settling_analysis = PerformanceAnalyzer.estimate_settling_time_change(old_config, new_config) # Performance is preserved if bandwidth and settling time are reasonable bandwidth_ok = bandwidth_analysis.get(‘performance_preserved’, True) settling_ok = settling_analysis.get(‘performance_change’) in [‘improved’, ‘maintained’] return { ‘passed’: bandwidth_ok and settling_ok, ‘bandwidth_analysis’: bandwidth_analysis, ‘settling_analysis’: settling_analysis } def test_numerical_stability(self, new_config: Dict[str, Any], controller_type: str) -&gt; Dict[str, Any]: “””Test numerical stability of parameters.””” gains = new_config.get(‘gains’, []) dt = new_config.get(‘dt’, 0.001) issues = [] # Check condition numbers and numerical issues if controller_type in [‘classical_smc’, ‘adaptive_smc’, ‘sta_smc’]: if len(gains) &gt;= 4: k1, k2, lam1, lam2 = gains[:4] # Check gain ratios for numerical stability if lam1/k1 &gt; 100 or lam2/k2 &gt; 100: issues.append(“High λ/k ratios may cause numerical instability”) if k1/k2 &gt; 10 or k2/k1 &gt; 10: issues.append(“Large k1/k2 ratio may indicate unbalanced design”) # Check discrete-time stability if controller_type in [‘adaptive_smc’, ‘sta_smc’]: max_gain = max(gains) if gains else 0 nyquist_limit = 1.0 / (2 * dt) if max_gain &gt; nyquist_limit / 10: # Rule of thumb issues.append(f”High gains relative to sampling rate may cause instability”) return { ‘passed’: len(issues) == 0, ‘issues’: issues, ‘sampling_time’: dt, ‘stability_margins’: ‘acceptable’ if len(issues) == 0 else ‘marginal’ } # Full validation example<a class="headerlink" href="#runnable-false-class-migrationvalidationsuite-test-suite-for-migration-validation-def-init-self-self-test-results-def-run-full-validation-self-old-config-dict-str-any-new-config-dict-str-any-controller-type-str-dict-str-any-run-migration-validation-results-controller-type-controller-type-migration-successful-true-tests-warnings-errors-test-1-parameter-count-validation-results-tests-parameter-count-self-test-parameter-count-old-config-new-config-controller-type-test-2-stability-preservation-results-tests-stability-self-test-stability-preservation-new-config-controller-type-test-3-physical-realizability-results-tests-physical-realizability-self-test-physical-realizability-new-config-controller-type-test-4-performance-preservation-results-tests-performance-self-test-performance-preservation-old-config-new-config-controller-type-test-5-numerical-stability-results-tests-numerical-stability-self-test-numerical-stability-new-config-controller-type-aggregate-results-failed-tests-name-for-name-result-in-results-tests-items-if-not-result-get-passed-false-results-migration-successful-len-failed-tests-0-if-failed-tests-results-errors-extend-f-failed-test-test-for-test-in-failed-tests-return-results-def-test-parameter-count-self-old-config-dict-str-any-new-config-dict-str-any-controller-type-str-dict-str-any-test-parameter-count-migration-expected-counts-classical-smc-6-adaptive-smc-5-sta-smc-6-hybrid-adaptive-sta-smc-4-new-gains-new-config-get-gains-expected-count-expected-counts-get-controller-type-0-passed-len-new-gains-expected-count-return-passed-passed-expected-count-expected-count-actual-count-len-new-gains-gains-new-gains-def-test-stability-preservation-self-new-config-dict-str-any-controller-type-str-dict-str-any-test-stability-preservation-gains-new-config-get-gains-if-controller-type-classical-smc-return-stabilityvalidator-validate-classical-smc-stability-gains-elif-controller-type-adaptive-smc-adaptation-params-leak-rate-new-config-get-leak-rate-0-01-k-min-new-config-get-k-min-0-1-k-max-new-config-get-k-max-100-0-return-stabilityvalidator-validate-adaptive-smc-convergence-gains-adaptation-params-elif-controller-type-sta-smc-algorithm-params-power-exponent-new-config-get-power-exponent-0-5-return-stabilityvalidator-validate-sta-smc-finite-time-convergence-gains-algorithm-params-return-passed-true-reason-no-stability-test-for-this-controller-type-def-test-physical-realizability-self-new-config-dict-str-any-controller-type-str-dict-str-any-test-physical-realizability-of-parameters-gains-new-config-get-gains-max-force-new-config-get-max-force-150-0-dt-new-config-get-dt-0-001-issues-check-gain-magnitudes-if-any-g-1000-for-g-in-gains-issues-append-extremely-high-gains-may-be-unrealistic-check-sampling-time-if-dt-1e-4-less-than-0-1ms-issues-append-f-very-fast-sampling-time-dt-dt-s-may-be-unrealistic-elif-dt-0-1-more-than-100ms-issues-append-f-slow-sampling-time-dt-dt-s-may-degrade-performance-check-actuator-limits-if-max-force-1000-more-than-1kn-issues-append-f-high-force-limit-max-force-n-may-be-unrealistic-elif-max-force-1-less-than-1n-issues-append-f-low-force-limit-max-force-n-may-be-insufficient-return-passed-len-issues-0-issues-issues-parameters-checked-gains-max-force-dt-def-test-performance-preservation-self-old-config-dict-str-any-new-config-dict-str-any-controller-type-str-dict-str-any-test-performance-preservation-bandwidth-analysis-performanceanalyzer-analyze-control-bandwidth-old-config-get-gains-new-config-get-gains-controller-type-settling-analysis-performanceanalyzer-estimate-settling-time-change-old-config-new-config-performance-is-preserved-if-bandwidth-and-settling-time-are-reasonable-bandwidth-ok-bandwidth-analysis-get-performance-preserved-true-settling-ok-settling-analysis-get-performance-change-in-improved-maintained-return-passed-bandwidth-ok-and-settling-ok-bandwidth-analysis-bandwidth-analysis-settling-analysis-settling-analysis-def-test-numerical-stability-self-new-config-dict-str-any-controller-type-str-dict-str-any-test-numerical-stability-of-parameters-gains-new-config-get-gains-dt-new-config-get-dt-0-001-issues-check-condition-numbers-and-numerical-issues-if-controller-type-in-classical-smc-adaptive-smc-sta-smc-if-len-gains-4-k1-k2-lam1-lam2-gains-4-check-gain-ratios-for-numerical-stability-if-lam1-k1-100-or-lam2-k2-100-issues-append-high-k-ratios-may-cause-numerical-instability-if-k1-k2-10-or-k2-k1-10-issues-append-large-k1-k2-ratio-may-indicate-unbalanced-design-check-discrete-time-stability-if-controller-type-in-adaptive-smc-sta-smc-max-gain-max-gains-if-gains-else-0-nyquist-limit-1-0-2-dt-if-max-gain-nyquist-limit-10-rule-of-thumb-issues-append-f-high-gains-relative-to-sampling-rate-may-cause-instability-return-passed-len-issues-0-issues-issues-sampling-time-dt-stability-margins-acceptable-if-len-issues-0-else-marginal-full-validation-example" title="Link to this heading">¶</a></h1>
<p>migration_suite = MigrationValidationSuite() old_config = { ‘gains’: [20, 15, 12, 8, 35], ‘K_switching’: 5.0, ‘switch_function’: ‘sign’
} new_config = { ‘gains’: [20, 15, 12, 8, 35, 5.0], ‘switch_method’: ‘sign’, ‘boundary_layer’: 0.02, ‘max_force’: 150.0, ‘dt’: 0.001
} validation_results = migration_suite.run_full_validation(old_config, new_config, ‘classical_smc’)
print(“Migration validation results:”)
for test_name, result in validation_results[‘tests’].items(): status = “✅ PASS” if result.get(‘passed’, False) else “❌ FAIL” print(f” {test_name}: {status}”) if validation_results[‘migration_successful’]: print(”✅ Migration validation SUCCESSFUL”)
else: print(”❌ Migration validation FAILED”) for error in validation_results[‘errors’]: print(f” - {error}”)</p>
<div class="highlight-## notranslate"><div class="highlight"><pre><span></span>2. **Stability Preservation**: Validation of Lyapunov stability conditions during migration
3. **Performance Analysis**: Bandwidth and settling time preservation validation
4. **Scientific Validation**: test suites for migration verification
5. **Physical Realizability**: Checks for practical implementation constraints The enhanced factory system ensures that all parameter migrations maintain mathematical soundness and preserve the essential control-theoretic properties required for stable operation of the double-inverted pendulum system.
</pre></div>
</div>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Research Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on Oct 10, 2025</div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=4ebf8126"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=46bd48cc"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=08e7b316"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../_static/back-to-top.js?v=840797bb"></script>
    <script src="../_static/lazy-load.js?v=dc25293c"></script>
    <script src="../_static/dark-mode.js?v=bf328970"></script>
    </body>
</html>