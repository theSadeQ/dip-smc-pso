<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark">
<style>
/* Mathematical Visualization Containers */
.mathviz-container {
    margin: 2.5em 0;
    background: linear-gradient(135deg, #f0f4f8 0%, #e2e8f0 100%);
    border-radius: 16px;
    padding: 24px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
    border: 1px solid rgba(99, 102, 241, 0.1);
}

/* Header styling */
.mathviz-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding: 14px 18px;
    background: white;
    border-radius: 10px;
    border-left: 5px solid #6366f1;
    font-size: 16px;
    color: #1e293b;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}

.mathviz-badge {
    padding: 5px 14px;
    background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
    color: white;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
    letter-spacing: 0.5px;
}

.mathviz-equation {
    padding: 4px 12px;
    background: #f1f5f9;
    border-radius: 6px;
    font-family: 'Courier New', monospace;
    font-size: 13px;
    color: #4338ca;
    border: 1px solid #c7d2fe;
}

/* Plot container */
.mathviz-plot {
    background: white;
    border-radius: 10px;
    border: 1px solid #e2e8f0;
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.03);
}

/* Controls styling */
.mathviz-controls {
    margin-top: 18px;
    padding: 16px;
    background: rgba(255, 255, 255, 0.7);
    border-radius: 10px;
    display: flex;
    gap: 16px;
    align-items: center;
    flex-wrap: wrap;
    backdrop-filter: blur(10px);
}

.mathviz-controls label {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 14px;
    font-weight: 500;
    color: #475569;
}

.mathviz-controls select,
.mathviz-controls input[type="range"] {
    padding: 6px 12px;
    border: 2px solid #cbd5e1;
    border-radius: 6px;
    font-size: 14px;
    background: white;
    transition: border-color 0.2s;
}

.mathviz-controls select:hover,
.mathviz-controls select:focus {
    border-color: #6366f1;
    outline: none;
}

.mathviz-controls input[type="range"] {
    width: 150px;
    height: 6px;
    border-radius: 3px;
    background: #cbd5e1;
    outline: none;
}

.mathviz-controls input[type="range"]::-webkit-slider-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #6366f1;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(99, 102, 241, 0.4);
}

.mathviz-value {
    min-width: 50px;
    padding: 4px 10px;
    background: #f1f5f9;
    border-radius: 4px;
    font-family: monospace;
    font-size: 13px;
    color: #4338ca;
}

.mathviz-btn {
    padding: 8px 18px;
    background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s;
    box-shadow: 0 2px 8px rgba(99, 102, 241, 0.25);
}

.mathviz-btn:hover {
    background: linear-gradient(135deg, #4f46e5 0%, #4338ca 100%);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.35);
}

.mathviz-btn:active {
    transform: translateY(0);
}

.mathviz-toggle {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
}

.mathviz-toggle input[type="checkbox"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
}

/* Info box styling */
.mathviz-info {
    margin-top: 18px;
    padding: 14px 18px;
    background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
    border-radius: 8px;
    border-left: 4px solid #3b82f6;
    font-size: 13px;
    line-height: 1.6;
    color: #1e40af;
}

.mathviz-info code {
    padding: 2px 6px;
    background: rgba(255, 255, 255, 0.7);
    border-radius: 3px;
    font-family: 'Courier New', monospace;
    font-size: 12px;
    color: #4338ca;
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
    .mathviz-container {
        background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
        border-color: rgba(139, 92, 246, 0.2);
    }

    .mathviz-header {
        background: #1e293b;
        color: #e2e8f0;
        border-left-color: #8b5cf6;
    }

    .mathviz-equation {
        background: #0f172a;
        color: #c4b5fd;
        border-color: #4c1d95;
    }

    .mathviz-plot {
        background: #1e293b;
        border-color: #334155;
    }

    .mathviz-controls {
        background: rgba(30, 41, 59, 0.7);
    }

    .mathviz-controls label {
        color: #cbd5e1;
    }

    .mathviz-controls select,
    .mathviz-value {
        background: #0f172a;
        border-color: #475569;
        color: #e2e8f0;
    }

    .mathviz-controls input[type="range"] {
        background: #475569;
    }

    .mathviz-info {
        background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%);
        border-left-color: #60a5fa;
        color: #bfdbfe;
    }

    .mathviz-info code {
        background: rgba(15, 23, 42, 0.7);
        color: #c4b5fd;
    }
}

/* Responsive design */
@media (max-width: 768px) {
    .mathviz-container {
        padding: 16px;
        margin: 1.5em 0;
    }

    .mathviz-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
    }

    .mathviz-controls {
        flex-direction: column;
        align-items: stretch;
    }

    .mathviz-controls label {
        flex-direction: column;
        align-items: flex-start;
    }

    .mathviz-controls input[type="range"] {
        width: 100%;
    }
}
</style>
    <link rel="index" title="Index" href="../genindex.html"><link rel="search" title="Search" href="../search.html">

    <!-- Generated with Sphinx 7.4.7 and Furo 2025.09.25 -->
        <title>Factory Integration Documentation Suite - DIP_SMC_PSO Documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5349f25f" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=580074bf" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=8dab3a3b" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=84d0d889" />
    <link rel="stylesheet" type="text/css" href="../_static/code-collapse.css?v=f6d90a45" />
    <link rel="stylesheet" type="text/css" href="../_static/code-runner.css?v=bc684ae2" />
    <link rel="stylesheet" type="text/css" href="../_static/mathviz.css?v=d1238736" />
    
    


<style>
  body {
    --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">DIP_SMC_PSO Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  <span class="sidebar-brand-text">DIP_SMC_PSO Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../ACADEMIC_INTEGRITY_STATEMENT.html">Academic Integrity Statement <strong>Status:</strong> To be completed in Phase B (Citation System Implementation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CHANGELOG.html">Changelog All notable changes to the ResearchPlan validation system will be documented in this file. The format is based on Keep a Changelog,</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CITATIONS.html">Citations &amp; Academic Attribution <strong>Project:</strong> Double Inverted Pendulum - Sliding Mode Control with PSO Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CITATIONS_ACADEMIC.html">Academic Theory Citations &amp; References <strong>Project:</strong> Double Inverted Pendulum - Sliding Mode Control with PSO Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CITATION_SYSTEM.html">Citation System Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CONTRIBUTING.html">Contributing ‚Äì ResearchPlanSpec Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CONTROLLER_FACTORY.html">Controller Factory Documentation &gt; <strong>Note:</strong> This document has been consolidated into the Factory System Guide. ## Quick Links - <strong><span class="xref myst">Factory System Guide</span></strong> - Complete controller factory documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CROSS_REFERENCE_AUDIT_REPORT.html">Documentation Cross-Reference Audit Report <strong>Report Date:</strong> 2025-10-07</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DEPENDENCIES.html">Software Dependencies &amp; Citations <strong>Project:</strong> Double Inverted Pendulum - Sliding Mode Control with PSO Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DOCUMENTATION_COVERAGE_MATRIX.html">Documentation Coverage Matrix</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DOCUMENTATION_IMPLEMENTATION_PLAN.html">Documentation Coverage Implementation Plan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DOCUMENTATION_INVENTORY_SUMMARY.html">DIP-SMC-PSO Documentation Inventory Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DOCUMENTATION_STYLE_GUIDE.html">Documentation Style Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../DOCUMENTATION_SYSTEM.html">üìö World-Class Documentation System for DIP_SMC_PSO ## üåü Overview This repository now features a <strong>world-class technical documentation system</strong> designed for research-grade publications. The system provides LaTeX-quality mathematical rendering, professional citation management, and cross-referencing features. ## ‚ú® Features ### üî¨ Research-Grade Mathematics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../EXAMPLE_VALIDATION_REPORT.html">Documentation Code Example Validation Report <strong>Report Date:</strong> 2025-10-07</a></li>
<li class="toctree-l1"><a class="reference internal" href="../LICENSES.html">License Compliance &amp; Attribution <strong>Project:</strong> Double Inverted Pendulum - Sliding Mode Control with PSO Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PACKAGE_CONTENTS.html">Sphinx Documentation Implementation Package ## üìÅ Package Contents for ChatGPT Review This package contains the complete implementation of production-grade Sphinx documentation with GitHub CI/CD based on expert recommendations. ### üöÄ Core Implementation Files #### GitHub Workflows (Enhanced CI/CD)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PATTERNS.html">Software Design Patterns &amp; Architecture Attribution <strong>Project:</strong> Double Inverted Pendulum - Sliding Mode Control with PSO Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PATTERNS.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PATTERNS.html#runnable-false-src-controllers-factory-py-lines-507-543-def-create-controller-controller-type-str-config-optional-any-none-gains-optional-union-list-np-ndarray-none-any-create-a-controller-instance-of-the-specified-type-this-function-is-thread-safe-and-can-be-called-concurrently-supported-types-classical-smc-sta-smc-adaptive-smc-hybrid-adaptive-sta-smc-mpc-controller-normalize-controller-type-handles-aliases-controller-type-canonicalize-controller-type-controller-type-retrieve-from-registry-controller-info-get-controller-info-controller-type-controller-class-controller-info-class-resolve-gains-from-config-defaults-controller-gains-resolve-controller-gains-gains-config-controller-type-validate-gains-with-controller-specific-rules-validate-controller-gains-controller-gains-controller-info-create-and-return-configured-instance-return-controller-class-controller-gains-kwargs">runnable: false # src/controllers/factory.py (lines 507-543) def create_controller(controller_type: str, config: Optional[Any] = None, gains: Optional[Union[list, np.ndarray]] = None) -&gt; Any: ‚Äú‚Äù‚Äù Create a controller instance of the specified type. This function is thread-safe and can be called concurrently. Supported types: ‚Äòclassical_smc‚Äô, ‚Äòsta_smc‚Äô, ‚Äòadaptive_smc‚Äô, ‚Äòhybrid_adaptive_sta_smc‚Äô, ‚Äòmpc_controller‚Äô ‚Äú‚Äù‚Äù # Normalize controller type (handles aliases) controller_type = _canonicalize_controller_type(controller_type) # Retrieve from registry controller_info = _get_controller_info(controller_type) controller_class = controller_info[‚Äòclass‚Äô] # Resolve gains from config/defaults controller_gains = _resolve_controller_gains(gains, config, controller_type) # Validate gains with controller-specific rules _validate_controller_gains(controller_gains, controller_info) # Create and return configured instance return controller_class(controller_gains, **kwargs)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PATTERNS.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PATTERNS.html#runnable-false-src-utils-validation-parameter-validators-py-def-validate-gains-n-expected-int-decorator-to-validate-gain-array-length-def-decorator-func-def-wrapper-self-gains-args-kwargs-if-len-gains-n-expected-raise-valueerror-f-expected-n-expected-gains-got-len-gains-return-func-self-gains-args-kwargs-return-wrapper-return-decorator-usage">runnable: false # src/utils/validation/parameter_validators.py def validate_gains(n_expected: int): ‚Äú‚Äù‚ÄùDecorator to validate gain array length.‚Äù‚Äù‚Äù def decorator(func): def wrapper(self, gains, *args, **kwargs): if len(gains) != n_expected: raise ValueError(f‚ÄùExpected {n_expected} gains, got {len(gains)}‚Äù) return func(self, gains, *args, **kwargs) return wrapper return decorator # Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PLANT_CONFIGURATION.html">Plant Configuration Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PSO_Documentation_Validation_Report.html">PSO Documentation Validation Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PSO_INTEGRATION_GUIDE.html">PSO Integration Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../QUICKSTART_VALIDATION.html">Quick Start: Issue #12 Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Optimal Sliding Mode Control for a Double-Inverted Pendulum via PSO </a></li>
<li class="toctree-l1"><a class="reference internal" href="../RELEASE_CHECKLIST.html">Release Checklist Use this checklist when preparing a new release of the ResearchPlan validation system. ## Pre-Release ### Code &amp; Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_100_PERCENT_COMPLETION_REPORT.html">Sphinx Documentation - 100% Warning Elimination Complete</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE10_COMPLETION_REPORT.html">Sphinx Phase 10 Completion Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE11_COMPLETION_REPORT.html">Sphinx Phase 11 Completion Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE2_COMPLETION_REPORT.html">Phase 2 Completion Report: Live Python Code Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE3_COMPLETION_REPORT.html">Phase 3 Completion Report: Plotly Interactive Charts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE4_COMPLETION_REPORT.html">Phase 4: Jupyter Notebooks Integration - Completion Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE5_COMPLETION_REPORT.html">Phase 5 Completion Report: Mathematical Visualization Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE6_COMPLETION_REPORT.html">Phase 6 Completion Report: Progressive Web App (PWA)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE8_SUMMARY.html">Sphinx Documentation Phase 8 - Final Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SPHINX_PHASE9_PROGRESS_REPORT.html">Sphinx Documentation Phase 9 - Final Progress Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TESTING.html">Testing Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../analysis_plan.html">5. Analysis &amp; Verification Plan ## üîß <strong>Recent Testing Infrastructure Improvements</strong> (September 2024) ### <strong>Vector Simulation Engine Robustness</strong> The vector simulation engine (<code class="docutils literal notranslate"><span class="pre">src/simulation/engines/vector_sim.py</span></code>) has been enhanced with edge case handling and improved reliability: #### <strong>‚úÖ Fixes Applied</strong> 1. <strong>Scalar Control Input Support</strong> - <strong>Issue</strong>: <code class="docutils literal notranslate"><span class="pre">IndexError</span></code> when control input was 0-dimensional scalar - <strong>Fix</strong>: Added proper scalar handling with <code class="docutils literal notranslate"><span class="pre">.item()</span></code> extraction for 0D arrays - <strong>Benefit</strong>: Supports simplified test scenarios and edge cases 2. <strong>Flexible Control Sequence Length</strong> - <strong>Issue</strong>: Crashes when simulation horizon exceeded control input sequence length - <strong>Fix</strong>: Implemented graceful bounds checking with <code class="docutils literal notranslate"><span class="pre">min(i,</span> <span class="pre">length-1)</span></code> indexing strategy - <strong>Benefit</strong>: Uses last available control input when sequence is exhausted 3. <strong>Empty State Array Handling</strong> - <strong>Issue</strong>: Tests expected exceptions for empty arrays, but function handled them gracefully - <strong>Fix</strong>: Updated test expectations to match actual behavior (returns <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">0)</span></code> shaped array) - <strong>Benefit</strong>: Consistent behavior for degenerate cases 4. <strong>Mock Function Accuracy</strong> - <strong>Issue</strong>: Test mocks didn‚Äôt reflect actual physics-based state evolution - <strong>Fix</strong>: Updated mock dynamics to properly simulate <code class="docutils literal notranslate"><span class="pre">state</span> <span class="pre">+</span> <span class="pre">dt</span> <span class="pre">*</span> <span class="pre">state_derivative</span></code> evolution - <strong>Benefit</strong>: Tests now validate realistic controller-plant interactions #### <strong>‚úÖ Test Coverage Improvements</strong> <strong>Vector Simulation Test Suite</strong>: Now <strong>100% passing</strong> (20/21 tests pass, 1 skipped)</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../api/index.html">API Reference Documentation</a><input aria-label="Toggle navigation of API Reference Documentation" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../api/controller_api_reference.html">Controller API Reference &gt; <strong>Note:</strong> Controller API documentation has been consolidated into references. ## Quick Links - <strong><span class="xref myst">Factory System API</span></strong> - Complete factory and controller creation API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/controller_theory.html">Controller Theory Reference <strong>Status:</strong> üöß Under Construction This document will contain controller theory documentation including: ## Planned Content ### Sliding Mode Control Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html">Factory System API Reference <strong>Module:</strong> <code class="docutils literal notranslate"><span class="pre">src.controllers.factory</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#runnable-false-thread-safe-factory-operations-with-timeout-protection">runnable: false # Thread-safe factory operations with timeout protection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#runnable-false-def-list-available-controllers-list">runnable: false def list_available_controllers() -&gt; list</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#example-return-values">Example return values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#runnable-false-controller-registry-dict-str-dict-str-any-controller-type-class-controllerclass-controller-class-reference-config-class-configclass-configuration-class-reference-default-gains-list-float-default-gain-vector-gain-count-int-expected-number-of-gains-description-str-human-readable-description-supports-dynamics-bool-whether-controller-uses-dynamics-model-required-params-list-str-required-configuration-parameters">runnable: false CONTROLLER_REGISTRY: Dict[str, Dict[str, Any]] = { ‚Äòcontroller_type‚Äô: { ‚Äòclass‚Äô: ControllerClass, # Controller class reference ‚Äòconfig_class‚Äô: ConfigClass, # Configuration class reference ‚Äòdefault_gains‚Äô: List[float], # Default gain vector ‚Äògain_count‚Äô: int, # Expected number of gains ‚Äòdescription‚Äô: str, # Human-readable description ‚Äòsupports_dynamics‚Äô: bool, # Whether controller uses dynamics model ‚Äòrequired_params‚Äô: List[str] # Required configuration parameters }</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#runnable-false-class-psocontrollerwrapper-wrapper-for-smc-controllers-to-provide-pso-compatible-interface-def-init-self-controller-n-gains-int-controller-type-str-self-controller-controller-self-n-gains-n-gains-self-controller-type-controller-type-self-max-force-getattr-controller-max-force-150-0-self-dynamics-model-getattr-controller-dynamics-model-none-def-validate-gains-self-particles-np-ndarray-np-ndarray-validate-gain-particles-for-pso-optimization-checks-gain-count-finiteness-positivity-and-controller-specific-constraints-def-compute-control-self-state-np-ndarray-np-ndarray-pso-compatible-control-computation-interface-simplified-interface-for-pso-fitness-evaluation">runnable: false class PSOControllerWrapper: ‚Äú‚Äù‚ÄùWrapper for SMC controllers to provide PSO-compatible interface.‚Äù‚Äù‚Äù def <strong>init</strong>(self, controller, n_gains: int, controller_type: str): self.controller = controller self.n_gains = n_gains self.controller_type = controller_type self.max_force = getattr(controller, ‚Äòmax_force‚Äô, 150.0) self.dynamics_model = getattr(controller, ‚Äòdynamics_model‚Äô, None) def validate_gains(self, particles: np.ndarray) -&gt; np.ndarray: ‚Äú‚Äù‚ÄùValidate gain particles for PSO optimization.‚Äù‚Äù‚Äù # Checks gain count, finiteness, positivity, and controller-specific constraints ‚Ä¶ def compute_control(self, state: np.ndarray) -&gt; np.ndarray: ‚Äú‚Äù‚ÄùPSO-compatible control computation interface.‚Äù‚Äù‚Äù # Simplified interface for PSO fitness evaluation ‚Ä¶</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#runnable-false-src-controllers-new-controller-py-import-numpy-as-np">runnable: false # src/controllers/new_controller.py import numpy as np</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#runnable-false-src-controllers-new-controller-config-py-from-dataclasses-import-dataclass">runnable: false # src/controllers/new_controller_config.py from dataclasses import dataclass</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#import-new-controller">Import new controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#add-aliases-for-convenience">Add aliases for convenience</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#runnable-false-add-to-smctype-enum">runnable: false # Add to SMCType enum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#test-new-controller-py-from-src-controllers-factory-import-create-controller-get-default-gains">test_new_controller.py from src.controllers.factory import create_controller, get_default_gains</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#id7">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#runnable-false">runnable: false ‚Äú‚Äù‚Äù</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#id8">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_system_api_reference.html#id9">runnable: false ‚Äú‚Äù‚Äù</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_reference.html">Factory API Reference ## Controller Factory System - GitHub Issue #6 Implementation ### Overview The Controller Factory System provides a unified, type-safe interface for creating and managing sliding mode control (SMC) controllers in the DIP-SMC-PSO project. This system implements the factory pattern to ensure consistent controller instantiation, parameter validation, and optimization integration. ### Architecture #### Core Components 1. <strong>Main Factory</strong> (<code class="docutils literal notranslate"><span class="pre">src/controllers/factory.py</span></code>) - Central controller registry and creation interface - Thread-safe operations with RLock protection - error handling and validation - Legacy compatibility support 2. <strong>SMC Factory</strong> (<code class="docutils literal notranslate"><span class="pre">src/controllers/factory/smc_factory.py</span></code>) - Specialized factory for SMC controllers - PSO optimization integration - Type-safe parameter handling 3. <strong>Legacy Factory</strong> (<code class="docutils literal notranslate"><span class="pre">src/controllers/factory/legacy_factory.py</span></code>) - Backward compatibility interface - Deprecation handling and migration support ### Supported Controllers | Controller Type | Class | Gains | Description |</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html">Factory Methods API Reference ## Overview This document provides API reference documentation for the Enterprise Controller Factory system. The factory provides thread-safe, type-safe controller instantiation with deep PSO integration and robust error handling. ## Table of Contents 1. Core Factory Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#basic-usage-with-default-parameters">Basic usage with default parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#runnable-false-def-list-available-controllers-list-str">runnable: false def list_available_controllers() -&gt; List[str]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#output-classical-smc-sta-smc-adaptive-smc-hybrid-adaptive-sta-smc">Output: [‚Äòclassical_smc‚Äô, ‚Äòsta_smc‚Äô, ‚Äòadaptive_smc‚Äô, ‚Äòhybrid_adaptive_sta_smc‚Äô]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#note-mpc-controller-only-included-if-optional-dependencies-available">Note: ‚Äòmpc_controller‚Äô only included if optional dependencies available</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#runnable-false-def-get-default-gains-controller-type-str-list-float">runnable: false def get_default_gains(controller_type: str) -&gt; List[float]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#runnable-false-get-default-gains-for-different-controllers">runnable: false # Get default gains for different controllers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#output-20-0-15-0-12-0-8-0-35-0-5-0-adaptive-gains-get-default-gains-adaptive-smc">Output: [20.0, 15.0, 12.0, 8.0, 35.0, 5.0] adaptive_gains = get_default_gains(‚Äòadaptive_smc‚Äô)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#output-25-0-18-0-15-0-10-0-4-0-use-as-starting-point-for-optimization">Output: [25.0, 18.0, 15.0, 10.0, 4.0] # Use as starting point for optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#runnable-false-create-factory-once-expensive-operation">runnable: false # Create factory once (expensive operation)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#runnable-false-def-validate-smc-gains-smc-type-smctype-gains-union-list-np-ndarray-bool">runnable: false def validate_smc_gains(smc_type: SMCType, gains: Union[list, np.ndarray]) -&gt; bool</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#runnable-false-validate-gains-before-expensive-simulation">runnable: false # Validate gains before expensive simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#pattern-1-direct-controller-configuration">Pattern 1: Direct controller configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#type-aliases-for-better-type-safety">Type aliases for better type safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/factory_methods_reference.html#runnable-false-class-controllerprotocol-protocol-protocol-defining-the-standard-controller-interface-def-compute-control-self-state-statevector-last-control-float-history-configdict-controloutput-compute-control-output-for-given-state-def-reset-self-none-reset-controller-internal-state-property-def-gains-self-list-float-return-controller-gains">runnable: false class ControllerProtocol(Protocol): ‚Äú‚Äù‚ÄùProtocol defining the standard controller interface.‚Äù‚Äù‚Äù def compute_control( self, state: StateVector, last_control: float, history: ConfigDict ) -&gt; ControlOutput: ‚Äú‚Äù‚ÄùCompute control output for given state.‚Äù‚Äù‚Äù ‚Ä¶ def reset(self) -&gt; None: ‚Äú‚Äù‚ÄùReset controller internal state.‚Äù‚Äù‚Äù ‚Ä¶ @property def gains(self) -&gt; List[float]: ‚Äú‚Äù‚ÄùReturn controller gains.‚Äù‚Äù‚Äù ‚Ä¶</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html">Optimization Module API Reference <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#runnable-false-usr-bin-env-python3">runnable: false #!/usr/bin/env python3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#configuration">Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#config-path-config-yaml">============================================================================ CONFIG_PATH = ‚Äúconfig.yaml‚Äù</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#convergence-monitoring-callback">Convergence Monitoring Callback</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#class-convergencemonitor-callback-for-real-time-convergence-monitoring-def-init-self-analyzer-enhancedconvergenceanalyzer-self-analyzer-analyzer-self-metrics-history-def-call-self-iteration-int-best-fitness-float-mean-fitness-float-fitness-std-float-swarm-positions-np-ndarray-check-convergence-at-each-iteration-status-metrics-self-analyzer-check-convergence-iteration-iteration-best-fitness-best-fitness-mean-fitness-mean-fitness-fitness-std-fitness-std-swarm-positions-swarm-positions-self-metrics-history-append-metrics-log-key-metrics-if-iteration-10-0-print-f-iter-iteration-3d-status-status-value-20s-f-best-metrics-best-fitness-6f-f-diversity-metrics-population-diversity-4f-f-conv-velocity-metrics-convergence-velocity-4e-f-predicted-remaining-metrics-predicted-iterations-remaining-3d-early-stopping-if-status-convergencestatus-converged-print-f-n-convergence-detected-at-iteration-iteration-return-true-signal-early-stop-elif-status-convergencestatus-stagnated-print-f-n-stagnation-detected-at-iteration-iteration-return-true-signal-early-stop-return-false-continue">============================================================================ class ConvergenceMonitor: ‚Äú‚Äù‚ÄùCallback for real-time convergence monitoring.‚Äù‚Äù‚Äù def <strong>init</strong>(self, analyzer: EnhancedConvergenceAnalyzer): self.analyzer = analyzer self.metrics_history = [] def <strong>call</strong>(self, iteration: int, best_fitness: float, mean_fitness: float, fitness_std: float, swarm_positions: np.ndarray): ‚Äú‚Äù‚ÄùCheck convergence at each iteration.‚Äù‚Äù‚Äù status, metrics = self.analyzer.check_convergence( iteration=iteration, best_fitness=best_fitness, mean_fitness=mean_fitness, fitness_std=fitness_std, swarm_positions=swarm_positions ) self.metrics_history.append(metrics) # Log key metrics if iteration % 10 == 0: print(f‚ÄùIter {iteration:3d} | Status: {status.value:20s} | ‚Äú f‚ÄùBest: {metrics.best_fitness:.6f} | ‚Äú f‚ÄùDiversity: {metrics.population_diversity:.4f} | ‚Äú f‚ÄùConv. Velocity: {metrics.convergence_velocity:.4e} | ‚Äú f‚ÄùPredicted Remaining: {metrics.predicted_iterations_remaining:3d}‚Äù) # Early stopping if status == ConvergenceStatus.CONVERGED: print(f‚Äù\n&gt;&gt;&gt; CONVERGENCE DETECTED at iteration {iteration} &lt;&lt;&lt;‚Äù) return True # Signal early stop elif status == ConvergenceStatus.STAGNATED: print(f‚Äù\n&gt;&gt;&gt; STAGNATION DETECTED at iteration {iteration} &lt;&lt;&lt;‚Äù) return True # Signal early stop return False # Continue # ============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#main">Main</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#def-main-load-configuration-config-load-config-config-path-initialize-convergence-analyzer-with-custom-criteria-criteria-convergencecriteria-fitness-tolerance-1e-6-relative-improvement-threshold-1e-4-min-diversity-threshold-1e-3-max-stagnation-iterations-50-enable-performance-prediction-true-premature-convergence-detection-true-analyzer-enhancedconvergenceanalyzer-criteria-criteria-controller-type-smctype-sta-monitor-convergencemonitor-analyzer-create-controller-factory-controller-factory-partial-create-controller-controller-type-controller-type-config-config-initialize-pso-tuner-tuner-psotuner-controller-factory-controller-factory-config-config-seed-seed-run-optimization-with-monitoring-print-f-running-pso-optimization-with-real-time-convergence-monitoring-print-f-120-result-tuner-optimise-print-f-120-n-plot-convergence-metrics-metrics-monitor-metrics-history-iterations-m-iteration-for-m-in-metrics-best-fitness-m-best-fitness-for-m-in-metrics-diversity-m-population-diversity-for-m-in-metrics-conv-velocity-m-convergence-velocity-for-m-in-metrics-fig-axes-plt-subplots-3-1-figsize-12-10-best-fitness-axes-0-plot-iterations-best-fitness-linewidth-2-color-blue-axes-0-set-ylabel-best-fitness-fontsize-12-axes-0-set-yscale-log-axes-0-set-title-convergence-monitoring-sta-smc-fontsize-14-fontweight-bold-axes-0-grid-true-alpha-0-3-population-diversity-axes-1-plot-iterations-diversity-linewidth-2-color-green-axes-1-set-ylabel-population-diversity-fontsize-12-axes-1-grid-true-alpha-0-3-convergence-velocity-axes-2-plot-iterations-conv-velocity-linewidth-2-color-red-axes-2-set-ylabel-convergence-velocity-fontsize-12-axes-2-set-xlabel-iteration-fontsize-12-axes-2-grid-true-alpha-0-3-plt-tight-layout-plt-savefig-pso-convergence-monitoring-png-dpi-300-print-convergence-monitoring-plot-saved-pso-convergence-monitoring-png-if-name-main-main">============================================================================ def main(): # Load configuration config = load_config(CONFIG_PATH) # Initialize convergence analyzer with custom criteria criteria = ConvergenceCriteria( fitness_tolerance=1e-6, relative_improvement_threshold=1e-4, min_diversity_threshold=1e-3, max_stagnation_iterations=50, enable_performance_prediction=True, premature_convergence_detection=True ) analyzer = EnhancedConvergenceAnalyzer( criteria=criteria, controller_type=SMCType.STA ) monitor = ConvergenceMonitor(analyzer) # Create controller factory controller_factory = partial( create_controller, controller_type=CONTROLLER_TYPE, config=config ) # Initialize PSO tuner tuner = PSOTuner( controller_factory=controller_factory, config=config, seed=SEED ) # Run optimization with monitoring print(f‚ÄùRunning PSO optimization with real-time convergence monitoring‚Ä¶‚Äù) print(f‚Äù{‚Äò=‚Äô*120}‚Äù) result = tuner.optimise() print(f‚Äù{‚Äò=‚Äô*120}\n‚Äù) # Plot convergence metrics metrics = monitor.metrics_history iterations = [m.iteration for m in metrics] best_fitness = [m.best_fitness for m in metrics] diversity = [m.population_diversity for m in metrics] conv_velocity = [m.convergence_velocity for m in metrics] fig, axes = plt.subplots(3, 1, figsize=(12, 10)) # Best fitness axes[0].plot(iterations, best_fitness, linewidth=2, color=‚Äôblue‚Äô) axes[0].set_ylabel(‚ÄòBest Fitness‚Äô, fontsize=12) axes[0].set_yscale(‚Äòlog‚Äô) axes[0].set_title(‚ÄòConvergence Monitoring - STA SMC‚Äô, fontsize=14, fontweight=‚Äôbold‚Äô) axes[0].grid(True, alpha=0.3) # Population diversity axes[1].plot(iterations, diversity, linewidth=2, color=‚Äôgreen‚Äô) axes[1].set_ylabel(‚ÄòPopulation Diversity‚Äô, fontsize=12) axes[1].grid(True, alpha=0.3) # Convergence velocity axes[2].plot(iterations, conv_velocity, linewidth=2, color=‚Äôred‚Äô) axes[2].set_ylabel(‚ÄòConvergence Velocity‚Äô, fontsize=12) axes[2].set_xlabel(‚ÄòIteration‚Äô, fontsize=12) axes[2].grid(True, alpha=0.3) plt.tight_layout() plt.savefig(‚Äòpso_convergence_monitoring.png‚Äô, dpi=300) print(‚ÄúConvergence monitoring plot saved: pso_convergence_monitoring.png‚Äù) if <strong>name</strong> == ‚Äú<strong>main</strong>‚Äù: main()</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#expected-output-running-pso-optimization-with-real-time-convergence-monitoring"><code class="docutils literal notranslate"><span class="pre">**Expected</span> <span class="pre">Output:**</span></code>
Running PSO optimization with real-time convergence monitoring‚Ä¶</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#id2">runnable: false #!/usr/bin/env python3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#id3">Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#id4">============================================================================ CONFIG_PATH = ‚Äúconfig.yaml‚Äù</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#id5">Main</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/optimization_module_api_reference.html#def-main-load-configuration-config-load-config-config-path-initialize-meta-optimizer-print-initializing-pso-hyperparameter-optimizer-meta-optimizer-psohyperparameteroptimizer-config-run-meta-optimization-print-f-nrunning-meta-optimization-for-controller-type-value-print-f-max-evaluations-max-meta-evaluations-print-f-trials-per-evaluation-n-trials-per-eval-print-f-objective-optimizationobjective-multi-objective-value-print-80-result-meta-optimizer-optimize-hyperparameters-controller-type-controller-type-objective-optimizationobjective-multi-objective-max-evaluations-max-meta-evaluations-n-trials-per-evaluation-n-trials-per-eval-display-results-print-n-80-print-hyperparameter-optimization-results-print-80-print-f-noptimized-hyperparameters-print-f-inertia-weight-w-result-hyperparameters-w-6f-print-f-cognitive-c1-result-hyperparameters-c1-6f-print-f-social-c2-result-hyperparameters-c2-6f-print-f-swarm-size-result-hyperparameters-n-particles-print-f-nbaseline-hyperparameters-print-f-inertia-weight-w-result-baseline-hyperparameters-w-6f-print-f-cognitive-c1-result-baseline-hyperparameters-c1-6f-print-f-social-c2-result-baseline-hyperparameters-c2-6f-print-f-swarm-size-result-baseline-hyperparameters-n-particles-print-f-nperformance-improvements-vs-baseline-print-f-convergence-speedup-result-convergence-improvement-2f-x-print-f-quality-improvement-result-quality-improvement100-2f-print-f-robustness-improvement-result-robustness-improvement100-2f-print-f-efficiency-score-result-efficiency-score-4f-print-80-visualize-comparison-fig-axes-plt-subplots-2-2-figsize-12-10-categories-w-c1-c2-n-baseline-values-result-baseline-hyperparameters-w-result-baseline-hyperparameters-c1-result-baseline-hyperparameters-c2-result-baseline-hyperparameters-n-particles-optimized-values-result-hyperparameters-w-result-hyperparameters-c1-result-hyperparameters-c2-result-hyperparameters-n-particles-x-np-arange-len-categories-width-0-35-axes-0-0-bar-x-width-2-baseline-values-width-label-baseline-alpha-0-7-axes-0-0-bar-x-width-2-optimized-values-width-label-optimized-alpha-0-7-axes-0-0-set-ylabel-value-axes-0-0-set-title-hyperparameter-comparison-axes-0-0-set-xticks-x-axes-0-0-set-xticklabels-categories-axes-0-0-legend-axes-0-0-grid-true-alpha-0-3-performance-metrics-metrics-convergence-nspeed-solution-nquality-robustness-improvements-result-convergence-improvement-1-result-quality-improvement-1-result-robustness-improvement-axes-0-1-bar-metrics-improvements-color-blue-green-orange-alpha-0-7-axes-0-1-axhline-y-1-0-color-red-linestyle-label-baseline-axes-0-1-set-ylabel-improvement-factor-axes-0-1-set-title-performance-improvements-axes-0-1-legend-axes-0-1-grid-true-alpha-0-3-convergence-history-if-available-if-hasattr-result-optimization-history-axes-1-0-plot-result-optimization-history-best-objective-linewidth-2-axes-1-0-set-xlabel-meta-optimization-iteration-axes-1-0-set-ylabel-objective-value-axes-1-0-set-title-meta-optimization-convergence-axes-1-0-grid-true-alpha-0-3-hide-unused-subplot-axes-1-1-axis-off-plt-tight-layout-plt-savefig-pso-hyperparameter-optimization-png-dpi-300-print-nvisualization-saved-pso-hyperparameter-optimization-png-if-name-main-main">============================================================================ def main(): # Load configuration config = load_config(CONFIG_PATH) # Initialize meta-optimizer print(‚ÄúInitializing PSO Hyperparameter Optimizer‚Ä¶‚Äù) meta_optimizer = PSOHyperparameterOptimizer(config) # Run meta-optimization print(f‚Äù\nRunning meta-optimization for {CONTROLLER_TYPE.value}‚Ä¶‚Äù) print(f‚ÄùMax evaluations: {MAX_META_EVALUATIONS}‚Äù) print(f‚ÄùTrials per evaluation: {N_TRIALS_PER_EVAL}‚Äù) print(f‚ÄùObjective: {OptimizationObjective.MULTI_OBJECTIVE.value}‚Äù) print(‚Äú=‚Äù*80) result = meta_optimizer.optimize_hyperparameters( controller_type=CONTROLLER_TYPE, objective=OptimizationObjective.MULTI_OBJECTIVE, max_evaluations=MAX_META_EVALUATIONS, n_trials_per_evaluation=N_TRIALS_PER_EVAL ) # Display results print(‚Äú\n‚Äù + ‚Äú=‚Äù<em>80) print(‚ÄúHYPERPARAMETER OPTIMIZATION RESULTS‚Äù) print(‚Äú=‚Äù<em>80) print(f‚Äù\nOptimized Hyperparameters:‚Äù) print(f‚Äù Inertia weight (w): {result.hyperparameters.w:.6f}‚Äù) print(f‚Äù Cognitive (c1): {result.hyperparameters.c1:.6f}‚Äù) print(f‚Äù Social (c2): {result.hyperparameters.c2:.6f}‚Äù) print(f‚Äù Swarm size: {result.hyperparameters.n_particles}‚Äù) print(f‚Äù\nBaseline Hyperparameters:‚Äù) print(f‚Äù Inertia weight (w): {result.baseline_hyperparameters.w:.6f}‚Äù) print(f‚Äù Cognitive (c1): {result.baseline_hyperparameters.c1:.6f}‚Äù) print(f‚Äù Social (c2): {result.baseline_hyperparameters.c2:.6f}‚Äù) print(f‚Äù Swarm size: {result.baseline_hyperparameters.n_particles}‚Äù) print(f‚Äù\nPerformance Improvements vs. Baseline:‚Äù) print(f‚Äù Convergence speedup: {result.convergence_improvement:.2f}x‚Äù) print(f‚Äù Quality improvement: {result.quality_improvement</em>100:.2f}%‚Äù) print(f‚Äù Robustness improvement: {result.robustness_improvement</em>100:.2f}%‚Äù) print(f‚Äù Efficiency score: {result.efficiency_score:.4f}‚Äù) print(‚Äú=‚Äù*80) # Visualize comparison fig, axes = plt.subplots(2, 2, figsize=(12, 10)) categories = [‚Äòw‚Äô, ‚Äòc1‚Äô, ‚Äòc2‚Äô, ‚ÄòN‚Äô] baseline_values = [ result.baseline_hyperparameters.w, result.baseline_hyperparameters.c1, result.baseline_hyperparameters.c2, result.baseline_hyperparameters.n_particles ] optimized_values = [ result.hyperparameters.w, result.hyperparameters.c1, result.hyperparameters.c2, result.hyperparameters.n_particles ] x = np.arange(len(categories)) width = 0.35 axes[0, 0].bar(x - width/2, baseline_values, width, label=‚ÄôBaseline‚Äô, alpha=0.7) axes[0, 0].bar(x + width/2, optimized_values, width, label=‚ÄôOptimized‚Äô, alpha=0.7) axes[0, 0].set_ylabel(‚ÄòValue‚Äô) axes[0, 0].set_title(‚ÄòHyperparameter Comparison‚Äô) axes[0, 0].set_xticks(x) axes[0, 0].set_xticklabels(categories) axes[0, 0].legend() axes[0, 0].grid(True, alpha=0.3) # Performance metrics metrics = [‚ÄòConvergence\nSpeed‚Äô, ‚ÄòSolution\nQuality‚Äô, ‚ÄòRobustness‚Äô] improvements = [ result.convergence_improvement, 1 + result.quality_improvement, 1 + result.robustness_improvement ] axes[0, 1].bar(metrics, improvements, color=[‚Äòblue‚Äô, ‚Äògreen‚Äô, ‚Äòorange‚Äô], alpha=0.7) axes[0, 1].axhline(y=1.0, color=‚Äôred‚Äô, linestyle=‚Äô‚Äì‚Äô, label=‚ÄôBaseline‚Äô) axes[0, 1].set_ylabel(‚ÄòImprovement Factor‚Äô) axes[0, 1].set_title(‚ÄòPerformance Improvements‚Äô) axes[0, 1].legend() axes[0, 1].grid(True, alpha=0.3) # Convergence history (if available) if hasattr(result, ‚Äòoptimization_history‚Äô): axes[1, 0].plot(result.optimization_history[‚Äòbest_objective‚Äô], linewidth=2) axes[1, 0].set_xlabel(‚ÄòMeta-Optimization Iteration‚Äô) axes[1, 0].set_ylabel(‚ÄòObjective Value‚Äô) axes[1, 0].set_title(‚ÄòMeta-Optimization Convergence‚Äô) axes[1, 0].grid(True, alpha=0.3) # Hide unused subplot axes[1, 1].axis(‚Äòoff‚Äô) plt.tight_layout() plt.savefig(‚Äòpso_hyperparameter_optimization.png‚Äô, dpi=300) print(‚Äú\nVisualization saved: pso_hyperparameter_optimization.png‚Äù) if <strong>name</strong> == ‚Äú<strong>main</strong>‚Äù: main()</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/pso_optimization.html">PSO Optimization Guide <strong>Status:</strong> üöß Under Construction This document will contain PSO optimization documentation including: ## Planned Content ### PSO Algorithm Fundamentals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html">Simulation Engine API Reference <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#runnable-false-class-dynamicsmodel-protocol-protocol-for-plant-dynamics-models-def-compute-dynamics-self-state-np-ndarray-control-input-np-ndarray-time-float-0-0-kwargs-any-dynamicsresult-compute-system-dynamics-at-given-state-and-input-def-get-physics-matrices-self-state-np-ndarray-tuple-np-ndarray-np-ndarray-np-ndarray-get-physics-matrices-m-c-g-at-current-state-def-validate-state-self-state-np-ndarray-bool-validate-state-vector-format-and-bounds-def-get-state-dimension-self-int-get-dimension-of-state-vector-def-get-control-dimension-self-int-get-dimension-of-control-input-vector">runnable: false class DynamicsModel(Protocol): ‚Äú‚Äù‚ÄùProtocol for plant dynamics models.‚Äù‚Äù‚Äù def compute_dynamics( self, state: np.ndarray, control_input: np.ndarray, time: float = 0.0, **kwargs: Any ) -&gt; DynamicsResult: ‚Äú‚Äù‚ÄùCompute system dynamics at given state and input.‚Äù‚Äù‚Äù ‚Ä¶ def get_physics_matrices( self, state: np.ndarray ) -&gt; Tuple[np.ndarray, np.ndarray, np.ndarray]: ‚Äú‚Äù‚ÄùGet physics matrices M, C, G at current state.‚Äù‚Äù‚Äù ‚Ä¶ def validate_state(self, state: np.ndarray) -&gt; bool: ‚Äú‚Äù‚ÄùValidate state vector format and bounds.‚Äù‚Äù‚Äù ‚Ä¶ def get_state_dimension(self) -&gt; int: ‚Äú‚Äù‚ÄùGet dimension of state vector.‚Äù‚Äù‚Äù ‚Ä¶ def get_control_dimension(self) -&gt; int: ‚Äú‚Äù‚ÄùGet dimension of control input vector.‚Äù‚Äù‚Äù ‚Ä¶</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#runnable-false-abstractmethod">runnable: false @abstractmethod</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#runnable-false-class-orchestrator-abc-base-interface-for-simulation-execution-strategies-abstractmethod-def-execute-self-initial-state-np-ndarray-control-inputs-np-ndarray-dt-float-horizon-int-kwargs-resultcontainer-execute-simulation-with-specified-strategy-pass">runnable: false class Orchestrator(ABC): ‚Äú‚Äù‚ÄùBase interface for simulation execution strategies.‚Äù‚Äù‚Äù @abstractmethod def execute( self, initial_state: np.ndarray, control_inputs: np.ndarray, dt: float, horizon: int, **kwargs ) -&gt; ResultContainer: ‚Äú‚Äù‚ÄùExecute simulation with specified strategy.‚Äù‚Äù‚Äù pass</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#runnable-false-class-batchorchestrator-baseorchestrator-batch-simulation-orchestrator-for-vectorized-execution-def-execute-self-initial-state-np-ndarray-control-inputs-np-ndarray-dt-float-horizon-int-kwargs-resultcontainer-execute-batch-simulation">runnable: false class BatchOrchestrator(BaseOrchestrator): ‚Äú‚Äù‚ÄùBatch simulation orchestrator for vectorized execution.‚Äù‚Äù‚Äù def execute( self, initial_state: np.ndarray, control_inputs: np.ndarray, dt: float, horizon: int, **kwargs ) -&gt; ResultContainer: ‚Äú‚Äù‚ÄùExecute batch simulation.‚Äù‚Äù‚Äù</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#step-1-load-configuration">STEP 1: Load Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#id4">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#step-2-create-controller">STEP 2: Create Controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#id5">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#step-3-create-dynamics-model">STEP 3: Create Dynamics Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#id6">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#step-4-run-simulation">STEP 4: Run Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#id7">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#step-5-analyze-results">STEP 5: Analyze Results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#id8">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#step-6-plot-results">STEP 6: Plot Results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/simulation_engine_api_reference.html#id9">============================================================================</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/performance_benchmarks.html">Performance Benchmarks Reference <strong>Status:</strong> üöß Under Construction This document will contain performance benchmarking documentation including: ## Planned Content ### Benchmark Methodology</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/configuration_schema.html">Configuration Schema Reference <strong>Status:</strong> üöß Under Construction This document will contain configuration schema documentation including: ## Planned Content ### YAML Configuration Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_1_completion_report.html">Phase 4.1 Controller API Documentation Completion Report <strong>Date:</strong> 2025-10-07</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_1_completion_report.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_1_completion_report.html#runnable-false">runnable: false</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_1_completion_report.html#examples-section">Examples section</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_2_completion_report.html">Phase 4.2 Completion Report: Factory System API Documentation <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_2_completion_report.html#tests-test-factory-examples-py-import-pytest">tests/test_factory_examples.py import pytest</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_3_progress_report.html">Phase 4.3 Progress Report: Optimization Module API Documentation <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_3_progress_report.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_3_progress_report.html#runnable-false-def-optimize-bounds-for-controller-self-controller-type-smctype-strategy-boundsoptimizationstrategy-boundsoptimizationstrategy-hybrid-max-optimization-time-float-300-0">runnable: false def optimize_bounds_for_controller( self, controller_type: SMCType, strategy: BoundsOptimizationStrategy = BoundsOptimizationStrategy.HYBRID, max_optimization_time: float = 300.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_3_completion_report.html">Phase 4.3 Completion Report: Optimization Module API Documentation <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/phase_4_4_completion_report.html">Phase 4.4 Completion Report: Simulation Engine API Documentation <strong>Project:</strong> Double-Inverted Pendulum SMC Control System</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../architecture.html">3. System Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../architecture_control_room.html">System Architecture Control Room</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../benchmarks/index.html">Performance Benchmarks</a><input aria-label="Toggle navigation of Performance Benchmarks" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../benchmarks/controller_performance_benchmarks.html">Controller Performance Benchmarks with Statistical Analysis <strong>Project:</strong> Double-Inverted Pendulum Sliding Mode Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../benchmarks/phase_3_2_completion_report.html">Phase 3.2 Completion Report: Controller Performance Benchmarks <strong>Project:</strong> Double-Inverted Pendulum Sliding Mode Control</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html">Benchmarks &amp; Methodology This project includes benchmarking features for statistical analysis and performance comparison of sliding mode controllers. The benchmarking system provides standardized evaluation protocols and robust statistical metrics. ## Overview The benchmarking framework evaluates controllers across multiple dimensions: - <strong>Performance metrics</strong>: ISE, ITAE, RMS control effort, overshoot, constraint violations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#base-seed-for-reproducibility">Base seed for reproducibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#configurable-noise-standard-deviation">Configurable noise standard deviation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#example-5-degree-initial-angle-variation">Example: ¬±5 degree initial angle variation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#test-with-physics-uncertainty-and-sensor-noise">Test with physics uncertainty and sensor noise</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#runnable-false-controllers-classical-smc-sta-smc-adaptive-smc">runnable: false controllers = [‚Äòclassical_smc‚Äô, ‚Äòsta_smc‚Äô, ‚Äòadaptive_smc‚Äô]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks_methodology.html#runnable-false-benchmark-metadata-timestamp-datetime-now-isoformat-config-hash-hashlib-md5-config-content-hexdigest-random-seed-1234-n-trials-30-environment-python-version-sys-version-numpy-version-np-version-platform-platform-platform">runnable: false benchmark_metadata = { ‚Äòtimestamp‚Äô: datetime.now().isoformat(), ‚Äòconfig_hash‚Äô: hashlib.md5(config_content).hexdigest(), ‚Äòrandom_seed‚Äô: 1234, ‚Äòn_trials‚Äô: 30, ‚Äòenvironment‚Äô: { ‚Äòpython_version‚Äô: sys.version, ‚Äònumpy_version‚Äô: np.<strong>version</strong>, ‚Äòplatform‚Äô: platform.platform() }</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bibliography.html">Bibliography &amp; Academic References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../claude-backup.html">Automated Git Backup System</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html">Configuration Integration Documentation ## Overview This document provides guidance on integrating the configuration system with the Enterprise Controller Factory. The DIP SMC-PSO project features a sophisticated configuration architecture that supports multiple sources, type safety, validation, and integration with controller creation workflows. ## Table of Contents 1. Configuration Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#config-yaml-complete-configuration-example-global-settings">config.yaml - Complete configuration example # Global settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#runnable-false-from-pydantic-import-basemodel-field-validator">runnable: false from pydantic import BaseModel, Field, validator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#runnable-false-def-resolve-controller-gains-gains-optional-union-list-float-np-ndarray-config-optional-any-controller-type-str-controller-info-dict-str-any">runnable: false def _resolve_controller_gains( gains: Optional[Union[List[float], np.ndarray]], config: Optional[Any], controller_type: str, controller_info: Dict[str, Any]</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#runnable-false-nested-dictionary-configuration">runnable: false # Nested dictionary configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#runnable-false-class-attributeconfig-configuration-using-attributes-def-init-self-create-controller-configurations-as-attributes-self-classical-smc-type-config-gains-25-20-15-10-40-6-max-force-160-0-boundary-layer-0-025-dt-0-001-self-adaptive-smc-type-config-gains-30-22-18-12-5-0-max-force-160-0-dt-0-001-leak-rate-0-02-initialize-controllers-namespace">runnable: false class AttributeConfig: ‚Äú‚Äù‚ÄùConfiguration using attributes.‚Äù‚Äù‚Äù def <strong>init</strong>(self): # Create controller configurations as attributes self.classical_smc = type(‚ÄòConfig‚Äô, (), { ‚Äògains‚Äô: [25, 20, 15, 10, 40, 6], ‚Äòmax_force‚Äô: 160.0, ‚Äòboundary_layer‚Äô: 0.025, ‚Äòdt‚Äô: 0.001 })() self.adaptive_smc = type(‚ÄòConfig‚Äô, (), { ‚Äògains‚Äô: [30, 22, 18, 12, 5.0], ‚Äòmax_force‚Äô: 160.0, ‚Äòdt‚Äô: 0.001, ‚Äòleak_rate‚Äô: 0.02 })() # Initialize controllers namespace</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_integration_documentation.html#generated-configuration-for-system-name">Generated configuration for {{ system_name }}</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_schema_validation.html">Configuration Schema Validation Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configuration_schema_validation.html#config-yaml-master-configuration-file">config.yaml - Master Configuration File</a></li>
<li class="toctree-l1"><a class="reference internal" href="../context.html">2. Application Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../control_law_testing_standards.html">Control Law Testing Standards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../controller_pso_interface_api_documentation.html">Controller-PSO Interface API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coverage_analysis_methodology.html">Coverage Analysis Methodology Framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coverage_analysis_methodology.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coverage_analysis_methodology.html#runnable-false-mathematical-model-for-isolated-coverage">runnable: false # Mathematical Model for Isolated Coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deployment/DEPLOYMENT_GUIDE.html">üöÄ Sphinx Documentation System - Deployment Guide ## ‚úÖ System Successfully Deployed! Your production-grade Sphinx documentation system is now <strong>ready for use</strong>. All expert recommendations have been implemented and the system has been committed to your repository. ## üìã Next Steps for Activation ### 1. GitHub Repository Settings To activate the documentation system, configure these GitHub settings: #### <strong>GitHub Pages:</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../deployment/STREAMLIT_DEPLOYMENT.html">Streamlit Deployment Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deployment/docker.html">Docker Deployment Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../deployment_validation_checklists.html">Deployment Validation Checklists and Quality Gates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../documentation_structure.html">Documentation Structure &amp; Site Map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault_detection_guide.html">Fault Detection &amp; Isolation (FDI) Guide ## Overview The DIP_SMC_PSO system includes a Fault Detection and Isolation (FDI) module that monitors system health in real-time. The FDI system compares model predictions with actual measurements to detect deviations that may indicate component failures, sensor faults, or unexpected disturbances. ## Architecture The FDI system uses a <strong>model-based residual approach</strong>: ```</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fault_detection_system_documentation.html">Fault Detection and Isolation (FDI) System - Technical Documentation ## Table of Contents 1. Mathematical Foundations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fdi_threshold_calibration_methodology.html">FDI Threshold Calibration Methodology <strong>Issue</strong>: #18 - FDI Threshold Too Sensitive - False Positives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/getting-started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/getting-started.html#or-on-some-systems">OR on some systems:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/getting-started.html#clone-repository">Clone repository</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/getting-started.html#you-should-see-simulate-py-config-yaml-src-tests-docs-etc">You should see: simulate.py, config.yaml, src/, tests/, docs/, etc.</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/getting-started-validation-report.html">Getting Started Guide Validation Report <strong>Phase 5.1: Getting Started Guide Validation</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../hil_quickstart.html">Hardware-in-the-Loop (HIL) Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html">Mathematical Algorithm Validation Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#runnable-false-def-compute-control-self-state-np-ndarray-target-np-ndarray-float-compute-smc-control-signal-extract-state-variables-theta1-theta2-x-theta1-dot-theta2-dot-x-dot-state-compute-errors-e1-theta1-target-0-position-error-pendulum-1-e2-theta2-target-1-position-error-pendulum-2-e1-dot-theta1-dot-target-3-velocity-error-pendulum-1-e2-dot-theta2-dot-target-4-velocity-error-pendulum-2-sliding-surface-s-1e1-2e2-e1-e2-s-self-lambda1-e1-self-lambda2-e2-e1-dot-e2-dot-control-law-u-u-eq-u-sw-u-equivalent-self-compute-equivalent-control-state-target-u-switching-self-k-np-sign-s-return-u-equivalent-u-switching">runnable: false def compute_control(self, state: np.ndarray, target: np.ndarray) -&gt; float: ‚Äú‚Äù‚ÄùCompute SMC control signal.‚Äù‚Äù‚Äù # Extract state variables theta1, theta2, x, theta1_dot, theta2_dot, x_dot = state # Compute errors e1 = theta1 - target[0] # Position error pendulum 1 e2 = theta2 - target[1] # Position error pendulum 2 e1_dot = theta1_dot - target[3] # Velocity error pendulum 1 e2_dot = theta2_dot - target[4] # Velocity error pendulum 2 # Sliding surface: s = Œª‚ÇÅe‚ÇÅ + Œª‚ÇÇe‚ÇÇ + ƒó‚ÇÅ + ƒó‚ÇÇ s = self.lambda1 * e1 + self.lambda2 * e2 + e1_dot + e2_dot # Control law: u = u_eq + u_sw u_equivalent = self._compute_equivalent_control(state, target) u_switching = -self.K * np.sign(s) return u_equivalent + u_switching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#runnable-false-def-compute-control-self-state-np-ndarray-target-np-ndarray-float-compute-super-twisting-control-signal-compute-sliding-surface-s-self-compute-sliding-surface-state-target-super-twisting-control-law-u1-1-s-1-2-sign-s-u1-self-alpha1-np-power-np-abs-s-0-5-np-sign-s-u2-2-sign-s-dt-self-integral-term-self-alpha2-np-sign-s-self-dt-return-u1-self-integral-term">runnable: false def compute_control(self, state: np.ndarray, target: np.ndarray) -&gt; float: ‚Äú‚Äù‚ÄùCompute Super-Twisting control signal.‚Äù‚Äù‚Äù # Compute sliding surface s = self._compute_sliding_surface(state, target) # Super-Twisting control law # u‚ÇÅ = -Œ±‚ÇÅ|s|^(1/2) sign(s) u1 = -self.alpha1 * np.power(np.abs(s), 0.5) * np.sign(s) # u‚ÇÇ = ‚à´(-Œ±‚ÇÇ sign(s)) dt self.integral_term += -self.alpha2 * np.sign(s) * self.dt return u1 + self.integral_term</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#runnable-false-def-update-particles-self-update-particle-velocities-and-positions-for-i-in-range-self-n-particles-random-coefficients-r1-r2-np-random-random-2-velocity-update-with-constriction-factor-self-velocities-i-self-chi-self-w-self-velocities-i-self-c1-r1-self-personal-best-positions-i-self-positions-i-self-c2-r2-self-global-best-position-self-positions-i-position-update-self-positions-i-self-velocities-i-boundary-handling-self-positions-i-np-clip-self-positions-i-self-bounds-min-self-bounds-max">runnable: false def update_particles(self): ‚Äú‚Äù‚ÄùUpdate particle velocities and positions.‚Äù‚Äù‚Äù for i in range(self.n_particles): # Random coefficients r1, r2 = np.random.random(2) # Velocity update with constriction factor self.velocities[i] = self.chi * ( self.w * self.velocities[i] + self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i]) + self.c2 * r2 * (self.global_best_position - self.positions[i]) ) # Position update self.positions[i] += self.velocities[i] # Boundary handling self.positions[i] = np.clip(self.positions[i], self.bounds_min, self.bounds_max)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#runnable-false-class-testmathematicalcorrectness-test-mathematical-properties-of-implementations-def-test-lyapunov-function-properties-self-test-lyapunov-function-is-positive-definite-controller-classicalsmc-for-in-range-1000-state-np-random-uniform-6-v-controller-compute-lyapunov-function-state-property-1-v-0-assert-v-0-property-2-v-0-only-at-equilibrium-if-not-np-allclose-state-0-assert-v-0-def-test-sliding-surface-stability-self-test-sliding-surface-leads-to-stable-dynamics-controller-classicalsmc-lambda1-2-0-lambda2-1-5-test-exponential-stability-on-sliding-surface-dt-0-01-times-np-arange-0-5-dt-for-initial-error-in-0-1-0-5-1-0-e1-history-initial-error-e2-history-initial-error-for-t-in-times-1-sliding-dynamics-e1-1e1-0-e2-2e2-0-e1-new-e1-history-1-np-exp-controller-lambda1-dt-e2-new-e2-history-1-np-exp-controller-lambda2-dt-e1-history-append-e1-new-e2-history-append-e2-new-verify-exponential-decay-assert-e1-history-1-0-01-initial-error-assert-e2-history-1-0-01-initial-error">runnable: false class TestMathematicalCorrectness: ‚Äú‚Äù‚ÄùTest mathematical properties of implementations.‚Äù‚Äù‚Äù def test_lyapunov_function_properties(self): ‚Äú‚Äù‚ÄùTest Lyapunov function is positive definite.‚Äù‚Äù‚Äù controller = ClassicalSMC() for _ in range(1000): state = np.random.uniform(-œÄ, œÄ, 6) V = controller.compute_lyapunov_function(state) # Property 1: V ‚â• 0 assert V &gt;= 0 # Property 2: V = 0 only at equilibrium if not np.allclose(state, 0): assert V &gt; 0 def test_sliding_surface_stability(self): ‚Äú‚Äù‚ÄùTest sliding surface leads to stable dynamics.‚Äù‚Äù‚Äù controller = ClassicalSMC(lambda1=2.0, lambda2=1.5) # Test exponential stability on sliding surface dt = 0.01 times = np.arange(0, 5, dt) for initial_error in [0.1, 0.5, 1.0]: e1_history = [initial_error] e2_history = [initial_error] for t in times[1:]: # Sliding dynamics: ƒó‚ÇÅ + Œª‚ÇÅe‚ÇÅ = 0, ƒó‚ÇÇ + Œª‚ÇÇe‚ÇÇ = 0 e1_new = e1_history[-1] * np.exp(-controller.lambda1 * dt) e2_new = e2_history[-1] * np.exp(-controller.lambda2 * dt) e1_history.append(e1_new) e2_history.append(e2_new) # Verify exponential decay assert e1_history[-1] &lt; 0.01 * initial_error assert e2_history[-1] &lt; 0.01 * initial_error</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#id4">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_algorithm_validation.html#runnable-false-def-test-end-to-end-mathematical-properties-test-mathematical-properties-in-complete-system-initialize-system-system-doubleinvertedpendulum-controller-classicalsmc-initial-condition-away-from-equilibrium-x0-np-array-0-2-0-1-0-0-0-0-0-0-0-0-target-np-zeros-6-simulate-system-trajectory-simulate-system-system-controller-x0-target-t-final-10-0-mathematical-property-verification-1-verify-lyapunov-function-decreases-v-values-controller-compute-lyapunov-function-state-for-state-in-trajectory-states-assert-np-all-np-diff-v-values-0-lyapunov-function-must-be-non-increasing-2-verify-convergence-to-target-final-error-np-linalg-norm-trajectory-states-1-target-assert-final-error-0-01-f-final-error-final-error-too-large-3-verify-control-signal-bounds-max-control-np-max-np-abs-trajectory-controls-assert-max-control-controller-u-max-control-signal-exceeds-limits">runnable: false def test_end_to_end_mathematical_properties(): ‚Äú‚Äù‚ÄùTest mathematical properties in complete system.‚Äù‚Äù‚Äù # Initialize system system = DoubleInvertedPendulum() controller = ClassicalSMC() # Initial condition away from equilibrium x0 = np.array([0.2, 0.1, 0.0, 0.0, 0.0, 0.0]) target = np.zeros(6) # Simulate system trajectory = simulate_system(system, controller, x0, target, t_final=10.0) # Mathematical property verification # 1. Verify Lyapunov function decreases V_values = [controller.compute_lyapunov_function(state) for state in trajectory.states] assert np.all(np.diff(V_values) &lt;= 0), ‚ÄúLyapunov function must be non-increasing‚Äù # 2. Verify convergence to target final_error = np.linalg.norm(trajectory.states[-1] - target) assert final_error &lt; 0.01, f‚ÄùFinal error {final_error} too large‚Äù # 3. Verify control signal bounds max_control = np.max(np.abs(trajectory.controls)) assert max_control &lt;= controller.u_max, ‚ÄúControl signal exceeds limits‚Äù</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../mathematical_foundations/index.html">Mathematical Foundations</a><input aria-label="Toggle navigation of Mathematical Foundations" class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/README.html">SMC Mathematical Foundations Documentation This directory contains mathematical documentation for all SMC algorithm fixes and validation methodology implemented for GitHub Issue #5. ## üìã Documentation Overview This mathematical foundation documentation provides: - <strong>Complete mathematical theory</strong> behind all SMC algorithm implementations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/smc_complete_theory.html">Complete Sliding Mode Control Mathematical Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/smc_theory.html">SMC Mathematical Theory Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/sliding_surface_analysis.html">Sliding Surface Mathematical Properties and Stability Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/boundary_layer_derivations.html">Boundary Layer Mathematical Derivations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/controller_comparison_theory.html">SMC Controller Comparison Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html">Advanced Algorithms Guide <strong>Technical Reference for Optimization, Numerical Stability, and Algorithm Comparison</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#configure-inertia-weight-schedule-in-config-yaml">Configure inertia weight schedule in config.yaml:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#pso">pso:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#w-schedule-0-9-0-4-start-at-0-9-end-at-0-4">w_schedule: [0.9, 0.4] # Start at 0.9, end at 0.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#iters-100">iters: 100</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#n-particles-30-result-tuner-optimise-uses-w-schedule-from-config-manual-iteration-loop-for-custom-control">n_particles: 30 result = tuner.optimise() # Uses w_schedule from config # Manual iteration loop for custom control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#runnable-false-configure-physics-uncertainty-in-config-yaml">runnable: false # Configure physics uncertainty in config.yaml:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#physics-uncertainty">physics_uncertainty:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#n-evals-5-5-perturbed-models-per-evaluation">n_evals: 5 # 5 perturbed models per evaluation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#cart-mass-0-10-10">cart_mass: 0.10 # ¬±10%</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#pendulum1-mass-0-15-15">pendulum1_mass: 0.15 # ¬±15%</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#pendulum2-mass-0-15-15">pendulum2_mass: 0.15 # ¬±15%</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#pendulum1-length-0-05-5">pendulum1_length: 0.05 # ¬±5%</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#pendulum2-length-0-05-5-tuner-psotuner-controller-factory-controller-factory-config-config-seed-42">pendulum2_length: 0.05 # ¬±5% tuner = PSOTuner( controller_factory=controller_factory, config=config, seed=42</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/advanced_algorithms_guide.html#cost-aggregation-0-7-mean-0-3-max">Cost aggregation: 0.7 * mean + 0.3 * max</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html">SMC Algorithm Fixes and Mathematical Validation Summary This document provides a summary of all mathematical algorithm fixes, validation improvements, and corrected implementations in the SMC controller system for GitHub Issue #5. ## 1. Executive Summary The SMC mathematical foundation has been completely restructured and validated with the following major improvements: - <strong>Boundary Layer Mathematics</strong>: Corrected chattering reduction theory and implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-compute-switching-function-self-surface-value-float-float-compute-continuous-switching-function-with-adaptive-boundary-layer-adaptive-boundary-layer-thickness-surface-derivative-self-get-surface-derivative-effective-thickness-self-base-thickness-self-slope-abs-surface-derivative-continuous-switching-approximation-if-self-switch-method-tanh-return-np-tanh-surface-value-effective-thickness-elif-self-switch-method-linear-return-np-clip-surface-value-effective-thickness-1-0-1-0-else-sign-return-np-sign-surface-value-3-validation-rules-python-if-thickness-0-raise-valueerror-boundary-layer-thickness-must-be-positive-if-slope-0-raise-valueerror-boundary-layer-slope-must-be-non-negative-mathematical-impact">runnable: false def compute_switching_function(self, surface_value: float) -&gt; float: ‚Äú‚Äù‚ÄùCompute continuous switching function with adaptive boundary layer.‚Äù‚Äù‚Äù # Adaptive boundary layer thickness surface_derivative = self._get_surface_derivative() effective_thickness = self.base_thickness + self.slope * abs(surface_derivative) # Continuous switching approximation if self.switch_method == ‚Äútanh‚Äù: return np.tanh(surface_value / effective_thickness) elif self.switch_method == ‚Äúlinear‚Äù: return np.clip(surface_value / effective_thickness, -1.0, 1.0) else: # ‚Äúsign‚Äù return np.sign(surface_value) <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Validation</span> <span class="pre">Rules:**</span></code>python if thickness &lt;= 0: raise ValueError(‚ÄúBoundary layer thickness must be positive‚Äù) if slope &lt; 0: raise ValueError(‚ÄúBoundary layer slope must be non-negative‚Äù) ``` <strong>Mathematical Impact:</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-compute-self-state-np-ndarray-float-compute-linear-sliding-surface-with-numerical-safeguards-input-validation-if-len-state-6-raise-valueerror-state-must-have-at-least-6-elements-handle-non-finite-values-if-not-np-all-np-isfinite-state-state-np-where-np-isfinite-state-state-0-0-extract-components-theta1-theta1-dot-state-2-state-3-theta2-theta2-dot-state-4-state-5-linear-sliding-surface-s-11-k11-22-k22-s-self-lam1-theta1-dot-self-k1-theta1-self-lam2-theta2-dot-self-k2-theta2-numerical-safety-return-0-0-if-not-np-isfinite-s-else-float-s-2-stability-analysis-integration-python">runnable: false def compute(self, state: np.ndarray) -&gt; float: ‚Äú‚Äù‚ÄùCompute linear sliding surface with numerical safeguards.‚Äù‚Äù‚Äù # Input validation if len(state) &lt; 6: raise ValueError(‚ÄúState must have at least 6 elements‚Äù) # Handle non-finite values if not np.all(np.isfinite(state)): state = np.where(np.isfinite(state), state, 0.0) # Extract components theta1, theta1_dot = state[2], state[3] theta2, theta2_dot = state[4], state[5] # Linear sliding surface: s = Œª‚ÇÅŒ∏Ãá‚ÇÅ + k‚ÇÅŒ∏‚ÇÅ + Œª‚ÇÇŒ∏Ãá‚ÇÇ + k‚ÇÇŒ∏‚ÇÇ s = (self.lam1 * theta1_dot + self.k1 * theta1 + self.lam2 * theta2_dot + self.k2 * theta2) # Numerical safety return 0.0 if not np.isfinite(s) else float(s) <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Stability</span> <span class="pre">Analysis</span> <span class="pre">Integration:**</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-validate-gains-self-none-validate-gains-according-to-hurwitz-stability-requirements-check-finite-values-if-not-np-all-np-isfinite-self-gains-invalid-indices-np-where-np-isfinite-self-gains-0-raise-valueerror-f-gains-contain-nan-infinite-values-at-indices-invalid-indices-positivity-requirement-for-stability-if-len-self-gains-4-if-any-g-0-for-g-in-self-gains-4-raise-valueerror-surface-gains-k1-k2-1-2-must-be-positive-for-stability-minimum-threshold-for-numerical-stability-if-any-g-1e-12-for-g-in-self-gains-4-raise-valueerror-gains-too-small-min-1e-12-numerical-instability-risk-3-mathematical-property-verification-linearity-s-x1-x2-s-x1-s-x2-homogeneity-s-x-s-x-continuity-lim-xx0-s-x-s-x0-differentiability-ds-dt-exists-and-is-computable-mathematical-impact">runnable: false def _validate_gains(self) -&gt; None: ‚Äú‚Äù‚ÄùValidate gains according to Hurwitz stability requirements.‚Äù‚Äù‚Äù # Check finite values if not np.all(np.isfinite(self.gains)): invalid_indices = np.where(~np.isfinite(self.gains))[0] raise ValueError(f‚ÄùGains contain NaN/infinite values at indices: {invalid_indices}‚Äù) # Positivity requirement for stability if len(self.gains) &gt;= 4: if any(g &lt;= 0 for g in self.gains[:4]): raise ValueError(‚ÄúSurface gains [k1, k2, Œª1, Œª2] must be positive for stability‚Äù) # Minimum threshold for numerical stability if any(g &lt; 1e-12 for g in self.gains[:4]): raise ValueError(‚ÄúGains too small (min: 1e-12) - numerical instability risk‚Äù) ``` 3. <strong>Mathematical Property Verification:</strong> - <strong>Linearity</strong>: <code class="docutils literal notranslate"><span class="pre">s(Œ±x‚ÇÅ</span> <span class="pre">+</span> <span class="pre">Œ≤x‚ÇÇ)</span> <span class="pre">=</span> <span class="pre">Œ±s(x‚ÇÅ)</span> <span class="pre">+</span> <span class="pre">Œ≤s(x‚ÇÇ)</span></code> - <strong>Homogeneity</strong>: <code class="docutils literal notranslate"><span class="pre">s(Œ±x)</span> <span class="pre">=</span> <span class="pre">Œ±s(x)</span></code> - <strong>Continuity</strong>: <code class="docutils literal notranslate"><span class="pre">lim_{x‚Üíx‚ÇÄ}</span> <span class="pre">s(x)</span> <span class="pre">=</span> <span class="pre">s(x‚ÇÄ)</span></code> - <strong>Differentiability</strong>: <code class="docutils literal notranslate"><span class="pre">ds/dt</span></code> exists and is computable <strong>Mathematical Impact:</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-dataclass-frozen-true-class-classicalsmcconfig-type-safe-configuration-with-mathematical-validation-def-post-init-self-validate-configuration-after-creation-self-validate-gains-self-validate-parameters-self-validate-mathematical-constraints-def-validate-gains-self-none-validate-gain-vector-according-to-smc-theory-if-len-self-gains-6-raise-valueerror-classical-smc-requires-exactly-6-gains-k1-k2-lam1-lam2-k-kd-self-gains-surface-gains-positive-for-hurwitz-stability-if-any-g-0-for-g-in-k1-k2-lam1-lam2-raise-valueerror-surface-gains-must-be-positive-for-stability-switching-gain-positive-for-reaching-condition-if-k-0-raise-valueerror-switching-gain-k-must-be-positive-derivative-gain-non-negative-for-damping-if-kd-0-raise-valueerror-derivative-gain-kd-must-be-non-negative-def-validate-mathematical-constraints-self-none-validate-constraints-from-mathematical-theory-damping-ratio-bounds-for-each-subsystem-zeta1-self-lam1-2-np-sqrt-self-k1-zeta2-self-lam2-2-np-sqrt-self-k2-if-zeta1-0-1-or-zeta2-0-1-raise-valueerror-damping-ratios-too-low-may-cause-oscillations-if-zeta1-10-0-or-zeta2-10-0-raise-valueerror-damping-ratios-too-high-may-cause-sluggish-response-2-edge-case-handling-python-def-get-effective-controllability-threshold-self-float-auto-compute-threshold-based-on-system-parameters-if-self-controllability-threshold-is-not-none-return-self-controllability-threshold-scale-with-surface-gains-for-adaptive-behavior-base-threshold-0-05-self-k1-self-k2-bound-within-reasonable-limits-return-np-clip-base-threshold-0-01-1-0-mathematical-impact">runnable: false @dataclass(frozen=True) class ClassicalSMCConfig: ‚Äú‚Äù‚ÄùType-safe configuration with mathematical validation.‚Äù‚Äù‚Äù def <strong>post_init</strong>(self): ‚Äú‚Äù‚ÄùValidate configuration after creation.‚Äù‚Äù‚Äù self._validate_gains() self._validate_parameters() self._validate_mathematical_constraints() def _validate_gains(self) -&gt; None: ‚Äú‚Äù‚ÄùValidate gain vector according to SMC theory.‚Äù‚Äù‚Äù if len(self.gains) != 6: raise ValueError(‚ÄúClassical SMC requires exactly 6 gains‚Äù) k1, k2, lam1, lam2, K, kd = self.gains # Surface gains: positive for Hurwitz stability if any(g &lt;= 0 for g in [k1, k2, lam1, lam2]): raise ValueError(‚ÄúSurface gains must be positive for stability‚Äù) # Switching gain: positive for reaching condition if K &lt;= 0: raise ValueError(‚ÄúSwitching gain K must be positive‚Äù) # Derivative gain: non-negative for damping if kd &lt; 0: raise ValueError(‚ÄúDerivative gain kd must be non-negative‚Äù) def _validate_mathematical_constraints(self) -&gt; None: ‚Äú‚Äù‚ÄùValidate constraints from mathematical theory.‚Äù‚Äù‚Äù # Damping ratio bounds for each subsystem zeta1 = self.lam1 / (2 * np.sqrt(self.k1)) zeta2 = self.lam2 / (2 * np.sqrt(self.k2)) if zeta1 &lt; 0.1 or zeta2 &lt; 0.1: raise ValueError(‚ÄúDamping ratios too low - may cause oscillations‚Äù) if zeta1 &gt; 10.0 or zeta2 &gt; 10.0: raise ValueError(‚ÄúDamping ratios too high - may cause sluggish response‚Äù) <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Edge</span> <span class="pre">Case</span> <span class="pre">Handling:**</span></code>python def get_effective_controllability_threshold(self) -&gt; float: ‚Äú‚Äù‚ÄùAuto-compute threshold based on system parameters.‚Äù‚Äù‚Äù if self.controllability_threshold is not None: return self.controllability_threshold # Scale with surface gains for adaptive behavior base_threshold = 0.05 * (self.k1 + self.k2) # Bound within reasonable limits return np.clip(base_threshold, 0.01, 1.0) ``` <strong>Mathematical Impact:</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-given-gains-st-lists-st-floats-min-value-0-1-max-value-50-0-min-size-4-max-size-4-state-st-lists-st-floats-min-value-10-0-max-value-10-0-min-size-6-max-size-6-def-test-sliding-surface-linearity-property-self-gains-state-test-linearity-property-for-all-valid-parameter-combinations-surface-linearslidingsurface-gains-state1-np-array-state-state2-np-random-uniform-10-10-6-s1-surface-compute-state1-s2-surface-compute-state2-s-combined-surface-compute-state1-state2-mathematical-property-s-x1-x2-s-x1-s-x2-assert-abs-s-combined-s1-s2-1e-10-2-boundary-layer-monotonicity-python">runnable: false @given( gains=st.lists(st.floats(min_value=0.1, max_value=50.0), min_size=4, max_size=4), state=st.lists(st.floats(min_value=-10.0, max_value=10.0), min_size=6, max_size=6) ) def test_sliding_surface_linearity_property(self, gains, state): ‚Äú‚Äù‚ÄùTest linearity property for all valid parameter combinations.‚Äù‚Äù‚Äù surface = LinearSlidingSurface(gains) state1 = np.array(state) state2 = np.random.uniform(-10, 10, 6) s1 = surface.compute(state1) s2 = surface.compute(state2) s_combined = surface.compute(state1 + state2) # Mathematical property: s(x1 + x2) = s(x1) + s(x2) assert abs(s_combined - (s1 + s2)) &lt; 1e-10 <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Boundary</span> <span class="pre">Layer</span> <span class="pre">Monotonicity:**</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-test-boundary-layer-monotonicity-all-methods-self-test-monotonicity-for-all-switching-methods-methods-tanh-linear-sign-for-method-in-methods-boundary-layer-boundarylayer-thickness-0-1-switch-method-method-s-values-np-linspace-2-2-1000-switch-values-boundary-layer-compute-switching-function-s-for-s-in-s-values-must-be-monotonically-increasing-for-i-in-range-len-switch-values-1-assert-switch-values-i-1-switch-values-i-3-configuration-validation-coverage-python">runnable: false def test_boundary_layer_monotonicity_all_methods(self): ‚Äú‚Äù‚ÄùTest monotonicity for all switching methods.‚Äù‚Äù‚Äù methods = [‚Äútanh‚Äù, ‚Äúlinear‚Äù, ‚Äúsign‚Äù] for method in methods: boundary_layer = BoundaryLayer(thickness=0.1, switch_method=method) s_values = np.linspace(-2, 2, 1000) switch_values = [boundary_layer.compute_switching_function(s) for s in s_values] # Must be monotonically increasing for i in range(len(switch_values) - 1): assert switch_values[i+1] &gt;= switch_values[i] <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Configuration</span> <span class="pre">Validation</span> <span class="pre">Coverage:**</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-class-testconfigurationvalidationcoverage-coverage-of-all-validation-rules-pytest-mark-parametrize-invalid-gain-index-0-1-2-3-def-test-zero-surface-gains-rejection-self-invalid-gain-index-test-rejection-of-zero-surface-gains-gains-5-0-3-0-4-0-2-0-10-0-1-0-gains-invalid-gain-index-0-0-with-pytest-raises-valueerror-match-must-be-positive-classicalsmcconfig-gains-gains-max-force-100-dt-0-01-boundary-layer-0-01-pytest-mark-parametrize-invalid-gain-index-0-1-2-3-def-test-negative-surface-gains-rejection-self-invalid-gain-index-test-rejection-of-negative-surface-gains-gains-5-0-3-0-4-0-2-0-10-0-1-0-gains-invalid-gain-index-1-0-with-pytest-raises-valueerror-match-must-be-positive-classicalsmcconfig-gains-gains-max-force-100-dt-0-01-boundary-layer-0-01-3-2-numerical-stability-testing-enhanced-numerical-robustness-tests-1-extreme-value-testing-python">runnable: false class TestConfigurationValidationCoverage: ‚Äú‚Äù‚Äùcoverage of all validation rules.‚Äù‚Äù‚Äù @pytest.mark.parametrize(‚Äúinvalid_gain_index‚Äù, [0, 1, 2, 3]) def test_zero_surface_gains_rejection(self, invalid_gain_index): ‚Äú‚Äù‚ÄùTest rejection of zero surface gains.‚Äù‚Äù‚Äù gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] gains[invalid_gain_index] = 0.0 with pytest.raises(ValueError, match=‚Äùmust be positive‚Äù): ClassicalSMCConfig(gains=gains, max_force=100, dt=0.01, boundary_layer=0.01) @pytest.mark.parametrize(‚Äúinvalid_gain_index‚Äù, [0, 1, 2, 3]) def test_negative_surface_gains_rejection(self, invalid_gain_index): ‚Äú‚Äù‚ÄùTest rejection of negative surface gains.‚Äù‚Äù‚Äù gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] gains[invalid_gain_index] = -1.0 with pytest.raises(ValueError, match=‚Äùmust be positive‚Äù): ClassicalSMCConfig(gains=gains, max_force=100, dt=0.01, boundary_layer=0.01) <code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">3.2</span> <span class="pre">Numerical</span> <span class="pre">Stability</span> <span class="pre">Testing</span> <span class="pre">**Enhanced</span> <span class="pre">Numerical</span> <span class="pre">Robustness</span> <span class="pre">Tests:**</span> <span class="pre">1.</span> <span class="pre">**Extreme</span> <span class="pre">Value</span> <span class="pre">Testing:**</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id7">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-test-numerical-stability-extreme-values-self-test-behavior-with-extreme-but-valid-parameter-values-very-small-gains-but-above-minimum-threshold-small-gains-1e-10-1e-10-1e-10-1e-10-1e-8-0-0-config-small-classicalsmcconfig-gains-small-gains-max-force-1e-6-dt-1e-6-boundary-layer-1e-8-very-large-gains-large-gains-1e6-1e6-1e6-1e6-1e8-1e4-config-large-classicalsmcconfig-gains-large-gains-max-force-1e8-dt-1e-3-boundary-layer-1-0-both-should-create-valid-controllers-controller-small-modularclassicalsmc-config-config-small-controller-large-modularclassicalsmc-config-config-large-test-with-moderate-state-values-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-result-small-controller-small-compute-control-state-result-large-controller-large-compute-control-state-both-should-produce-finite-bounded-results-assert-np-all-np-isfinite-result-small-get-control-output-0-assert-np-all-np-isfinite-result-large-get-control-output-0-2-precision-consistency-testing-python">runnable: false def test_numerical_stability_extreme_values(self): ‚Äú‚Äù‚ÄùTest behavior with extreme but valid parameter values.‚Äù‚Äù‚Äù # Very small gains (but above minimum threshold) small_gains = [1e-10, 1e-10, 1e-10, 1e-10, 1e-8, 0.0] config_small = ClassicalSMCConfig(gains=small_gains, max_force=1e-6, dt=1e-6, boundary_layer=1e-8) # Very large gains large_gains = [1e6, 1e6, 1e6, 1e6, 1e8, 1e4] config_large = ClassicalSMCConfig(gains=large_gains, max_force=1e8, dt=1e-3, boundary_layer=1.0) # Both should create valid controllers controller_small = ModularClassicalSMC(config=config_small) controller_large = ModularClassicalSMC(config=config_large) # Test with moderate state values state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) result_small = controller_small.compute_control(state, {}, {}) result_large = controller_large.compute_control(state, {}, {}) # Both should produce finite, bounded results assert np.all(np.isfinite(result_small.get(‚Äòcontrol_output‚Äô, [0]))) assert np.all(np.isfinite(result_large.get(‚Äòcontrol_output‚Äô, [0]))) <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Precision</span> <span class="pre">Consistency</span> <span class="pre">Testing:**</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id8">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-def-test-computation-precision-consistency-self-test-that-repeated-computations-maintain-precision-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-state-np-array-0-123456789-0-987654321-0-456789123-0-321654987-0-789123456-0-654987321-compute-control-1000-times-results-for-in-range-1000-result-controller-compute-control-state-control-result-get-control-output-result-get-control-0-results-append-control-results-np-array-results-standard-deviation-should-be-zero-deterministic-computation-std-dev-np-std-results-axis-0-if-results-ndim-1-else-np-std-results-assert-np-all-std-dev-1e-15-machine-precision-level-4-implementation-architecture-improvements-4-1-modular-component-design-before-monolithic-single-458-line-controller-with-mixed-concerns">runnable: false def test_computation_precision_consistency(self): ‚Äú‚Äù‚ÄùTest that repeated computations maintain precision.‚Äù‚Äù‚Äù config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) state = np.array([0.123456789, 0.987654321, 0.456789123, 0.321654987, 0.789123456, 0.654987321]) # Compute control 1000 times results = [] for _ in range(1000): result = controller.compute_control(state, {}, {}) control = result.get(‚Äòcontrol_output‚Äô, result.get(‚Äòcontrol‚Äô, 0)) results.append(control) results = np.array(results) # Standard deviation should be zero (deterministic computation) std_dev = np.std(results, axis=0) if results.ndim &gt; 1 else np.std(results) assert np.all(std_dev &lt; 1e-15) # Machine precision level ``` ## 4. Implementation Architecture Improvements ### 4.1 Modular Component Design <strong>Before (Monolithic):</strong> Single 458-line controller with mixed concerns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#id9">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/algorithm_fixes_summary.html#runnable-false-class-slidingsurface-abc-abstract-interface-for-sliding-surface-calculations-abstractmethod-def-compute-self-state-np-ndarray-float-compute-sliding-surface-value-pass-abstractmethod-def-compute-derivative-self-state-np-ndarray-state-dot-np-ndarray-float-compute-sliding-surface-derivative-pass-abstractmethod-def-validate-gains-self-none-validate-gains-for-mathematical-correctness-pass-class-boundarylayer-interface-for-boundary-layer-implementations-def-compute-switching-function-self-surface-value-float-float-compute-continuous-switching-function-pass-def-compute-switching-control-self-surface-value-float-gain-float-surface-derivative-float-0-0-float-compute-switching-control-with-boundary-layer-pass">runnable: false class SlidingSurface(ABC): ‚Äú‚Äù‚ÄùAbstract interface for sliding surface calculations.‚Äù‚Äù‚Äù @abstractmethod def compute(self, state: np.ndarray) -&gt; float: ‚Äú‚Äù‚ÄùCompute sliding surface value.‚Äù‚Äù‚Äù pass @abstractmethod def compute_derivative(self, state: np.ndarray, state_dot: np.ndarray) -&gt; float: ‚Äú‚Äù‚ÄùCompute sliding surface derivative.‚Äù‚Äù‚Äù pass @abstractmethod def _validate_gains(self) -&gt; None: ‚Äú‚Äù‚ÄùValidate gains for mathematical correctness.‚Äù‚Äù‚Äù pass class BoundaryLayer: ‚Äú‚Äù‚ÄùInterface for boundary layer implementations.‚Äù‚Äù‚Äù def compute_switching_function(self, surface_value: float) -&gt; float: ‚Äú‚Äù‚ÄùCompute continuous switching function.‚Äù‚Äù‚Äù pass def compute_switching_control(self, surface_value: float, gain: float, surface_derivative: float = 0.0) -&gt; float: ‚Äú‚Äù‚ÄùCompute switching control with boundary layer.‚Äù‚Äù‚Äù pass</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/pso_algorithm_theory.html">Particle Swarm Optimization: Mathematical Theory <strong>Module:</strong> Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/pso_algorithm_theory.html#balanced-recommended-for-smc">Balanced (recommended for SMC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/optimization_landscape_analysis.html">Optimization Landscape Analysis for Controller Gain Tuning</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/dynamics_derivations.html">Double Inverted Pendulum Dynamics: Complete Derivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/numerical_integration_theory.html">Numerical Integration Methods: Theory and Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/simulation_architecture_guide.html">Simulation Architecture Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/config_validation_specification.html">ClassicalSMCConfig Parameters and Validation Rules This document provides specification of the <code class="docutils literal notranslate"><span class="pre">ClassicalSMCConfig</span></code> parameters, their mathematical foundations, validation rules, and edge case handling. ## 1. Configuration Schema Overview The <code class="docutils literal notranslate"><span class="pre">ClassicalSMCConfig</span></code> dataclass provides type-safe, validated configuration for Classical Sliding Mode Control with the following parameter categories: - <strong>Control Parameters</strong>: Core SMC gains and timing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html">Mathematical Test Validation Methodology This document describes the methodology for validating mathematical properties and algorithm correctness in the SMC controller implementations. ## 1. Overview The test validation methodology ensures that all mathematical algorithms and fixes in the SMC system are rigorously validated through: - <strong>Property-based testing</strong>: Verification of mathematical properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-def-test-sliding-surface-linearity-test-that-sliding-surface-is-linear-in-state-surface-linearslidingsurface-gains-5-3-4-2-state1-np-array-0-1-0-1-0-1-0-05-0-05-0-05-state2-np-array-0-2-0-2-0-2-0-1-0-1-0-1-s1-surface-compute-state1-s2-surface-compute-state2-s-combined-surface-compute-state1-state2-linearity-s-x1-x2-s-x1-s-x2-assert-abs-s-combined-s1-s2-1e-10-2-homogeneity-property-python-def-test-sliding-surface-homogeneity-test-that-sliding-surface-is-homogeneous-of-degree-1-surface-linearslidingsurface-gains-5-3-4-2-state-np-array-0-1-0-1-0-1-0-05-0-05-0-05-alpha-2-5-s-original-surface-compute-state-s-scaled-surface-compute-alpha-state-homogeneity-s-x-s-x-assert-abs-s-scaled-alpha-s-original-1e-10-3-gain-sensitivity-python">runnable: false def test_sliding_surface_linearity(): ‚Äú‚Äù‚ÄùTest that sliding surface is linear in state.‚Äù‚Äù‚Äù surface = LinearSlidingSurface(gains=[5, 3, 4, 2]) state1 = np.array([0.1, 0.1, 0.1, 0.05, 0.05, 0.05]) state2 = np.array([0.2, 0.2, 0.2, 0.1, 0.1, 0.1]) s1 = surface.compute(state1) s2 = surface.compute(state2) s_combined = surface.compute(state1 + state2) # Linearity: s(x1 + x2) = s(x1) + s(x2) assert abs(s_combined - (s1 + s2)) &lt; 1e-10 <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Homogeneity</span> <span class="pre">Property**:</span></code>python def test_sliding_surface_homogeneity(): ‚Äú‚Äù‚ÄùTest that sliding surface is homogeneous of degree 1.‚Äù‚Äù‚Äù surface = LinearSlidingSurface(gains=[5, 3, 4, 2]) state = np.array([0.1, 0.1, 0.1, 0.05, 0.05, 0.05]) alpha = 2.5 s_original = surface.compute(state) s_scaled = surface.compute(alpha * state) # Homogeneity: s(Œ±¬∑x) = Œ±¬∑s(x) assert abs(s_scaled - alpha * s_original) &lt; 1e-10 <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Gain</span> <span class="pre">Sensitivity**:</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-def-test-sliding-surface-gain-sensitivity-test-that-surface-responds-correctly-to-gain-changes-gains1-5-3-4-2-gains2-10-6-8-4-doubled-gains-surface1-linearslidingsurface-gains1-surface2-linearslidingsurface-gains2-state-np-array-0-1-0-1-0-1-0-05-0-05-0-05-s1-surface1-compute-state-s2-surface2-compute-state-surface-value-should-double-with-doubled-gains-assert-abs-s2-2-s1-1e-10-2-1-2-boundary-layer-properties-test-suite-tests-test-controllers-smc-algorithms-classical-test-boundary-layer-py-mathematical-properties-validated-1-continuity-python">runnable: false def test_sliding_surface_gain_sensitivity(): ‚Äú‚Äù‚ÄùTest that surface responds correctly to gain changes.‚Äù‚Äù‚Äù gains1 = [5, 3, 4, 2] gains2 = [10, 6, 8, 4] # Doubled gains surface1 = LinearSlidingSurface(gains1) surface2 = LinearSlidingSurface(gains2) state = np.array([0.1, 0.1, 0.1, 0.05, 0.05, 0.05]) s1 = surface1.compute(state) s2 = surface2.compute(state) # Surface value should double with doubled gains assert abs(s2 - 2 * s1) &lt; 1e-10 <code class="docutils literal notranslate"><span class="pre">####</span> <span class="pre">2.1.2</span> <span class="pre">Boundary</span> <span class="pre">Layer</span> <span class="pre">Properties</span> <span class="pre">**Test</span> <span class="pre">Suite:**</span> <span class="pre">`tests/test_controllers/smc/algorithms/classical/test_boundary_layer.py`</span> <span class="pre">**Mathematical</span> <span class="pre">Properties</span> <span class="pre">Validated:**</span> <span class="pre">1.</span> <span class="pre">**Continuity**:</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-def-test-boundary-layer-continuity-test-that-boundary-layer-provides-continuous-switching-boundary-layer-boundarylayer-thickness-0-1-switch-method-tanh-test-continuity-at-surface-s-0-epsilon-1e-8-switch-left-boundary-layer-compute-switching-function-epsilon-switch-right-boundary-layer-compute-switching-function-epsilon-switch-center-boundary-layer-compute-switching-function-0-0-values-should-be-very-close-at-the-boundary-assert-abs-switch-left-switch-center-1e-6-assert-abs-switch-right-switch-center-1e-6-2-monotonicity-python-def-test-boundary-layer-monotonicity-test-that-switching-function-is-monotonic-boundary-layer-boundarylayer-thickness-0-1-switch-method-tanh-s-values-np-linspace-1-1-100-switch-values-boundary-layer-compute-switching-function-s-for-s-in-s-values-switching-function-should-be-strictly-increasing-for-i-in-range-len-switch-values-1-assert-switch-values-i-1-switch-values-i-3-asymptotic-behavior-python-def-test-boundary-layer-asymptotic-behavior-test-asymptotic-limits-of-switching-function-boundary-layer-boundarylayer-thickness-0-1-switch-method-tanh-large-positive-surface-value-switch-pos-boundary-layer-compute-switching-function-10-0-assert-abs-switch-pos-1-0-1e-3-large-negative-surface-value-switch-neg-boundary-layer-compute-switching-function-10-0-assert-abs-switch-neg-1-0-1e-3-2-2-configuration-validation-tests-test-suite-tests-test-controllers-smc-algorithms-classical-test-config-validation-py-2-2-1-parameter-validationpython">runnable: false def test_boundary_layer_continuity(): ‚Äú‚Äù‚ÄùTest that boundary layer provides continuous switching.‚Äù‚Äù‚Äù boundary_layer = BoundaryLayer(thickness=0.1, switch_method=‚Äùtanh‚Äù) # Test continuity at surface (s=0) epsilon = 1e-8 switch_left = boundary_layer.compute_switching_function(-epsilon) switch_right = boundary_layer.compute_switching_function(epsilon) switch_center = boundary_layer.compute_switching_function(0.0) # Values should be very close at the boundary assert abs(switch_left - switch_center) &lt; 1e-6 assert abs(switch_right - switch_center) &lt; 1e-6 <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Monotonicity**:</span></code>python def test_boundary_layer_monotonicity(): ‚Äú‚Äù‚ÄùTest that switching function is monotonic.‚Äù‚Äù‚Äù boundary_layer = BoundaryLayer(thickness=0.1, switch_method=‚Äùtanh‚Äù) s_values = np.linspace(-1, 1, 100) switch_values = [boundary_layer.compute_switching_function(s) for s in s_values] # Switching function should be strictly increasing for i in range(len(switch_values) - 1): assert switch_values[i+1] &gt;= switch_values[i] <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Asymptotic</span> <span class="pre">Behavior**:</span></code>python def test_boundary_layer_asymptotic_behavior(): ‚Äú‚Äù‚ÄùTest asymptotic limits of switching function.‚Äù‚Äù‚Äù boundary_layer = BoundaryLayer(thickness=0.1, switch_method=‚Äùtanh‚Äù) # Large positive surface value switch_pos = boundary_layer.compute_switching_function(10.0) assert abs(switch_pos - 1.0) &lt; 1e-3 # Large negative surface value switch_neg = boundary_layer.compute_switching_function(-10.0) assert abs(switch_neg - (-1.0)) &lt; 1e-3 <code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">2.2</span> <span class="pre">Configuration</span> <span class="pre">Validation</span> <span class="pre">Tests</span> <span class="pre">**Test</span> <span class="pre">Suite:**</span> <span class="pre">`tests/test_controllers/smc/algorithms/classical/test_config_validation.py`</span> <span class="pre">####</span> <span class="pre">2.2.1</span> <span class="pre">Parameter</span> <span class="pre">Validation</span></code>python</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-class-testclassicalsmcconfigvalidation-test-configuration-parameter-validation-def-test-positive-gain-requirement-self-test-that-all-surface-gains-must-be-positive-valid-configuration-valid-gains-5-0-3-0-4-0-2-0-10-0-1-0-config-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-01-invalid-zero-gain-with-pytest-raises-valueerror-match-must-be-positive-invalid-gains-0-0-3-0-4-0-2-0-10-0-1-0-classicalsmcconfig-gains-invalid-gains-max-force-100-dt-0-01-boundary-layer-0-01-invalid-negative-gain-with-pytest-raises-valueerror-match-must-be-positive-invalid-gains-5-0-3-0-4-0-2-0-10-0-1-0-classicalsmcconfig-gains-invalid-gains-max-force-100-dt-0-01-boundary-layer-0-01-def-test-switching-gain-validation-self-test-switching-gain-must-be-positive-with-pytest-raises-valueerror-match-switching-gain-k-must-be-positive-invalid-gains-5-0-3-0-4-0-2-0-10-0-1-0-k-0-classicalsmcconfig-gains-invalid-gains-max-force-100-dt-0-01-boundary-layer-0-01-def-test-boundary-layer-validation-self-test-boundary-layer-thickness-validation-valid-boundary-layer-valid-gains-5-0-3-0-4-0-2-0-10-0-1-0-config-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-05-invalid-zero-boundary-layer-with-pytest-raises-valueerror-match-boundary-layer-must-be-positive-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-0-invalid-negative-boundary-layer-with-pytest-raises-valueerror-match-boundary-layer-must-be-positive-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-01">runnable: false class TestClassicalSMCConfigValidation: ‚Äú‚Äù‚ÄùTest configuration parameter validation.‚Äù‚Äù‚Äù def test_positive_gain_requirement(self): ‚Äú‚Äù‚ÄùTest that all surface gains must be positive.‚Äù‚Äù‚Äù # Valid configuration valid_gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] config = ClassicalSMCConfig(gains=valid_gains, max_force=100, dt=0.01, boundary_layer=0.01) # Invalid: zero gain with pytest.raises(ValueError, match=‚Äùmust be positive‚Äù): invalid_gains = [0.0, 3.0, 4.0, 2.0, 10.0, 1.0] ClassicalSMCConfig(gains=invalid_gains, max_force=100, dt=0.01, boundary_layer=0.01) # Invalid: negative gain with pytest.raises(ValueError, match=‚Äùmust be positive‚Äù): invalid_gains = [5.0, -3.0, 4.0, 2.0, 10.0, 1.0] ClassicalSMCConfig(gains=invalid_gains, max_force=100, dt=0.01, boundary_layer=0.01) def test_switching_gain_validation(self): ‚Äú‚Äù‚ÄùTest switching gain must be positive.‚Äù‚Äù‚Äù with pytest.raises(ValueError, match=‚ÄùSwitching gain K must be positive‚Äù): invalid_gains = [5.0, 3.0, 4.0, 2.0, -10.0, 1.0] # K &lt; 0 ClassicalSMCConfig(gains=invalid_gains, max_force=100, dt=0.01, boundary_layer=0.01) def test_boundary_layer_validation(self): ‚Äú‚Äù‚ÄùTest boundary layer thickness validation.‚Äù‚Äù‚Äù # Valid boundary layer valid_gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] config = ClassicalSMCConfig(gains=valid_gains, max_force=100, dt=0.01, boundary_layer=0.05) # Invalid: zero boundary layer with pytest.raises(ValueError, match=‚Äùboundary_layer must be positive‚Äù): ClassicalSMCConfig(gains=valid_gains, max_force=100, dt=0.01, boundary_layer=0.0) # Invalid: negative boundary layer with pytest.raises(ValueError, match=‚Äùboundary_layer must be positive‚Äù): ClassicalSMCConfig(gains=valid_gains, max_force=100, dt=0.01, boundary_layer=-0.01)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-def-test-hurwitz-stability-check-test-that-gain-combinations-satisfy-hurwitz-stability-def-check-stability-k1-k2-lam1-lam2-check-if-gains-produce-stable-sliding-dynamics-for-each-2x2-subsystem-s2-is-ci-0-stability-requires-i-0-and-ci-0-return-k1-0-and-k2-0-and-lam1-0-and-lam2-0-stable-configuration-stable-gains-5-0-3-0-4-0-2-0-10-0-1-0-config-classicalsmcconfig-gains-stable-gains-max-force-100-dt-0-01-boundary-layer-0-01-assert-check-stability-config-k1-config-k2-config-lam1-config-lam2-check-damping-ratios-zeta1-config-lam1-2-np-sqrt-config-k1-zeta2-config-lam2-2-np-sqrt-config-k2-both-subsystems-should-have-positive-damping-assert-zeta1-0-assert-zeta2-0">runnable: false def test_hurwitz_stability_check(): ‚Äú‚Äù‚ÄùTest that gain combinations satisfy Hurwitz stability.‚Äù‚Äù‚Äù def check_stability(k1, k2, lam1, lam2): ‚Äú‚Äù‚ÄùCheck if gains produce stable sliding dynamics.‚Äù‚Äù‚Äù # For each 2x2 subsystem: s¬≤ + Œª·µ¢s + c·µ¢ = 0 # Stability requires Œª·µ¢ &gt; 0 and c·µ¢ &gt; 0 return k1 &gt; 0 and k2 &gt; 0 and lam1 &gt; 0 and lam2 &gt; 0 # Stable configuration stable_gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] config = ClassicalSMCConfig(gains=stable_gains, max_force=100, dt=0.01, boundary_layer=0.01) assert check_stability(config.k1, config.k2, config.lam1, config.lam2) # Check damping ratios zeta1 = config.lam1 / (2 * np.sqrt(config.k1)) zeta2 = config.lam2 / (2 * np.sqrt(config.k2)) # Both subsystems should have positive damping assert zeta1 &gt; 0 assert zeta2 &gt; 0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id5">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-class-testnumericalaccuracy-test-numerical-accuracy-and-precision-def-test-floating-point-consistency-self-test-that-computations-are-consistent-across-repeated-calls-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-compute-control-multiple-times-results-for-in-range-100-result-controller-compute-control-state-control-result-get-control-output-result-get-control-result-get-u-if-control-is-not-none-results-append-control-if-results-results-np-array-results-all-results-should-be-identical-deterministic-computation-std-dev-np-std-results-axis-0-assert-np-all-std-dev-1e-15-machine-precision-def-test-numerical-stability-small-values-self-test-numerical-stability-with-very-small-state-values-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-very-small-state-values-near-machine-precision-small-state-np-array-1e-15-1e-15-1e-15-1e-15-1e-15-1e-15-result-controller-compute-control-small-state-control-result-get-control-output-result-get-control-result-get-u-if-control-is-not-none-control-should-be-finite-and-small-assert-np-all-np-isfinite-control-assert-np-all-np-abs-control-1-0-def-test-numerical-stability-large-values-self-test-numerical-stability-with-large-state-values-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-large-state-values-but-within-reasonable-bounds-large-state-np-array-10-0-5-0-3-0-2-0-2-0-1-0-result-controller-compute-control-large-state-control-result-get-control-output-result-get-control-result-get-u-if-control-is-not-none-control-should-be-finite-and-saturated-assert-np-all-np-isfinite-control-assert-np-all-np-abs-control-config-max-force-1-01-within-saturation">runnable: false class TestNumericalAccuracy: ‚Äú‚Äù‚ÄùTest numerical accuracy and precision.‚Äù‚Äù‚Äù def test_floating_point_consistency(self): ‚Äú‚Äù‚ÄùTest that computations are consistent across repeated calls.‚Äù‚Äù‚Äù config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) # Compute control multiple times results = [] for _ in range(100): result = controller.compute_control(state, {}, {}) control = result.get(‚Äòcontrol_output‚Äô, result.get(‚Äòcontrol‚Äô, result.get(‚Äòu‚Äô))) if control is not None: results.append(control) if results: results = np.array(results) # All results should be identical (deterministic computation) std_dev = np.std(results, axis=0) assert np.all(std_dev &lt; 1e-15) # Machine precision def test_numerical_stability_small_values(self): ‚Äú‚Äù‚ÄùTest numerical stability with very small state values.‚Äù‚Äù‚Äù config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) # Very small state values (near machine precision) small_state = np.array([1e-15, 1e-15, 1e-15, 1e-15, 1e-15, 1e-15]) result = controller.compute_control(small_state, {}, {}) control = result.get(‚Äòcontrol_output‚Äô, result.get(‚Äòcontrol‚Äô, result.get(‚Äòu‚Äô))) if control is not None: # Control should be finite and small assert np.all(np.isfinite(control)) assert np.all(np.abs(control) &lt; 1.0) def test_numerical_stability_large_values(self): ‚Äú‚Äù‚ÄùTest numerical stability with large state values.‚Äù‚Äù‚Äù config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) # Large state values (but within reasonable bounds) large_state = np.array([10.0, 5.0, 3.0, 2.0, 2.0, 1.0]) result = controller.compute_control(large_state, {}, {}) control = result.get(‚Äòcontrol_output‚Äô, result.get(‚Äòcontrol‚Äô, result.get(‚Äòu‚Äô))) if control is not None: # Control should be finite and saturated assert np.all(np.isfinite(control)) assert np.all(np.abs(control) &lt;= config.max_force * 1.01) # Within saturation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#id6">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#runnable-false-class-testsystemlevelmathematics-test-mathematical-consistency-across-system-components-def-test-control-law-decomposition-self-test-that-control-law-components-sum-correctly-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-get-overall-control-output-result-controller-compute-control-state-total-control-result-get-control-output-result-get-control-result-get-u-get-individual-components-if-available-in-debug-output-components-result-get-debug-if-u-equivalent-in-components-and-u-switching-in-components-and-u-derivative-in-components-u-eq-components-u-equivalent-u-sw-components-u-switching-u-d-components-u-derivative-before-saturation-should-sum-correctly-u-unsaturated-u-eq-u-sw-u-d-after-saturation-u-saturated-np-clip-u-unsaturated-config-max-force-config-max-force-should-match-total-control-before-any-additional-processing-if-total-control-is-not-none-assert-np-allclose-u-saturated-total-control-rtol-1e-10-def-test-lyapunov-function-properties-self-test-lyapunov-function-properties-for-stability-analysis-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-surface-linearslidingsurface-config-get-surface-gains-multiple-test-states-states-np-array-0-1-0-05-0-08-0-02-0-03-0-01-np-array-0-2-0-1-0-15-0-05-0-08-0-03-np-array-0-1-0-05-0-08-0-02-0-03-0-01-for-state-in-states-s-surface-compute-state-lyapunov-function-candidate-v-0-5-s2-v-0-5-s-2-v-should-be-non-negative-assert-v-0-v-0-if-and-only-if-s-0-if-abs-s-1e-10-assert-v-1e-15-else-assert-v-0-def-test-reaching-law-satisfaction-self-test-that-reaching-law-is-satisfied-ss-s-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-surface-linearslidingsurface-config-get-surface-gains-test-state-away-from-surface-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-s-surface-compute-state-simplified-reaching-law-check-without-full-dynamics-for-switching-control-u-sw-k-sign-s-the-reaching-condition-ss-s-should-be-satisfied-when-k-is-chosen-large-enough-this-is-a-simplified-test-full-test-would-require-dynamics-model-if-abs-s-config-boundary-layer-outside-boundary-layer-should-have-strong-reaching-behavior-expected-reaching-rate-config-k-abs-s-max-abs-s-config-boundary-layer-assert-expected-reaching-rate-0-should-be-moving-toward-surface">runnable: false class TestSystemLevelMathematics: ‚Äú‚Äù‚ÄùTest mathematical consistency across system components.‚Äù‚Äù‚Äù def test_control_law_decomposition(self): ‚Äú‚Äù‚ÄùTest that control law components sum correctly.‚Äù‚Äù‚Äù config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) # Get overall control output result = controller.compute_control(state, {}, {}) total_control = result.get(‚Äòcontrol_output‚Äô, result.get(‚Äòcontrol‚Äô, result.get(‚Äòu‚Äô))) # Get individual components (if available in debug output) components = result.get(‚Äòdebug‚Äô, {}) if ‚Äòu_equivalent‚Äô in components and ‚Äòu_switching‚Äô in components and ‚Äòu_derivative‚Äô in components: u_eq = components[‚Äòu_equivalent‚Äô] u_sw = components[‚Äòu_switching‚Äô] u_d = components[‚Äòu_derivative‚Äô] # Before saturation, should sum correctly u_unsaturated = u_eq + u_sw + u_d # After saturation u_saturated = np.clip(u_unsaturated, -config.max_force, config.max_force) # Should match total control (before any additional processing) if total_control is not None: assert np.allclose(u_saturated, total_control, rtol=1e-10) def test_lyapunov_function_properties(self): ‚Äú‚Äù‚ÄùTest Lyapunov function properties for stability analysis.‚Äù‚Äù‚Äù config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) surface = LinearSlidingSurface(config.get_surface_gains()) # Multiple test states states = [ np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]), np.array([0.2, 0.1, 0.15, 0.05, 0.08, 0.03]), np.array([-0.1, -0.05, -0.08, -0.02, -0.03, -0.01]) ] for state in states: s = surface.compute(state) # Lyapunov function candidate: V = 0.5 * s¬≤ V = 0.5 * s**2 # V should be non-negative assert V &gt;= 0 # V = 0 if and only if s = 0 if abs(s) &lt; 1e-10: assert V &lt; 1e-15 else: assert V &gt; 0 def test_reaching_law_satisfaction(self): ‚Äú‚Äù‚ÄùTest that reaching law is satisfied: s<em>·π° ‚â§ -Œ∑|s|.‚Äù‚Äù‚Äù config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) surface = LinearSlidingSurface(config.get_surface_gains()) # Test state away from surface state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) s = surface.compute(state) # Simplified reaching law check (without full dynamics) # For switching control: u_sw = -K * sign(s) # The reaching condition s</em>·π° ‚â§ -Œ∑|s| should be satisfied # when K is chosen large enough # This is a simplified test - full test would require dynamics model if abs(s) &gt; config.boundary_layer: # Outside boundary layer, should have strong reaching behavior expected_reaching_rate = -config.K * abs(s) / max(abs(s), config.boundary_layer) assert expected_reaching_rate &lt; 0 # Should be moving toward surface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#fast-unit-tests-mathematical-properties">Fast unit tests (mathematical properties)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/test_validation_methodology.html#extended-property-based-testing">Extended property-based testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/validation_framework_guide.html">Validation Framework Guide <strong>System Reliability Foundation: Robust Parameter Validation &amp; Scientific Verification</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/validation_framework_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/validation_framework_guide.html#runnable-false-good-validate-once-at-construction">runnable: false # ‚úÖ GOOD: Validate once at construction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mathematical_foundations/validation_framework_guide.html#good-single-validation-for-array">‚úÖ GOOD: Single validation for array</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../mathematical_validation_procedures.html">Mathematical Validation Procedures for Control Systems ## Executive Summary This document establishes mathematical validation procedures for the double-inverted pendulum sliding mode control (DIP-SMC) project, ensuring theoretical soundness and implementation correctness through rigorous mathematical property verification. The procedures integrate control theory, optimization theory, and numerical analysis validation with automated testing frameworks. <strong>Core Mathematical Domains:</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_management_patterns.html">Controller Memory Management Patterns (Issue #15 Resolution) <strong>Date:</strong> 2025-10-01</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_management_patterns.html#no-explicit-cleanup-needed-automatic-via-del">No explicit cleanup needed (automatic via <strong>del</strong>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_management_patterns.html#controller-automatically-cleaned-up-when-out-of-scope">Controller automatically cleaned up when out of scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_management_patterns.html#explicit-cleanup-recommended">Explicit cleanup recommended</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_management_patterns.html#cleanup-every-n-iterations">Cleanup every N iterations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_management_quick_reference.html">Controller Memory Management Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../numerical_stability_guide.html">Numerical Stability Guide <strong>Version</strong>: 1.2.0 | <strong>Last Updated</strong>: 2025-10-01 ## Overview This guide documents the adaptive matrix regularization system implemented in the double-inverted pendulum control framework. The system provides robust numerical stability for matrix operations in plant dynamics, controllers, and optimization algorithms.</a></li>
<li class="toctree-l1"><a class="reference internal" href="../numerical_stability_guide.html#for-well-conditioned-systems-or-debugging">For well-conditioned systems or debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plant_model.html">1.x Plant Model</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../production/index.html">Production Deployment</a><input aria-label="Toggle navigation of Production Deployment" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../production/production_readiness_assessment_v2.html">Production Readiness Assessment v2.0 <strong>Date</strong>: 2025-09-29</a></li>
<li class="toctree-l2"><a class="reference internal" href="../production_readiness_final.html">Production Readiness Assessment - Final Report <strong>Date:</strong> 2025-09-29</a></li>
<li class="toctree-l2"><a class="reference internal" href="../production_readiness_framework.html">Production Readiness Assessment Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../production_documentation_summary.html">Production Documentation Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html">PSO Configuration Schema Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#top-level-pso-configuration-structure">Top-level PSO configuration structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#runnable-false-class-constraintpropagator-intelligent-constraint-propagation-for-interdependent-pso-parameters-def-init-self-controller-type-str-self-controller-type-controller-type-self-constraint-graph-self-build-constraint-graph-def-propagate-constraints-self-initial-bounds-dict-dict-propagate-constraints-through-parameter-dependency-graph-example-if-1-is-constrained-to-0-1-5-0-for-issue-2-then-c1-bounds-must-ensure-1-1-2c1-0-69-0-8-propagated-bounds-initial-bounds-copy-iterative-constraint-propagation-converged-false-max-iterations-10-iteration-0-while-not-converged-and-iteration-max-iterations-old-bounds-propagated-bounds-copy-apply-constraint-rules-for-constraint-in-self-constraint-graph-propagated-bounds-self-apply-constraint-rule-constraint-propagated-bounds-check-convergence-converged-self-bounds-converged-old-bounds-propagated-bounds-iteration-1-return-propagated-bounds-def-apply-constraint-rule-self-constraint-dict-bounds-dict-dict-apply-individual-constraint-rule-with-mathematical-validation-if-constraint-type-damping-ratio-2c-constraint-propagation-lambda-idx-constraint-lambda-idx-c-idx-constraint-c-idx-target-zeta-range-constraint-zeta-range-lambda-min-lambda-max-bounds-min-lambda-idx-bounds-max-lambda-idx-derive-c-bounds-from-lambda-bounds-and-zeta-constraints-for-min-2c-max-c-min-2-max-2-c-max-2-min-2-c-min-from-lambda-lambda-min-2-target-zeta-range-1-2-c-max-from-lambda-lambda-max-2-target-zeta-range-0-2-update-c-bounds-with-constraint-propagation-bounds-min-c-idx-max-bounds-min-c-idx-c-min-from-lambda-bounds-max-c-idx-min-bounds-max-c-idx-c-max-from-lambda-elif-constraint-type-sta-stability-k1-k2-constraint-with-margin-k1-idx-k2-idx-constraint-k1-idx-constraint-k2-idx-margin-constraint-get-margin-0-1-ensure-k1-min-k2-max-margin-bounds-min-k1-idx-max-bounds-min-k1-idx-bounds-max-k2-idx-margin-return-bounds-def-build-constraint-graph-self-list-build-constraint-dependency-graph-for-controller-type-if-self-controller-type-classical-smc-return-type-damping-ratio-lambda-idx-1-c-idx-0-zeta-range-0-6-0-8-type-damping-ratio-lambda-idx-3-c-idx-2-zeta-range-0-6-0-8-type-actuator-saturation-gain-indices-4-5-k-kd-max-total-150-0-elif-self-controller-type-sta-smc-return-type-sta-stability-k1-idx-0-k2-idx-1-margin-0-1-type-damping-ratio-lambda-idx-4-c-idx-2-lambda1-k1-zeta-range-0-69-0-8-issue-2-requirement-type-damping-ratio-lambda-idx-5-c-idx-3-lambda2-k2-zeta-range-0-69-0-8-issue-2-requirement-return">runnable: false class ConstraintPropagator: ‚Äú‚Äù‚Äù Intelligent constraint propagation for interdependent PSO parameters. ‚Äú‚Äù‚Äù def <strong>init</strong>(self, controller_type: str): self.controller_type = controller_type self.constraint_graph = self._build_constraint_graph() def propagate_constraints(self, initial_bounds: dict) -&gt; dict: ‚Äú‚Äù‚Äù Propagate constraints through parameter dependency graph. Example: If Œª‚ÇÅ is constrained to [0.1, 5.0] for Issue #2, then c‚ÇÅ bounds must ensure Œ∂‚ÇÅ = Œª‚ÇÅ/(2‚àöc‚ÇÅ) ‚àà [0.69, 0.8] ‚Äú‚Äù‚Äù propagated_bounds = initial_bounds.copy() # Iterative constraint propagation converged = False max_iterations = 10 iteration = 0 while not converged and iteration &lt; max_iterations: old_bounds = propagated_bounds.copy() # Apply constraint rules for constraint in self.constraint_graph: propagated_bounds = self._apply_constraint_rule( constraint, propagated_bounds ) # Check convergence converged = self._bounds_converged(old_bounds, propagated_bounds) iteration += 1 return propagated_bounds def _apply_constraint_rule(self, constraint: dict, bounds: dict) -&gt; dict: ‚Äú‚Äù‚Äù Apply individual constraint rule with mathematical validation. ‚Äú‚Äù‚Äù if constraint[‚Äòtype‚Äô] == ‚Äòdamping_ratio‚Äô: # Œ∂ = Œª/(2‚àöc) constraint propagation lambda_idx = constraint[‚Äòlambda_idx‚Äô] c_idx = constraint[‚Äòc_idx‚Äô] target_zeta_range = constraint[‚Äòzeta_range‚Äô] lambda_min, lambda_max = bounds[‚Äòmin‚Äô][lambda_idx], bounds[‚Äòmax‚Äô][lambda_idx] # Derive c bounds from lambda bounds and zeta constraints # For Œ∂_min ‚â§ Œª/(2‚àöc) ‚â§ Œ∂_max: # c_min = (Œª/(2Œ∂_max))¬≤, c_max = (Œª/(2Œ∂_min))¬≤ c_min_from_lambda = (lambda_min / (2 * target_zeta_range[1]))**2 c_max_from_lambda = (lambda_max / (2 * target_zeta_range[0]))**2 # Update c bounds with constraint propagation bounds[‚Äòmin‚Äô][c_idx] = max(bounds[‚Äòmin‚Äô][c_idx], c_min_from_lambda) bounds[‚Äòmax‚Äô][c_idx] = min(bounds[‚Äòmax‚Äô][c_idx], c_max_from_lambda) elif constraint[‚Äòtype‚Äô] == ‚Äòsta_stability‚Äô: # K‚ÇÅ &gt; K‚ÇÇ constraint with margin k1_idx, k2_idx = constraint[‚Äòk1_idx‚Äô], constraint[‚Äòk2_idx‚Äô] margin = constraint.get(‚Äòmargin‚Äô, 0.1) # Ensure K‚ÇÅ_min &gt; K‚ÇÇ_max + margin bounds[‚Äòmin‚Äô][k1_idx] = max( bounds[‚Äòmin‚Äô][k1_idx], bounds[‚Äòmax‚Äô][k2_idx] + margin ) return bounds def _build_constraint_graph(self) -&gt; list: ‚Äú‚Äù‚Äù Build constraint dependency graph for controller type. ‚Äú‚Äù‚Äù if self.controller_type == ‚Äòclassical_smc‚Äô: return [ { ‚Äòtype‚Äô: ‚Äòdamping_ratio‚Äô, ‚Äòlambda_idx‚Äô: 1, ‚Äòc_idx‚Äô: 0, ‚Äòzeta_range‚Äô: [0.6, 0.8] }, { ‚Äòtype‚Äô: ‚Äòdamping_ratio‚Äô, ‚Äòlambda_idx‚Äô: 3, ‚Äòc_idx‚Äô: 2, ‚Äòzeta_range‚Äô: [0.6, 0.8] }, { ‚Äòtype‚Äô: ‚Äòactuator_saturation‚Äô, ‚Äògain_indices‚Äô: [4, 5], # K, kd ‚Äòmax_total‚Äô: 150.0 } ] elif self.controller_type == ‚Äòsta_smc‚Äô: return [ { ‚Äòtype‚Äô: ‚Äòsta_stability‚Äô, ‚Äòk1_idx‚Äô: 0, ‚Äòk2_idx‚Äô: 1, ‚Äòmargin‚Äô: 0.1 }, { ‚Äòtype‚Äô: ‚Äòdamping_ratio‚Äô, ‚Äòlambda_idx‚Äô: 4, ‚Äòc_idx‚Äô: 2, # lambda1, k1 ‚Äòzeta_range‚Äô: [0.69, 0.8] # Issue #2 requirement }, { ‚Äòtype‚Äô: ‚Äòdamping_ratio‚Äô, ‚Äòlambda_idx‚Äô: 5, ‚Äòc_idx‚Äô: 3, # lambda2, k2 ‚Äòzeta_range‚Äô: [0.69, 0.8] # Issue #2 requirement } ] return []</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#configuration-schema-version-metadata">Configuration schema version metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#runnable-false-class-configurationmigrator-automatic-migration-framework-for-pso-configuration-schema-evolution-def-init-self-self-migration-rules-1-0-self-migrate-from-v1-0-1-5-self-migrate-from-v1-5-2-0-self-migrate-from-v2-0-def-migrate-configuration-self-config-dict-source-version-str-tuple-migrate-configuration-from-source-version-to-current-schema-returns-tuple-migrated-config-migration-warnings-compatibility-issues-if-source-version-not-in-self-migration-rules-raise-valueerror-f-unsupported-source-version-source-version-migrated-config-config-copy-warnings-issues-apply-migration-rules-in-sequence-current-version-source-version-while-current-version-current-schema-version-migrator-self-migration-rules-current-version-migrated-config-step-warnings-migrator-migrated-config-warnings-extend-step-warnings-current-version-self-get-next-version-current-version-validate-migrated-configuration-validation-result-pso-configurationvalidator-validate-complete-config-migrated-config-if-not-validation-result-is-valid-issues-extend-validation-result-errors-return-migrated-config-warnings-issues-def-migrate-from-v1-0-self-config-dict-tuple-migrate-from-v1-0-to-v1-5-remove-deprecated-fields-update-bounds-migrated-config-copy-warnings-remove-deprecated-fields-deprecated-fields-n-processes-hyper-trials-hyper-search-study-timeout-for-field-in-deprecated-fields-if-field-in-migrated-get-pso-del-migrated-pso-field-warnings-append-f-removed-deprecated-field-field-update-pso-bounds-structure-if-pso-in-migrated-and-bounds-in-migrated-pso-old-bounds-migrated-pso-bounds-new-bounds-self-restructure-bounds-v1-5-old-bounds-migrated-pso-bounds-new-bounds-warnings-append-restructured-bounds-for-controller-specific-optimization-return-migrated-warnings-def-migrate-from-v2-0-self-config-dict-tuple-migrate-from-v2-0-to-v2-1-issue-2-bounds-updates-and-enhanced-features-migrated-config-copy-warnings-update-sta-smc-bounds-for-issue-2-compliance-if-pso-in-migrated-and-bounds-in-migrated-pso-bounds-migrated-pso-bounds-if-sta-smc-in-bounds-sta-bounds-bounds-sta-smc-check-for-issue-2-problematic-bounds-if-max-in-sta-bounds-and-len-sta-bounds-max-6-lambda1-max-lambda2-max-sta-bounds-max-4-sta-bounds-max-5-if-lambda1-max-10-0-or-lambda2-max-10-0-apply-issue-2-corrections-sta-bounds-max-4-min-lambda1-max-10-0-lambda1-sta-bounds-max-5-min-lambda2-max-10-0-lambda2-warnings-append-applied-issue-2-lambda-bounds-corrections-for-overshoot-mitigation-add-enhanced-features-if-missing-if-enhanced-features-not-in-migrated-get-pso-migrated-pso-enhanced-features-w-schedule-0-9-0-4-velocity-clamp-0-1-0-2-early-stopping-patience-50-tolerance-1e-6-warnings-append-added-enhanced-pso-features-for-improved-convergence-return-migrated-warnings-def-generate-migration-report-self-old-config-dict-new-config-dict-warnings-list-issues-list-str-generate-migration-report-for-documentation-report-f">runnable: false class ConfigurationMigrator: ‚Äú‚Äù‚Äù Automatic migration framework for PSO configuration schema evolution. ‚Äú‚Äù‚Äù def <strong>init</strong>(self): self.migration_rules = { ‚Äú1.0‚Äù: self._migrate_from_v1_0, ‚Äú1.5‚Äù: self._migrate_from_v1_5, ‚Äú2.0‚Äù: self._migrate_from_v2_0 } def migrate_configuration(self, config: dict, source_version: str) -&gt; tuple: ‚Äú‚Äù‚Äù Migrate configuration from source version to current schema. Returns: tuple: (migrated_config, migration_warnings, compatibility_issues) ‚Äú‚Äù‚Äù if source_version not in self.migration_rules: raise ValueError(f‚ÄùUnsupported source version: {source_version}‚Äù) migrated_config = config.copy() warnings = [] issues = [] # Apply migration rules in sequence current_version = source_version while current_version != CURRENT_SCHEMA_VERSION: migrator = self.migration_rules[current_version] migrated_config, step_warnings = migrator(migrated_config) warnings.extend(step_warnings) current_version = self._get_next_version(current_version) # Validate migrated configuration validation_result = PSO_ConfigurationValidator().validate_complete_config(migrated_config) if not validation_result.is_valid: issues.extend(validation_result.errors) return migrated_config, warnings, issues def _migrate_from_v1_0(self, config: dict) -&gt; tuple: ‚Äú‚Äù‚Äù Migrate from v1.0 to v1.5: Remove deprecated fields, update bounds. ‚Äú‚Äù‚Äù migrated = config.copy() warnings = [] # Remove deprecated fields deprecated_fields = [‚Äòn_processes‚Äô, ‚Äòhyper_trials‚Äô, ‚Äòhyper_search‚Äô, ‚Äòstudy_timeout‚Äô] for field in deprecated_fields: if field in migrated.get(‚Äòpso‚Äô, {}): del migrated[‚Äòpso‚Äô][field] warnings.append(f‚ÄùRemoved deprecated field: {field}‚Äù) # Update PSO bounds structure if ‚Äòpso‚Äô in migrated and ‚Äòbounds‚Äô in migrated[‚Äòpso‚Äô]: old_bounds = migrated[‚Äòpso‚Äô][‚Äòbounds‚Äô] new_bounds = self._restructure_bounds_v1_5(old_bounds) migrated[‚Äòpso‚Äô][‚Äòbounds‚Äô] = new_bounds warnings.append(‚ÄúRestructured bounds for controller-specific optimization‚Äù) return migrated, warnings def _migrate_from_v2_0(self, config: dict) -&gt; tuple: ‚Äú‚Äù‚Äù Migrate from v2.0 to v2.1: Issue #2 bounds updates and enhanced features. ‚Äú‚Äù‚Äù migrated = config.copy() warnings = [] # Update STA-SMC bounds for Issue #2 compliance if ‚Äòpso‚Äô in migrated and ‚Äòbounds‚Äô in migrated[‚Äòpso‚Äô]: bounds = migrated[‚Äòpso‚Äô][‚Äòbounds‚Äô] if ‚Äòsta_smc‚Äô in bounds: sta_bounds = bounds[‚Äòsta_smc‚Äô] # Check for Issue #2 problematic bounds if ‚Äòmax‚Äô in sta_bounds and len(sta_bounds[‚Äòmax‚Äô]) &gt;= 6: lambda1_max, lambda2_max = sta_bounds[‚Äòmax‚Äô][4], sta_bounds[‚Äòmax‚Äô][5] if lambda1_max &gt; 10.0 or lambda2_max &gt; 10.0: # Apply Issue #2 corrections sta_bounds[‚Äòmax‚Äô][4] = min(lambda1_max, 10.0) # lambda1 sta_bounds[‚Äòmax‚Äô][5] = min(lambda2_max, 10.0) # lambda2 warnings.append(‚ÄúApplied Issue #2 lambda bounds corrections for overshoot mitigation‚Äù) # Add enhanced features if missing if ‚Äòenhanced_features‚Äô not in migrated.get(‚Äòpso‚Äô, {}): migrated[‚Äòpso‚Äô][‚Äòenhanced_features‚Äô] = { ‚Äòw_schedule‚Äô: [0.9, 0.4], ‚Äòvelocity_clamp‚Äô: [0.1, 0.2], ‚Äòearly_stopping‚Äô: {‚Äòpatience‚Äô: 50, ‚Äòtolerance‚Äô: 1e-6} } warnings.append(‚ÄúAdded enhanced PSO features for improved convergence‚Äù) return migrated, warnings def generate_migration_report(self, old_config: dict, new_config: dict, warnings: list, issues: list) -&gt; str: ‚Äú‚Äù‚Äù Generate migration report for documentation. ‚Äú‚Äù‚Äù report = f‚Äù‚Äù‚Äù</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#pso-configuration-migration-report-summary">PSO Configuration Migration Report ## Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_configuration_schema_documentation.html#runnable-false-class-configurationerrorhandler-error-handling-and-diagnostic-system-for-pso-configuration-error-categories-syntax-severity-critical-auto-fixable-false-description-yaml-syntax-or-structure-errors-type-severity-critical-auto-fixable-true-description-data-type-mismatches-bounds-severity-high-auto-fixable-true-description-parameter-bounds-violations-mathematical-severity-high-auto-fixable-false-description-mathematical-consistency-violations-performance-severity-medium-auto-fixable-true-description-suboptimal-performance-configuration-compatibility-severity-medium-auto-fixable-true-description-controller-compatibility-issues-def-diagnose-configuration-errors-self-config-dict-controller-type-str-none-dict-configuration-error-diagnosis-with-auto-fix-suggestions-diagnosis-errors-warnings-auto-fixes-manual-actions-overall-status-unknown-run-diagnostic-checks-for-category-info-in-self-error-categories-items-category-errors-self-check-category-category-config-controller-type-for-error-in-category-errors-error-category-category-error-severity-info-severity-error-auto-fixable-info-auto-fixable-if-error-severity-critical-diagnosis-errors-append-error-else-diagnosis-warnings-append-error-generate-fix-suggestions-if-error-auto-fixable-fix-self-generate-auto-fix-error-config-if-fix-diagnosis-auto-fixes-append-fix-else-manual-action-self-generate-manual-action-error-if-manual-action-diagnosis-manual-actions-append-manual-action-determine-overall-status-if-diagnosis-errors-diagnosis-overall-status-critical-elif-len-diagnosis-warnings-5-diagnosis-overall-status-needs-attention-elif-diagnosis-warnings-diagnosis-overall-status-minor-issues-else-diagnosis-overall-status-healthy-return-diagnosis-def-check-category-self-category-str-config-dict-controller-type-str-list-check-specific-error-category-and-return-found-issues-errors-if-category-mathematical-pso-convergence-check-if-algorithm-params-in-config-params-config-algorithm-params-if-c1-in-params-and-c2-in-params-phi-params-c1-params-c2-if-phi-4-0-errors-append-code-pso-convergence-risk-message-f-pso-may-not-converge-c1-c2-phi-3f-4-0-location-algorithm-params-c1-algorithm-params-c2-impact-optimization-may-fail-to-converge-elif-category-bounds-and-controller-type-issue-2-specific-checks-for-sta-smc-if-controller-type-sta-smc-and-bounds-in-config-bounds-config-bounds-if-sta-smc-in-bounds-and-max-in-bounds-sta-smc-max-bounds-bounds-sta-smc-max-if-len-max-bounds-6-lambda1-max-lambda2-max-max-bounds-4-max-bounds-5-if-lambda1-max-10-0-or-lambda2-max-10-0-errors-append-code-issue2-bounds-violation-message-f-sta-smc-lambda-bounds-may-cause-overshoot-1-max-lambda1-max-2-max-lambda2-max-location-bounds-sta-smc-max-4-6-impact-may-cause-5-overshoot-issue-2-regression-elif-category-performance-suboptimal-parameter-detection-if-algorithm-params-in-config-params-config-algorithm-params-if-n-particles-in-params-n-particles-params-n-particles-if-n-particles-10-or-n-particles-50-errors-append-code-suboptimal-swarm-size-message-f-swarm-size-n-particles-outside-optimal-range-10-50-location-algorithm-params-n-particles-impact-suboptimal-convergence-speed-or-quality-return-errors-def-generate-auto-fix-self-error-dict-config-dict-dict-generate-automatic-fix-for-fixable-errors-if-error-code-pso-convergence-risk-return-error-code-error-code-fix-type-parameter-adjustment-action-increase-c1-and-c2-to-ensure-4-changes-algorithm-params-c1-2-1-algorithm-params-c2-2-1-justification-ensures-pso-convergence-with-4-2-4-elif-error-code-issue2-bounds-violation-return-error-code-error-code-fix-type-bounds-correction-action-apply-issue-2-lambda-bounds-corrections-changes-bounds-sta-smc-max-4-10-0-lambda1-bounds-sta-smc-max-5-10-0-lambda2-justification-prevents-overshoot-regression-from-issue-2-elif-error-code-suboptimal-swarm-size-current-size-config-algorithm-params-n-particles-optimal-size-np-clip-current-size-15-25-clamp-to-optimal-range-return-error-code-error-code-fix-type-parameter-optimization-action-f-adjust-swarm-size-to-optimal-range-changes-algorithm-params-n-particles-optimal-size-justification-f-optimizes-convergence-for-optimal-size-particles-return-none-def-apply-auto-fixes-self-config-dict-fixes-list-tuple-apply-automatic-fixes-to-configuration-returns-tuple-fixed-config-applied-fixes-failed-fixes-fixed-config-config-copy-applied-fixes-failed-fixes-for-fix-in-fixes-try-for-path-new-value-in-fix-changes-items-self-set-nested-value-fixed-config-path-new-value-applied-fixes-append-fix-except-exception-as-e-fix-error-str-e-failed-fixes-append-fix-return-fixed-config-applied-fixes-failed-fixes-def-set-nested-value-self-config-dict-path-str-value-any-none-set-nested-configuration-value-using-dot-notation-path-keys-path-split-current-config-for-key-in-keys-1-if-in-key-and-in-key-handle-array-indexing-array-key-index-str-key-split-index-int-index-str-rstrip-if-array-key-not-in-current-current-array-key-current-current-array-key-extend-array-if-necessary-while-len-current-index-current-append-none-current-current-index-else-if-key-not-in-current-current-key-current-current-key-set-the-final-value-final-key-keys-1-if-in-final-key-and-in-final-key-array-key-index-str-final-key-split-index-int-index-str-rstrip-if-array-key-not-in-current-current-array-key-while-len-current-array-key-index-current-array-key-append-none-current-array-key-index-value-else-current-final-key-value">runnable: false class ConfigurationErrorHandler: ‚Äú‚Äù‚Äù error handling and diagnostic system for PSO configuration. ‚Äú‚Äù‚Äù ERROR_CATEGORIES = { ‚ÄòSYNTAX‚Äô: { ‚Äòseverity‚Äô: ‚ÄòCRITICAL‚Äô, ‚Äòauto_fixable‚Äô: False, ‚Äòdescription‚Äô: ‚ÄòYAML syntax or structure errors‚Äô }, ‚ÄòTYPE‚Äô: { ‚Äòseverity‚Äô: ‚ÄòCRITICAL‚Äô, ‚Äòauto_fixable‚Äô: True, ‚Äòdescription‚Äô: ‚ÄòData type mismatches‚Äô }, ‚ÄòBOUNDS‚Äô: { ‚Äòseverity‚Äô: ‚ÄòHIGH‚Äô, ‚Äòauto_fixable‚Äô: True, ‚Äòdescription‚Äô: ‚ÄòParameter bounds violations‚Äô }, ‚ÄòMATHEMATICAL‚Äô: { ‚Äòseverity‚Äô: ‚ÄòHIGH‚Äô, ‚Äòauto_fixable‚Äô: False, ‚Äòdescription‚Äô: ‚ÄòMathematical consistency violations‚Äô }, ‚ÄòPERFORMANCE‚Äô: { ‚Äòseverity‚Äô: ‚ÄòMEDIUM‚Äô, ‚Äòauto_fixable‚Äô: True, ‚Äòdescription‚Äô: ‚ÄòSuboptimal performance configuration‚Äô }, ‚ÄòCOMPATIBILITY‚Äô: { ‚Äòseverity‚Äô: ‚ÄòMEDIUM‚Äô, ‚Äòauto_fixable‚Äô: True, ‚Äòdescription‚Äô: ‚ÄòController compatibility issues‚Äô } } def diagnose_configuration_errors(self, config: dict, controller_type: str = None) -&gt; dict: ‚Äú‚Äù‚Äù configuration error diagnosis with auto-fix suggestions. ‚Äú‚Äù‚Äù diagnosis = { ‚Äòerrors‚Äô: [], ‚Äòwarnings‚Äô: [], ‚Äòauto_fixes‚Äô: [], ‚Äòmanual_actions‚Äô: [], ‚Äòoverall_status‚Äô: ‚ÄòUNKNOWN‚Äô } # Run diagnostic checks for category, info in self.ERROR_CATEGORIES.items(): category_errors = self._check_category(category, config, controller_type) for error in category_errors: error[‚Äòcategory‚Äô] = category error[‚Äòseverity‚Äô] = info[‚Äòseverity‚Äô] error[‚Äòauto_fixable‚Äô] = info[‚Äòauto_fixable‚Äô] if error[‚Äòseverity‚Äô] == ‚ÄòCRITICAL‚Äô: diagnosis[‚Äòerrors‚Äô].append(error) else: diagnosis[‚Äòwarnings‚Äô].append(error) # Generate fix suggestions if error[‚Äòauto_fixable‚Äô]: fix = self._generate_auto_fix(error, config) if fix: diagnosis[‚Äòauto_fixes‚Äô].append(fix) else: manual_action = self._generate_manual_action(error) if manual_action: diagnosis[‚Äòmanual_actions‚Äô].append(manual_action) # Determine overall status if diagnosis[‚Äòerrors‚Äô]: diagnosis[‚Äòoverall_status‚Äô] = ‚ÄòCRITICAL‚Äô elif len(diagnosis[‚Äòwarnings‚Äô]) &gt; 5: diagnosis[‚Äòoverall_status‚Äô] = ‚ÄòNEEDS_ATTENTION‚Äô elif diagnosis[‚Äòwarnings‚Äô]: diagnosis[‚Äòoverall_status‚Äô] = ‚ÄòMINOR_ISSUES‚Äô else: diagnosis[‚Äòoverall_status‚Äô] = ‚ÄòHEALTHY‚Äô return diagnosis def _check_category(self, category: str, config: dict, controller_type: str) -&gt; list: ‚Äú‚Äù‚Äù Check specific error category and return found issues. ‚Äú‚Äù‚Äù errors = [] if category == ‚ÄòMATHEMATICAL‚Äô: # PSO convergence check if ‚Äòalgorithm_params‚Äô in config: params = config[‚Äòalgorithm_params‚Äô] if ‚Äòc1‚Äô in params and ‚Äòc2‚Äô in params: phi = params[‚Äòc1‚Äô] + params[‚Äòc2‚Äô] if phi &lt;= 4.0: errors.append({ ‚Äòcode‚Äô: ‚ÄòPSO_CONVERGENCE_RISK‚Äô, ‚Äòmessage‚Äô: f‚ÄôPSO may not converge: œÜ = c‚ÇÅ + c‚ÇÇ = {phi:.3f} ‚â§ 4.0‚Äô, ‚Äòlocation‚Äô: ‚Äòalgorithm_params.c1, algorithm_params.c2‚Äô, ‚Äòimpact‚Äô: ‚ÄòOptimization may fail to converge‚Äô }) elif category == ‚ÄòBOUNDS‚Äô and controller_type: # Issue #2 specific checks for STA-SMC if controller_type == ‚Äòsta_smc‚Äô and ‚Äòbounds‚Äô in config: bounds = config[‚Äòbounds‚Äô] if ‚Äòsta_smc‚Äô in bounds and ‚Äòmax‚Äô in bounds[‚Äòsta_smc‚Äô]: max_bounds = bounds[‚Äòsta_smc‚Äô][‚Äòmax‚Äô] if len(max_bounds) &gt;= 6: lambda1_max, lambda2_max = max_bounds[4], max_bounds[5] if lambda1_max &gt; 10.0 or lambda2_max &gt; 10.0: errors.append({ ‚Äòcode‚Äô: ‚ÄòISSUE2_BOUNDS_VIOLATION‚Äô, ‚Äòmessage‚Äô: f‚ÄôSTA-SMC lambda bounds may cause overshoot: Œª‚ÇÅ_max={lambda1_max}, Œª‚ÇÇ_max={lambda2_max}‚Äô, ‚Äòlocation‚Äô: ‚Äòbounds.sta_smc.max[4:6]‚Äô, ‚Äòimpact‚Äô: ‚ÄòMay cause &gt;5% overshoot (Issue #2 regression)‚Äô }) elif category == ‚ÄòPERFORMANCE‚Äô: # Suboptimal parameter detection if ‚Äòalgorithm_params‚Äô in config: params = config[‚Äòalgorithm_params‚Äô] if ‚Äòn_particles‚Äô in params: n_particles = params[‚Äòn_particles‚Äô] if n_particles &lt; 10 or n_particles &gt; 50: errors.append({ ‚Äòcode‚Äô: ‚ÄòSUBOPTIMAL_SWARM_SIZE‚Äô, ‚Äòmessage‚Äô: f‚ÄôSwarm size {n_particles} outside optimal range [10, 50]‚Äô, ‚Äòlocation‚Äô: ‚Äòalgorithm_params.n_particles‚Äô, ‚Äòimpact‚Äô: ‚ÄòSuboptimal convergence speed or quality‚Äô }) return errors def _generate_auto_fix(self, error: dict, config: dict) -&gt; dict: ‚Äú‚Äù‚Äù Generate automatic fix for fixable errors. ‚Äú‚Äù‚Äù if error[‚Äòcode‚Äô] == ‚ÄòPSO_CONVERGENCE_RISK‚Äô: return { ‚Äòerror_code‚Äô: error[‚Äòcode‚Äô], ‚Äòfix_type‚Äô: ‚Äòparameter_adjustment‚Äô, ‚Äòaction‚Äô: ‚ÄòIncrease c‚ÇÅ and c‚ÇÇ to ensure œÜ &gt; 4‚Äô, ‚Äòchanges‚Äô: { ‚Äòalgorithm_params.c1‚Äô: 2.1, ‚Äòalgorithm_params.c2‚Äô: 2.1 }, ‚Äòjustification‚Äô: ‚ÄòEnsures PSO convergence with œÜ = 4.2 &gt; 4‚Äô } elif error[‚Äòcode‚Äô] == ‚ÄòISSUE2_BOUNDS_VIOLATION‚Äô: return { ‚Äòerror_code‚Äô: error[‚Äòcode‚Äô], ‚Äòfix_type‚Äô: ‚Äòbounds_correction‚Äô, ‚Äòaction‚Äô: ‚ÄòApply Issue #2 lambda bounds corrections‚Äô, ‚Äòchanges‚Äô: { ‚Äòbounds.sta_smc.max[4]‚Äô: 10.0, # lambda1 ‚Äòbounds.sta_smc.max[5]‚Äô: 10.0 # lambda2 }, ‚Äòjustification‚Äô: ‚ÄòPrevents overshoot regression from Issue #2‚Äô } elif error[‚Äòcode‚Äô] == ‚ÄòSUBOPTIMAL_SWARM_SIZE‚Äô: current_size = config[‚Äòalgorithm_params‚Äô][‚Äòn_particles‚Äô] optimal_size = np.clip(current_size, 15, 25) # Clamp to optimal range return { ‚Äòerror_code‚Äô: error[‚Äòcode‚Äô], ‚Äòfix_type‚Äô: ‚Äòparameter_optimization‚Äô, ‚Äòaction‚Äô: f‚ÄôAdjust swarm size to optimal range‚Äô, ‚Äòchanges‚Äô: { ‚Äòalgorithm_params.n_particles‚Äô: optimal_size }, ‚Äòjustification‚Äô: f‚ÄôOptimizes convergence for {optimal_size} particles‚Äô } return None def apply_auto_fixes(self, config: dict, fixes: list) -&gt; tuple: ‚Äú‚Äù‚Äù Apply automatic fixes to configuration. Returns: tuple: (fixed_config, applied_fixes, failed_fixes) ‚Äú‚Äù‚Äù fixed_config = config.copy() applied_fixes = [] failed_fixes = [] for fix in fixes: try: for path, new_value in fix[‚Äòchanges‚Äô].items(): self._set_nested_value(fixed_config, path, new_value) applied_fixes.append(fix) except Exception as e: fix[‚Äòerror‚Äô] = str(e) failed_fixes.append(fix) return fixed_config, applied_fixes, failed_fixes def _set_nested_value(self, config: dict, path: str, value: any) -&gt; None: ‚Äú‚Äù‚Äù Set nested configuration value using dot notation path. ‚Äú‚Äù‚Äù keys = path.split(‚Äò.‚Äô) current = config for key in keys[:-1]: if ‚Äò[‚Äô in key and ‚Äò]‚Äô in key: # Handle array indexing array_key, index_str = key.split(‚Äò[‚Äô) index = int(index_str.rstrip(‚Äò]‚Äô)) if array_key not in current: current[array_key] = [] current = current[array_key] # Extend array if necessary while len(current) &lt;= index: current.append(None) current = current[index] else: if key not in current: current[key] = {} current = current[key] # Set the final value final_key = keys[-1] if ‚Äò[‚Äô in final_key and ‚Äò]‚Äô in final_key: array_key, index_str = final_key.split(‚Äò[‚Äô) index = int(index_str.rstrip(‚Äò]‚Äô)) if array_key not in current: current[array_key] = [] while len(current[array_key]) &lt;= index: current[array_key].append(None) current[array_key][index] = value else: current[final_key] = value</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_factory_integration_patterns.html">PSO-Factory Integration Patterns Documentation ## Overview This document provides guidance on integrating the factory system with Particle Swarm Optimization (PSO) workflows. The DIP SMC-PSO project features native PSO integration patterns that streamline controller optimization while maintaining scientific rigor and performance. ## Table of Contents 1. PSO Integration Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_factory_integration_patterns.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_factory_integration_patterns.html#runnable-false-def-adaptive-pso-optimization-controller-type-smctype-tuple-np-ndarray-float-adaptive-pso-with-dynamic-parameter-adjustment-factory-create-pso-controller-factory-controller-type-class-adaptivepsocontroller-adaptive-pso-controller-with-factory-integration-def-init-self-self-iteration-0-self-best-fitness-history-self-stagnation-counter-0-self-current-bounds-get-gain-bounds-for-pso-controller-type-def-adapt-parameters-self-current-best-fitness-float-dict-str-float-adapt-pso-parameters-based-on-progress-check-for-stagnation-if-len-self-best-fitness-history-0-and-abs-current-best-fitness-self-best-fitness-history-1-1e-6-self-stagnation-counter-1-else-self-stagnation-counter-0-self-best-fitness-history-append-current-best-fitness-adaptive-parameter-adjustment-if-self-stagnation-counter-10-increase-exploration-w-0-9-high-inertia-c1-c2-2-5-1-5-high-cognitive-low-social-expand-search-bounds-slightly-lower-upper-self-current-bounds-expansion-0-1-self-current-bounds-l-1-expansion-for-l-in-lower-u-1-expansion-for-u-in-upper-elif-self-iteration-50-early-exploration-phase-w-0-9-c1-c2-2-0-2-0-else-late-exploitation-phase-w-0-4-c1-c2-1-5-2-5-self-iteration-1-return-w-w-c1-c1-c2-c2-bounds-self-current-bounds-def-fitness-function-self-gains-np-ndarray-float-adaptive-fitness-function-with-dynamic-objectives-try-controller-factory-gains-metrics-evaluate-controller-performance-controller-dynamic-objective-weighting-based-on-iteration-if-self-iteration-30-early-phase-focus-on-basic-performance-return-0-7-metrics-ise-0-3-metrics-control-effort-elif-self-iteration-80-middle-phase-balance-performance-and-robustness-return-0-4-metrics-ise-0-3-metrics-control-effort-0-3-metrics-robustness-penalty-else-late-phase-focus-on-refinement-return-0-3-metrics-ise-0-2-metrics-control-effort-0-3-metrics-robustness-penalty-0-2-metrics-chattering-penalty-except-return-float-inf-run-adaptive-pso-adaptive-controller-adaptivepsocontroller-initial-pso-configuration-pso-params-adaptive-controller-adapt-parameters-float-inf-optimizer-psotuner-controller-factory-adaptive-controller-fitness-function-config-config-adaptive-callback-adaptive-controller-adapt-parameters-return-optimizer-optimize-adaptive">runnable: false def adaptive_pso_optimization(controller_type: SMCType) -&gt; Tuple[np.ndarray, float]: ‚Äú‚Äù‚ÄùAdaptive PSO with dynamic parameter adjustment.‚Äù‚Äù‚Äù factory = create_pso_controller_factory(controller_type) class AdaptivePSOController: ‚Äú‚Äù‚ÄùAdaptive PSO controller with factory integration.‚Äù‚Äù‚Äù def <strong>init</strong>(self): self.iteration = 0 self.best_fitness_history = [] self.stagnation_counter = 0 self.current_bounds = get_gain_bounds_for_pso(controller_type) def adapt_parameters(self, current_best_fitness: float) -&gt; Dict[str, float]: ‚Äú‚Äù‚ÄùAdapt PSO parameters based on progress.‚Äù‚Äù‚Äù # Check for stagnation if (len(self.best_fitness_history) &gt; 0 and abs(current_best_fitness - self.best_fitness_history[-1]) &lt; 1e-6): self.stagnation_counter += 1 else: self.stagnation_counter = 0 self.best_fitness_history.append(current_best_fitness) # Adaptive parameter adjustment if self.stagnation_counter &gt; 10: # Increase exploration w = 0.9 # High inertia c1, c2 = 2.5, 1.5 # High cognitive, low social # Expand search bounds slightly lower, upper = self.current_bounds expansion = 0.1 self.current_bounds = ( [l * (1 - expansion) for l in lower], [u * (1 + expansion) for u in upper] ) elif self.iteration &lt; 50: # Early exploration phase w = 0.9 c1, c2 = 2.0, 2.0 else: # Late exploitation phase w = 0.4 c1, c2 = 1.5, 2.5 self.iteration += 1 return { ‚Äòw‚Äô: w, ‚Äòc1‚Äô: c1, ‚Äòc2‚Äô: c2, ‚Äòbounds‚Äô: self.current_bounds } def fitness_function(self, gains: np.ndarray) -&gt; float: ‚Äú‚Äù‚ÄùAdaptive fitness function with dynamic objectives.‚Äù‚Äù‚Äù try: controller = factory(gains) metrics = evaluate_controller_performance(controller) # Dynamic objective weighting based on iteration if self.iteration &lt; 30: # Early phase: focus on basic performance return 0.7 * metrics[‚Äòise‚Äô] + 0.3 * metrics[‚Äòcontrol_effort‚Äô] elif self.iteration &lt; 80: # Middle phase: balance performance and robustness return (0.4 * metrics[‚Äòise‚Äô] + 0.3 * metrics[‚Äòcontrol_effort‚Äô] + 0.3 * metrics[‚Äòrobustness_penalty‚Äô]) else: # Late phase: focus on refinement return (0.3 * metrics[‚Äòise‚Äô] + 0.2 * metrics[‚Äòcontrol_effort‚Äô] + 0.3 * metrics[‚Äòrobustness_penalty‚Äô] + 0.2 * metrics[‚Äòchattering_penalty‚Äô]) except: return float(‚Äòinf‚Äô) # Run adaptive PSO adaptive_controller = AdaptivePSOController() # Initial PSO configuration pso_params = adaptive_controller.adapt_parameters(float(‚Äòinf‚Äô)) optimizer = PSOTuner( controller_factory=adaptive_controller.fitness_function, config=config, adaptive_callback=adaptive_controller.adapt_parameters ) return optimizer.optimize_adaptive()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_factory_integration_patterns.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_factory_integration_patterns.html#runnable-false-usr-bin-env-python3">runnable: false #!/usr/bin/env python3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html">PSO Integration Technical Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-def-controller-factory-gains-np-ndarray-controller-pso-compatible-controller-factory-interface-mathematical-foundation-the-factory-must-instantiate-controllers-with-gain-vector-g-n-where-n-is-controller-specific-dimensionality-classical-smc-g-6-c1-1-c2-2-k-kd-sta-smc-g-6-k1-k2-k1-k2-1-2-adaptive-smc-g-5-c1-1-c2-2-hybrid-adaptive-sta-smc-g-4-c1-1-c2-2-parameters-gains-np-ndarray-shape-n-controller-gain-vector-with-validated-bounds-returns-controller-configured-smc-instance-with-required-attributes-max-force-float-actuator-saturation-limit-validate-gains-optional-callable-pre-filtering-function-interface-contracts-1-factory-function-must-have-attribute-n-gains-specifying-dimensionality-2-returned-controller-must-implement-control-computation-interface-3-all-gains-must-be-positive-and-within-specified-bounds-4-controller-must-handle-edge-cases-singularities-saturation-return-create-controller-controller-type-config-gains-gains-required-factory-attribute">runnable: false def controller_factory(gains: np.ndarray) -&gt; Controller: ‚Äú‚Äù‚Äù PSO-compatible controller factory interface. Mathematical Foundation: The factory must instantiate controllers with gain vector G ‚àà ‚Ñù‚Åø where n is controller-specific dimensionality: - Classical SMC: G ‚àà ‚Ñù‚Å∂ (c‚ÇÅ, Œª‚ÇÅ, c‚ÇÇ, Œª‚ÇÇ, K, kd) - STA-SMC: G ‚àà ‚Ñù‚Å∂ (K‚ÇÅ, K‚ÇÇ, k‚ÇÅ, k‚ÇÇ, Œª‚ÇÅ, Œª‚ÇÇ) - Adaptive SMC: G ‚àà ‚Ñù‚Åµ (c‚ÇÅ, Œª‚ÇÅ, c‚ÇÇ, Œª‚ÇÇ, Œ≥) - Hybrid Adaptive STA-SMC: G ‚àà ‚Ñù‚Å¥ (c‚ÇÅ, Œª‚ÇÅ, c‚ÇÇ, Œª‚ÇÇ) Parameters ‚Äî‚Äî‚Äî- gains : np.ndarray, shape (n,) Controller gain vector with validated bounds Returns ‚Äî‚Äî- Controller Configured SMC instance with required attributes: - max_force: float (actuator saturation limit) - validate_gains: Optional[Callable] (pre-filtering function) Interface Contracts ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî 1. Factory function MUST have attribute ‚Äòn_gains‚Äô specifying dimensionality 2. Returned controller MUST implement control computation interface 3. All gains MUST be positive and within specified bounds 4. Controller MUST handle edge cases (singularities, saturation) ‚Äú‚Äù‚Äù return create_controller(controller_type, config, gains=gains) # Required factory attribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-controller-registry-with-pso-integration-metadata">runnable: false # Controller Registry with PSO Integration Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-def-validate-controller-gains-controller-type-str-gains-np-ndarray-np-ndarray-validate-gain-vectors-for-controller-specific-stability-requirements-mathematical-validation-rules-classical-smc-all-gains-0-positive-definiteness-sliding-surface-gains-c1-1-c2-2-ensure-hurwitz-characteristic-polynomial-switching-gains-k-kd-provide-reaching-condition-satisfaction-sta-smc-super-twisting-algorithmic-gains-k1-k2-0-stability-condition-surface-coefficients-1-2-for-target-damping-ratio-0-6-0-8-finite-time-convergence-k12-4k2-12-parameters-controller-type-str-controller-identifier-from-registry-gains-np-ndarray-shape-b-n-batch-of-gain-vectors-to-validate-returns-np-ndarray-shape-b-dtype-bool-validity-mask-for-each-gain-vector-registry-info-controller-registry-controller-type-bounds-registry-info-gain-bounds-basic-bounds-checking-valid-mask-np-ones-gains-shape-0-dtype-bool-for-i-min-val-max-val-in-enumerate-bounds-valid-mask-gains-i-min-val-gains-i-max-val-controller-specific-stability-checks-if-controller-type-sta-smc-k1-k2-condition-for-sta-stability-valid-mask-gains-0-gains-1-surface-coefficient-bounds-for-target-damping-lambda1-lambda2-gains-4-gains-5-damping-ratio-lambda2-2-np-sqrt-lambda1-valid-mask-damping-ratio-0-6-damping-ratio-0-8-return-valid-mask">runnable: false def validate_controller_gains(controller_type: str, gains: np.ndarray) -&gt; np.ndarray: ‚Äú‚Äù‚Äù Validate gain vectors for controller-specific stability requirements. Mathematical Validation Rules: Classical SMC: - All gains &gt; 0 (positive definiteness) - Sliding surface gains c‚ÇÅ, Œª‚ÇÅ, c‚ÇÇ, Œª‚ÇÇ ensure Hurwitz characteristic polynomial - Switching gains K, kd provide reaching condition satisfaction STA-SMC (Super-Twisting): - Algorithmic gains: K‚ÇÅ &gt; K‚ÇÇ &gt; 0 (stability condition) - Surface coefficients: Œª‚ÇÅ, Œª‚ÇÇ for target damping ratio Œ∂ ‚àà [0.6, 0.8] - Finite-time convergence: K‚ÇÅ¬≤ &gt; 4K‚ÇÇ|Œª‚ÇÅŒª‚ÇÇ| Parameters ‚Äî‚Äî‚Äî- controller_type : str Controller identifier from registry gains : np.ndarray, shape (B, n) Batch of gain vectors to validate Returns ‚Äî‚Äî- np.ndarray, shape (B,), dtype=bool Validity mask for each gain vector ‚Äú‚Äù‚Äù registry_info = CONTROLLER_REGISTRY[controller_type] bounds = registry_info[‚Äògain_bounds‚Äô] # Basic bounds checking valid_mask = np.ones(gains.shape[0], dtype=bool) for i, (min_val, max_val) in enumerate(bounds): valid_mask &amp;= (gains[:, i] &gt;= min_val) &amp; (gains[:, i] &lt;= max_val) # Controller-specific stability checks if controller_type == ‚Äòsta_smc‚Äô: # K‚ÇÅ &gt; K‚ÇÇ condition for STA stability valid_mask &amp;= gains[:, 0] &gt; gains[:, 1] # Surface coefficient bounds for target damping lambda1, lambda2 = gains[:, 4], gains[:, 5] damping_ratio = lambda2 / (2 * np.sqrt(lambda1)) valid_mask &amp;= (damping_ratio &gt;= 0.6) &amp; (damping_ratio &lt;= 0.8) return valid_mask</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-def-compute-fitness-cost-t-np-ndarray-x-np-ndarray-u-np-ndarray-sigma-np-ndarray-float-multi-objective-fitness-function-for-pso-optimization-mathematical-formulation-j-w10-e-t-2dt-w20-u2-t-dt-w30-du-dt-2dt-w40-2-t-dt-p-where-e-t-x-t-x-ref-state-error-vector-u-t-control-effort-du-dt-control-rate-chattering-penalty-t-sliding-variable-magnitude-p-instability-penalty-for-early-termination-cost-function-components-1-state-error-ise-0-e-t-2dt-2-control-effort-0-u2-t-dt-3-control-rate-0-du-dt-2dt-4-sliding-variable-energy-0-2-t-dt-5-stability-penalty-graded-penalty-for-premature-failure-dt-np-diff-t-dt-matrix-dt-none-shape-1-n-1-state-error-integration-all-state-components-state-error-sq-np-sum-x-1-2-dt-matrix-none-axis-1-2-control-effort-integration-control-effort-sq-np-sum-u2-dt-matrix-axis-1-control-rate-penalty-anti-chattering-du-np-diff-u-axis-1-prepend-u-0-1-control-rate-sq-np-sum-du2-dt-matrix-axis-1-sliding-variable-energy-sliding-energy-np-sum-sigma2-dt-matrix-axis-1-instability-detection-and-penalty-instability-mask-detect-instability-x-u-sigma-stability-penalty-compute-graded-penalty-instability-mask-t-weighted-cost-aggregation-total-cost-weights-state-error-normalize-state-error-sq-norms-ise-weights-control-effort-normalize-control-effort-sq-norms-control-weights-control-rate-normalize-control-rate-sq-norms-rate-weights-stability-normalize-sliding-energy-norms-sliding-stability-penalty-return-total-cost">runnable: false def compute_fitness_cost(t: np.ndarray, x: np.ndarray, u: np.ndarray, sigma: np.ndarray) -&gt; float: ‚Äú‚Äù‚Äù Multi-objective fitness function for PSO optimization. Mathematical Formulation: J = w‚ÇÅ‚à´‚ÇÄ·µÄ||e(t)||¬≤dt + w‚ÇÇ‚à´‚ÇÄ·µÄu¬≤(t)dt + w‚ÇÉ‚à´‚ÇÄ·µÄ(du/dt)¬≤dt + w‚ÇÑ‚à´‚ÇÄ·µÄœÉ¬≤(t)dt + P Where: - e(t) = x(t) - x_ref: state error vector - u(t): control effort - du/dt: control rate (chattering penalty) - œÉ(t): sliding variable magnitude - P: instability penalty for early termination Cost Function Components: 1. State Error (ISE): ‚à´‚ÇÄ·µÄ||e(t)||¬≤dt 2. Control Effort: ‚à´‚ÇÄ·µÄu¬≤(t)dt 3. Control Rate: ‚à´‚ÇÄ·µÄ(du/dt)¬≤dt 4. Sliding Variable Energy: ‚à´‚ÇÄ·µÄœÉ¬≤(t)dt 5. Stability Penalty: Graded penalty for premature failure ‚Äú‚Äù‚Äù dt = np.diff(t) dt_matrix = dt[None, :] # Shape (1, N-1) # State error integration (all state components) state_error_sq = np.sum(x[:, :-1, :]<strong>2 * dt_matrix[:, :, None], axis=(1, 2)) # Control effort integration control_effort_sq = np.sum(u</strong>2 * dt_matrix, axis=1) # Control rate penalty (anti-chattering) du = np.diff(u, axis=1, prepend=u[:, 0:1]) control_rate_sq = np.sum(du<strong>2 * dt_matrix, axis=1) # Sliding variable energy sliding_energy = np.sum(sigma</strong>2 * dt_matrix, axis=1) # Instability detection and penalty instability_mask = detect_instability(x, u, sigma) stability_penalty = compute_graded_penalty(instability_mask, t) # Weighted cost aggregation total_cost = ( weights.state_error * normalize(state_error_sq, norms.ise) + weights.control_effort * normalize(control_effort_sq, norms.control) + weights.control_rate * normalize(control_rate_sq, norms.rate) + weights.stability * normalize(sliding_energy, norms.sliding) + stability_penalty ) return total_cost</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#id4">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-class-pso-convergencemonitor-advanced-convergence-monitoring-with-multiple-termination-criteria-def-init-self-patience-int-50-tolerance-float-1e-6-diversity-threshold-float-1e-8-self-patience-patience-self-tolerance-tolerance-self-diversity-threshold-diversity-threshold-self-best-cost-history-self-diversity-history-self-stagnation-counter-0-def-check-convergence-self-swarm-positions-np-ndarray-swarm-costs-np-ndarray-tuple-bool-str-multi-criteria-convergence-detection-1-cost-improvement-stagnation-2-swarm-diversity-collapse-3-gradient-based-local-optimum-detection-current-best-np-min-swarm-costs-self-best-cost-history-append-current-best-swarm-diversity-standard-deviation-of-positions-diversity-np-mean-np-std-swarm-positions-axis-0-self-diversity-history-append-diversity-check-improvement-stagnation-if-len-self-best-cost-history-2-improvement-abs-self-best-cost-history-2-current-best-relative-improvement-improvement-abs-current-best-1e-12-if-relative-improvement-self-tolerance-self-stagnation-counter-1-else-self-stagnation-counter-0-convergence-conditions-if-self-stagnation-counter-self-patience-return-true-f-cost-stagnation-self-stagnation-counter-iterations-without-improvement-if-diversity-self-diversity-threshold-return-true-f-diversity-collapse-diversity-2e-self-diversity-threshold-2e-return-false-optimization-continuing">runnable: false class PSO_ConvergenceMonitor: ‚Äú‚Äù‚Äù Advanced convergence monitoring with multiple termination criteria. ‚Äú‚Äù‚Äù def <strong>init</strong>(self, patience: int = 50, tolerance: float = 1e-6, diversity_threshold: float = 1e-8): self.patience = patience self.tolerance = tolerance self.diversity_threshold = diversity_threshold self.best_cost_history = [] self.diversity_history = [] self.stagnation_counter = 0 def check_convergence(self, swarm_positions: np.ndarray, swarm_costs: np.ndarray) -&gt; tuple[bool, str]: ‚Äú‚Äù‚Äù Multi-criteria convergence detection: 1. Cost improvement stagnation 2. Swarm diversity collapse 3. Gradient-based local optimum detection ‚Äú‚Äù‚Äù current_best = np.min(swarm_costs) self.best_cost_history.append(current_best) # Swarm diversity (standard deviation of positions) diversity = np.mean(np.std(swarm_positions, axis=0)) self.diversity_history.append(diversity) # Check improvement stagnation if len(self.best_cost_history) &gt;= 2: improvement = abs(self.best_cost_history[-2] - current_best) relative_improvement = improvement / (abs(current_best) + 1e-12) if relative_improvement &lt; self.tolerance: self.stagnation_counter += 1 else: self.stagnation_counter = 0 # Convergence conditions if self.stagnation_counter &gt;= self.patience: return True, f‚ÄùCost stagnation: {self.stagnation_counter} iterations without improvement‚Äù if diversity &lt; self.diversity_threshold: return True, f‚ÄùDiversity collapse: œÉ = {diversity:.2e} &lt; {self.diversity_threshold:.2e}‚Äù return False, ‚ÄúOptimization continuing‚Äù</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#id5">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-def-robust-optimization-under-uncertainty-pso-tuner-psotuner-uncertainty-config-physicsuncertaintyschema-dict-monte-carlo-robust-optimization-with-uncertainty-quantification-methodology-1-sample-n-physics-realizations-from-uncertainty-distributions-2-evaluate-each-particle-against-all-realizations-3-aggregate-costs-using-risk-sensitive-criteria-mean-std-4-report-confidence-intervals-for-optimal-gains-mathematical-framework-uncertain-parameters-n-0-2-for-each-physics-parameter-robust-cost-j-robust-e-j-g-std-j-g-risk-parameter-0-1-balancing-mean-vs-variance-generate-uncertainty-samples-physics-samples-generate-physics-samples-uncertainty-config-multi-realization-evaluation-costs-per-realization-for-physics-params-in-physics-samples-evaluate-swarm-under-this-realization-realization-costs-pso-tuner-evaluate-swarm-with-physics-physics-params-costs-per-realization-append-realization-costs-risk-sensitive-aggregation-mean-costs-np-mean-costs-per-realization-axis-0-std-costs-np-std-costs-per-realization-axis-0-robust-costs-mean-costs-uncertainty-config-risk-factor-std-costs-return-robust-costs-robust-costs-mean-costs-mean-costs-std-costs-std-costs-confidence-intervals-compute-confidence-intervals-costs-per-realization-physics-samples-physics-samples">runnable: false def robust_optimization_under_uncertainty(pso_tuner: PSOTuner, uncertainty_config: PhysicsUncertaintySchema) -&gt; dict: ‚Äú‚Äù‚Äù Monte Carlo robust optimization with uncertainty quantification. Methodology: 1. Sample N physics realizations from uncertainty distributions 2. Evaluate each particle against all realizations 3. Aggregate costs using risk-sensitive criteria (mean + Œ±¬∑std) 4. Report confidence intervals for optimal gains Mathematical Framework: - Uncertain parameters: Œ∏ ~ N(Œ∏‚ÇÄ, œÉ¬≤) for each physics parameter - Robust cost: J_robust = E[J(G,Œ∏)] + Œ±¬∑Std[J(G,Œ∏)] - Risk parameter: Œ± ‚àà [0, 1] balancing mean vs variance ‚Äú‚Äù‚Äù # Generate uncertainty samples physics_samples = generate_physics_samples(uncertainty_config) # Multi-realization evaluation costs_per_realization = [] for physics_params in physics_samples: # Evaluate swarm under this realization realization_costs = pso_tuner.evaluate_swarm_with_physics(physics_params) costs_per_realization.append(realization_costs) # Risk-sensitive aggregation mean_costs = np.mean(costs_per_realization, axis=0) std_costs = np.std(costs_per_realization, axis=0) robust_costs = mean_costs + uncertainty_config.risk_factor * std_costs return { ‚Äòrobust_costs‚Äô: robust_costs, ‚Äòmean_costs‚Äô: mean_costs, ‚Äòstd_costs‚Äô: std_costs, ‚Äòconfidence_intervals‚Äô: compute_confidence_intervals(costs_per_realization), ‚Äòphysics_samples‚Äô: physics_samples }</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#version-1-0-legacy-deprecated">Version 1.0 (Legacy) - Deprecated</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#id6">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_integration_technical_specification.html#runnable-false-def-migrate-pso-configuration-legacy-config-dict-psoconfig-migrate-legacy-pso-configuration-to-current-schema-with-validation-migration-rules-1-remove-deprecated-fields-with-warnings-2-update-bounds-for-issue-2-resolution-compatibility-3-add-new-enhanced-features-with-sensible-defaults-4-validate-mathematical-consistency-of-migrated-parameters-warnings-remove-deprecated-fields-deprecated-fields-n-processes-hyper-trials-hyper-search-study-timeout-for-field-in-deprecated-fields-if-field-in-legacy-config-warnings-append-f-deprecated-field-field-removed-during-migration-del-legacy-config-field-update-bounds-for-issue-2-compatibility-if-bounds-in-legacy-config-old-bounds-legacy-config-bounds-if-max-in-old-bounds-and-len-old-bounds-max-6-check-for-problematic-lambda-bounds-from-issue-2-if-old-bounds-max-4-10-0-or-old-bounds-max-5-10-0-warnings-append-updated-lambda-bounds-for-issue-2-overshoot-resolution-old-bounds-max-4-min-old-bounds-max-4-10-0-old-bounds-max-5-min-old-bounds-max-5-10-0-add-enhanced-features-if-missing-if-w-schedule-not-in-legacy-config-legacy-config-w-schedule-0-9-0-4-warnings-append-added-inertia-weight-scheduling-for-improved-convergence-if-velocity-clamp-not-in-legacy-config-legacy-config-velocity-clamp-0-1-0-2-warnings-append-added-velocity-clamping-for-stability-validate-migrated-configuration-migrated-config-psoconfig-legacy-config-validation-result-pso-configvalidator-validate-hyperparameters-migrated-config-if-not-validation-result-is-valid-raise-configurationerror-f-migration-failed-validation-validation-result-errors-return-migrated-config-warnings">runnable: false def migrate_pso_configuration(legacy_config: dict) -&gt; PSOConfig: ‚Äú‚Äù‚Äù Migrate legacy PSO configuration to current schema with validation. Migration Rules: 1. Remove deprecated fields with warnings 2. Update bounds for Issue #2 resolution compatibility 3. Add new enhanced features with sensible defaults 4. Validate mathematical consistency of migrated parameters ‚Äú‚Äù‚Äù warnings = [] # Remove deprecated fields deprecated_fields = [‚Äòn_processes‚Äô, ‚Äòhyper_trials‚Äô, ‚Äòhyper_search‚Äô, ‚Äòstudy_timeout‚Äô] for field in deprecated_fields: if field in legacy_config: warnings.append(f‚ÄùDeprecated field ‚Äò{field}‚Äô removed during migration‚Äù) del legacy_config[field] # Update bounds for Issue #2 compatibility if ‚Äòbounds‚Äô in legacy_config: old_bounds = legacy_config[‚Äòbounds‚Äô] if ‚Äòmax‚Äô in old_bounds and len(old_bounds[‚Äòmax‚Äô]) &gt;= 6: # Check for problematic lambda bounds from Issue #2 if old_bounds[‚Äòmax‚Äô][4] &gt; 10.0 or old_bounds[‚Äòmax‚Äô][5] &gt; 10.0: warnings.append(‚ÄúUpdated lambda bounds for Issue #2 overshoot resolution‚Äù) old_bounds[‚Äòmax‚Äô][4] = min(old_bounds[‚Äòmax‚Äô][4], 10.0) old_bounds[‚Äòmax‚Äô][5] = min(old_bounds[‚Äòmax‚Äô][5], 10.0) # Add enhanced features if missing if ‚Äòw_schedule‚Äô not in legacy_config: legacy_config[‚Äòw_schedule‚Äô] = [0.9, 0.4] warnings.append(‚ÄúAdded inertia weight scheduling for improved convergence‚Äù) if ‚Äòvelocity_clamp‚Äô not in legacy_config: legacy_config[‚Äòvelocity_clamp‚Äô] = [0.1, 0.2] warnings.append(‚ÄúAdded velocity clamping for stability‚Äù) # Validate migrated configuration migrated_config = PSOConfig(**legacy_config) validation_result = PSO_ConfigValidator.validate_hyperparameters(migrated_config) if not validation_result.is_valid: raise ConfigurationError(f‚ÄùMigration failed validation: {validation_result.errors}‚Äù) return migrated_config, warnings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html">PSO Optimization Workflow Specifications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#runnable-false-class-optimizationworkflowmanager-management-of-pso-optimization-workflow-execution-def-init-self-config-dict-controller-type-str-self-config-config-self-controller-type-controller-type-self-monitors-performance-performancemonitor-convergence-convergencemonitor-memory-memorymonitor-safety-safetymonitor-self-workflow-state-workflowstate-def-execute-optimization-workflow-self-controller-factory-callable-optimizationresult-execute-complete-pso-optimization-workflow-with-monitoring-workflow-phases-1-pre-optimization-setup-and-validation-2-pso-tuner-initialization-3-optimization-loop-execution-4-real-time-monitoring-and-adaptation-5-post-optimization-validation-6-result-analysis-and-reporting-workflow-start-time-time-time-result-optimizationresult-try-phase-1-pre-optimization-setup-setup-result-self-execute-setup-phase-controller-factory-result-setup-results-setup-result-if-not-setup-result-success-result-status-setup-failed-return-result-phase-2-pso-tuner-initialization-tuner-result-self-execute-tuner-initialization-result-tuner-results-tuner-result-if-not-tuner-result-success-result-status-tuner-failed-return-result-phase-3-optimization-execution-optimization-result-self-execute-optimization-loop-result-optimization-results-optimization-result-if-not-optimization-result-success-result-status-optimization-failed-return-result-phase-4-post-optimization-validation-validation-result-self-execute-validation-phase-optimization-result-result-validation-results-validation-result-phase-5-result-analysis-analysis-result-self-execute-analysis-phase-optimization-result-result-analysis-results-analysis-result-result-status-success-result-total-time-time-time-workflow-start-time-except-exception-as-e-result-status-error-result-error-message-str-e-result-total-time-time-time-workflow-start-time-return-result-def-execute-setup-phase-self-controller-factory-callable-setupresult-execute-pre-optimization-setup-and-validation-setup-result-setupresult-validate-controller-factory-if-not-hasattr-controller-factory-n-gains-setup-result-errors-append-controller-factory-missing-n-gains-attribute-setup-result-success-false-return-setup-result-validate-factory-functionality-try-test-gains-np-ones-controller-factory-n-gains-test-controller-controller-factory-test-gains-if-not-hasattr-test-controller-max-force-setup-result-warnings-append-controller-missing-max-force-attribute-except-exception-as-e-setup-result-errors-append-f-controller-factory-test-failed-str-e-setup-result-success-false-return-setup-result-setup-monitoring-systems-for-name-monitor-in-self-monitors-items-try-monitor-initialize-self-config-setup-result-monitors-initialized-append-name-except-exception-as-e-setup-result-errors-append-f-monitor-name-initialization-failed-str-e-validate-memory-availability-available-memory-psutil-virtual-memory-available-1024-3-gb-required-memory-self-estimate-memory-requirement-if-available-memory-required-memory-setup-result-warnings-append-f-low-memory-available-memory-1f-gb-available-required-memory-1f-gb-recommended-setup-result-success-len-setup-result-errors-0-return-setup-result-def-execute-optimization-loop-self-optimizationloopresult-execute-pso-optimization-loop-with-real-time-monitoring-result-optimizationloopresult-try-initialize-pso-tuner-tuner-psotuner-controller-factory-self-controller-factory-config-self-config-seed-self-config-get-pso-get-execution-get-seed-42-setup-optimization-monitoring-optimization-monitor-optimizationmonitor-monitors-self-monitors-config-self-config-execute-optimization-with-monitoring-pso-result-tuner-optimise-extract-results-result-best-cost-pso-result-best-cost-result-best-gains-pso-result-best-pos-result-cost-history-pso-result-history-cost-result-position-history-pso-result-history-pos-get-monitoring-data-result-performance-metrics-optimization-monitor-get-performance-summary-result-convergence-analysis-optimization-monitor-get-convergence-analysis-result-success-true-except-exception-as-e-result-success-false-result-error-message-str-e-return-result">runnable: false class OptimizationWorkflowManager: ‚Äú‚Äù‚Äù management of PSO optimization workflow execution. ‚Äú‚Äù‚Äù def <strong>init</strong>(self, config: dict, controller_type: str): self.config = config self.controller_type = controller_type self.monitors = { ‚Äòperformance‚Äô: PerformanceMonitor(), ‚Äòconvergence‚Äô: ConvergenceMonitor(), ‚Äòmemory‚Äô: MemoryMonitor(), ‚Äòsafety‚Äô: SafetyMonitor() } self.workflow_state = WorkflowState() def execute_optimization_workflow(self, controller_factory: Callable) -&gt; OptimizationResult: ‚Äú‚Äù‚Äù Execute complete PSO optimization workflow with monitoring. Workflow Phases: 1. Pre-optimization setup and validation 2. PSO tuner initialization 3. Optimization loop execution 4. Real-time monitoring and adaptation 5. Post-optimization validation 6. Result analysis and reporting ‚Äú‚Äù‚Äù workflow_start_time = time.time() result = OptimizationResult() try: # Phase 1: Pre-optimization Setup setup_result = self._execute_setup_phase(controller_factory) result.setup_results = setup_result if not setup_result.success: result.status = ‚ÄòSETUP_FAILED‚Äô return result # Phase 2: PSO Tuner Initialization tuner_result = self._execute_tuner_initialization() result.tuner_results = tuner_result if not tuner_result.success: result.status = ‚ÄòTUNER_FAILED‚Äô return result # Phase 3: Optimization Execution optimization_result = self._execute_optimization_loop() result.optimization_results = optimization_result if not optimization_result.success: result.status = ‚ÄòOPTIMIZATION_FAILED‚Äô return result # Phase 4: Post-optimization Validation validation_result = self._execute_validation_phase(optimization_result) result.validation_results = validation_result # Phase 5: Result Analysis analysis_result = self._execute_analysis_phase(optimization_result) result.analysis_results = analysis_result result.status = ‚ÄòSUCCESS‚Äô result.total_time = time.time() - workflow_start_time except Exception as e: result.status = ‚ÄòERROR‚Äô result.error_message = str(e) result.total_time = time.time() - workflow_start_time return result def _execute_setup_phase(self, controller_factory: Callable) -&gt; SetupResult: ‚Äú‚Äù‚Äù Execute pre-optimization setup and validation. ‚Äú‚Äù‚Äù setup_result = SetupResult() # Validate controller factory if not hasattr(controller_factory, ‚Äòn_gains‚Äô): setup_result.errors.append(‚ÄòController factory missing n_gains attribute‚Äô) setup_result.success = False return setup_result # Validate factory functionality try: test_gains = np.ones(controller_factory.n_gains) test_controller = controller_factory(test_gains) if not hasattr(test_controller, ‚Äòmax_force‚Äô): setup_result.warnings.append(‚ÄòController missing max_force attribute‚Äô) except Exception as e: setup_result.errors.append(f‚ÄôController factory test failed: {str(e)}‚Äô) setup_result.success = False return setup_result # Setup monitoring systems for name, monitor in self.monitors.items(): try: monitor.initialize(self.config) setup_result.monitors_initialized.append(name) except Exception as e: setup_result.errors.append(f‚ÄôMonitor {name} initialization failed: {str(e)}‚Äô) # Validate memory availability available_memory = psutil.virtual_memory().available / (1024**3) # GB required_memory = self._estimate_memory_requirement() if available_memory &lt; required_memory: setup_result.warnings.append(f‚ÄôLow memory: {available_memory:.1f}GB available, {required_memory:.1f}GB recommended‚Äô) setup_result.success = len(setup_result.errors) == 0 return setup_result def _execute_optimization_loop(self) -&gt; OptimizationLoopResult: ‚Äú‚Äù‚Äù Execute PSO optimization loop with real-time monitoring. ‚Äú‚Äù‚Äù result = OptimizationLoopResult() try: # Initialize PSO tuner tuner = PSOTuner( controller_factory=self.controller_factory, config=self.config, seed=self.config.get(‚Äòpso‚Äô, {}).get(‚Äòexecution‚Äô, {}).get(‚Äòseed‚Äô, 42) ) # Setup optimization monitoring optimization_monitor = OptimizationMonitor( monitors=self.monitors, config=self.config ) # Execute optimization with monitoring pso_result = tuner.optimise() # Extract results result.best_cost = pso_result[‚Äòbest_cost‚Äô] result.best_gains = pso_result[‚Äòbest_pos‚Äô] result.cost_history = pso_result[‚Äòhistory‚Äô][‚Äòcost‚Äô] result.position_history = pso_result[‚Äòhistory‚Äô][‚Äòpos‚Äô] # Get monitoring data result.performance_metrics = optimization_monitor.get_performance_summary() result.convergence_analysis = optimization_monitor.get_convergence_analysis() result.success = True except Exception as e: result.success = False result.error_message = str(e) return result</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#runnable-false-class-optimizationmonitor-real-time-monitoring-system-for-pso-optimization-with-adaptive-features-def-init-self-monitors-dict-config-dict-self-monitors-monitors-self-config-config-self-monitoring-data-iteration-times-memory-usage-cost-improvements-diversity-metrics-constraint-violations-safety-alerts-def-monitor-iteration-self-iteration-int-swarm-state-dict-monitoringresult-monitor-single-pso-iteration-with-metrics-collection-iteration-start-time-time-result-monitoringresult-performance-monitoring-perf-metrics-self-monitors-performance-collect-metrics-swarm-state-self-monitoring-data-iteration-times-append-perf-metrics-iteration-time-self-monitoring-data-memory-usage-append-perf-metrics-memory-mb-convergence-monitoring-conv-metrics-self-monitors-convergence-analyze-convergence-swarm-state-self-monitoring-data-cost-improvements-append-conv-metrics-cost-improvement-self-monitoring-data-diversity-metrics-append-conv-metrics-diversity-constraint-validation-constraint-result-self-validate-constraints-realtime-swarm-state-self-monitoring-data-constraint-violations-extend-constraint-result-violations-safety-monitoring-safety-result-self-monitors-safety-check-safety-conditions-swarm-state-if-safety-result-alerts-self-monitoring-data-safety-alerts-extend-safety-result-alerts-adaptive-parameter-adjustment-if-self-should-adapt-parameters-iteration-swarm-state-adaptations-self-compute-parameter-adaptations-swarm-state-result-parameter-adaptations-adaptations-issue-2-specific-monitoring-for-sta-smc-if-self-config-get-controller-type-sta-smc-issue2-result-self-monitor-issue2-compliance-swarm-state-result-issue2-compliance-issue2-result-result-monitoring-data-self-monitoring-data-result-iteration-time-time-time-iteration-start-return-result-def-validate-constraints-realtime-self-swarm-state-dict-dict-real-time-validation-of-mathematical-and-physical-constraints-violations-particles-swarm-state-get-positions-np-array-if-particles-size-0-return-violations-violations-controller-type-self-config-get-controller-type-classical-smc-controller-specific-constraint-checking-if-controller-type-sta-smc-and-particles-shape-1-6-k1-k2-constraint-k1-particles-k2-particles-particles-0-particles-1-k1-le-k2-mask-k1-particles-k2-particles-if-np-any-k1-le-k2-mask-violation-count-np-sum-k1-le-k2-mask-violations-append-type-sta-stability-violation-count-violation-count-particles-np-where-k1-le-k2-mask-0-tolist-severity-high-issue-2-damping-ratio-constraint-if-particles-shape-1-6-lambda1-lambda2-particles-4-particles-5-k1-k2-particles-2-particles-3-safe-computation-with-epsilon-to-avoid-division-by-zero-epsilon-1e-12-zeta1-lambda1-2-np-sqrt-k1-epsilon-zeta2-lambda2-2-np-sqrt-k2-epsilon-check-issue-2-requirement-0-69-zeta1-violation-zeta1-0-69-zeta2-violation-zeta2-0-69-if-np-any-zeta1-violation-or-np-any-zeta2-violation-violation-particles-np-where-zeta1-violation-zeta2-violation-0-violations-append-type-issue2-damping-violation-count-len-violation-particles-particles-violation-particles-tolist-severity-high-details-min-zeta1-np-min-zeta1-min-zeta2-np-min-zeta2-requirement-0-69-for-5-overshoot-return-violations-violations-def-monitor-issue2-compliance-self-swarm-state-dict-dict-specialized-monitoring-for-issue-2-overshoot-compliance-particles-swarm-state-get-positions-np-array-if-particles-size-0-or-particles-shape-1-6-return-status-insufficient-data-extract-surface-coefficients-lambda1-lambda2-particles-4-particles-5-k1-k2-particles-2-particles-3-compute-damping-ratios-epsilon-1e-12-zeta1-lambda1-2-np-sqrt-k1-epsilon-zeta2-lambda2-2-np-sqrt-k2-epsilon-issue-2-compliance-analysis-compliance-stats-compliant-particles-0-total-particles-len-particles-min-damping-ratio-min-np-min-zeta1-np-min-zeta2-avg-damping-ratio-np-mean-zeta1-np-mean-zeta2-2-predicted-overshoot-range-lambda-bounds-status-unknown-count-compliant-particles-0-69-compliant-mask-zeta1-0-69-zeta2-0-69-compliance-stats-compliant-particles-np-sum-compliant-mask-predict-overshoot-for-representative-particles-for-i-in-range-min-5-len-particles-sample-first-5-particles-zeta-avg-zeta1-i-zeta2-i-2-if-zeta-avg-1-0-underdamped-predicted-overshoot-100-np-exp-zeta-avg-np-pi-np-sqrt-1-zeta-avg-2-else-overdamped-predicted-overshoot-0-0-compliance-stats-predicted-overshoot-range-append-predicted-overshoot-check-lambda-bounds-status-max-lambda1-max-lambda2-np-max-lambda1-np-max-lambda2-if-max-lambda1-10-0-and-max-lambda2-10-0-compliance-stats-lambda-bounds-status-compliant-else-compliance-stats-lambda-bounds-status-violation-return-compliance-stats">runnable: false class OptimizationMonitor: ‚Äú‚Äù‚Äù Real-time monitoring system for PSO optimization with adaptive features. ‚Äú‚Äù‚Äù def <strong>init</strong>(self, monitors: dict, config: dict): self.monitors = monitors self.config = config self.monitoring_data = { ‚Äòiteration_times‚Äô: [], ‚Äòmemory_usage‚Äô: [], ‚Äòcost_improvements‚Äô: [], ‚Äòdiversity_metrics‚Äô: [], ‚Äòconstraint_violations‚Äô: [], ‚Äòsafety_alerts‚Äô: [] } def monitor_iteration(self, iteration: int, swarm_state: dict) -&gt; MonitoringResult: ‚Äú‚Äù‚Äù Monitor single PSO iteration with metrics collection. ‚Äú‚Äù‚Äù iteration_start = time.time() result = MonitoringResult() # Performance monitoring perf_metrics = self.monitors[‚Äòperformance‚Äô].collect_metrics(swarm_state) self.monitoring_data[‚Äòiteration_times‚Äô].append(perf_metrics[‚Äòiteration_time‚Äô]) self.monitoring_data[‚Äòmemory_usage‚Äô].append(perf_metrics[‚Äòmemory_mb‚Äô]) # Convergence monitoring conv_metrics = self.monitors[‚Äòconvergence‚Äô].analyze_convergence(swarm_state) self.monitoring_data[‚Äòcost_improvements‚Äô].append(conv_metrics[‚Äòcost_improvement‚Äô]) self.monitoring_data[‚Äòdiversity_metrics‚Äô].append(conv_metrics[‚Äòdiversity‚Äô]) # Constraint validation constraint_result = self._validate_constraints_realtime(swarm_state) self.monitoring_data[‚Äòconstraint_violations‚Äô].extend(constraint_result[‚Äòviolations‚Äô]) # Safety monitoring safety_result = self.monitors[‚Äòsafety‚Äô].check_safety_conditions(swarm_state) if safety_result[‚Äòalerts‚Äô]: self.monitoring_data[‚Äòsafety_alerts‚Äô].extend(safety_result[‚Äòalerts‚Äô]) # Adaptive parameter adjustment if self._should_adapt_parameters(iteration, swarm_state): adaptations = self._compute_parameter_adaptations(swarm_state) result.parameter_adaptations = adaptations # Issue #2 specific monitoring for STA-SMC if self.config.get(‚Äòcontroller_type‚Äô) == ‚Äòsta_smc‚Äô: issue2_result = self._monitor_issue2_compliance(swarm_state) result.issue2_compliance = issue2_result result.monitoring_data = self.monitoring_data result.iteration_time = time.time() - iteration_start return result def _validate_constraints_realtime(self, swarm_state: dict) -&gt; dict: ‚Äú‚Äù‚Äù Real-time validation of mathematical and physical constraints. ‚Äú‚Äù‚Äù violations = [] particles = swarm_state.get(‚Äòpositions‚Äô, np.array([])) if particles.size == 0: return {‚Äòviolations‚Äô: violations} controller_type = self.config.get(‚Äòcontroller_type‚Äô, ‚Äòclassical_smc‚Äô) # Controller-specific constraint checking if controller_type == ‚Äòsta_smc‚Äô and particles.shape[1] &gt;= 6: # K‚ÇÅ &gt; K‚ÇÇ constraint k1_particles, k2_particles = particles[:, 0], particles[:, 1] k1_le_k2_mask = k1_particles &lt;= k2_particles if np.any(k1_le_k2_mask): violation_count = np.sum(k1_le_k2_mask) violations.append({ ‚Äòtype‚Äô: ‚ÄòSTA_STABILITY_VIOLATION‚Äô, ‚Äòcount‚Äô: violation_count, ‚Äòparticles‚Äô: np.where(k1_le_k2_mask)[0].tolist(), ‚Äòseverity‚Äô: ‚ÄòHIGH‚Äô }) # Issue #2 damping ratio constraint if particles.shape[1] &gt;= 6: lambda1, lambda2 = particles[:, 4], particles[:, 5] k1, k2 = particles[:, 2], particles[:, 3] # Safe computation with epsilon to avoid division by zero epsilon = 1e-12 zeta1 = lambda1 / (2 * np.sqrt(k1 + epsilon)) zeta2 = lambda2 / (2 * np.sqrt(k2 + epsilon)) # Check Issue #2 requirement: Œ∂ ‚â• 0.69 zeta1_violation = zeta1 &lt; 0.69 zeta2_violation = zeta2 &lt; 0.69 if np.any(zeta1_violation) or np.any(zeta2_violation): violation_particles = np.where(zeta1_violation | zeta2_violation)[0] violations.append({ ‚Äòtype‚Äô: ‚ÄòISSUE2_DAMPING_VIOLATION‚Äô, ‚Äòcount‚Äô: len(violation_particles), ‚Äòparticles‚Äô: violation_particles.tolist(), ‚Äòseverity‚Äô: ‚ÄòHIGH‚Äô, ‚Äòdetails‚Äô: { ‚Äòmin_zeta1‚Äô: np.min(zeta1), ‚Äòmin_zeta2‚Äô: np.min(zeta2), ‚Äòrequirement‚Äô: ‚ÄòŒ∂ ‚â• 0.69 for &lt;5% overshoot‚Äô } }) return {‚Äòviolations‚Äô: violations} def _monitor_issue2_compliance(self, swarm_state: dict) -&gt; dict: ‚Äú‚Äù‚Äù Specialized monitoring for Issue #2 overshoot compliance. ‚Äú‚Äù‚Äù particles = swarm_state.get(‚Äòpositions‚Äô, np.array([])) if particles.size == 0 or particles.shape[1] &lt; 6: return {‚Äòstatus‚Äô: ‚Äòinsufficient_data‚Äô} # Extract surface coefficients lambda1, lambda2 = particles[:, 4], particles[:, 5] k1, k2 = particles[:, 2], particles[:, 3] # Compute damping ratios epsilon = 1e-12 zeta1 = lambda1 / (2 * np.sqrt(k1 + epsilon)) zeta2 = lambda2 / (2 * np.sqrt(k2 + epsilon)) # Issue #2 compliance analysis compliance_stats = { ‚Äòcompliant_particles‚Äô: 0, ‚Äòtotal_particles‚Äô: len(particles), ‚Äòmin_damping_ratio‚Äô: min(np.min(zeta1), np.min(zeta2)), ‚Äòavg_damping_ratio‚Äô: (np.mean(zeta1) + np.mean(zeta2)) / 2, ‚Äòpredicted_overshoot_range‚Äô: [], ‚Äòlambda_bounds_status‚Äô: ‚Äòunknown‚Äô } # Count compliant particles (Œ∂ ‚â• 0.69) compliant_mask = (zeta1 &gt;= 0.69) &amp; (zeta2 &gt;= 0.69) compliance_stats[‚Äòcompliant_particles‚Äô] = np.sum(compliant_mask) # Predict overshoot for representative particles for i in range(min(5, len(particles))): # Sample first 5 particles zeta_avg = (zeta1[i] + zeta2[i]) / 2 if zeta_avg &lt; 1.0: # Underdamped predicted_overshoot = 100 * np.exp(-zeta_avg * np.pi / np.sqrt(1 - zeta_avg**2)) else: # Overdamped predicted_overshoot = 0.0 compliance_stats[‚Äòpredicted_overshoot_range‚Äô].append(predicted_overshoot) # Check lambda bounds status max_lambda1, max_lambda2 = np.max(lambda1), np.max(lambda2) if max_lambda1 &lt;= 10.0 and max_lambda2 &lt;= 10.0: compliance_stats[‚Äòlambda_bounds_status‚Äô] = ‚Äòcompliant‚Äô else: compliance_stats[‚Äòlambda_bounds_status‚Äô] = ‚Äòviolation‚Äô return compliance_stats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#runnable-false-class-qualitygatesystem-automated-quality-gate-system-for-pso-optimization-workflow-def-init-self-config-dict-self-config-config-self-quality-gates-configurationqualitygate-optimizationqualitygate-performancequalitygate-safetyqualitygate-issue2compliancequalitygate-regressionqualitygate-def-evaluate-quality-gates-self-workflow-result-dict-qualitygatereport-evaluate-all-quality-gates-and-generate-report-report-qualitygatereport-for-gate-in-self-quality-gates-gate-result-gate-evaluate-workflow-result-self-config-report-add-gate-result-gate-name-gate-result-generate-overall-assessment-report-generate-overall-assessment-return-report-class-issue2compliancequalitygate-qualitygate-quality-gate-specifically-for-issue-2-overshoot-compliance-def-init-self-self-name-issue2-overshoot-compliance-self-acceptance-criteria-max-predicted-overshoot-5-0-maximum-theoretical-overshoot-min-damping-ratio-0-69-minimum-damping-for-compliance-max-lambda-bounds-10-0-maximum-lambda-values-simulation-overshoot-limit-5-0-maximum-measured-overshoot-def-evaluate-self-workflow-result-dict-config-dict-qualitygateresult-evaluate-issue-2-overshoot-compliance-result-qualitygateresult-gate-name-self-name-skip-if-not-sta-smc-if-config-get-controller-type-sta-smc-result-status-skipped-result-message-issue-2-compliance-only-applies-to-sta-smc-return-result-optimized-gains-workflow-result-get-best-gains-if-optimized-gains-is-none-or-len-optimized-gains-6-result-status-failed-result-message-missing-or-insufficient-optimized-gains-return-result-extract-surface-coefficients-lambda1-lambda2-optimized-gains-4-optimized-gains-5-k1-k2-optimized-gains-2-optimized-gains-3-check-1-lambda-bounds-compliance-lambda-bounds-ok-lambda1-self-acceptance-criteria-max-lambda-bounds-and-lambda2-self-acceptance-criteria-max-lambda-bounds-check-2-damping-ratio-compliance-zeta1-lambda1-2-np-sqrt-k1-zeta2-lambda2-2-np-sqrt-k2-damping-ok-zeta1-self-acceptance-criteria-min-damping-ratio-and-zeta2-self-acceptance-criteria-min-damping-ratio-check-3-predicted-overshoot-avg-zeta-zeta1-zeta2-2-if-avg-zeta-1-0-predicted-overshoot-100-np-exp-avg-zeta-np-pi-np-sqrt-1-avg-zeta-2-else-predicted-overshoot-0-0-overshoot-prediction-ok-predicted-overshoot-self-acceptance-criteria-max-predicted-overshoot-check-4-simulation-validation-if-available-simulation-ok-true-measured-overshoot-none-if-overshoot-measurement-in-workflow-result-overshoot-data-workflow-result-overshoot-measurement-measured-overshoot-overshoot-data-get-measured-overshoot-percent-0-simulation-ok-measured-overshoot-self-acceptance-criteria-simulation-overshoot-limit-overall-assessment-all-checks-pass-lambda-bounds-ok-and-damping-ok-and-overshoot-prediction-ok-and-simulation-ok-if-all-checks-pass-result-status-passed-result-message-f-issue-2-compliance-verified-predicted-overshoot-predicted-overshoot-2f-else-result-status-failed-failed-checks-if-not-lambda-bounds-ok-failed-checks-append-f-lambda-bounds-1-lambda1-3f-2-lambda2-3f-self-acceptance-criteria-max-lambda-bounds-if-not-damping-ok-failed-checks-append-f-damping-ratios-1-zeta1-3f-2-zeta2-3f-self-acceptance-criteria-min-damping-ratio-if-not-overshoot-prediction-ok-failed-checks-append-f-predicted-overshoot-predicted-overshoot-2f-self-acceptance-criteria-max-predicted-overshoot-if-not-simulation-ok-and-measured-overshoot-is-not-none-failed-checks-append-f-measured-overshoot-measured-overshoot-2f-self-acceptance-criteria-simulation-overshoot-limit-result-message-f-issue-2-compliance-failed-join-failed-checks-add-detailed-metrics-result-metrics-lambda1-lambda1-lambda2-lambda2-damping-ratio-1-zeta1-damping-ratio-2-zeta2-predicted-overshoot-percent-predicted-overshoot-measured-overshoot-percent-measured-overshoot-lambda-bounds-compliant-lambda-bounds-ok-damping-compliant-damping-ok-overshoot-prediction-compliant-overshoot-prediction-ok-simulation-compliant-simulation-ok-return-result">runnable: false class QualityGateSystem: ‚Äú‚Äù‚Äù Automated quality gate system for PSO optimization workflow. ‚Äú‚Äù‚Äù def <strong>init</strong>(self, config: dict): self.config = config self.quality_gates = [ ConfigurationQualityGate(), OptimizationQualityGate(), PerformanceQualityGate(), SafetyQualityGate(), Issue2ComplianceQualityGate(), RegressionQualityGate() ] def evaluate_quality_gates(self, workflow_result: dict) -&gt; QualityGateReport: ‚Äú‚Äù‚Äù Evaluate all quality gates and generate report. ‚Äú‚Äù‚Äù report = QualityGateReport() for gate in self.quality_gates: gate_result = gate.evaluate(workflow_result, self.config) report.add_gate_result(gate.name, gate_result) # Generate overall assessment report.generate_overall_assessment() return report class Issue2ComplianceQualityGate(QualityGate): ‚Äú‚Äù‚Äù Quality gate specifically for Issue #2 overshoot compliance. ‚Äú‚Äù‚Äù def <strong>init</strong>(self): self.name = ‚ÄúIssue2_Overshoot_Compliance‚Äù self.acceptance_criteria = { ‚Äòmax_predicted_overshoot‚Äô: 5.0, # % maximum theoretical overshoot ‚Äòmin_damping_ratio‚Äô: 0.69, # Minimum damping for compliance ‚Äòmax_lambda_bounds‚Äô: 10.0, # Maximum lambda values ‚Äòsimulation_overshoot_limit‚Äô: 5.0 # % maximum measured overshoot } def evaluate(self, workflow_result: dict, config: dict) -&gt; QualityGateResult: ‚Äú‚Äù‚Äù Evaluate Issue #2 overshoot compliance. ‚Äú‚Äù‚Äù result = QualityGateResult(gate_name=self.name) # Skip if not STA-SMC if config.get(‚Äòcontroller_type‚Äô) != ‚Äòsta_smc‚Äô: result.status = ‚ÄòSKIPPED‚Äô result.message = ‚ÄòIssue #2 compliance only applies to STA-SMC‚Äô return result optimized_gains = workflow_result.get(‚Äòbest_gains‚Äô) if optimized_gains is None or len(optimized_gains) &lt; 6: result.status = ‚ÄòFAILED‚Äô result.message = ‚ÄòMissing or insufficient optimized gains‚Äô return result # Extract surface coefficients lambda1, lambda2 = optimized_gains[4], optimized_gains[5] k1, k2 = optimized_gains[2], optimized_gains[3] # Check 1: Lambda bounds compliance lambda_bounds_ok = (lambda1 &lt;= self.acceptance_criteria[‚Äòmax_lambda_bounds‚Äô] and lambda2 &lt;= self.acceptance_criteria[‚Äòmax_lambda_bounds‚Äô]) # Check 2: Damping ratio compliance zeta1 = lambda1 / (2 * np.sqrt(k1)) zeta2 = lambda2 / (2 * np.sqrt(k2)) damping_ok = (zeta1 &gt;= self.acceptance_criteria[‚Äòmin_damping_ratio‚Äô] and zeta2 &gt;= self.acceptance_criteria[‚Äòmin_damping_ratio‚Äô]) # Check 3: Predicted overshoot avg_zeta = (zeta1 + zeta2) / 2 if avg_zeta &lt; 1.0: predicted_overshoot = 100 * np.exp(-avg_zeta * np.pi / np.sqrt(1 - avg_zeta**2)) else: predicted_overshoot = 0.0 overshoot_prediction_ok = predicted_overshoot &lt;= self.acceptance_criteria[‚Äòmax_predicted_overshoot‚Äô] # Check 4: Simulation validation (if available) simulation_ok = True measured_overshoot = None if ‚Äòovershoot_measurement‚Äô in workflow_result: overshoot_data = workflow_result[‚Äòovershoot_measurement‚Äô] measured_overshoot = overshoot_data.get(‚Äòmeasured_overshoot_percent‚Äô, 0) simulation_ok = measured_overshoot &lt;= self.acceptance_criteria[‚Äòsimulation_overshoot_limit‚Äô] # Overall assessment all_checks_pass = lambda_bounds_ok and damping_ok and overshoot_prediction_ok and simulation_ok if all_checks_pass: result.status = ‚ÄòPASSED‚Äô result.message = f‚ÄôIssue #2 compliance verified: predicted overshoot {predicted_overshoot:.2f}%‚Äô else: result.status = ‚ÄòFAILED‚Äô failed_checks = [] if not lambda_bounds_ok: failed_checks.append(f‚ÄôLambda bounds: Œª‚ÇÅ={lambda1:.3f}, Œª‚ÇÇ={lambda2:.3f} &gt; {self.acceptance_criteria[‚Äúmax_lambda_bounds‚Äù]}‚Äô) if not damping_ok: failed_checks.append(f‚ÄôDamping ratios: Œ∂‚ÇÅ={zeta1:.3f}, Œ∂‚ÇÇ={zeta2:.3f} &lt; {self.acceptance_criteria[‚Äúmin_damping_ratio‚Äù]}‚Äô) if not overshoot_prediction_ok: failed_checks.append(f‚ÄôPredicted overshoot: {predicted_overshoot:.2f}% &gt; {self.acceptance_criteria[‚Äúmax_predicted_overshoot‚Äù]}%‚Äô) if not simulation_ok and measured_overshoot is not None: failed_checks.append(f‚ÄôMeasured overshoot: {measured_overshoot:.2f}% &gt; {self.acceptance_criteria[‚Äúsimulation_overshoot_limit‚Äù]}%‚Äô) result.message = f‚ÄôIssue #2 compliance failed: {‚Äù; ‚Äú.join(failed_checks)}‚Äô # Add detailed metrics result.metrics = { ‚Äòlambda1‚Äô: lambda1, ‚Äòlambda2‚Äô: lambda2, ‚Äòdamping_ratio_1‚Äô: zeta1, ‚Äòdamping_ratio_2‚Äô: zeta2, ‚Äòpredicted_overshoot_percent‚Äô: predicted_overshoot, ‚Äòmeasured_overshoot_percent‚Äô: measured_overshoot, ‚Äòlambda_bounds_compliant‚Äô: lambda_bounds_ok, ‚Äòdamping_compliant‚Äô: damping_ok, ‚Äòovershoot_prediction_compliant‚Äô: overshoot_prediction_ok, ‚Äòsimulation_compliant‚Äô: simulation_ok } return result</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_specifications.html#runnable-false-class-workflowperformanceoptimizer-adaptive-optimization-of-workflow-performance-based-on-runtime-metrics-def-init-self-self-performance-history-self-optimization-strategies-memory-optimization-self-optimize-memory-usage-convergence-acceleration-self-accelerate-convergence-bounds-tightening-self-tighten-bounds-dynamically-parameter-adaptation-self-adapt-pso-parameters-def-optimize-workflow-performance-self-current-metrics-dict-workflow-config-dict-optimizationresult-analyze-current-performance-and-apply-optimization-strategies-result-optimizationresult-analyze-performance-trends-performance-analysis-self-analyze-performance-trends-current-metrics-apply-relevant-optimization-strategies-for-strategy-name-strategy-func-in-self-optimization-strategies-items-if-self-should-apply-strategy-strategy-name-performance-analysis-strategy-result-strategy-func-current-metrics-workflow-config-result-add-strategy-result-strategy-name-strategy-result-return-result-def-accelerate-convergence-self-metrics-dict-config-dict-dict-apply-convergence-acceleration-strategies-based-on-performance-analysis-acceleration-result-applied-optimizations-expected-improvement-0-0-check-convergence-rate-convergence-rate-metrics-get-convergence-rate-0-0-if-convergence-rate-0-05-slow-convergence-detected-suggest-inertia-weight-adjustment-current-w-config-get-pso-get-algorithm-params-get-w-0-7-if-current-w-0-5-suggested-w-max-0-4-current-w-0-1-acceleration-result-applied-optimizations-append-parameter-inertia-weight-current-value-current-w-suggested-value-suggested-w-justification-reduce-inertia-for-faster-exploitation-acceleration-result-expected-improvement-15-0-15-improvement-check-diversity-metrics-diversity-metrics-get-swarm-diversity-1-0-if-diversity-1e-8-very-low-diversity-acceleration-result-applied-optimizations-append-parameter-restart-mechanism-action-enable-fraction-0-2-justification-restart-20-of-particles-to-escape-local-optimum-acceleration-result-expected-improvement-20-0-20-improvement-return-acceleration-result">runnable: false class WorkflowPerformanceOptimizer: ‚Äú‚Äù‚Äù Adaptive optimization of workflow performance based on runtime metrics. ‚Äú‚Äù‚Äù def <strong>init</strong>(self): self.performance_history = [] self.optimization_strategies = { ‚Äòmemory_optimization‚Äô: self._optimize_memory_usage, ‚Äòconvergence_acceleration‚Äô: self._accelerate_convergence, ‚Äòbounds_tightening‚Äô: self._tighten_bounds_dynamically, ‚Äòparameter_adaptation‚Äô: self._adapt_pso_parameters } def optimize_workflow_performance(self, current_metrics: dict, workflow_config: dict) -&gt; OptimizationResult: ‚Äú‚Äù‚Äù Analyze current performance and apply optimization strategies. ‚Äú‚Äù‚Äù result = OptimizationResult() # Analyze performance trends performance_analysis = self._analyze_performance_trends(current_metrics) # Apply relevant optimization strategies for strategy_name, strategy_func in self.optimization_strategies.items(): if self._should_apply_strategy(strategy_name, performance_analysis): strategy_result = strategy_func(current_metrics, workflow_config) result.add_strategy_result(strategy_name, strategy_result) return result def _accelerate_convergence(self, metrics: dict, config: dict) -&gt; dict: ‚Äú‚Äù‚Äù Apply convergence acceleration strategies based on performance analysis. ‚Äú‚Äù‚Äù acceleration_result = { ‚Äòapplied_optimizations‚Äô: [], ‚Äòexpected_improvement‚Äô: 0.0 } # Check convergence rate convergence_rate = metrics.get(‚Äòconvergence_rate‚Äô, 0.0) if convergence_rate &lt; 0.05: # Slow convergence detected # Suggest inertia weight adjustment current_w = config.get(‚Äòpso‚Äô, {}).get(‚Äòalgorithm_params‚Äô, {}).get(‚Äòw‚Äô, 0.7) if current_w &gt; 0.5: suggested_w = max(0.4, current_w - 0.1) acceleration_result[‚Äòapplied_optimizations‚Äô].append({ ‚Äòparameter‚Äô: ‚Äòinertia_weight‚Äô, ‚Äòcurrent_value‚Äô: current_w, ‚Äòsuggested_value‚Äô: suggested_w, ‚Äòjustification‚Äô: ‚ÄòReduce inertia for faster exploitation‚Äô }) acceleration_result[‚Äòexpected_improvement‚Äô] += 15.0 # 15% improvement # Check diversity metrics diversity = metrics.get(‚Äòswarm_diversity‚Äô, 1.0) if diversity &lt; 1e-8: # Very low diversity acceleration_result[‚Äòapplied_optimizations‚Äô].append({ ‚Äòparameter‚Äô: ‚Äòrestart_mechanism‚Äô, ‚Äòaction‚Äô: ‚Äòenable‚Äô, ‚Äòfraction‚Äô: 0.2, ‚Äòjustification‚Äô: ‚ÄòRestart 20% of particles to escape local optimum‚Äô }) acceleration_result[‚Äòexpected_improvement‚Äô] += 20.0 # 20% improvement return acceleration_result</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_optimization_workflow_user_guide.html">PSO Optimization Workflow User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_troubleshooting_maintenance_manual.html">PSO Troubleshooting and Maintenance Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_troubleshooting_maintenance_manual.html#pso-health-monitor-sh-regular-pso-system-health-monitoring-log-file-var-log-pso-health-log">pso_health_monitor.sh - Regular PSO system health monitoring LOG_FILE=‚Äù/var/log/pso_health.log‚Äù</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_troubleshooting_maintenance_manual.html#emergency-recovery-sh-emergency-pso-system-recovery-echo-pso-emergency-recovery-procedure">emergency_recovery.sh - Emergency PSO system recovery echo ‚Äúüö® PSO EMERGENCY RECOVERY PROCEDURE‚Äù</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_troubleshooting_maintenance_manual.html#recovery-restore-from-backup-backup-index-1">recovery.restore_from_backup(backup_index=1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pso_troubleshooting_maintenance_manual.html#recovery-restore-factory-defaults">recovery.restore_factory_defaults()</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quality_gate_independence_framework.html">Quality Gate Independence Framework ## Executive Summary The Quality Gate Independence Framework establishes resilient, parallel validation paths that operate independently to prevent cascade failures and ensure robust quality assessment for the double-inverted pendulum sliding mode control (DIP-SMC) project. This framework addresses the critical issue identified in GitHub Issue #9 where single component failures could prevent system validation. <strong>Core Principle:</strong> No single point of failure should block system quality assessment. ## 1. Framework Architecture ### 1.1 Independent Validation Paths The framework implements <strong>four parallel, independent validation paths</strong> that can operate and report results independently: ```python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quality_gate_independence_framework.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quality_gate_independence_framework.html#runnable-false-class-independentvalidationpaths-four-independent-validation-paths-preventing-cascade-failures-def-init-self-self-validation-paths-coverage-validation-coveragevalidationpath-mathematical-validation-mathematicalvalidationpath-performance-validation-performancevalidationpath-compliance-validation-compliancevalidationpath-def-execute-independent-validation-self-independentvalidationresults-execute-all-validation-paths-independently-with-failure-isolation-results-for-path-name-validator-in-self-validation-paths-items-try-each-path-executes-in-complete-isolation-results-path-name-validator-validate-independently-except-exception-as-e-failure-isolation-one-path-failure-doesn-t-affect-others-results-path-name-validationresult-status-failed-error-str-e-partial-results-validator-get-partial-results-return-independentvalidationresults-path-results-results-overall-status-self-calculate-composite-status-results-deployment-recommendation-self-make-deployment-decision-results">runnable: false class IndependentValidationPaths: ‚Äú‚Äù‚ÄùFour independent validation paths preventing cascade failures.‚Äù‚Äù‚Äù def <strong>init</strong>(self): self.validation_paths = { ‚Äòcoverage_validation‚Äô: CoverageValidationPath(), ‚Äòmathematical_validation‚Äô: MathematicalValidationPath(), ‚Äòperformance_validation‚Äô: PerformanceValidationPath(), ‚Äòcompliance_validation‚Äô: ComplianceValidationPath() } def execute_independent_validation(self) -&gt; IndependentValidationResults: ‚Äú‚Äù‚ÄùExecute all validation paths independently with failure isolation.‚Äù‚Äù‚Äù results = {} for path_name, validator in self.validation_paths.items(): try: # Each path executes in complete isolation results[path_name] = validator.validate_independently() except Exception as e: # Failure isolation: one path failure doesn‚Äôt affect others results[path_name] = ValidationResult( status=‚Äôfailed‚Äô, error=str(e), partial_results=validator.get_partial_results() ) return IndependentValidationResults( path_results=results, overall_status=self._calculate_composite_status(results), deployment_recommendation=self._make_deployment_decision(results) )</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../reference/analysis/index.html">Analysis Module</a><input aria-label="Toggle navigation of Analysis Module" class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/__init__.html">analysis.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/__init__.html#configure-with-custom-parameters">Configure with custom parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/__init__.html#complete-analysis-workflow">Complete analysis workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/__init__.html#fdi-system-usage">FDI system usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/__init__.html#generate-analysis-plots">Generate analysis plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/core_data_structures.html">analysis.core.data_structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/core_data_structures.html#compute-confidence-intervals">Compute confidence intervals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/core_data_structures.html#compute-metrics">Compute metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/core_data_structures.html#analyze-multiple-trials">Analyze multiple trials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/core_data_structures.html#parameter-sensitivity-analysis">Parameter sensitivity analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/core_interfaces.html">analysis.core.interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/core_metrics.html">analysis.core.metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/core_metrics.html#compute-confidence-intervals">Compute confidence intervals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/core_metrics.html#compute-metrics">Compute metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/core_metrics.html#analyze-multiple-trials">Analyze multiple trials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/core_metrics.html#parameter-sensitivity-analysis">Parameter sensitivity analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/core___init__.html">analysis.core.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/fault_detection_fdi.html">analysis.fault_detection.fdi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/fault_detection_fdi.html#configure-with-custom-parameters">Configure with custom parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/fault_detection_fdi.html#complete-analysis-workflow">Complete analysis workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/fault_detection_fdi.html#fdi-system-usage">FDI system usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/fault_detection_fdi.html#generate-analysis-plots">Generate analysis plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/fault_detection_fdi_system.html">analysis.fault_detection.fdi_system</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/fault_detection_fdi_system.html#configure-with-custom-parameters">Configure with custom parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/fault_detection_fdi_system.html#complete-analysis-workflow">Complete analysis workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/fault_detection_fdi_system.html#fdi-system-usage">FDI system usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/fault_detection_fdi_system.html#generate-analysis-plots">Generate analysis plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/fault_detection_residual_generators.html">analysis.fault_detection.residual_generators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/fault_detection_threshold_adapters.html">analysis.fault_detection.threshold_adapters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/fault_detection___init__.html">analysis.fault_detection.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance_control_analysis.html">analysis.performance.control_analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance_control_analysis.html#compute-confidence-intervals">Compute confidence intervals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance_control_analysis.html#compute-metrics">Compute metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance_control_analysis.html#analyze-multiple-trials">Analyze multiple trials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance_control_analysis.html#parameter-sensitivity-analysis">Parameter sensitivity analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance_control_metrics.html">analysis.performance.control_metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance_control_metrics.html#compute-confidence-intervals">Compute confidence intervals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance_control_metrics.html#compute-metrics">Compute metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance_control_metrics.html#analyze-multiple-trials">Analyze multiple trials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance_control_metrics.html#parameter-sensitivity-analysis">Parameter sensitivity analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance_robustness.html">analysis.performance.robustness</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance_robustness.html#compute-confidence-intervals">Compute confidence intervals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance_robustness.html#compute-metrics">Compute metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance_robustness.html#analyze-multiple-trials">Analyze multiple trials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance_robustness.html#parameter-sensitivity-analysis">Parameter sensitivity analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance_stability_analysis.html">analysis.performance.stability_analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance_stability_analysis.html#compute-confidence-intervals">Compute confidence intervals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance_stability_analysis.html#compute-metrics">Compute metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance_stability_analysis.html#analyze-multiple-trials">Analyze multiple trials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance_stability_analysis.html#parameter-sensitivity-analysis">Parameter sensitivity analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/performance___init__.html">analysis.performance.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/reports___init__.html">analysis.reports.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/reports___init__.html#configure-with-custom-parameters">Configure with custom parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/reports___init__.html#complete-analysis-workflow">Complete analysis workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/reports___init__.html#fdi-system-usage">FDI system usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/reports___init__.html#generate-analysis-plots">Generate analysis plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_benchmarking.html">analysis.validation.benchmarking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_core.html">analysis.validation.core</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_cross_validation.html">analysis.validation.cross_validation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_cross_validation.html#compute-confidence-intervals">Compute confidence intervals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_cross_validation.html#compute-metrics">Compute metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_cross_validation.html#analyze-multiple-trials">Analyze multiple trials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_cross_validation.html#parameter-sensitivity-analysis">Parameter sensitivity analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_metrics.html">analysis.validation.metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_metrics.html#compute-confidence-intervals">Compute confidence intervals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_metrics.html#compute-metrics">Compute metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_metrics.html#analyze-multiple-trials">Analyze multiple trials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_metrics.html#parameter-sensitivity-analysis">Parameter sensitivity analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_metrics.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_metrics.html#runnable-false">runnable: false</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_monte_carlo.html">analysis.validation.monte_carlo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_monte_carlo.html#compute-confidence-intervals">Compute confidence intervals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_monte_carlo.html#compute-metrics">Compute metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_monte_carlo.html#analyze-multiple-trials">Analyze multiple trials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_monte_carlo.html#parameter-sensitivity-analysis">Parameter sensitivity analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_monte_carlo.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_monte_carlo.html#runnable-false-controllers">runnable: false controllers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_statistical_benchmarks.html">analysis.validation.statistical_benchmarks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_statistical_tests.html">analysis.validation.statistical_tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_statistical_tests.html#compute-confidence-intervals">Compute confidence intervals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_statistical_tests.html#compute-metrics">Compute metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_statistical_tests.html#analyze-multiple-trials">Analyze multiple trials</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_statistical_tests.html#parameter-sensitivity-analysis">Parameter sensitivity analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation_statistics.html">analysis.validation.statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/validation___init__.html">analysis.validation.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_analysis_plots.html">analysis.visualization.analysis_plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_analysis_plots.html#configure-with-custom-parameters">Configure with custom parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_analysis_plots.html#complete-analysis-workflow">Complete analysis workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_analysis_plots.html#fdi-system-usage">FDI system usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_analysis_plots.html#generate-analysis-plots">Generate analysis plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_diagnostic_plots.html">analysis.visualization.diagnostic_plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_diagnostic_plots.html#configure-with-custom-parameters">Configure with custom parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_diagnostic_plots.html#complete-analysis-workflow">Complete analysis workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_diagnostic_plots.html#fdi-system-usage">FDI system usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_diagnostic_plots.html#generate-analysis-plots">Generate analysis plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_report_generator.html">analysis.visualization.report_generator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_report_generator.html#analysis-report">Analysis Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_report_generator.html#configure-with-custom-parameters">Configure with custom parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_report_generator.html#complete-analysis-workflow">Complete analysis workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_report_generator.html#fdi-system-usage">FDI system usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_report_generator.html#generate-analysis-plots">Generate analysis plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_statistical_plots.html">analysis.visualization.statistical_plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_statistical_plots.html#configure-with-custom-parameters">Configure with custom parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_statistical_plots.html#complete-analysis-workflow">Complete analysis workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_statistical_plots.html#fdi-system-usage">FDI system usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization_statistical_plots.html#generate-analysis-plots">Generate analysis plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization___init__.html">analysis.visualization.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization___init__.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization___init__.html#runnable-false-class">runnable: false class</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization___init__.html#configure-with-custom-parameters">Configure with custom parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization___init__.html#complete-analysis-workflow">Complete analysis workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization___init__.html#fdi-system-usage">FDI system usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/analysis/visualization___init__.html#generate-analysis-plots">Generate analysis plots</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../reference/controllers/index.html">Controllers Module</a><input aria-label="Toggle navigation of Controllers Module" class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/adaptive_smc.html">controllers.adaptive_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/classic_smc.html">controllers.classic_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory.html">controllers.factory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/mpc_controller.html">controllers.mpc_controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/sta_smc.html">controllers.sta_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/swing_up_smc.html">controllers.swing_up_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/__init__.html">controllers.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/base_controller_interface.html">controllers.base.controller_interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/base_control_primitives.html">controllers.base.control_primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/base___init__.html">controllers.base.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_deprecation.html">controllers.factory.deprecation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_fallback_configs.html">controllers.factory.fallback_configs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_legacy_factory.html">controllers.factory.legacy_factory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_optimization.html">controllers.factory.optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_pso_integration.html">controllers.factory.pso_integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_smc_factory.html">controllers.factory.smc_factory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_thread_safety.html">controllers.factory.thread_safety</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory___init__.html">controllers.factory.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/mpc_mpc_controller.html">controllers.mpc.mpc_controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/mpc___init__.html">controllers.mpc.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_adaptive_smc.html">controllers.smc.adaptive_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_classic_smc.html">controllers.smc.classic_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_hybrid_adaptive_sta_smc.html">controllers.smc.hybrid_adaptive_sta_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_sta_smc.html">controllers.smc.sta_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc___init__.html">controllers.smc.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/specialized_swing_up_smc.html">controllers.specialized.swing_up_smc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/specialized___init__.html">controllers.specialized.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_core_protocols.html">controllers.factory.core.protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_core_registry.html">controllers.factory.core.registry</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_core_threading.html">controllers.factory.core.threading</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_core_validation.html">controllers.factory.core.validation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/factory_core___init__.html">controllers.factory.core.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms___init__.html">controllers.smc.algorithms.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_core_equivalent_control.html">controllers.smc.core.equivalent_control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_core_gain_validation.html">controllers.smc.core.gain_validation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_core_sliding_surface.html">controllers.smc.core.sliding_surface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_core_switching_functions.html">controllers.smc.core.switching_functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_core___init__.html">controllers.smc.core.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_adaptive_adaptation_law.html">controllers.smc.algorithms.adaptive.adaptation_law</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_adaptive_config.html">controllers.smc.algorithms.adaptive.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_adaptive_controller.html">controllers.smc.algorithms.adaptive.controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_adaptive_controller.html#adjust-parameters-for-better-performance">Adjust parameters for better performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_adaptive_controller.html#use-in-complete-control-loop">Use in complete control loop</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_adaptive_controller.html#analyze-metrics">Analyze metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_adaptive_parameter_estimation.html">controllers.smc.algorithms.adaptive.parameter_estimation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_adaptive___init__.html">controllers.smc.algorithms.adaptive.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_classical_boundary_layer.html">controllers.smc.algorithms.classical.boundary_layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_classical_config.html">controllers.smc.algorithms.classical.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_classical_controller.html">controllers.smc.algorithms.classical.controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_classical___init__.html">controllers.smc.algorithms.classical.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_hybrid_config.html">controllers.smc.algorithms.hybrid.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_hybrid_controller.html">controllers.smc.algorithms.hybrid.controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_hybrid_switching_logic.html">controllers.smc.algorithms.hybrid.switching_logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_hybrid___init__.html">controllers.smc.algorithms.hybrid.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_super_twisting_config.html">controllers.smc.algorithms.super_twisting.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_super_twisting_controller.html">controllers.smc.algorithms.super_twisting.controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_super_twisting_controller.html#sta-stability-k1">STA stability: K‚ÇÅ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_super_twisting_twisting_algorithm.html">controllers.smc.algorithms.super_twisting.twisting_algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/controllers/smc_algorithms_super_twisting___init__.html">controllers.smc.algorithms.super_twisting.<strong>init</strong></a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../reference/interfaces/index.html">Interfaces Module</a><input aria-label="Toggle navigation of Interfaces Module" class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/__init__.html">interfaces.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/core_data_types.html">interfaces.core.data_types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/core_protocols.html">interfaces.core.protocols</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/core___init__.html">interfaces.core.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/data_exchange_data_types.html">interfaces.data_exchange.data_types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/data_exchange_factory.html">interfaces.data_exchange.factory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/data_exchange_factory_resilient.html">interfaces.data_exchange.factory_resilient</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/data_exchange_schemas.html">interfaces.data_exchange.schemas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/data_exchange_serializers.html">interfaces.data_exchange.serializers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/data_exchange_streaming.html">interfaces.data_exchange.streaming</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/data_exchange___init__.html">interfaces.data_exchange.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/hardware_actuators.html">interfaces.hardware.actuators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/hardware_daq_systems.html">interfaces.hardware.daq_systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/hardware_device_drivers.html">interfaces.hardware.device_drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/hardware_factory.html">interfaces.hardware.factory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/hardware_sensors.html">interfaces.hardware.sensors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/hardware_serial_devices.html">interfaces.hardware.serial_devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/hardware___init__.html">interfaces.hardware.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/hil_controller_client.html">interfaces.hil.controller_client</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/hil_data_logging.html">interfaces.hil.data_logging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/hil_enhanced_hil.html">interfaces.hil.enhanced_hil</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/hil_fault_injection.html">interfaces.hil.fault_injection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/hil_plant_server.html">interfaces.hil.plant_server</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/hil_real_time_sync.html">interfaces.hil.real_time_sync</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/hil_simulation_bridge.html">interfaces.hil.simulation_bridge</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/hil_test_automation.html">interfaces.hil.test_automation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/hil___init__.html">interfaces.hil.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/monitoring_alerting.html">interfaces.monitoring.alerting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/monitoring_dashboard.html">interfaces.monitoring.dashboard</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/monitoring_diagnostics.html">interfaces.monitoring.diagnostics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/monitoring_health_monitor.html">interfaces.monitoring.health_monitor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/monitoring_metrics_collector.html">interfaces.monitoring.metrics_collector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/monitoring_metrics_collector_deadlock_free.html">interfaces.monitoring.metrics_collector_deadlock_free</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/monitoring_metrics_collector_fixed.html">interfaces.monitoring.metrics_collector_fixed</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/monitoring_metrics_collector_threadsafe.html">interfaces.monitoring.metrics_collector_threadsafe</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/monitoring_performance_tracker.html">interfaces.monitoring.performance_tracker</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/monitoring___init__.html">interfaces.monitoring.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/network_factory.html">interfaces.network.factory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/network_http_interface.html">interfaces.network.http_interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/network_message_queue.html">interfaces.network.message_queue</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/network_tcp_interface.html">interfaces.network.tcp_interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/network_udp_interface.html">interfaces.network.udp_interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/network_udp_interface_deadlock_free.html">interfaces.network.udp_interface_deadlock_free</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/network_udp_interface_threadsafe.html">interfaces.network.udp_interface_threadsafe</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/network_websocket_interface.html">interfaces.network.websocket_interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/interfaces/network___init__.html">interfaces.network.<strong>init</strong></a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../reference/optimization/index.html">Optimization Module</a><input aria-label="Toggle navigation of Optimization Module" class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/__init__.html">optimization.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/algorithms_base.html">optimization.algorithms.base</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/algorithms_memory_efficient_pso.html">optimization.algorithms.memory_efficient_pso</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/algorithms_multi_objective_pso.html">optimization.algorithms.multi_objective_pso</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/algorithms_pso_optimizer.html">optimization.algorithms.pso_optimizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/algorithms___init__.html">optimization.algorithms.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/benchmarks___init__.html">optimization.benchmarks.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/constraints___init__.html">optimization.constraints.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/core_context.html">optimization.core.context</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/core_interfaces.html">optimization.core.interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/core_parameters.html">optimization.core.parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/core_problem.html">optimization.core.problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/core_results_manager.html">optimization.core.results_manager</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/core_results_manager.html#adjust-parameters-for-better-performance">Adjust parameters for better performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/core_results_manager.html#use-in-complete-optimization-loop">Use in complete optimization loop</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/core_results_manager.html#analyze-metrics">Analyze metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/core___init__.html">optimization.core.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/integration_pso_factory_bridge.html">optimization.integration.pso_factory_bridge</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/integration___init__.html">optimization.integration.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/objectives_base.html">optimization.objectives.base</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/objectives___init__.html">optimization.objectives.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/results_convergence.html">optimization.results.convergence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/results___init__.html">optimization.results.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/solvers___init__.html">optimization.solvers.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/tuning_pso_hyperparameter_optimizer.html">optimization.tuning.pso_hyperparameter_optimizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/validation_enhanced_convergence_analyzer.html">optimization.validation.enhanced_convergence_analyzer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/validation_enhanced_convergence_analyzer.html#adjust-parameters-for-better-performance">Adjust parameters for better performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/validation_enhanced_convergence_analyzer.html#use-in-complete-optimization-loop">Use in complete optimization loop</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/validation_enhanced_convergence_analyzer.html#analyze-metrics">Analyze metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/validation_pso_bounds_optimizer.html">optimization.validation.pso_bounds_optimizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/validation_pso_bounds_validator.html">optimization.validation.pso_bounds_validator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/validation___init__.html">optimization.validation.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/algorithms_bayesian___init__.html">optimization.algorithms.bayesian.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/algorithms_evolutionary_differential.html">optimization.algorithms.evolutionary.differential</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/algorithms_evolutionary_genetic.html">optimization.algorithms.evolutionary.genetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/algorithms_evolutionary___init__.html">optimization.algorithms.evolutionary.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/algorithms_gradient___init__.html">optimization.algorithms.gradient.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/algorithms_gradient_based_bfgs.html">optimization.algorithms.gradient_based.bfgs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/algorithms_gradient_based_nelder_mead.html">optimization.algorithms.gradient_based.nelder_mead</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/algorithms_gradient_based___init__.html">optimization.algorithms.gradient_based.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/algorithms_swarm_pso.html">optimization.algorithms.swarm.pso</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/algorithms_swarm___init__.html">optimization.algorithms.swarm.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/objectives_control_energy.html">optimization.objectives.control.energy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/objectives_control_robustness.html">optimization.objectives.control.robustness</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/objectives_control_stability.html">optimization.objectives.control.stability</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/objectives_control_tracking.html">optimization.objectives.control.tracking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/objectives_control___init__.html">optimization.objectives.control.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/objectives_multi_pareto.html">optimization.objectives.multi.pareto</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/objectives_multi_weighted_sum.html">optimization.objectives.multi.weighted_sum</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/objectives_multi___init__.html">optimization.objectives.multi.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/objectives_system_overshoot.html">optimization.objectives.system.overshoot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/objectives_system_settling_time.html">optimization.objectives.system.settling_time</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/objectives_system_steady_state.html">optimization.objectives.system.steady_state</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/objectives_system___init__.html">optimization.objectives.system.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/results_convergence___init__.html">optimization.results.convergence.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/optimization/results_visualization___init__.html">optimization.results.visualization.<strong>init</strong></a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../reference/plant/index.html">Plant Module</a><input aria-label="Toggle navigation of Plant Module" class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/__init__.html">plant.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/configurations_base_config.html">plant.configurations.base_config</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/configurations_unified_config.html">plant.configurations.unified_config</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/configurations_validation.html">plant.configurations.validation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/configurations___init__.html">plant.configurations.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/core_dynamics.html">plant.core.dynamics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/core_numerical_stability.html">plant.core.numerical_stability</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/core_numerical_stability.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/core_numerical_stability.html#runnable-false-conservative-research-grade-precision">runnable: false # Conservative (research-grade precision)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/core_physics_matrices.html">plant.core.physics_matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/core_state_validation.html">plant.core.state_validation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/core___init__.html">plant.core.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/models_dynamics.html">plant.models.dynamics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/models___init__.html">plant.models.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/parameters___init__.html">plant.parameters.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/models_base_dynamics_interface.html">plant.models.base.dynamics_interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/models_base___init__.html">plant.models.base.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/models_full_config.html">plant.models.full.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/models_full_dynamics.html">plant.models.full.dynamics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/models_full_physics.html">plant.models.full.physics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/models_full___init__.html">plant.models.full.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/models_lowrank_config.html">plant.models.lowrank.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/models_lowrank_dynamics.html">plant.models.lowrank.dynamics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/models_lowrank_physics.html">plant.models.lowrank.physics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/models_lowrank___init__.html">plant.models.lowrank.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/models_simplified_config.html">plant.models.simplified.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/models_simplified_dynamics.html">plant.models.simplified.dynamics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/models_simplified_dynamics.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/models_simplified_dynamics.html#runnable-false">runnable: false</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/models_simplified_physics.html">plant.models.simplified.physics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/plant/models_simplified___init__.html">plant.models.simplified.<strong>init</strong></a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../reference/simulation/index.html">Simulation Module</a><input aria-label="Toggle navigation of Simulation Module" class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/__init__.html">simulation.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/context_safety_guards.html">simulation.context.safety_guards</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/context_simulation_context.html">simulation.context.simulation_context</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/context___init__.html">simulation.context.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/core_interfaces.html">simulation.core.interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/core_simulation_context.html">simulation.core.simulation_context</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/core_state_space.html">simulation.core.state_space</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/core_time_domain.html">simulation.core.time_domain</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/core___init__.html">simulation.core.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/engines_adaptive_integrator.html">simulation.engines.adaptive_integrator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/engines_simulation_runner.html">simulation.engines.simulation_runner</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/engines_vector_sim.html">simulation.engines.vector_sim</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/engines___init__.html">simulation.engines.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/integrators_base.html">simulation.integrators.base</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/integrators_compatibility.html">simulation.integrators.compatibility</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/integrators_factory.html">simulation.integrators.factory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/integrators___init__.html">simulation.integrators.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/logging___init__.html">simulation.logging.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_base.html">simulation.orchestrators.base</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_batch.html">simulation.orchestrators.batch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_parallel.html">simulation.orchestrators.parallel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_real_time.html">simulation.orchestrators.real_time</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_real_time.html#create-real-time-orchestrator-100-hz">Create real-time orchestrator (100 Hz)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_real_time.html#real-time-simulation">Real-time simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_real_time.html#multiple-tasks-with-different-priorities">Multiple tasks with different priorities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_real_time.html#run-all-tasks-with-priority-scheduling">Run all tasks with priority scheduling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_real_time.html#monitor-performance">Monitor performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_real_time.html#real-time-with-recovery-callback">Real-time with recovery callback</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_real_time.html#weakly-hard-1-10-firm-constraint">Weakly-hard (1, 10)-firm constraint</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_real_time.html#check-constraint-satisfaction">Check constraint satisfaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_real_time.html#run-simulation-with-jitter-tracking">Run simulation with jitter tracking</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_real_time.html#analyze-jitter">Analyze jitter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_real_time.html#plot-jitter-distribution">Plot jitter distribution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_real_time.html#example-task-set">Example task set</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_real_time.html#basic-usage-example">Basic usage example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_real_time.html#advanced-configuration">Advanced configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_real_time.html#integration-example">Integration example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_real_time.html#performance-optimized-usage">Performance-optimized usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_real_time.html#error-handling">Error handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators_sequential.html">simulation.orchestrators.sequential</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators___init__.html">simulation.orchestrators.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators___init__.html#create-orchestrator">Create orchestrator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators___init__.html#define-simulation-campaign">Define simulation campaign</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators___init__.html#run-campaign-sequentially">Run campaign sequentially</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators___init__.html#create-parallel-orchestrator">Create parallel orchestrator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators___init__.html#large-scale-campaign">Large-scale campaign</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators___init__.html#run-in-parallel">Run in parallel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators___init__.html#real-time-orchestrator-with-deadline">Real-time orchestrator with deadline</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators___init__.html#real-time-campaign">Real-time campaign</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators___init__.html#run-with-hard-deadlines">Run with hard deadlines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators___init__.html#use-adaptive-orchestrator">Use adaptive orchestrator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators___init__.html#basic-usage-example">Basic usage example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators___init__.html#advanced-configuration">Advanced configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators___init__.html#integration-example">Integration example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators___init__.html#performance-optimized-usage">Performance-optimized usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/orchestrators___init__.html#error-handling">Error handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results_containers.html">simulation.results.containers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results_containers.html#basic-usage-example">Basic usage example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results_containers.html#advanced-configuration">Advanced configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results_containers.html#integration-example">Integration example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results_containers.html#performance-optimized-usage">Performance-optimized usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results_containers.html#error-handling">Error handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results_exporters.html">simulation.results.exporters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results_exporters.html#basic-usage-example">Basic usage example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results_exporters.html#advanced-configuration">Advanced configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results_exporters.html#integration-example">Integration example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results_exporters.html#performance-optimized-usage">Performance-optimized usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results_exporters.html#error-handling">Error handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results_processors.html">simulation.results.processors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results_validators.html">simulation.results.validators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results___init__.html">simulation.results.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results___init__.html#create-result-container">Create result container</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results___init__.html#store-simulation-data">Store simulation data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results___init__.html#access-data">Access data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results___init__.html#create-batch-container">Create batch container</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results___init__.html#add-multiple-trial-results">Add multiple trial results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results___init__.html#aggregate-results">Aggregate results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results___init__.html#create-validator">Create validator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results___init__.html#validate-result">Validate result</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results___init__.html#export-to-csv">Export to CSV</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results___init__.html#export-to-hdf5-with-compression">Export to HDF5 (with compression)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results___init__.html#export-to-json">Export to JSON</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results___init__.html#define-processing-pipeline">Define processing pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results___init__.html#run-pipeline">Run pipeline</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results___init__.html#basic-usage-example">Basic usage example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results___init__.html#advanced-configuration">Advanced configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results___init__.html#integration-example">Integration example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results___init__.html#performance-optimized-usage">Performance-optimized usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/results___init__.html#error-handling">Error handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/safety_constraints.html">simulation.safety.constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/safety_guards.html">simulation.safety.guards</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/safety_monitors.html">simulation.safety.monitors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/safety_recovery.html">simulation.safety.recovery</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/safety___init__.html">simulation.safety.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/strategies_monte_carlo.html">simulation.strategies.monte_carlo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/strategies___init__.html">simulation.strategies.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/validation___init__.html">simulation.validation.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/integrators_adaptive_error_control.html">simulation.integrators.adaptive.error_control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/integrators_adaptive_runge_kutta.html">simulation.integrators.adaptive.runge_kutta</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/integrators_adaptive___init__.html">simulation.integrators.adaptive.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/integrators_discrete_zero_order_hold.html">simulation.integrators.discrete.zero_order_hold</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/integrators_discrete___init__.html">simulation.integrators.discrete.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/integrators_fixed_step_euler.html">simulation.integrators.fixed_step.euler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/integrators_fixed_step_runge_kutta.html">simulation.integrators.fixed_step.runge_kutta</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/simulation/integrators_fixed_step___init__.html">simulation.integrators.fixed_step.<strong>init</strong></a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../reference/utils/index.html">Utils Module</a><input aria-label="Toggle navigation of Utils Module" class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/config_compatibility.html">utils.config_compatibility</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/control_analysis.html">utils.control_analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/control_analysis.html#integration-example">Integration example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/seed.html">utils.seed</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/__init__.html">utils.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/analysis_statistics.html">utils.analysis.statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/analysis_statistics.html#integration-example">Integration example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/analysis___init__.html">utils.analysis.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/control_saturation.html">utils.control.saturation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/control_saturation.html#scalar-saturation">Scalar saturation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/control_saturation.html#vector-saturation">Vector saturation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/control_saturation.html#smc-with-smooth-saturation">SMC with smooth saturation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/control_saturation.html#comparison-hard-vs-smooth">Comparison: hard vs smooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/control_saturation.html#plot-to-show-smoothness">Plot to show smoothness</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/control_saturation.html#filter-small-control-signals">Filter small control signals</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/control_saturation.html#result-0-0">Result: [0, 0,</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/control_saturation.html#application-pd-controller-with-dead-zone">Application: PD controller with dead zone</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/control_saturation.html#use-pi-with-anti-windup">Use PI with anti-windup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/control_saturation.html#track-saturation-during-simulation">Track saturation during simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/control___init__.html">utils.control.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/control___init__.html#integration-example">Integration example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/coverage_monitoring.html">utils.coverage.monitoring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/development_jupyter_tools.html">utils.development.jupyter_tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/development_jupyter_tools.html#basic-usage-example">Basic usage example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/development_jupyter_tools.html#advanced-configuration">Advanced configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/development_jupyter_tools.html#integration-example">Integration example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/development_jupyter_tools.html#performance-optimized-usage">Performance-optimized usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/development_jupyter_tools.html#error-handling">Error handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/development___init__.html">utils.development.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/memory_memory_pool.html">utils.memory.memory_pool</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/memory___init__.html">utils.memory.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/monitoring_diagnostics.html">utils.monitoring.diagnostics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/monitoring_diagnostics.html#integration-example">Integration example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/monitoring_latency.html">utils.monitoring.latency</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/monitoring_latency.html#create-monitor-for-10ms-control-loop-dt-0-01s">Create monitor for 10ms control loop (dt=0.01s)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/monitoring_latency.html#get-performance-statistics">Get performance statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/monitoring_latency.html#phase-1-transient-response-0-5s">Phase 1: Transient response (0-5s)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/monitoring_latency.html#analyze-transient-phase">Analyze transient phase</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/monitoring_latency.html#reset-for-steady-state-monitoring">Reset for steady-state monitoring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/monitoring_latency.html#phase-2-steady-state-5-10s">Phase 2: Steady-state (5-10s)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/monitoring_latency.html#compare-steady-state-performance">Compare steady-state performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/monitoring_memory_monitor.html">utils.monitoring.memory_monitor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/monitoring_memory_monitor.html#integration-example">Integration example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/monitoring_stability.html">utils.monitoring.stability</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/monitoring___init__.html">utils.monitoring.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/numerical_stability_safe_operations.html">utils.numerical_stability.safe_operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/numerical_stability_safe_operations.html#integration-example">Integration example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/numerical_stability___init__.html">utils.numerical_stability.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/reproducibility_seed.html">utils.reproducibility.seed</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/reproducibility___init__.html">utils.reproducibility.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/types_control_outputs.html">utils.types.control_outputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/types___init__.html">utils.types.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/validation_parameter_validators.html">utils.validation.parameter_validators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/validation_range_validators.html">utils.validation.range_validators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/validation___init__.html">utils.validation.<strong>init</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/visualization_animation.html">utils.visualization.animation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/visualization_legacy_visualizer.html">utils.visualization.legacy_visualizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/visualization_movie_generator.html">utils.visualization.movie_generator</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/visualization_movie_generator.html#basic-usage-example">Basic usage example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/visualization_movie_generator.html#advanced-configuration">Advanced configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/visualization_movie_generator.html#integration-example">Integration example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/visualization_movie_generator.html#performance-optimized-usage">Performance-optimized usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/visualization_movie_generator.html#error-handling">Error handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/visualization_static_plots.html">utils.visualization.static_plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/utils/visualization___init__.html">utils.visualization.<strong>init</strong></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../results_readme.html">Results &amp; Plots</a></li>
<li class="toctree-l1"><a class="reference internal" href="../safety_system_validation_protocols.html">Safety System Validation Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sitemap_cards.html">Visual Documentation Navigator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sitemap_interactive.html">Interactive Documentation Map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sitemap_visual.html">Visual Documentation Map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../streamlit_dashboard_guide.html">Streamlit Dashboard User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../symbols.html">Symbols &amp; Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_execution_guide.html">Test Execution Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_guide.html">Test Execution Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_guide.html#quick-development-testing-unit-tests-only">Quick development testing (unit tests only)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_guide.html#recommended-pre-commit-test-sequence">Recommended pre-commit test sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_guide.html#test-algorithm-convergence-properties">Test algorithm convergence properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_guide.html#quality-gate-sh-production-deployment-validation-set-e-echo-starting-quality-gate-validation-1-fast-unit-tests">quality_gate.sh - Production deployment validation set -e echo ‚ÄúüöÄ Starting quality gate validation‚Ä¶‚Äù # 1. Fast unit tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_execution_guide.html#pre-commit-config-yaml">.pre-commit-config.yaml</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html">Test Infrastructure Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html#run-only-unit-tests-fast-execution">Run only unit tests (fast execution)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html#full-test-suite-with-coverage">Full test suite with coverage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html#convergence-and-stability-analysis">Convergence and stability analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html#all-tests-except-known-failing-concurrent-tests">All tests except known failing concurrent tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html#automatic-configuration-in-tests-conftest-py">Automatic configuration in tests/conftest.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_documentation.html#quality-gate-sh-production-deployment-gate-echo-running-quality-gate-validation-1-unit-and-integration-tests">quality_gate.sh - Production deployment gate echo ‚ÄúRunning quality gate validation‚Ä¶‚Äù # 1. Unit and integration tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_infrastructure_validation_report.html">Test Infrastructure Validation Report</a></li>
<li class="toctree-l1"><a class="reference internal" href="../test_protocols.html">Test Protocols</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../testing/index.html">Testing &amp; Quality Assurance</a><input aria-label="Toggle navigation of Testing &amp; Quality Assurance" class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../testing/BROWSER_TESTING_CHECKLIST.html">Browser Testing Checklist - Collapsible Code Blocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/PHASE5_SETUP_COMPLETE.html">Phase 5:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/PHASE6_TEST_EXECUTION_REPORT.html">Phase 6: Automated Browser Testing - Execution Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/README.html">Testing Documentation Index ## Overview testing documentation and analysis for the DIP SMC PSO project. This directory contains organized test reports, workflow documentation, standards, and quality gate specifications. ## Directory Structure ```</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/TESTING_PROCEDURES.html">Collapsible Code Blocks - Testing Procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html">Benchmarking Framework Technical Guide <strong>DIP-SMC-PSO Project</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#benchmarks-integration-numerical-methods-py-class-eulerintegrator-forward-euler-integration-method-first-order-accurate-o-h-def-init-self-dynamics-self-dynamics-dynamics-def-integrate-self-x0-np-ndarray-t-span-tuple-dt-float-controller-optional-any-none-dict-integrate-dynamics-using-forward-euler-parameters-x0-np-ndarray-initial-state-t-span-tuple-t-start-t-end-dt-float-time-step-controller-object-optional-controller-for-closed-loop-simulation-returns-dict-t-time-vector-x-state-history-u-control-history-if-controller-provided-t-start-t-end-t-span-t-np-arange-t-start-t-end-dt-dt-n-steps-len-t-x-np-zeros-n-steps-len-x0-x-0-x0-if-controller-u-np-zeros-n-steps-1-for-i-in-range-n-steps-1-if-controller-result-controller-compute-control-x-i-u-i-result-get-control-output-result-get-control-0-0-x-dot-self-dynamics-dynamics-x-i-u-i-else-x-dot-self-dynamics-dynamics-x-i-0-0-x-i-1-x-i-dt-x-dot-result-t-t-x-x-if-controller-result-u-u-return-result-class-rk4integrator-fourth-order-runge-kutta-integration-fourth-order-accurate-o-h4-def-init-self-dynamics-self-dynamics-dynamics-def-integrate-self-x0-np-ndarray-t-span-tuple-dt-float-controller-optional-any-none-dict-integrate-using-rk4-method-t-start-t-end-t-span-t-np-arange-t-start-t-end-dt-dt-n-steps-len-t-x-np-zeros-n-steps-len-x0-x-0-x0-if-controller-u-np-zeros-n-steps-1-for-i-in-range-n-steps-1-if-controller-result-controller-compute-control-x-i-u-i-result-get-control-output-result-get-control-0-0-u-current-u-i-else-u-current-0-0-rk4-stages-k1-self-dynamics-dynamics-x-i-u-current-k2-self-dynamics-dynamics-x-i-0-5dtk1-u-current-k3-self-dynamics-dynamics-x-i-0-5dtk2-u-current-k4-self-dynamics-dynamics-x-i-dtk3-u-current-x-i-1-x-i-dt-6-k1-2k2-2-k3-k4-result-t-t-x-x-if-controller-result-u-u-return-result-class-adaptiverk45integrator-adaptive-runge-kutta-4-5-method-dormand-prince-variable-step-size-for-error-control-def-init-self-dynamics-self-dynamics-dynamics-def-integrate-self-x0-np-ndarray-t-span-tuple-rtol-float-1e-6-atol-float-1e-9-controller-optional-any-none-dict-integrate-using-adaptive-rk45-from-scipy-integrate-import-solve-ivp-if-controller-def-dynamics-func-t-x-result-controller-compute-control-x-u-result-get-control-output-result-get-control-0-0-return-self-dynamics-dynamics-x-u-else-def-dynamics-func-t-x-return-self-dynamics-dynamics-x-0-0-sol-solve-ivp-dynamics-func-t-span-x0-method-rk45-rtol-rtol-atol-atol-return-t-sol-t-x-sol-y-t">benchmarks/integration/numerical_methods.py class EulerIntegrator: ‚Äú‚Äù‚ÄùForward Euler integration method. First-order accurate: O(h) ‚Äú‚Äù‚Äù def <strong>init</strong>(self, dynamics): self.dynamics = dynamics def integrate(self, x0: np.ndarray, t_span: tuple, dt: float, controller: Optional[Any] = None) -&gt; dict: ‚Äú‚Äù‚ÄùIntegrate dynamics using Forward Euler. Parameters ‚Äî‚Äî‚Äî- x0 : np.ndarray Initial state t_span : tuple (t_start, t_end) dt : float Time step controller : object, optional Controller for closed-loop simulation Returns ‚Äî‚Äî- dict { ‚Äòt‚Äô: time vector, ‚Äòx‚Äô: state history, ‚Äòu‚Äô: control history (if controller provided) } ‚Äú‚Äù‚Äù t_start, t_end = t_span t = np.arange(t_start, t_end + dt, dt) n_steps = len(t) x = np.zeros((n_steps, len(x0))) x[0] = x0 if controller: u = np.zeros(n_steps - 1) for i in range(n_steps - 1): if controller: result = controller.compute_control(x[i], {}, {}) u[i] = result.get(‚Äòcontrol_output‚Äô, result.get(‚Äòcontrol‚Äô, 0.0)) x_dot = self.dynamics.dynamics(x[i], u[i]) else: x_dot = self.dynamics.dynamics(x[i], 0.0) x[i+1] = x[i] + dt * x_dot result = {‚Äòt‚Äô: t, ‚Äòx‚Äô: x} if controller: result[‚Äòu‚Äô] = u return result class RK4Integrator: ‚Äú‚Äù‚ÄùFourth-order Runge-Kutta integration. Fourth-order accurate: O(h‚Å¥) ‚Äú‚Äù‚Äù def <strong>init</strong>(self, dynamics): self.dynamics = dynamics def integrate(self, x0: np.ndarray, t_span: tuple, dt: float, controller: Optional[Any] = None) -&gt; dict: ‚Äú‚Äù‚ÄùIntegrate using RK4 method.‚Äù‚Äù‚Äù t_start, t_end = t_span t = np.arange(t_start, t_end + dt, dt) n_steps = len(t) x = np.zeros((n_steps, len(x0))) x[0] = x0 if controller: u = np.zeros(n_steps - 1) for i in range(n_steps - 1): if controller: result = controller.compute_control(x[i], {}, {}) u[i] = result.get(‚Äòcontrol_output‚Äô, result.get(‚Äòcontrol‚Äô, 0.0)) u_current = u[i] else: u_current = 0.0 # RK4 stages k1 = self.dynamics.dynamics(x[i], u_current) k2 = self.dynamics.dynamics(x[i] + 0.5<em>dt</em>k1, u_current) k3 = self.dynamics.dynamics(x[i] + 0.5<em>dt</em>k2, u_current) k4 = self.dynamics.dynamics(x[i] + dt<em>k3, u_current) x[i+1] = x[i] + (dt/6) * (k1 + 2</em>k2 + 2*k3 + k4) result = {‚Äòt‚Äô: t, ‚Äòx‚Äô: x} if controller: result[‚Äòu‚Äô] = u return result class AdaptiveRK45Integrator: ‚Äú‚Äù‚ÄùAdaptive Runge-Kutta 4-5 method (Dormand-Prince). Variable step size for error control. ‚Äú‚Äù‚Äù def <strong>init</strong>(self, dynamics): self.dynamics = dynamics def integrate(self, x0: np.ndarray, t_span: tuple, rtol: float = 1e-6, atol: float = 1e-9, controller: Optional[Any] = None) -&gt; dict: ‚Äú‚Äù‚ÄùIntegrate using adaptive RK45.‚Äù‚Äù‚Äù from scipy.integrate import solve_ivp if controller: def dynamics_func(t, x): result = controller.compute_control(x, {}, {}) u = result.get(‚Äòcontrol_output‚Äô, result.get(‚Äòcontrol‚Äô, 0.0)) return self.dynamics.dynamics(x, u) else: def dynamics_func(t, x): return self.dynamics.dynamics(x, 0.0) sol = solve_ivp( dynamics_func, t_span, x0, method=‚ÄôRK45‚Äô, rtol=rtol, atol=atol ) return { ‚Äòt‚Äô: sol.t, ‚Äòx‚Äô: sol.y.T }</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#runnable-false-benchmarks-analysis-accuracy-metrics-py-def-compute-energy-conservation-t-np-ndarray-x-np-ndarray-physics-params-dict-dict-analyze-energy-conservation-for-hamiltonian-systems-parameters-t-np-ndarray-time-vector-x-np-ndarray-state-trajectories-physics-params-dict-physics-parameters-returns-dict-initial-energy-float-final-energy-float-max-drift-float-relative-drift-float-def-compute-energy-state-kinetic-energy-x-dot-theta1-dot-theta2-dot-state-3-state-4-state-5-ke-0-5-physics-params-m-x-dot-2-cart-pendulum-kinetic-energy-potential-energy-theta1-theta2-state-1-state-2-pe-physics-params-m1-physics-params-g-physics-params-l1-1-np-cos-theta1-second-pendulum-pe-return-ke-pe-energies-np-array-compute-energy-state-for-state-in-x-initial-energy-energies-0-final-energy-energies-1-max-drift-np-max-np-abs-energies-initial-energy-relative-drift-max-drift-initial-energy-if-initial-energy-0-else-np-inf-return-initial-energy-float-initial-energy-final-energy-float-final-energy-max-drift-float-max-drift-relative-drift-float-relative-drift-energies-energies-def-estimate-convergence-order-integrator-x0-np-ndarray-t-span-tuple-dt-values-list-float-dict-estimate-numerical-convergence-order-uses-richardson-extrapolation-to-estimate-p-in-e-h-ch-p-parameters-integrator-object-integration-method-instance-x0-np-ndarray-initial-state-t-span-tuple-time-span-dt-values-list-of-float-decreasing-time-steps-for-convergence-analysis-returns-dict-convergence-order-float-errors-list-of-float-dt-values-list-of-float-get-reference-solution-finest-dt-ref-dt-min-dt-values-4-ref-result-integrator-integrate-x0-t-span-ref-dt-ref-x-final-ref-result-x-1-errors-for-dt-in-dt-values-result-integrator-integrate-x0-t-span-dt-x-final-result-x-1-error-np-linalg-norm-x-final-ref-x-final-errors-append-error-estimate-convergence-order-p-log-e-h1-e-h2-log-h1-h2-orders-for-i-in-range-len-errors-1-if-errors-i-1-0-order-np-log-errors-i-errors-i-1-np-log-dt-values-i-dt-values-i-1-orders-append-order-avg-order-np-mean-orders-if-orders-else-np-nan-return-convergence-order-float-avg-order-errors-float-e-for-e-in-errors-dt-values-dt-values">runnable: false # benchmarks/analysis/accuracy_metrics.py def compute_energy_conservation(t: np.ndarray, x: np.ndarray, physics_params: dict) -&gt; dict: ‚Äú‚Äù‚ÄùAnalyze energy conservation for Hamiltonian systems. Parameters ‚Äî‚Äî‚Äî- t : np.ndarray Time vector x : np.ndarray State trajectories physics_params : dict Physics parameters Returns ‚Äî‚Äî- dict { ‚Äòinitial_energy‚Äô: float, ‚Äòfinal_energy‚Äô: float, ‚Äòmax_drift‚Äô: float, ‚Äòrelative_drift‚Äô: float } ‚Äú‚Äù‚Äù def compute_energy(state): # Kinetic energy x_dot, theta1_dot, theta2_dot = state[3], state[4], state[5] KE = 0.5 * physics_params[‚ÄòM‚Äô] * x_dot**2 # Cart # ‚Ä¶ (pendulum kinetic energy) # Potential energy theta1, theta2 = state[1], state[2] PE = physics_params[‚Äòm1‚Äô] * physics_params[‚Äòg‚Äô] * physics_params[‚ÄòL1‚Äô] * (1 - np.cos(theta1)) # ‚Ä¶ (second pendulum PE) return KE + PE energies = np.array([compute_energy(state) for state in x]) initial_energy = energies[0] final_energy = energies[-1] max_drift = np.max(np.abs(energies - initial_energy)) relative_drift = max_drift / initial_energy if initial_energy != 0 else np.inf return { ‚Äòinitial_energy‚Äô: float(initial_energy), ‚Äòfinal_energy‚Äô: float(final_energy), ‚Äòmax_drift‚Äô: float(max_drift), ‚Äòrelative_drift‚Äô: float(relative_drift), ‚Äòenergies‚Äô: energies } def estimate_convergence_order(integrator, x0: np.ndarray, t_span: tuple, dt_values: List[float]) -&gt; dict: ‚Äú‚Äù‚ÄùEstimate numerical convergence order. Uses Richardson extrapolation to estimate p in: e_h = C¬∑h^p Parameters ‚Äî‚Äî‚Äî- integrator : object Integration method instance x0 : np.ndarray Initial state t_span : tuple Time span dt_values : list of float Decreasing time steps for convergence analysis Returns ‚Äî‚Äî- dict { ‚Äòconvergence_order‚Äô: float, ‚Äòerrors‚Äô: list of float, ‚Äòdt_values‚Äô: list of float } ‚Äú‚Äù‚Äù # Get reference solution (finest dt) ref_dt = min(dt_values) / 4 ref_result = integrator.integrate(x0, t_span, ref_dt) ref_x_final = ref_result[‚Äòx‚Äô][-1] errors = [] for dt in dt_values: result = integrator.integrate(x0, t_span, dt) x_final = result[‚Äòx‚Äô][-1] error = np.linalg.norm(x_final - ref_x_final) errors.append(error) # Estimate convergence order: p = log(e_h1/e_h2) / log(h1/h2) orders = [] for i in range(len(errors) - 1): if errors[i+1] &gt; 0: order = np.log(errors[i] / errors[i+1]) / np.log(dt_values[i] / dt_values[i+1]) orders.append(order) avg_order = np.mean(orders) if orders else np.nan return { ‚Äòconvergence_order‚Äô: float(avg_order), ‚Äòerrors‚Äô: [float(e) for e in errors], ‚Äòdt_values‚Äô: dt_values }</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#benchmarks-comparison-method-comparison-py-class-integrationmethodcomparator-systematic-comparison-of-integration-methods-def-init-self-dynamics-physics-params-dict-self-dynamics-dynamics-self-physics-params-physics-params-def-compare-methods-self-methods-list-str-x0-np-ndarray-t-span-tuple-dt-values-list-float-dict-compare-multiple-integration-methods-parameters-methods-list-of-str-method-names-euler-rk4-rk45-x0-np-ndarray-initial-state-t-span-tuple-time-span-dt-values-list-of-float-time-steps-to-test-returns-dict-comparison-results-for-all-methods-from-benchmarks-integration-import-eulerintegrator-rk4integrator-adaptiverk45integrator-from-benchmarks-analysis-import-compute-energy-conservation-estimate-convergence-order-integrators-euler-eulerintegrator-self-dynamics-rk4-rk4integrator-self-dynamics-rk45-adaptiverk45integrator-self-dynamics-results-for-method-name-in-methods-integrator-integrators-method-name-convergence-analysis-convergence-estimate-convergence-order-integrator-x0-t-span-dt-values-energy-conservation-for-frictionless-system-result-integrator-integrate-x0-t-span-dt-min-dt-values-energy-analysis-compute-energy-conservation-result-t-result-x-self-physics-params-performance-measurement-import-time-start-time-time-integrator-integrate-x0-t-span-dt-min-dt-values-elapsed-time-time-start-results-method-name-convergence-order-convergence-convergence-order-energy-drift-energy-analysis-relative-drift-computation-time-elapsed-errors-convergence-errors-return-results">benchmarks/comparison/method_comparison.py class IntegrationMethodComparator: ‚Äú‚Äù‚ÄùSystematic comparison of integration methods.‚Äù‚Äù‚Äù def <strong>init</strong>(self, dynamics, physics_params: dict): self.dynamics = dynamics self.physics_params = physics_params def compare_methods(self, methods: List[str], x0: np.ndarray, t_span: tuple, dt_values: List[float]) -&gt; dict: ‚Äú‚Äù‚ÄùCompare multiple integration methods. Parameters ‚Äî‚Äî‚Äî- methods : list of str Method names: [‚ÄòEuler‚Äô, ‚ÄòRK4‚Äô, ‚ÄòRK45‚Äô] x0 : np.ndarray Initial state t_span : tuple Time span dt_values : list of float Time steps to test Returns ‚Äî‚Äî- dict Comparison results for all methods ‚Äú‚Äù‚Äù from benchmarks.integration import EulerIntegrator, RK4Integrator, AdaptiveRK45Integrator from benchmarks.analysis import compute_energy_conservation, estimate_convergence_order integrators = { ‚ÄòEuler‚Äô: EulerIntegrator(self.dynamics), ‚ÄòRK4‚Äô: RK4Integrator(self.dynamics), ‚ÄòRK45‚Äô: AdaptiveRK45Integrator(self.dynamics) } results = {} for method_name in methods: integrator = integrators[method_name] # Convergence analysis convergence = estimate_convergence_order(integrator, x0, t_span, dt_values) # Energy conservation (for frictionless system) result = integrator.integrate(x0, t_span, dt=min(dt_values)) energy_analysis = compute_energy_conservation( result[‚Äòt‚Äô], result[‚Äòx‚Äô], self.physics_params ) # Performance measurement import time start = time.time() _ = integrator.integrate(x0, t_span, dt=min(dt_values)) elapsed = time.time() - start results[method_name] = { ‚Äòconvergence_order‚Äô: convergence[‚Äòconvergence_order‚Äô], ‚Äòenergy_drift‚Äô: energy_analysis[‚Äòrelative_drift‚Äô], ‚Äòcomputation_time‚Äô: elapsed, ‚Äòerrors‚Äô: convergence[‚Äòerrors‚Äô] } return results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#config-yaml-benchmark-configuration-benchmarks-statistical-n-trials-30-clt-compliance-confidence-level-0-95-95-ci-seed-42-reproducibility-physics-uncertainty-enabled-true-n-scenarios-10-variations-cart-mass-0-05-5-pendulum1-mass-0-10-10-pendulum2-mass-0-10-10-pendulum1-length-0-05-5-pendulum2-length-0-05-5-friction-cart-0-20-20-sensor-noise-enabled-false-std-position-0-001-1mm-std-angle-0-001-0-06-integration-methods-euler-rk4-rk45-dt-values-0-05-0-01-0-005-0-001-convergence-analysis-true-energy-conservation-check-true-performance-regression-threshold-0-05-5-slowdown-alert-baseline-file-benchmarks-baseline-json">config.yaml - Benchmark configuration benchmarks: statistical: n_trials: 30 # CLT compliance confidence_level: 0.95 # 95% CI seed: 42 # Reproducibility physics_uncertainty: enabled: true n_scenarios: 10 variations: cart_mass: 0.05 # ¬±5% pendulum1_mass: 0.10 # ¬±10% pendulum2_mass: 0.10 # ¬±10% pendulum1_length: 0.05 # ¬±5% pendulum2_length: 0.05 # ¬±5% friction_cart: 0.20 # ¬±20% sensor_noise: enabled: false std_position: 0.001 # 1mm std_angle: 0.001 # ~0.06¬∞ integration: methods: [‚ÄòEuler‚Äô, ‚ÄòRK4‚Äô, ‚ÄòRK45‚Äô] dt_values: [0.05, 0.01, 0.005, 0.001] convergence_analysis: true energy_conservation_check: true performance: regression_threshold: 0.05 # 5% slowdown alert baseline_file: ‚Äòbenchmarks/baseline.json‚Äô</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/code_collapse_validation_report.html">Code Collapse Feature - Validation Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html">Testing Framework Technical Guide <strong>DIP-SMC-PSO Project</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#tests-conftest-py">tests/conftest.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#id1">tests/conftest.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#tests-conftest-py-top-of-file-before-any-imports">tests/conftest.py (top of file, before any imports)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#id2">tests/conftest.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#install-pytest-xdist-for-parallel-execution">Install pytest-xdist for parallel execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#run-all-tests">Run all tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#generate-html-coverage-report">Generate HTML coverage report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#open-coverage-html-report-index-html-generate-terminal-coverage-report">Open coverage_html_report/index.html # Generate terminal coverage report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#test-specific-class">Test specific class</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_framework_technical_guide.html#drop-into-debugger-on-failure">Drop into debugger on failure</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html">Testing Workflows &amp; Best Practices <strong>DIP-SMC-PSO Project</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#runnable-false-step-1-red-write-failing-test">runnable: false # Step 1: RED - Write failing test</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#tests-test-controllers-smc-algorithms-classical-test-new-feature-py-def-test-chattering-reduction-effectiveness-test-that-chattering-reduction-algorithm-reduces-control-rate-controller-classicalsmc-gains-10-8-15-12-50-5-max-force-100-boundary-layer-0-01-chattering-reduction-true-new-feature-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-control-history-for-in-range-100-result-controller-compute-control-state-control-result-control-control-history-append-control-calculate-control-rate-control-rate-np-std-np-diff-control-history-should-be-significantly-lower-than-baseline-assert-control-rate-5-0-f-chattering-reduction-ineffective-rate-control-rate-run-test-fails-feature-not-implemented">tests/test_controllers/smc/algorithms/classical/test_new_feature.py def test_chattering_reduction_effectiveness(): ‚Äú‚Äù‚ÄùTest that chattering reduction algorithm reduces control rate.‚Äù‚Äù‚Äù controller = ClassicalSMC( gains=[10, 8, 15, 12, 50, 5], max_force=100, boundary_layer=0.01, chattering_reduction=True # New feature ) state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) control_history = [] for _ in range(100): result = controller.compute_control(state, {}, {}) control = result[‚Äòcontrol‚Äô] control_history.append(control) # Calculate control rate control_rate = np.std(np.diff(control_history)) # Should be significantly lower than baseline assert control_rate &lt; 5.0, f‚ÄùChattering reduction ineffective: rate={control_rate}‚Äù # Run test ‚Üí FAILS (feature not implemented)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#pytest-tests-test-controllers-smc-algorithms-classical-test-new-feature-py-v">pytest tests/test_controllers/smc/algorithms/classical/test_new_feature.py -v</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#runnable-false-step-2-green-implement-minimal-code-to-pass">runnable: false # Step 2: GREEN - Implement minimal code to pass</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#src-controllers-smc-classic-smc-py-class-classicalsmc-def-init-self-gains-max-force-boundary-layer-0-01-chattering-reduction-false-self-gains-gains-self-max-force-max-force-self-boundary-layer-boundary-layer-self-chattering-reduction-chattering-reduction-self-last-control-0-0-def-compute-control-self-state-state-vars-history-existing-smc-logic-control-u-eq-u-switch-u-derivative-if-self-chattering-reduction-simple-low-pass-filter-alpha-0-8-control-alpha-self-last-control-1-alpha-control-self-last-control-control-saturation-control-np-clip-control-self-max-force-self-max-force-return-control-control-run-test-passes">src/controllers/smc/classic_smc.py class ClassicalSMC: def <strong>init</strong>(self, gains, max_force, boundary_layer=0.01, chattering_reduction=False): self.gains = gains self.max_force = max_force self.boundary_layer = boundary_layer self.chattering_reduction = chattering_reduction self.last_control = 0.0 def compute_control(self, state, state_vars, history): # ‚Ä¶ existing SMC logic ‚Ä¶ control = u_eq + u_switch + u_derivative if self.chattering_reduction: # Simple low-pass filter alpha = 0.8 control = alpha * self.last_control + (1 - alpha) * control self.last_control = control # Saturation control = np.clip(control, -self.max_force, self.max_force) return {‚Äòcontrol‚Äô: control} # Run test ‚Üí PASSES</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#runnable-false-step-3-refactor-clean-up-implementation">runnable: false # Step 3: REFACTOR - Clean up implementation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#run-full-test-suite-all-pass">Run full test suite ‚Üí ALL PASS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#runnable-false-step-1-write-interface-tests-first">runnable: false # Step 1: Write interface tests FIRST</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#tests-test-controllers-smc-algorithms-adaptive-sta-test-adaptive-sta-interface-py-class-testadaptivestainterface-test-interface-compliance-for-adaptive-sta-smc-def-test-implements-controller-protocol-self-test-controller-implements-required-protocol-from-src-controllers-interfaces-import-controllerprotocol-controller-adaptivestasmc-gains-20-15-12-10-max-force-100-adaptation-rate-0-5-assert-isinstance-controller-controllerprotocol-assert-hasattr-controller-compute-control-assert-callable-controller-compute-control-def-test-compute-control-signature-self-test-compute-control-has-correct-signature-controller-adaptivestasmc-gains-20-15-12-10-max-force-100-state-np-zeros-6-result-controller-compute-control-state-assert-isinstance-result-dict-assert-control-in-result-assert-isinstance-result-control-int-float-np-ndarray-step-2-write-functionality-tests">tests/test_controllers/smc/algorithms/adaptive_sta/test_adaptive_sta_interface.py class TestAdaptiveSTAInterface: ‚Äú‚Äù‚ÄùTest interface compliance for Adaptive STA SMC.‚Äù‚Äù‚Äù def test_implements_controller_protocol(self): ‚Äú‚Äù‚ÄùTest controller implements required protocol.‚Äù‚Äù‚Äù from src.controllers.interfaces import ControllerProtocol controller = AdaptiveSTASMC( gains=[20, 15, 12, 10], max_force=100, adaptation_rate=0.5 ) assert isinstance(controller, ControllerProtocol) assert hasattr(controller, ‚Äòcompute_control‚Äô) assert callable(controller.compute_control) def test_compute_control_signature(self): ‚Äú‚Äù‚ÄùTest compute_control has correct signature.‚Äù‚Äù‚Äù controller = AdaptiveSTASMC(gains=[20,15,12,10], max_force=100) state = np.zeros(6) result = controller.compute_control(state, {}, {}) assert isinstance(result, dict) assert ‚Äòcontrol‚Äô in result assert isinstance(result[‚Äòcontrol‚Äô], (int, float, np.ndarray)) # Step 2: Write functionality tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#src-controllers-smc-algorithms-adaptive-sta-adaptive-sta-smc-py-class-adaptivestasmc-adaptive-super-twisting-sliding-mode-controller-def-init-self-gains-max-force-adaptation-rate-0-5-self-initial-gains-np-array-gains-self-current-gains-self-initial-gains-copy-self-max-force-max-force-self-adaptation-rate-adaptation-rate-def-compute-control-self-state-state-vars-history-super-twisting-control-logic-adaptive-gain-update-return-control-control-def-get-current-gains-self-return-self-current-gains-copy">src/controllers/smc/algorithms/adaptive_sta/adaptive_sta_smc.py class AdaptiveSTASMC: ‚Äú‚Äù‚ÄùAdaptive Super-Twisting Sliding Mode Controller.‚Äù‚Äù‚Äù def <strong>init</strong>(self, gains, max_force, adaptation_rate=0.5): self.initial_gains = np.array(gains) self.current_gains = self.initial_gains.copy() self.max_force = max_force self.adaptation_rate = adaptation_rate def compute_control(self, state, state_vars, history): # ‚Ä¶ Super-twisting control logic ‚Ä¶ # ‚Ä¶ Adaptive gain update ‚Ä¶ return {‚Äòcontrol‚Äô: control} def get_current_gains(self): return self.current_gains.copy()</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#level-1-component-level-tests">Level 1: Component-level tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#run-specific-failing-test-with-maximum-verbosity">1. Run specific failing test with maximum verbosity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#tests-test-property-based-debug-py">tests/test_property_based_debug.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#reproduce-failure-6-82-0-b-aaaa-to-reproduce">@reproduce_failure(‚Äò6.82.0‚Äô, b‚ÄôAAAA‚Ä¶‚Äô) to reproduce</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#quick-test-while-developing">Quick test while developing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#full-validation-checklist">Full validation checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#by-marker">By marker</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/testing_workflows_best_practices.html#auto-detect-cpu-cores">Auto-detect CPU cores</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/validation_methodology_guide.html">Validation Methodology Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html">Control Systems Unit Testing Guide ## Overview This guide provides testing patterns for sliding mode control (SMC) implementations in the double-inverted pendulum control system. It covers state space validation, controller interface compliance, optimal gains interpretation, and production-ready testing methodologies. ## Table of Contents 1. SMC Controller Testing Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#runnable-false-def-test-classical-smc-initialization-test-classical-smc-initialization-with-valid-parameters-optimal-gains-from-pso-optimization-report-log-line-2-gains-77-62-44-45-17-31-14-25-18-66-9-76-boundary-layer-9-76-matched-to-kd-for-chattering-reduction-max-force-20-0-controller-classicalsmc-gains-gains-max-force-max-force-boundary-layer-boundary-layer-switch-method-tanh-verify-gains-unpacked-correctly-assert-controller-k1-pytest-approx-77-62-rel-1e-6-assert-controller-k2-pytest-approx-44-45-rel-1e-6-assert-controller-lam1-pytest-approx-17-31-rel-1e-6-assert-controller-lam2-pytest-approx-14-25-rel-1e-6-assert-controller-k-pytest-approx-18-66-rel-1e-6-assert-controller-kd-pytest-approx-9-76-rel-1e-6-verify-boundary-layer-for-chattering-reduction-assert-controller-epsilon0-pytest-approx-9-76-verify-control-authority-limits-assert-controller-max-force-20-0">runnable: false def test_classical_smc_initialization(): ‚Äú‚Äù‚ÄùTest Classical SMC initialization with valid parameters.‚Äù‚Äù‚Äù # Optimal gains from PSO optimization (report.log line 2) gains = [77.62, 44.45, 17.31, 14.25, 18.66, 9.76] boundary_layer = 9.76 # Matched to kd for chattering reduction max_force = 20.0 controller = ClassicalSMC( gains=gains, max_force=max_force, boundary_layer=boundary_layer, switch_method=‚Äôtanh‚Äô ) # Verify gains unpacked correctly assert controller.k1 == pytest.approx(77.62, rel=1e-6) assert controller.k2 == pytest.approx(44.45, rel=1e-6) assert controller.lam1 == pytest.approx(17.31, rel=1e-6) assert controller.lam2 == pytest.approx(14.25, rel=1e-6) assert controller.K == pytest.approx(18.66, rel=1e-6) assert controller.kd == pytest.approx(9.76, rel=1e-6) # Verify boundary layer for chattering reduction assert controller.epsilon0 == pytest.approx(9.76) # Verify control authority limits assert controller.max_force == 20.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#runnable-false-def-test-lyapunov-decrease-property-test-lyapunov-decrease-property-v-0-when-0-controller-create-test-controller-test-states-with-non-zero-sliding-surface-values-test-states-np-array-0-0-0-1-0-0-0-0-0-0-0-0-pendulum-1-displaced-np-array-0-0-0-0-0-1-0-0-0-0-0-0-pendulum-2-displaced-np-array-0-0-0-05-0-05-0-0-0-1-0-1-both-displaced-with-velocity-history-for-state-in-test-states-result-controller-compute-control-state-history-extract-sliding-surface-from-history-assert-sigma-in-history-sigma-history-sigma-1-lyapunov-function-v-0-5-sigma-2-v-0-5-sigma-2-for-non-zero-sigma-ensure-control-acts-to-reduce-v-if-abs-sigma-1e-6-control-should-oppose-sigma-to-drive-v-0-for-classical-smc-u-u-eq-ksat-kd-the-robust-term-k-sat-should-have-opposite-sign-to">runnable: false def test_lyapunov_decrease_property(): ‚Äú‚Äù‚ÄùTest Lyapunov decrease property: VÃá &lt; 0 when |œÉ| &gt; 0.‚Äù‚Äù‚Äù controller = create_test_controller() # Test states with non-zero sliding surface values test_states = [ np.array([0.0, 0.1, 0.0, 0.0, 0.0, 0.0]), # Pendulum 1 displaced np.array([0.0, 0.0, 0.1, 0.0, 0.0, 0.0]), # Pendulum 2 displaced np.array([0.0, 0.05, 0.05, 0.0, 0.1, 0.1]), # Both displaced with velocity ] history = {} for state in test_states: result = controller.compute_control(state, (), history) # Extract sliding surface from history assert ‚Äòsigma‚Äô in history sigma = history[‚Äòsigma‚Äô][-1] # Lyapunov function V = 0.5 * sigma^2 V = 0.5 * sigma**2 # For non-zero sigma, ensure control acts to reduce V if abs(sigma) &gt; 1e-6: # Control should oppose sigma to drive VÃá &lt; 0 # For classical SMC: u = u_eq - K<em>sat(œÉ/Œµ) - kd</em>œÉ # The robust term -K*sat(œÉ/Œµ) should have opposite sign to œÉ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#id2">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#runnable-false-def-test-controller-interface-compliance-test-compliance-with-basecontroller-interface-controller-create-test-controller-test-required-properties-assert-hasattr-controller-gains-must-expose-gains-property-assert-hasattr-controller-n-gains-must-declare-n-gains-for-pso-assert-controller-n-gains-6-classical-smc-requires-6-gains-test-required-methods-assert-hasattr-controller-compute-control-must-implement-compute-control-assert-hasattr-controller-reset-must-implement-reset-assert-hasattr-controller-initialize-state-must-implement-initialize-state-assert-hasattr-controller-initialize-history-must-implement-initialize-history-test-gains-property-returns-copy-gains1-controller-gains-gains2-controller-gains-assert-gains1-gains2-gains-should-be-consistent-gains1-0-999-0-try-to-mutate-assert-controller-gains-0-999-0-gains-property-should-return-copy">runnable: false def test_controller_interface_compliance(): ‚Äú‚Äù‚ÄùTest compliance with BaseController interface.‚Äù‚Äù‚Äù controller = create_test_controller() # Test required properties assert hasattr(controller, ‚Äògains‚Äô), ‚ÄúMust expose gains property‚Äù assert hasattr(controller, ‚Äòn_gains‚Äô), ‚ÄúMust declare n_gains for PSO‚Äù assert controller.n_gains == 6, ‚ÄúClassical SMC requires 6 gains‚Äù # Test required methods assert hasattr(controller, ‚Äòcompute_control‚Äô), ‚ÄúMust implement compute_control‚Äù assert hasattr(controller, ‚Äòreset‚Äô), ‚ÄúMust implement reset‚Äù assert hasattr(controller, ‚Äòinitialize_state‚Äô), ‚ÄúMust implement initialize_state‚Äù assert hasattr(controller, ‚Äòinitialize_history‚Äô), ‚ÄúMust implement initialize_history‚Äù # Test gains property returns copy gains1 = controller.gains gains2 = controller.gains assert gains1 == gains2, ‚ÄúGains should be consistent‚Äù gains1[0] = 999.0 # Try to mutate assert controller.gains[0] != 999.0, ‚ÄúGains property should return copy‚Äù</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#id3">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#runnable-false-def-test-history-telemetry-test-that-controller-properly-tracks-telemetry-in-history-controller-create-test-controller-state-np-array-0-1-0-2-0-1-0-0-0-3-0-2-history-result-controller-compute-control-state-history-verify-all-required-telemetry-is-tracked-required-keys-sigma-epsilon-eff-u-eq-u-robust-u-total-u-for-key-in-required-keys-assert-key-in-history-f-missing-required-history-key-key-assert-len-history-key-1-f-history-key-key-should-have-1-entry-run-multiple-steps-and-verify-accumulation-for-in-range-5-controller-compute-control-state-history-for-key-in-required-keys-assert-len-history-key-6-f-history-key-key-should-accumulate-expected-6-got-len-history-key">runnable: false def test_history_telemetry(): ‚Äú‚Äù‚ÄùTest that controller properly tracks telemetry in history.‚Äù‚Äù‚Äù controller = create_test_controller() state = np.array([0.1, 0.2, -0.1, 0.0, 0.3, -0.2]) history = {} result = controller.compute_control(state, (), history) # Verify all required telemetry is tracked required_keys = [‚Äòsigma‚Äô, ‚Äòepsilon_eff‚Äô, ‚Äòu_eq‚Äô, ‚Äòu_robust‚Äô, ‚Äòu_total‚Äô, ‚Äòu‚Äô] for key in required_keys: assert key in history, f‚ÄùMissing required history key: {key}‚Äù assert len(history[key]) == 1, f‚ÄùHistory key {key} should have 1 entry‚Äù # Run multiple steps and verify accumulation for _ in range(5): controller.compute_control(state, (), history) for key in required_keys: assert len(history[key]) == 6, \ f‚ÄùHistory key {key} should accumulate (expected 6, got {len(history[key])})‚Äù</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#id4">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/control_systems_unit_testing.html#runnable-false-def-create-test-controller-create-controller-with-optimal-gains-for-testing-optimal-gains-77-62-44-45-17-31-14-25-18-66-9-76-return-classicalsmc-gains-optimal-gains-max-force-20-0-boundary-layer-9-76-switch-method-tanh-regularization-1e-10">runnable: false def create_test_controller(): ‚Äú‚Äù‚ÄùCreate controller with optimal gains for testing.‚Äù‚Äù‚Äù optimal_gains = [77.62, 44.45, 17.31, 14.25, 18.66, 9.76] return ClassicalSMC( gains=optimal_gains, max_force=20.0, boundary_layer=9.76, switch_method=‚Äôtanh‚Äô, regularization=1e-10 )</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/test_infrastructure_guide.html">Test Infrastructure Guide ## Overview This document provides guidance for the DIP SMC PSO test infrastructure, including pytest configuration, test execution procedures, and troubleshooting guidelines. ## Pytest Configuration ### Test Markers The project uses an extensive set of pytest markers for test categorization: #### Core Test Categories</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/test_infrastructure_guide.html#run-all-tests">Run all tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/test_infrastructure_guide.html#parallel-execution-if-pytest-xdist-installed">Parallel execution (if pytest-xdist installed)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/property_based_testing.html">Property-Based Testing for Control Systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/integration_workflows.html">Integration Testing Workflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/performance_benchmarking.html">Performance Benchmarking Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/coverage_quality_gates_runbook.html">Coverage Quality Gates Runbook</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/coverage_quality_gates_troubleshooting.html">Coverage Quality Gates Troubleshooting Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/coverage_quality_gates_troubleshooting.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/coverage_quality_gates_troubleshooting.html#runnable-false-def-calculate-coverage-production-score-gate-results-calculate-coverage-contribution-to-overall-production-readiness-score-current-production-readiness-6-1-10-target-production-readiness-8-5-10-coverage-weight-25-of-total-score-weights-infrastructure-health-0-15-safety-critical-coverage-0-40-highest-weight-critical-components-coverage-0-25-overall-coverage-0-20-coverage-score-0-0-for-gate-id-weight-in-weights-items-if-gate-results-get-gate-id-get-status-passed-coverage-score-weight-scale-to-0-10-production-contribution-coverage-score-10-return-coverage-production-score-production-contribution-production-ready-production-contribution-8-0-improvement-needed-max-0-8-0-production-contribution">runnable: false def calculate_coverage_production_score(gate_results): ‚Äú‚Äù‚Äù Calculate coverage contribution to overall production readiness score. Current Production Readiness: 6.1/10 Target Production Readiness: 8.5/10 Coverage Weight: 25% of total score ‚Äú‚Äù‚Äù weights = { ‚Äòinfrastructure_health‚Äô: 0.15, ‚Äòsafety_critical_coverage‚Äô: 0.40, # Highest weight ‚Äòcritical_components_coverage‚Äô: 0.25, ‚Äòoverall_coverage‚Äô: 0.20 } coverage_score = 0.0 for gate_id, weight in weights.items(): if gate_results.get(gate_id, {}).get(‚Äòstatus‚Äô) == ‚Äòpassed‚Äô: coverage_score += weight # Scale to 0-10 production_contribution = coverage_score * 10 return { ‚Äòcoverage_production_score‚Äô: production_contribution, ‚Äòproduction_ready‚Äô: production_contribution &gt;= 8.0, ‚Äòimprovement_needed‚Äô: max(0, 8.0 - production_contribution) }</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/coverage_local_development_guide.html">Coverage Local Development Integration Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/coverage_integration_summary.html">Coverage Quality Gates Integration Summary</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/coverage_baseline.html">Coverage Baseline Report <strong>Generated:</strong> 2025-10-05</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/integration_workflows.html">Integration Testing Workflows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/guides/performance_benchmarking.html">Performance Benchmarking Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html">Benchmarking Framework Technical Guide <strong>DIP-SMC-PSO Project</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#benchmarks-integration-numerical-methods-py-class-eulerintegrator-forward-euler-integration-method-first-order-accurate-o-h-def-init-self-dynamics-self-dynamics-dynamics-def-integrate-self-x0-np-ndarray-t-span-tuple-dt-float-controller-optional-any-none-dict-integrate-dynamics-using-forward-euler-parameters-x0-np-ndarray-initial-state-t-span-tuple-t-start-t-end-dt-float-time-step-controller-object-optional-controller-for-closed-loop-simulation-returns-dict-t-time-vector-x-state-history-u-control-history-if-controller-provided-t-start-t-end-t-span-t-np-arange-t-start-t-end-dt-dt-n-steps-len-t-x-np-zeros-n-steps-len-x0-x-0-x0-if-controller-u-np-zeros-n-steps-1-for-i-in-range-n-steps-1-if-controller-result-controller-compute-control-x-i-u-i-result-get-control-output-result-get-control-0-0-x-dot-self-dynamics-dynamics-x-i-u-i-else-x-dot-self-dynamics-dynamics-x-i-0-0-x-i-1-x-i-dt-x-dot-result-t-t-x-x-if-controller-result-u-u-return-result-class-rk4integrator-fourth-order-runge-kutta-integration-fourth-order-accurate-o-h4-def-init-self-dynamics-self-dynamics-dynamics-def-integrate-self-x0-np-ndarray-t-span-tuple-dt-float-controller-optional-any-none-dict-integrate-using-rk4-method-t-start-t-end-t-span-t-np-arange-t-start-t-end-dt-dt-n-steps-len-t-x-np-zeros-n-steps-len-x0-x-0-x0-if-controller-u-np-zeros-n-steps-1-for-i-in-range-n-steps-1-if-controller-result-controller-compute-control-x-i-u-i-result-get-control-output-result-get-control-0-0-u-current-u-i-else-u-current-0-0-rk4-stages-k1-self-dynamics-dynamics-x-i-u-current-k2-self-dynamics-dynamics-x-i-0-5dtk1-u-current-k3-self-dynamics-dynamics-x-i-0-5dtk2-u-current-k4-self-dynamics-dynamics-x-i-dtk3-u-current-x-i-1-x-i-dt-6-k1-2k2-2-k3-k4-result-t-t-x-x-if-controller-result-u-u-return-result-class-adaptiverk45integrator-adaptive-runge-kutta-4-5-method-dormand-prince-variable-step-size-for-error-control-def-init-self-dynamics-self-dynamics-dynamics-def-integrate-self-x0-np-ndarray-t-span-tuple-rtol-float-1e-6-atol-float-1e-9-controller-optional-any-none-dict-integrate-using-adaptive-rk45-from-scipy-integrate-import-solve-ivp-if-controller-def-dynamics-func-t-x-result-controller-compute-control-x-u-result-get-control-output-result-get-control-0-0-return-self-dynamics-dynamics-x-u-else-def-dynamics-func-t-x-return-self-dynamics-dynamics-x-0-0-sol-solve-ivp-dynamics-func-t-span-x0-method-rk45-rtol-rtol-atol-atol-return-t-sol-t-x-sol-y-t">benchmarks/integration/numerical_methods.py class EulerIntegrator: ‚Äú‚Äù‚ÄùForward Euler integration method. First-order accurate: O(h) ‚Äú‚Äù‚Äù def <strong>init</strong>(self, dynamics): self.dynamics = dynamics def integrate(self, x0: np.ndarray, t_span: tuple, dt: float, controller: Optional[Any] = None) -&gt; dict: ‚Äú‚Äù‚ÄùIntegrate dynamics using Forward Euler. Parameters ‚Äî‚Äî‚Äî- x0 : np.ndarray Initial state t_span : tuple (t_start, t_end) dt : float Time step controller : object, optional Controller for closed-loop simulation Returns ‚Äî‚Äî- dict { ‚Äòt‚Äô: time vector, ‚Äòx‚Äô: state history, ‚Äòu‚Äô: control history (if controller provided) } ‚Äú‚Äù‚Äù t_start, t_end = t_span t = np.arange(t_start, t_end + dt, dt) n_steps = len(t) x = np.zeros((n_steps, len(x0))) x[0] = x0 if controller: u = np.zeros(n_steps - 1) for i in range(n_steps - 1): if controller: result = controller.compute_control(x[i], {}, {}) u[i] = result.get(‚Äòcontrol_output‚Äô, result.get(‚Äòcontrol‚Äô, 0.0)) x_dot = self.dynamics.dynamics(x[i], u[i]) else: x_dot = self.dynamics.dynamics(x[i], 0.0) x[i+1] = x[i] + dt * x_dot result = {‚Äòt‚Äô: t, ‚Äòx‚Äô: x} if controller: result[‚Äòu‚Äô] = u return result class RK4Integrator: ‚Äú‚Äù‚ÄùFourth-order Runge-Kutta integration. Fourth-order accurate: O(h‚Å¥) ‚Äú‚Äù‚Äù def <strong>init</strong>(self, dynamics): self.dynamics = dynamics def integrate(self, x0: np.ndarray, t_span: tuple, dt: float, controller: Optional[Any] = None) -&gt; dict: ‚Äú‚Äù‚ÄùIntegrate using RK4 method.‚Äù‚Äù‚Äù t_start, t_end = t_span t = np.arange(t_start, t_end + dt, dt) n_steps = len(t) x = np.zeros((n_steps, len(x0))) x[0] = x0 if controller: u = np.zeros(n_steps - 1) for i in range(n_steps - 1): if controller: result = controller.compute_control(x[i], {}, {}) u[i] = result.get(‚Äòcontrol_output‚Äô, result.get(‚Äòcontrol‚Äô, 0.0)) u_current = u[i] else: u_current = 0.0 # RK4 stages k1 = self.dynamics.dynamics(x[i], u_current) k2 = self.dynamics.dynamics(x[i] + 0.5<em>dt</em>k1, u_current) k3 = self.dynamics.dynamics(x[i] + 0.5<em>dt</em>k2, u_current) k4 = self.dynamics.dynamics(x[i] + dt<em>k3, u_current) x[i+1] = x[i] + (dt/6) * (k1 + 2</em>k2 + 2*k3 + k4) result = {‚Äòt‚Äô: t, ‚Äòx‚Äô: x} if controller: result[‚Äòu‚Äô] = u return result class AdaptiveRK45Integrator: ‚Äú‚Äù‚ÄùAdaptive Runge-Kutta 4-5 method (Dormand-Prince). Variable step size for error control. ‚Äú‚Äù‚Äù def <strong>init</strong>(self, dynamics): self.dynamics = dynamics def integrate(self, x0: np.ndarray, t_span: tuple, rtol: float = 1e-6, atol: float = 1e-9, controller: Optional[Any] = None) -&gt; dict: ‚Äú‚Äù‚ÄùIntegrate using adaptive RK45.‚Äù‚Äù‚Äù from scipy.integrate import solve_ivp if controller: def dynamics_func(t, x): result = controller.compute_control(x, {}, {}) u = result.get(‚Äòcontrol_output‚Äô, result.get(‚Äòcontrol‚Äô, 0.0)) return self.dynamics.dynamics(x, u) else: def dynamics_func(t, x): return self.dynamics.dynamics(x, 0.0) sol = solve_ivp( dynamics_func, t_span, x0, method=‚ÄôRK45‚Äô, rtol=rtol, atol=atol ) return { ‚Äòt‚Äô: sol.t, ‚Äòx‚Äô: sol.y.T }</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#runnable-false-benchmarks-analysis-accuracy-metrics-py-def-compute-energy-conservation-t-np-ndarray-x-np-ndarray-physics-params-dict-dict-analyze-energy-conservation-for-hamiltonian-systems-parameters-t-np-ndarray-time-vector-x-np-ndarray-state-trajectories-physics-params-dict-physics-parameters-returns-dict-initial-energy-float-final-energy-float-max-drift-float-relative-drift-float-def-compute-energy-state-kinetic-energy-x-dot-theta1-dot-theta2-dot-state-3-state-4-state-5-ke-0-5-physics-params-m-x-dot-2-cart-pendulum-kinetic-energy-potential-energy-theta1-theta2-state-1-state-2-pe-physics-params-m1-physics-params-g-physics-params-l1-1-np-cos-theta1-second-pendulum-pe-return-ke-pe-energies-np-array-compute-energy-state-for-state-in-x-initial-energy-energies-0-final-energy-energies-1-max-drift-np-max-np-abs-energies-initial-energy-relative-drift-max-drift-initial-energy-if-initial-energy-0-else-np-inf-return-initial-energy-float-initial-energy-final-energy-float-final-energy-max-drift-float-max-drift-relative-drift-float-relative-drift-energies-energies-def-estimate-convergence-order-integrator-x0-np-ndarray-t-span-tuple-dt-values-list-float-dict-estimate-numerical-convergence-order-uses-richardson-extrapolation-to-estimate-p-in-e-h-ch-p-parameters-integrator-object-integration-method-instance-x0-np-ndarray-initial-state-t-span-tuple-time-span-dt-values-list-of-float-decreasing-time-steps-for-convergence-analysis-returns-dict-convergence-order-float-errors-list-of-float-dt-values-list-of-float-get-reference-solution-finest-dt-ref-dt-min-dt-values-4-ref-result-integrator-integrate-x0-t-span-ref-dt-ref-x-final-ref-result-x-1-errors-for-dt-in-dt-values-result-integrator-integrate-x0-t-span-dt-x-final-result-x-1-error-np-linalg-norm-x-final-ref-x-final-errors-append-error-estimate-convergence-order-p-log-e-h1-e-h2-log-h1-h2-orders-for-i-in-range-len-errors-1-if-errors-i-1-0-order-np-log-errors-i-errors-i-1-np-log-dt-values-i-dt-values-i-1-orders-append-order-avg-order-np-mean-orders-if-orders-else-np-nan-return-convergence-order-float-avg-order-errors-float-e-for-e-in-errors-dt-values-dt-values">runnable: false # benchmarks/analysis/accuracy_metrics.py def compute_energy_conservation(t: np.ndarray, x: np.ndarray, physics_params: dict) -&gt; dict: ‚Äú‚Äù‚ÄùAnalyze energy conservation for Hamiltonian systems. Parameters ‚Äî‚Äî‚Äî- t : np.ndarray Time vector x : np.ndarray State trajectories physics_params : dict Physics parameters Returns ‚Äî‚Äî- dict { ‚Äòinitial_energy‚Äô: float, ‚Äòfinal_energy‚Äô: float, ‚Äòmax_drift‚Äô: float, ‚Äòrelative_drift‚Äô: float } ‚Äú‚Äù‚Äù def compute_energy(state): # Kinetic energy x_dot, theta1_dot, theta2_dot = state[3], state[4], state[5] KE = 0.5 * physics_params[‚ÄòM‚Äô] * x_dot**2 # Cart # ‚Ä¶ (pendulum kinetic energy) # Potential energy theta1, theta2 = state[1], state[2] PE = physics_params[‚Äòm1‚Äô] * physics_params[‚Äòg‚Äô] * physics_params[‚ÄòL1‚Äô] * (1 - np.cos(theta1)) # ‚Ä¶ (second pendulum PE) return KE + PE energies = np.array([compute_energy(state) for state in x]) initial_energy = energies[0] final_energy = energies[-1] max_drift = np.max(np.abs(energies - initial_energy)) relative_drift = max_drift / initial_energy if initial_energy != 0 else np.inf return { ‚Äòinitial_energy‚Äô: float(initial_energy), ‚Äòfinal_energy‚Äô: float(final_energy), ‚Äòmax_drift‚Äô: float(max_drift), ‚Äòrelative_drift‚Äô: float(relative_drift), ‚Äòenergies‚Äô: energies } def estimate_convergence_order(integrator, x0: np.ndarray, t_span: tuple, dt_values: List[float]) -&gt; dict: ‚Äú‚Äù‚ÄùEstimate numerical convergence order. Uses Richardson extrapolation to estimate p in: e_h = C¬∑h^p Parameters ‚Äî‚Äî‚Äî- integrator : object Integration method instance x0 : np.ndarray Initial state t_span : tuple Time span dt_values : list of float Decreasing time steps for convergence analysis Returns ‚Äî‚Äî- dict { ‚Äòconvergence_order‚Äô: float, ‚Äòerrors‚Äô: list of float, ‚Äòdt_values‚Äô: list of float } ‚Äú‚Äù‚Äù # Get reference solution (finest dt) ref_dt = min(dt_values) / 4 ref_result = integrator.integrate(x0, t_span, ref_dt) ref_x_final = ref_result[‚Äòx‚Äô][-1] errors = [] for dt in dt_values: result = integrator.integrate(x0, t_span, dt) x_final = result[‚Äòx‚Äô][-1] error = np.linalg.norm(x_final - ref_x_final) errors.append(error) # Estimate convergence order: p = log(e_h1/e_h2) / log(h1/h2) orders = [] for i in range(len(errors) - 1): if errors[i+1] &gt; 0: order = np.log(errors[i] / errors[i+1]) / np.log(dt_values[i] / dt_values[i+1]) orders.append(order) avg_order = np.mean(orders) if orders else np.nan return { ‚Äòconvergence_order‚Äô: float(avg_order), ‚Äòerrors‚Äô: [float(e) for e in errors], ‚Äòdt_values‚Äô: dt_values }</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#benchmarks-comparison-method-comparison-py-class-integrationmethodcomparator-systematic-comparison-of-integration-methods-def-init-self-dynamics-physics-params-dict-self-dynamics-dynamics-self-physics-params-physics-params-def-compare-methods-self-methods-list-str-x0-np-ndarray-t-span-tuple-dt-values-list-float-dict-compare-multiple-integration-methods-parameters-methods-list-of-str-method-names-euler-rk4-rk45-x0-np-ndarray-initial-state-t-span-tuple-time-span-dt-values-list-of-float-time-steps-to-test-returns-dict-comparison-results-for-all-methods-from-benchmarks-integration-import-eulerintegrator-rk4integrator-adaptiverk45integrator-from-benchmarks-analysis-import-compute-energy-conservation-estimate-convergence-order-integrators-euler-eulerintegrator-self-dynamics-rk4-rk4integrator-self-dynamics-rk45-adaptiverk45integrator-self-dynamics-results-for-method-name-in-methods-integrator-integrators-method-name-convergence-analysis-convergence-estimate-convergence-order-integrator-x0-t-span-dt-values-energy-conservation-for-frictionless-system-result-integrator-integrate-x0-t-span-dt-min-dt-values-energy-analysis-compute-energy-conservation-result-t-result-x-self-physics-params-performance-measurement-import-time-start-time-time-integrator-integrate-x0-t-span-dt-min-dt-values-elapsed-time-time-start-results-method-name-convergence-order-convergence-convergence-order-energy-drift-energy-analysis-relative-drift-computation-time-elapsed-errors-convergence-errors-return-results">benchmarks/comparison/method_comparison.py class IntegrationMethodComparator: ‚Äú‚Äù‚ÄùSystematic comparison of integration methods.‚Äù‚Äù‚Äù def <strong>init</strong>(self, dynamics, physics_params: dict): self.dynamics = dynamics self.physics_params = physics_params def compare_methods(self, methods: List[str], x0: np.ndarray, t_span: tuple, dt_values: List[float]) -&gt; dict: ‚Äú‚Äù‚ÄùCompare multiple integration methods. Parameters ‚Äî‚Äî‚Äî- methods : list of str Method names: [‚ÄòEuler‚Äô, ‚ÄòRK4‚Äô, ‚ÄòRK45‚Äô] x0 : np.ndarray Initial state t_span : tuple Time span dt_values : list of float Time steps to test Returns ‚Äî‚Äî- dict Comparison results for all methods ‚Äú‚Äù‚Äù from benchmarks.integration import EulerIntegrator, RK4Integrator, AdaptiveRK45Integrator from benchmarks.analysis import compute_energy_conservation, estimate_convergence_order integrators = { ‚ÄòEuler‚Äô: EulerIntegrator(self.dynamics), ‚ÄòRK4‚Äô: RK4Integrator(self.dynamics), ‚ÄòRK45‚Äô: AdaptiveRK45Integrator(self.dynamics) } results = {} for method_name in methods: integrator = integrators[method_name] # Convergence analysis convergence = estimate_convergence_order(integrator, x0, t_span, dt_values) # Energy conservation (for frictionless system) result = integrator.integrate(x0, t_span, dt=min(dt_values)) energy_analysis = compute_energy_conservation( result[‚Äòt‚Äô], result[‚Äòx‚Äô], self.physics_params ) # Performance measurement import time start = time.time() _ = integrator.integrate(x0, t_span, dt=min(dt_values)) elapsed = time.time() - start results[method_name] = { ‚Äòconvergence_order‚Äô: convergence[‚Äòconvergence_order‚Äô], ‚Äòenergy_drift‚Äô: energy_analysis[‚Äòrelative_drift‚Äô], ‚Äòcomputation_time‚Äô: elapsed, ‚Äòerrors‚Äô: convergence[‚Äòerrors‚Äô] } return results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/benchmarking_framework_technical_guide.html#config-yaml-benchmark-configuration-benchmarks-statistical-n-trials-30-clt-compliance-confidence-level-0-95-95-ci-seed-42-reproducibility-physics-uncertainty-enabled-true-n-scenarios-10-variations-cart-mass-0-05-5-pendulum1-mass-0-10-10-pendulum2-mass-0-10-10-pendulum1-length-0-05-5-pendulum2-length-0-05-5-friction-cart-0-20-20-sensor-noise-enabled-false-std-position-0-001-1mm-std-angle-0-001-0-06-integration-methods-euler-rk4-rk45-dt-values-0-05-0-01-0-005-0-001-convergence-analysis-true-energy-conservation-check-true-performance-regression-threshold-0-05-5-slowdown-alert-baseline-file-benchmarks-baseline-json">config.yaml - Benchmark configuration benchmarks: statistical: n_trials: 30 # CLT compliance confidence_level: 0.95 # 95% CI seed: 42 # Reproducibility physics_uncertainty: enabled: true n_scenarios: 10 variations: cart_mass: 0.05 # ¬±5% pendulum1_mass: 0.10 # ¬±10% pendulum2_mass: 0.10 # ¬±10% pendulum1_length: 0.05 # ¬±5% pendulum2_length: 0.05 # ¬±5% friction_cart: 0.20 # ¬±20% sensor_noise: enabled: false std_position: 0.001 # 1mm std_angle: 0.001 # ~0.06¬∞ integration: methods: [‚ÄòEuler‚Äô, ‚ÄòRK4‚Äô, ‚ÄòRK45‚Äô] dt_values: [0.05, 0.01, 0.005, 0.001] convergence_analysis: true energy_conservation_check: true performance: regression_threshold: 0.05 # 5% slowdown alert baseline_file: ‚Äòbenchmarks/baseline.json‚Äô</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/validation_methodology_guide.html">Validation Methodology Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/theory/lyapunov_stability_testing.html">Lyapunov Stability Testing Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/theory/smc_validation_mathematics.html">SMC Validation Mathematics <strong>Status:</strong> Integrated into validation framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/theory/smc_validation_mathematics.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/theory/smc_validation_mathematics.html#runnable-false-def-monte-carlo-validation-controller-n-trials-1000-statistical-validation-of-controller-performance-settling-times-overshoot-values-for-in-range-n-trials-x0-random-initial-condition-result-simulate-controller-x0-duration-10-0-settling-times-append-compute-settling-time-result-overshoot-values-append-compute-overshoot-result-statistical-acceptance-criteria-assert-np-mean-settling-times-3-0-assert-np-percentile-settling-times-95-5-0-assert-np-mean-overshoot-values-0-1">runnable: false def monte_carlo_validation(controller, n_trials=1000): ‚Äú‚Äù‚ÄùStatistical validation of controller performance.‚Äù‚Äù‚Äù settling_times = [] overshoot_values = [] for _ in range(n_trials): x0 = random_initial_condition() result = simulate(controller, x0, duration=10.0) settling_times.append(compute_settling_time(result)) overshoot_values.append(compute_overshoot(result)) # Statistical acceptance criteria assert np.mean(settling_times) &lt; 3.0 assert np.percentile(settling_times, 95) &lt; 5.0 assert np.mean(overshoot_values) &lt; 0.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/executive/executive_summary.html">Executive Test Summary Report <strong>Date</strong>: 2025-09-30 06:03</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/test_failure_analysis.html">Test Failure Analysis Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/failure_breakdown.html">Failure Resolution Tracking Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/pso_convergence_analysis.html">PSO Convergence Analysis - September 30, 2025</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/pso_fitness_investigation.html">PSO Fitness Function Investigation - cost=0.0 Root Cause Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/technical_analysis.html">Technical Deep-Dive: Pytest Failure Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/technical/control_theory_analysis.html">Control Theory Technical Analysis Report</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/reports/2025-09-30/technical/resolution_roadmap.html">Technical Resolution Roadmap <strong>Date</strong>: 2025-09-30 06:03</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/standards/testing_standards.html">Testing Standards and Guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/accessibility_checklist.html">WCAG 2.1 AA Accessibility Checklist</a></li>
<li class="toctree-l2"><a class="reference internal" href="../testing/navigation_index.html">Testing Documentation Navigation Index</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../theory/index.html">Theoretical Foundations ```{toctree}</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory_overview.html">Theory Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../use_cases.html">4. Use Cases &amp; Operating Modes</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../validation/index.html">Validation &amp; Verification</a><input aria-label="Toggle navigation of Validation &amp; Verification" class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" role="switch" type="checkbox"/><label for="toctree-checkbox-13"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_workflow.html">Validation Workflow Guide &gt; <strong>Coming Soon:</strong> validation workflow documentation. ## Current Resources For validation guidance, see: - <strong><span class="xref myst">Validation Examples</span></strong> - Practical validation examples and patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_validation_guide.html">Simulation Validation Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html">Simulation Result Validation Methodology <strong>Document Status:</strong> Phase 3.3 Completion - Monte Carlo and Statistical Testing Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html#controller-adapts-on-t0-t1">- Controller adapts on [t‚ÇÄ, t‚ÇÅ]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html#performance-evaluated-on-t1-gap-t2">- Performance evaluated on [t‚ÇÅ+gap, t‚ÇÇ]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html#runnable-false-monte-carlo-cross-validation-statistical-tests">runnable: false # Monte Carlo + Cross-Validation + Statistical Tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/simulation_result_validation.html#if-diverge-investigate-why">If diverge ‚Üí investigate why</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html">Validation Examples: Practical Implementation Guide <strong>Document Status:</strong> Phase 3.3 Completion - Executable Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#runnable-false">runnable: false ‚Äú‚Äù‚Äù</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#conservative-20-uncertainty">Conservative (¬±20% uncertainty)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#pso-hyperparameter-selection-via-cross-validation-1-configuration-number-of-scenarios-100-pso-configurations-to-compare-4-1-small-explorative-pop-20-w-0-9-c1-2-0-c2-1-0-2-standard-pop-30-w-0-7-c1-1-5-c2-1-5-3-large-exploitative-pop-50-w-0-4-c1-1-0-c2-2-0-4-adaptive-pop-30-w-0-5-c1-1-8-c2-1-2-2-cross-validation-setup-method-monte-carlo-repetitions-50-train-test-split-80-20-3-running-cross-validation-this-may-take-several-minutes-4-results-cross-validation-scores-small-explorative-mean-cv-score-2-134-std-cv-score-0-312-median-cv-score-2-098-95-ci-2-223-2-045-standard-mean-cv-score-1-987-std-cv-score-0-267-median-cv-score-1-963-95-ci-2-062-1-912-large-exploitative-mean-cv-score-2-056-std-cv-score-0-298-median-cv-score-2-031-95-ci-2-138-1-974-adaptive-mean-cv-score-1-923-std-cv-score-0-245-median-cv-score-1-904-95-ci-1-992-1-854-5-statistical-comparison-pairwise-tests-after-multiple-comparison-correction-model-0-vs-model-3-model-3-is-significantly-better-p-0-0023-0-211-model-1-vs-model-3-model-3-is-significantly-better-p-0-0412-0-064-overall-ranking-1-adaptive-score-1-923-2-standard-score-1-987-3-large-exploitative-score-2-056-4-small-explorative-score-2-134-6-bias-variance-analysis-small-explorative-bias2-0-123456-variance-0-098234-high-bias-underfitting-consider-larger-population-standard-bias2-0-087654-variance-0-071234-good-balance-large-exploitative-bias2-0-091234-variance-0-089012-good-balance-adaptive-bias2-0-076543-variance-0-060123-good-balance-recommendation-recommended-pso-configuration-adaptive-parameters-population-size-30-inertia-weight-w-0-5-cognitive-coeff-c1-1-8-social-coeff-c2-1-2-mean-cv-score-1-923-this-configuration-showed-best-generalization-across-50-random-splits">======================================================================
PSO Hyperparameter Selection via Cross-Validation
====================================================================== 1. Configuration: Number of scenarios: 100 PSO configurations to compare: 4 1. Small-Explorative: pop=20, w=0.9, c1=2.0, c2=1.0 2. Standard: pop=30, w=0.7, c1=1.5, c2=1.5 3. Large-Exploitative: pop=50, w=0.4, c1=1.0, c2=2.0 4. Adaptive: pop=30, w=0.5, c1=1.8, c2=1.2 2. Cross-Validation Setup: Method: monte_carlo Repetitions: 50 Train-test split: 80%-20% 3. Running cross-validation‚Ä¶ (This may take several minutes‚Ä¶) 4. Results:
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî- Cross-Validation Scores: Small-Explorative: Mean CV score: -2.134 Std CV score: 0.312 Median CV score: -2.098 95% CI: [-2.223, -2.045] Standard: Mean CV score: -1.987 Std CV score: 0.267 Median CV score: -1.963 95% CI: [-2.062, -1.912] Large-Exploitative: Mean CV score: -2.056 Std CV score: 0.298 Median CV score: -2.031 95% CI: [-2.138, -1.974] Adaptive: Mean CV score: -1.923 Std CV score: 0.245 Median CV score: -1.904 95% CI: [-1.992, -1.854] 5. Statistical Comparison: Pairwise Tests (after multiple comparison correction): model_0_vs_model_3: model_3 is significantly better (p=0.0023, Œî=0.211) model_1_vs_model_3: model_3 is significantly better (p=0.0412, Œî=0.064) Overall Ranking: 1. Adaptive (score: -1.923) 2. Standard (score: -1.987) 3. Large-Exploitative (score: -2.056) 4. Small-Explorative (score: -2.134) 6. Bias-Variance Analysis: Small-Explorative: Bias¬≤: 0.123456 Variance: 0.098234 ‚ö† High bias - underfitting (consider larger population) Standard: Bias¬≤: 0.087654 Variance: 0.071234 ‚úì Good balance Large-Exploitative: Bias¬≤: 0.091234 Variance: 0.089012 ‚úì Good balance Adaptive: Bias¬≤: 0.076543 Variance: 0.060123 ‚úì Good balance ======================================================================
RECOMMENDATION: ‚úì RECOMMENDED PSO Configuration: Adaptive Parameters: - Population size: 30 - Inertia weight (w): 0.5 - Cognitive coeff (c1): 1.8 - Social coeff (c2): 1.2 Mean CV score: -1.923 This configuration showed best generalization across 50 random splits.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#statistical-comparison-of-controller-performance-1-experimental-setup-controllers-classical-smc-super-twisting-smc-adaptive-smc-trials-per-controller-30-significance-level-0-05-metric-settling-time-seconds-2-collecting-performance-data-3-descriptive-statistics-classical-smc-mean-2-487-s-std-0-398-s-median-2-465-s-min-1-823-s-max-3-312-s-cv-16-0-super-twisting-smc-mean-1-789-s-std-0-246-s-median-1-776-s-min-1-312-s-max-2-345-s-cv-13-8-adaptive-smc-mean-2-098-s-std-0-489-s-median-2-073-s-min-1-234-s-max-3-145-s-cv-23-3-4-assumption-testing-normality-tests-shapiro-wilk-classical-smc-w-0-9821-p-0-8734-normal-super-twisting-smc-w-0-9765-p-0-7231-normal-adaptive-smc-w-0-9798-p-0-8123-normal-homogeneity-of-variance-levene-s-test-f-3-2145-p-0-0456-unequal-variances-will-use-welch-s-test-5-pairwise-comparisons-multiple-comparison-correction-bonferroni-corrected-significance-level-0-0167-classical-smc-vs-super-twisting-smc-welch-s-t-test-t-7-8234-p-0-0001-significant-p-0-0167-mann-whitney-u-test-non-parametric-u-123-0-p-0-0002-effect-size-cohen-s-d-d-2-013-large-mean-difference-0-698-s-95-ci-for-difference-0-512-0-884-s-classical-smc-vs-adaptive-smc-welch-s-t-test-t-3-4567-p-0-0012-significant-p-0-0167-mann-whitney-u-test-non-parametric-u-287-0-p-0-0018-effect-size-cohen-s-d-d-0-891-large-mean-difference-0-389-s-95-ci-for-difference-0-167-0-611-s-super-twisting-smc-vs-adaptive-smc-welch-s-t-test-t-2-8901-p-0-0056-significant-p-0-0167-mann-whitney-u-test-non-parametric-u-234-0-p-0-0071-effect-size-cohen-s-d-d-0-743-medium-mean-difference-0-309-s-95-ci-for-difference-0-521-0-097-s-6-omnibus-test-one-way-anova-f-26-7891-p-0-000001-significant-at-least-one-controller-differs-kruskal-wallis-test-non-parametric-h-25-3456-p-0-000003-7-power-analysis-classical-smc-vs-super-twisting-smc-effect-size-d-2-013-sample-size-n-30-power-0-998-99-8-adequate-power-80-classical-smc-vs-adaptive-smc-effect-size-d-0-891-sample-size-n-30-power-0-865-86-5-adequate-power-80-super-twisting-smc-vs-adaptive-smc-effect-size-d-0-743-sample-size-n-30-power-0-752-75-2-low-power-recommend-n-36-for-80-power-conclusions-1-statistical-significance-significant-differences-found-0-0167-classical-smc-vs-super-twisting-smc-classical-smc-vs-adaptive-smc-super-twisting-smc-vs-adaptive-smc-2-effect-sizes-classical-smc-vs-super-twisting-smc-cohen-s-d-2-013-large-classical-smc-vs-adaptive-smc-cohen-s-d-0-891-large-super-twisting-smc-vs-adaptive-smc-cohen-s-d-0-743-medium-3-practical-recommendations-performance-ranking-by-mean-settling-time-1-super-twisting-smc-1-789-s-2-adaptive-smc-2-098-s-3-classical-smc-2-487-s-recommended-super-twisting-smc-fastest-mean-settling-time-significantly-better-than-classical-smc-p-0-0001-d-2-013-significantly-better-than-adaptive-smc-p-0-0056-d-0-743">======================================================================
Statistical Comparison of Controller Performance
====================================================================== 1. Experimental Setup: Controllers: Classical SMC, Super-Twisting SMC, Adaptive SMC Trials per controller: 30 Significance level: 0.05 Metric: Settling time (seconds) 2. Collecting performance data‚Ä¶ 3. Descriptive Statistics:
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî- Classical SMC: Mean: 2.487 s Std: 0.398 s Median: 2.465 s Min: 1.823 s Max: 3.312 s CV: 16.0% Super-Twisting SMC: Mean: 1.789 s Std: 0.246 s Median: 1.776 s Min: 1.312 s Max: 2.345 s CV: 13.8% Adaptive SMC: Mean: 2.098 s Std: 0.489 s Median: 2.073 s Min: 1.234 s Max: 3.145 s CV: 23.3% 4. Assumption Testing:
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî- Normality Tests (Shapiro-Wilk): Classical SMC : W=0.9821, p=0.8734 ‚úì Normal Super-Twisting SMC : W=0.9765, p=0.7231 ‚úì Normal Adaptive SMC : W=0.9798, p=0.8123 ‚úì Normal Homogeneity of Variance (Levene‚Äôs test): F=3.2145, p=0.0456 ‚ö† Unequal variances - will use Welch‚Äôs test 5. Pairwise Comparisons:
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî- Multiple comparison correction: Bonferroni Corrected significance level: Œ±=0.0167 Classical SMC vs Super-Twisting SMC: Welch‚Äôs t-test: t=7.8234, p=0.0001 ‚úì SIGNIFICANT (p &lt; 0.0167) Mann-Whitney U test (non-parametric): U=123.0, p=0.0002 Effect Size (Cohen‚Äôs d): d=2.013 (large) Mean difference: 0.698 s 95% CI for difference: [0.512, 0.884] s Classical SMC vs Adaptive SMC: Welch‚Äôs t-test: t=3.4567, p=0.0012 ‚úì SIGNIFICANT (p &lt; 0.0167) Mann-Whitney U test (non-parametric): U=287.0, p=0.0018 Effect Size (Cohen‚Äôs d): d=0.891 (large) Mean difference: 0.389 s 95% CI for difference: [0.167, 0.611] s Super-Twisting SMC vs Adaptive SMC: Welch‚Äôs t-test: t=-2.8901, p=0.0056 ‚úì SIGNIFICANT (p &lt; 0.0167) Mann-Whitney U test (non-parametric): U=234.0, p=0.0071 Effect Size (Cohen‚Äôs d): d=-0.743 (medium) Mean difference: -0.309 s 95% CI for difference: [-0.521, -0.097] s 6. Omnibus Test (One-Way ANOVA):
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî- F=26.7891, p=0.000001 ‚úì SIGNIFICANT: At least one controller differs Kruskal-Wallis test (non-parametric): H=25.3456, p=0.000003 7. Power Analysis:
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî- Classical SMC vs Super-Twisting SMC: Effect size (d): 2.013 Sample size (n): 30 Power: 0.998 (99.8%) ‚úì Adequate power (‚â•80%) Classical SMC vs Adaptive SMC: Effect size (d): 0.891 Sample size (n): 30 Power: 0.865 (86.5%) ‚úì Adequate power (‚â•80%) Super-Twisting SMC vs Adaptive SMC: Effect size (d): 0.743 Sample size (n): 30 Power: 0.752 (75.2%) ‚ö† Low power - recommend n=36 for 80% power ======================================================================
CONCLUSIONS:
====================================================================== 1. Statistical Significance: Significant differences found (Œ±=0.0167): - Classical SMC vs Super-Twisting SMC - Classical SMC vs Adaptive SMC - Super-Twisting SMC vs Adaptive SMC 2. Effect Sizes: Classical SMC vs Super-Twisting SMC: Cohen‚Äôs d = 2.013 (large) Classical SMC vs Adaptive SMC: Cohen‚Äôs d = 0.891 (large) Super-Twisting SMC vs Adaptive SMC: Cohen‚Äôs d = -0.743 (medium) 3. Practical Recommendations: Performance ranking (by mean settling time): 1. Super-Twisting SMC : 1.789 s 2. Adaptive SMC : 2.098 s 3. Classical SMC : 2.487 s ‚úì RECOMMENDED: Super-Twisting SMC - Fastest mean settling time - Significantly better than Classical SMC (p=0.0001, d=2.013) - Significantly better than Adaptive SMC (p=0.0056, d=0.743)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/validation_examples.html#uncertainty-quantification-for-settling-time-1-safety-requirement-settling-time-must-be-3-0s-with-99-confidence-2-collecting-experimental-data-number-of-test-runs-200-3-descriptive-statistics-mean-2-123-s-std-0-687-s-median-1-983-s-min-0-987-s-max-4-823-s-range-3-836-s-percentiles-5-1-234-s-25-1-653-s-50-1-983-s-75-2-456-s-95-3-567-s-99-4-234-s-4-bootstrap-confidence-intervals-bootstrap-iterations-10000-confidence-level-95-mean-settling-time-point-estimate-2-123-s-95-ci-2-026-2-223-s-ci-width-0-197-s-median-settling-time-point-estimate-1-983-s-95-ci-1-876-2-087-s-95th-percentile-point-estimate-3-567-s-95-ci-3-289-3-891-s-5-distribution-fitting-normal-k-s-statistic-0-0867-p-value-0-0234-aic-412-34-reject-poor-fit-lognormal-k-s-statistic-0-0421-p-value-0-6523-aic-387-12-cannot-reject-good-fit-gamma-k-s-statistic-0-0534-p-value-0-3421-aic-391-67-cannot-reject-good-fit-exponential-k-s-statistic-0-1234-p-value-0-0001-aic-445-89-reject-poor-fit-best-fit-lowest-aic-lognormal-aic-387-12-6-risk-analysis-value-at-risk-var-var-1-3-892-s-top-1-worst-cases-var-5-3-567-s-top-5-worst-cases-var-10-3-234-s-top-10-worst-cases-conditional-value-at-risk-cvar-expected-shortfall-cvar-1-4-123-s-avg-of-worst-1-cvar-5-3-789-s-avg-of-worst-5-cvar-10-3-456-s-avg-of-worst-10-7-safety-validation-empirical-analysis-samples-exceeding-3-0s-18-200-empirical-p-t-3-0s-0-0900-9-00-95-ci-for-p-t-3-0s-0-0523-0-1342-fitted-lognormal-distribution-p-t-3-0s-0-0823-8-23-p-t-3-0s-0-9177-91-77-fails-safety-requirement-91-8-99-0-to-meet-99-confidence-target-99-percentile-4-521-s-required-4-521s-3-0s-need-to-improve-99-percentile-by-1-521s-8-extreme-value-analysis-block-maxima-method-block-size-20-number-of-blocks-10-gev-parameters-0-234-3-876-0-456-return-levels-10-run-worst-case-4-876-s-50-run-worst-case-5-432-s-100-run-worst-case-5-687-s-uncertainty-quantification-summary-1-point-estimates-mean-2-123-s-95th-percentile-3-567-s-99th-percentile-4-234-s-2-uncertainty-95-ci-mean-2-026-2-223-s-95th-percentile-3-289-3-891-s-3-distributional-model-best-fit-lognormal-goodness-of-fit-p-value-0-6523-4-safety-assessment-threshold-3-0s-required-confidence-99-fails-only-91-8-of-scenarios-meet-requirement-5-recommendations-further-controller-improvement-needed-option-1-tune-controller-for-better-worst-case-performance-option-2-increase-safety-threshold-option-3-accept-lower-confidence-level-if-acceptable">======================================================================
Uncertainty Quantification for Settling Time
====================================================================== 1. Safety Requirement: Settling time must be &lt; 3.0s with 99% confidence 2. Collecting experimental data‚Ä¶ Number of test runs: 200 3. Descriptive Statistics:
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî- Mean: 2.123 s Std: 0.687 s Median: 1.983 s Min: 0.987 s Max: 4.823 s Range: 3.836 s Percentiles: 5%: 1.234 s 25%: 1.653 s 50%: 1.983 s 75%: 2.456 s 95%: 3.567 s 99%: 4.234 s 4. Bootstrap Confidence Intervals:
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî- Bootstrap iterations: 10000 Confidence level: 95% Mean settling time: Point estimate: 2.123 s 95% CI: [2.026, 2.223] s CI width: 0.197 s Median settling time: Point estimate: 1.983 s 95% CI: [1.876, 2.087] s 95th percentile: Point estimate: 3.567 s 95% CI: [3.289, 3.891] s 5. Distribution Fitting:
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî- Normal: K-S statistic: 0.0867 p-value: 0.0234 AIC: 412.34 ‚úó Reject (poor fit) Lognormal: K-S statistic: 0.0421 p-value: 0.6523 AIC: 387.12 ‚úì Cannot reject (good fit) Gamma: K-S statistic: 0.0534 p-value: 0.3421 AIC: 391.67 ‚úì Cannot reject (good fit) Exponential: K-S statistic: 0.1234 p-value: 0.0001 AIC: 445.89 ‚úó Reject (poor fit) Best fit (lowest AIC): Lognormal AIC = 387.12 6. Risk Analysis:
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî- Value at Risk (VaR): VaR(1%): 3.892 s (top 1% worst cases) VaR(5%): 3.567 s (top 5% worst cases) VaR(10%): 3.234 s (top 10% worst cases) Conditional Value at Risk (CVaR / Expected Shortfall): CVaR(1%): 4.123 s (avg of worst 1%) CVaR(5%): 3.789 s (avg of worst 5%) CVaR(10%): 3.456 s (avg of worst 10%) 7. Safety Validation:
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî- Empirical Analysis: Samples exceeding 3.0s: 18/200 Empirical P(T &gt; 3.0s) = 0.0900 (9.00%) 95% CI for P(T &gt; 3.0s): [0.0523, 0.1342] Fitted Lognormal Distribution: P(T &gt; 3.0s) = 0.0823 (8.23%) P(T ‚â§ 3.0s) = 0.9177 (91.77%) ‚úó FAILS safety requirement (91.8% &lt; 99.0%) To meet 99% confidence: Target: 99% percentile = 4.521 s Required: 4.521s &lt; 3.0s ‚ö† Need to improve 99% percentile by 1.521s 8. Extreme Value Analysis:
‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî- Block Maxima Method: Block size: 20 Number of blocks: 10 GEV parameters: Œæ=-0.234, Œº=3.876, œÉ=0.456 Return Levels: 10-run worst-case: 4.876 s 50-run worst-case: 5.432 s 100-run worst-case: 5.687 s ======================================================================
UNCERTAINTY QUANTIFICATION SUMMARY:
====================================================================== 1. Point Estimates: Mean: 2.123 s 95th percentile: 3.567 s 99th percentile: 4.234 s 2. Uncertainty (95% CI): Mean: [2.026, 2.223] s 95th percentile: [3.289, 3.891] s 3. Distributional Model: Best fit: Lognormal Goodness-of-fit p-value: 0.6523 4. Safety Assessment: Threshold: 3.0s Required confidence: 99% ‚úó FAILS: Only 91.8% of scenarios meet requirement 5. Recommendations: ‚úó Further controller improvement needed ‚ñ° Option 1: Tune controller for better worst-case performance ‚ñ° Option 2: Increase safety threshold ‚ñ° Option 3: Accept lower confidence level (if acceptable)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/api_reference.html">Validation API Reference &gt; <strong>Coming Soon:</strong> validation API documentation. ## Current Resources For validation APIs, see: - <strong><span class="xref myst">Analysis Validation</span></strong> - Validation metrics API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/statistical_reference_tables.html">Statistical Reference Tables &gt; <strong>Coming Soon:</strong> statistical reference tables for validation. ## Current Resources For statistical validation, see: - <strong><span class="xref myst">Statistical Tests</span></strong> - Statistical test implementations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../validation/phase_3_3_completion_report.html">Phase 3.3 Completion Report: Simulation Result Validation Documentation <strong>Completion Date:</strong> 2025-10-07</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../versioning_guide.html">Documentation Versioning Guide</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../workflows/index.html">Workflows &amp; Integration Guides</a><input aria-label="Toggle navigation of Workflows &amp; Integration Guides" class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" role="switch" type="checkbox"/><label for="toctree-checkbox-14"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html">Complete Integration Workflow Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#test-each-controller-individually">Test each controller individually</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#use-pre-optimized-gains-for-immediate-results">Use pre-optimized gains for immediate results</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#launch-interactive-web-interface">Launch interactive web interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#select-controller-adjust-parameters-run-simulations">Select controller, adjust parameters, run simulations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#optimize-classical-smc-gains">Optimize classical SMC gains</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#optimize-adaptive-smc-with-uncertainty">Optimize adaptive SMC with uncertainty</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#optimize-sta-smc-for-finite-time-performance">Optimize STA SMC for finite-time performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#optimize-hybrid-smc-most-sophisticated">Optimize hybrid SMC (most sophisticated)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#optimize-all-controllers-in-sequence">Optimize all controllers in sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#runnable-false-scripts-custom-batch-optimization-py">runnable: false # scripts/custom_batch_optimization.py</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#multi-objective-optimization-for-competing-requirements">Multi-objective optimization for competing requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#id1">example-metadata:</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#runnable-false-adaptive-pso-with-time-varying-parameters">runnable: false # Adaptive PSO with time-varying parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#run-hil-simulation">Run HIL simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#real-time-monitoring-setup">Real-time monitoring setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#distributed-control-system">Distributed control system</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#adaptive-controller-selection-based-on-performance">Adaptive controller selection based on performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#diagnose-controller-performance-problems">Diagnose controller performance problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#debug-pso-optimization-problems">Debug PSO optimization problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/complete_integration_guide.html#continuous-system-health-monitoring">Continuous system health monitoring</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/pytest_testing_workflow.html">Quick Start Guide for Running Tests <strong>Document Version</strong>: 1.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workflows/pytest_testing_workflow.html#run-all-tests-basic-command">1. Run all tests (basic command)</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/blob/main/docs/factory/README.md?plain=true" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div><div class="edit-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/edit/main/docs/factory/README.md" rel="edit" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <p>#==========================================================================================\<br />
#========================== docs/factory/README.md ==================================\<br />
#==========================================================================================\</p>
<section id="factory-integration-documentation-suite">
<h1>Factory Integration Documentation Suite<a class="headerlink" href="#factory-integration-documentation-suite" title="Link to this heading">¬∂</a></h1>
<section id="github-issue-6-resolution-complete-documentation-package-overview-this-documentation-suite-covers-the-enhanced-controller-factory-system-implemented-as-part-of-github-issue-6-resolution-the-improvements-increased-system-success-rates-from-68-9-to-95-through-systematic-fixes-to-thread-safety-parameter-validation-pso-integration-and-deprecation-management-documentation-structure-core-documentation-files-document-purpose-target-audience">
<h2>GitHub Issue #6 Resolution - Complete Documentation Package ### Overview This documentation suite covers the enhanced controller factory system implemented as part of GitHub Issue #6 resolution. The improvements increased system success rates from <strong>68.9% to 95%+</strong> through systematic fixes to thread safety, parameter validation, PSO integration, and deprecation management. ## üìö Documentation Structure ### Core Documentation Files | Document | Purpose | Target Audience |<a class="headerlink" href="#github-issue-6-resolution-complete-documentation-package-overview-this-documentation-suite-covers-the-enhanced-controller-factory-system-implemented-as-part-of-github-issue-6-resolution-the-improvements-increased-system-success-rates-from-68-9-to-95-through-systematic-fixes-to-thread-safety-parameter-validation-pso-integration-and-deprecation-management-documentation-structure-core-documentation-files-document-purpose-target-audience" title="Link to this heading">¬∂</a></h2>
<p>|‚Äî‚Äî‚Äî-|‚Äî‚Äî‚Äî|‚Äî‚Äî‚Äî‚Äî‚Äî‚Äì|
| <strong><a class="reference internal" href="factory_integration_user_guide.html"><span class="std std-doc">Factory Integration User Guide</span></a></strong> | Complete user guide for the enhanced factory system | All users - beginners to advanced |
| <strong><a class="reference internal" href="factory_api_reference.html"><span class="std std-doc">Factory API Reference</span></a></strong> | API documentation with examples | Developers and integrators |
| <strong><a class="reference internal" href="troubleshooting_guide.html"><span class="std std-doc">Troubleshooting Guide</span></a></strong> | Diagnostic procedures and problem resolution | System administrators and developers |
| <strong><a class="reference internal" href="production_deployment_guide.html"><span class="std std-doc">Production Deployment Guide</span></a></strong> | Production deployment and monitoring procedures | DevOps engineers and system administrators |
| <strong><a class="reference internal" href="migration_guide.html"><span class="std std-doc">Configuration Migration Guide</span></a></strong> | Automated and manual migration procedures | Users upgrading from legacy systems |
| <strong><a class="reference internal" href="configuration_migration_mathematical_foundations.html"><span class="std std-doc">Mathematical Foundations</span></a></strong> | Scientific validation and control theory foundations | Researchers and advanced users | ### Additional Documentation | Document | Purpose |
|‚Äî‚Äî‚Äî-|‚Äî‚Äî‚Äî|
| <strong><a class="reference internal" href="deprecation_management.html"><span class="std std-doc">Deprecation Management Guide</span></a></strong> | Systematic deprecation handling and migration |
| <strong><a class="reference internal" href="performance_benchmarks.html"><span class="std std-doc">Factory Performance Benchmarks</span></a></strong> | Performance metrics and optimization guidelines |</p>
</section>
<hr class="docutils" />
<section id="complete-documentation-navigation">
<h2>Complete Documentation Navigation<a class="headerlink" href="#complete-documentation-navigation" title="Link to this heading">¬∂</a></h2>
<section id="core-documentation">
<h3>Core Documentation<a class="headerlink" href="#core-documentation" title="Link to this heading">¬∂</a></h3>
<div class="toctree-wrapper compound">
<p class="caption" role="heading"><span class="caption-text">Core Factory Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="factory_integration_user_guide.html">Factory Integration User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="factory_integration_user_guide.html#github-issue-6-resolution-documentation-overview-this-user-guide-covers-the-enhanced-controller-factory-system-implemented-as-part-of-github-issue-6-resolution-the-factory-integration-fixes-address-critical-stability-performance-and-usability-issues-that-improved-system-success-rates-from-68-9-to-95-key-improvements-in-github-issue-6-resolution-1-unified-parameter-interface">GitHub Issue #6 Resolution Documentation ### Overview This user guide covers the enhanced controller factory system implemented as part of GitHub Issue #6 resolution. The factory integration fixes address critical stability, performance, and usability issues that improved system success rates from 68.9% to 95%+. ## Key Improvements in GitHub Issue #6 Resolution ### 1. <strong>Unified Parameter Interface</strong></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="factory_api_reference.html">Factory API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="factory_api_reference.html#github-issue-6-enhanced-controller-factory-system-overview-this-api-reference-documents-the-enhanced-controller-factory-system-implemented-as-part-of-github-issue-6-resolution-the-factory-provides-thread-safe-type-safe-controller-instantiation-with-advanced-validation-and-pso-optimization-support-core-factory-functions-create-controller-controller-type-config-none-gains-none-primary-factory-function-for-creating-controller-instances-signature">GitHub Issue #6 Enhanced Controller Factory System ### Overview This API reference documents the enhanced controller factory system implemented as part of GitHub Issue #6 resolution. The factory provides thread-safe, type-safe controller instantiation with advanced validation and PSO optimization support. ## Core Factory Functions ### <code class="docutils literal notranslate"><span class="pre">create_controller(controller_type,</span> <span class="pre">config=None,</span> <span class="pre">gains=None)</span></code> <strong>Primary factory function for creating controller instances.</strong> #### Signature</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="enhanced_factory_api_reference.html">Enhanced Factory API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="enhanced_factory_api_reference.html#github-issue-6-resolution-complete-mathematical-foundations-overview-this-api-reference-documents-the-enhanced-controller-factory-system-implemented-as-part-of-github-issue-6-resolution-the-factory-provides-thread-safe-type-safe-controller-instantiation-with-advanced-validation-pso-optimization-support-and-rigorous-mathematical-foundations-for-all-sliding-mode-control-variants-architecture-overview-factory-design-principles-1-thread-safety-all-factory-operations-use-rlock-for-concurrent-access">GitHub Issue #6 Resolution - Complete Mathematical Foundations ### Overview This API reference documents the enhanced controller factory system implemented as part of GitHub Issue #6 resolution. The factory provides thread-safe, type-safe controller instantiation with advanced validation, PSO optimization support, and rigorous mathematical foundations for all sliding mode control variants. ## Architecture Overview ### Factory Design Principles 1. <strong>Thread Safety</strong>: All factory operations use RLock for concurrent access</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="enhanced_factory_api_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="enhanced_factory_api_reference.html#runnable-false-controller-registry-classical-smc-class-modularclassicalsmc-config-class-classicalsmcconfig-default-gains-20-0-15-0-12-0-8-0-35-0-5-0-gain-count-6-description-classical-sliding-mode-controller-with-boundary-layer-supports-dynamics-true-required-params-gains-max-force-boundary-layer-additional-controllers">runnable: false CONTROLLER_REGISTRY = { ‚Äòclassical_smc‚Äô: { ‚Äòclass‚Äô: ModularClassicalSMC, ‚Äòconfig_class‚Äô: ClassicalSMCConfig, ‚Äòdefault_gains‚Äô: [20.0, 15.0, 12.0, 8.0, 35.0, 5.0], ‚Äògain_count‚Äô: 6, ‚Äòdescription‚Äô: ‚ÄòClassical sliding mode controller with boundary layer‚Äô, ‚Äòsupports_dynamics‚Äô: True, ‚Äòrequired_params‚Äô: [‚Äògains‚Äô, ‚Äòmax_force‚Äô, ‚Äòboundary_layer‚Äô] }, # ‚Ä¶ additional controllers</a></li>
<li class="toctree-l1"><a class="reference internal" href="troubleshooting_guide.html">Factory Troubleshooting and Diagnostics Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="troubleshooting_guide.html#github-issue-6-factory-integration-resolution-overview-this-troubleshooting-guide-addresses-common-issues-diagnostic-procedures-and-approaches-for-the-enhanced-controller-factory-system-implemented-in-github-issue-6-resolution-the-guide-is-organized-by-symptom-categories-with-systematic-diagnostic-workflows-and-validated-solutions-quick-diagnostic-checklist-immediate-health-check-run-this-diagnostic-script-to-quickly-identify-factory-system-status-python">GitHub Issue #6 Factory Integration Resolution ### Overview This troubleshooting guide addresses common issues, diagnostic procedures, and approaches for the enhanced controller factory system implemented in GitHub Issue #6 resolution. The guide is organized by symptom categories with systematic diagnostic workflows and validated solutions. ## Quick Diagnostic Checklist ### üîç <strong>Immediate Health Check</strong> Run this diagnostic script to quickly identify factory system status: ```python</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="production_deployment_guide.html">Production Deployment Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="production_deployment_guide.html#github-issue-6-enhanced-factory-system-overview-this-production-deployment-guide-covers-the-deployment-monitoring-and-maintenance-of-the-enhanced-controller-factory-system-implemented-in-github-issue-6-resolution-the-guide-ensures-reliable-operation-in-production-environments-with-proper-quality-gates-and-monitoring-production-readiness-assessment-current-production-readiness-score-8-5-10-improved-from-6-1-10-due-to-github-issue-6-resolution-verified-production-ready-components-1-thread-safety-resolved-thread-safe-locking-implementation-timeout-protection-for-lock-acquisition-extensive-concurrent-operation-testing-no-detected-deadlock-conditions-2-parameter-validation-enhanced-type-safe-parameter-validation-with-detailed-error-messages-automatic-deprecation-handling-and-migration-gain-bounds-checking-controller-specific-validation-rules-3-error-handling-improved-graceful-fallback-mechanisms-exception-handling-detailed-diagnostic-information-automatic-error-recovery-patterns-4-memory-management-optimized-bounded-memory-usage-patterns-efficient-controller-instantiation-no-memory-leaks-detected-in-stress-testing-proper-resource-cleanup-5-performance-benchmarked-sub-millisecond-controller-creation-optimized-pso-integration-workflows-minimal-cpu-overhead-scalable-concurrent-operations-areas-requiring-monitoring-1-configuration-validation-requires-runtime-monitoring">GitHub Issue #6 Enhanced Factory System ### Overview This production deployment guide covers the deployment, monitoring, and maintenance of the enhanced controller factory system implemented in GitHub Issue #6 resolution. The guide ensures reliable operation in production environments with proper quality gates and monitoring. ## Production Readiness Assessment ### Current Production Readiness Score: <strong>8.5/10</strong> <strong>Improved from 6.1/10</strong> due to GitHub Issue #6 resolution: #### ‚úÖ <strong>Verified Production-Ready Components</strong> 1. <strong>Thread Safety</strong>: ‚úÖ <strong>RESOLVED</strong> - thread-safe locking implementation - Timeout protection for lock acquisition - Extensive concurrent operation testing - No detected deadlock conditions 2. <strong>Parameter Validation</strong>: ‚úÖ <strong>ENHANCED</strong> - Type-safe parameter validation with detailed error messages - Automatic deprecation handling and migration - gain bounds checking - Controller-specific validation rules 3. <strong>Error Handling</strong>: ‚úÖ <strong>IMPROVED</strong> - Graceful fallback mechanisms - exception handling - Detailed diagnostic information - Automatic error recovery patterns 4. <strong>Memory Management</strong>: ‚úÖ <strong>OPTIMIZED</strong> - Bounded memory usage patterns - Efficient controller instantiation - No memory leaks detected in stress testing - Proper resource cleanup 5. <strong>Performance</strong>: ‚úÖ <strong>BENCHMARKED</strong> - Sub-millisecond controller creation - Optimized PSO integration workflows - Minimal CPU overhead - Scalable concurrent operations #### ‚ö†Ô∏è <strong>Areas Requiring Monitoring</strong> 1. <strong>Configuration Validation</strong>: Requires runtime monitoring</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="production_deployment_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="production_deployment_guide.html#runnable-false-def-production-readiness-check-production-readiness-validation-import-time-import-threading-import-numpy-as-np-from-src-controllers-factory-import-create-controller-list-available-controllers-get-default-gains-create-pso-controller-factory-smctype-print-production-readiness-assessment-n-results-basic-functionality-false-thread-safety-false-performance-false-pso-integration-false-error-handling-false-memory-stability-false-1-basic-functionality-test-print-1-testing-basic-functionality-try-controllers-list-available-controllers-if-len-controllers-4-expect-at-least-4-controller-types-for-controller-type-in-controllers-gains-get-default-gains-controller-type-controller-create-controller-controller-type-gains-gains-test-control-computation-test-state-np-array-0-1-0-1-0-0-0-0-0-0-0-0-result-controller-compute-control-test-state-control-value-result-u-if-hasattr-result-u-else-result-if-not-np-isfinite-control-value-raise-valueerror-f-invalid-control-output-control-value-results-basic-functionality-true-print-basic-functionality-test-passed-else-print-f-insufficient-controllers-available-len-controllers-except-exception-as-e-print-f-basic-functionality-test-failed-e-2-thread-safety-test-print-n2-testing-thread-safety-try-def-concurrent-creation-return-create-controller-classical-smc-gains-20-6-test-concurrent-controller-creation-start-time-time-time-threads-for-in-range-10-thread-threading-thread-target-concurrent-creation-threads-append-thread-thread-start-for-thread-in-threads-thread-join-timeout-5-if-thread-is-alive-raise-timeouterror-thread-did-not-complete-in-time-execution-time-time-time-start-time-if-execution-time-10-should-complete-within-10-seconds-results-thread-safety-true-print-f-thread-safety-test-passed-execution-time-2f-s-else-print-f-thread-safety-test-slow-execution-time-2f-s-except-exception-as-e-print-f-thread-safety-test-failed-e-3-performance-test-print-n3-testing-performance-try-measure-controller-creation-time-creation-times-for-in-range-100-start-time-perf-counter-create-controller-classical-smc-gains-20-6-end-time-perf-counter-creation-times-append-end-start-1000-convert-to-ms-avg-time-sum-creation-times-len-creation-times-max-time-max-creation-times-if-avg-time-5-0-and-max-time-50-0-5ms-average-50ms-max-results-performance-true-print-f-performance-test-passed-avg-avg-time-2f-ms-max-max-time-2f-ms-else-print-f-performance-test-failed-avg-avg-time-2f-ms-max-max-time-2f-ms-except-exception-as-e-print-f-performance-test-failed-e-4-pso-integration-test-print-n4-testing-pso-integration-try-factory-func-create-pso-controller-factory-smctype-classical-check-required-attributes-if-hasattr-factory-func-n-gains-and-hasattr-factory-func-controller-type-test-gains-20-15-12-8-35-5-controller-factory-func-test-gains-if-controller-is-not-none-results-pso-integration-true-print-pso-integration-test-passed-else-print-pso-factory-returned-none-else-print-pso-factory-missing-required-attributes-except-exception-as-e-print-f-pso-integration-test-failed-e-5-error-handling-test-print-n5-testing-error-handling-try-error-cases-invalid-type-10-6-classical-smc-10-3-wrong-gain-count-classical-smc-10-6-negative-gains-handled-errors-0-for-controller-type-gains-in-error-cases-try-create-controller-controller-type-gains-gains-print-f-expected-error-not-raised-for-controller-type-except-valueerror-typeerror-as-e-handled-errors-1-except-exception-as-e-print-f-unexpected-error-type-for-controller-type-type-e-if-handled-errors-len-error-cases-1-allow-one-unexpected-case-results-error-handling-true-print-f-error-handling-test-passed-handled-errors-len-error-cases-cases-else-print-f-error-handling-test-failed-handled-errors-len-error-cases-cases-except-exception-as-e-print-f-error-handling-test-failed-e-6-memory-stability-test-print-n6-testing-memory-stability-try-import-psutil-import-os-process-psutil-process-os-getpid-initial-memory-process-memory-info-rss-1024-1024-mb-create-and-destroy-many-controllers-for-in-range-1000-controller-create-controller-classical-smc-gains-20-6-del-controller-final-memory-process-memory-info-rss-1024-1024-memory-increase-final-memory-initial-memory-if-memory-increase-10-less-than-10mb-increase-results-memory-stability-true-print-f-memory-stability-test-passed-memory-increase-2f-mb-increase-else-print-f-memory-stability-test-failed-memory-increase-2f-mb-increase-except-importerror-print-psutil-not-available-skipping-memory-test-results-memory-stability-true-assume-pass-if-can-t-test-except-exception-as-e-print-f-memory-stability-test-failed-e-summary-passed-tests-sum-results-values-total-tests-len-results-success-rate-passed-tests-total-tests-100-print-f-n-production-readiness-summary-print-f-tests-passed-passed-tests-total-tests-print-f-success-rate-success-rate-1f-if-success-rate-95-print-ready-for-production-deployment-return-true-elif-success-rate-80-print-deployment-with-monitoring-recommended-return-false-else-print-not-ready-for-production-return-false-run-production-readiness-check">runnable: false def production_readiness_check(): ‚Äú‚Äù‚Äùproduction readiness validation.‚Äù‚Äù‚Äù import time import threading import numpy as np from src.controllers.factory import ( create_controller, list_available_controllers, get_default_gains, create_pso_controller_factory, SMCType ) print(‚Äú=== Production Readiness Assessment ===\n‚Äù) results = { ‚Äòbasic_functionality‚Äô: False, ‚Äòthread_safety‚Äô: False, ‚Äòperformance‚Äô: False, ‚Äòpso_integration‚Äô: False, ‚Äòerror_handling‚Äô: False, ‚Äòmemory_stability‚Äô: False } # 1. Basic Functionality Test print(‚Äú1. Testing Basic Functionality‚Ä¶‚Äù) try: controllers = list_available_controllers() if len(controllers) &gt;= 4: # Expect at least 4 controller types for controller_type in controllers: gains = get_default_gains(controller_type) controller = create_controller(controller_type, gains=gains) # Test control computation test_state = np.array([0.1, 0.1, 0.0, 0.0, 0.0, 0.0]) result = controller.compute_control(test_state, (), {}) control_value = result.u if hasattr(result, ‚Äòu‚Äô) else result if not np.isfinite(control_value): raise ValueError(f‚ÄùInvalid control output: {control_value}‚Äù) results[‚Äòbasic_functionality‚Äô] = True print(‚Äù ‚úÖ Basic functionality test PASSED‚Äù) else: print(f‚Äù ‚ùå Insufficient controllers available: {len(controllers)}‚Äù) except Exception as e: print(f‚Äù ‚ùå Basic functionality test FAILED: {e}‚Äù) # 2. Thread Safety Test print(‚Äú\n2. Testing Thread Safety‚Ä¶‚Äù) try: def concurrent_creation(): return create_controller(‚Äòclassical_smc‚Äô, gains=[20]*6) # Test concurrent controller creation start_time = time.time() threads = [] for _ in range(10): thread = threading.Thread(target=concurrent_creation) threads.append(thread) thread.start() for thread in threads: thread.join(timeout=5) if thread.is_alive(): raise TimeoutError(‚ÄúThread did not complete in time‚Äù) execution_time = time.time() - start_time if execution_time &lt; 10: # Should complete within 10 seconds results[‚Äòthread_safety‚Äô] = True print(f‚Äù ‚úÖ Thread safety test PASSED ({execution_time:.2f}s)‚Äù) else: print(f‚Äù ‚ùå Thread safety test SLOW ({execution_time:.2f}s)‚Äù) except Exception as e: print(f‚Äù ‚ùå Thread safety test FAILED: {e}‚Äù) # 3. Performance Test print(‚Äú\n3. Testing Performance‚Ä¶‚Äù) try: # Measure controller creation time creation_times = [] for _ in range(100): start = time.perf_counter() create_controller(‚Äòclassical_smc‚Äô, gains=[20]*6) end = time.perf_counter() creation_times.append((end - start) * 1000) # Convert to ms avg_time = sum(creation_times) / len(creation_times) max_time = max(creation_times) if avg_time &lt; 5.0 and max_time &lt; 50.0: # &lt; 5ms average, &lt; 50ms max results[‚Äòperformance‚Äô] = True print(f‚Äù ‚úÖ Performance test PASSED (avg: {avg_time:.2f}ms, max: {max_time:.2f}ms)‚Äù) else: print(f‚Äù ‚ùå Performance test FAILED (avg: {avg_time:.2f}ms, max: {max_time:.2f}ms)‚Äù) except Exception as e: print(f‚Äù ‚ùå Performance test FAILED: {e}‚Äù) # 4. PSO Integration Test print(‚Äú\n4. Testing PSO Integration‚Ä¶‚Äù) try: factory_func = create_pso_controller_factory(SMCType.CLASSICAL) # Check required attributes if hasattr(factory_func, ‚Äòn_gains‚Äô) and hasattr(factory_func, ‚Äòcontroller_type‚Äô): test_gains = [20, 15, 12, 8, 35, 5] controller = factory_func(test_gains) if controller is not None: results[‚Äòpso_integration‚Äô] = True print(‚Äù ‚úÖ PSO integration test PASSED‚Äù) else: print(‚Äù ‚ùå PSO factory returned None‚Äù) else: print(‚Äù ‚ùå PSO factory missing required attributes‚Äù) except Exception as e: print(f‚Äù ‚ùå PSO integration test FAILED: {e}‚Äù) # 5. Error Handling Test print(‚Äú\n5. Testing Error Handling‚Ä¶‚Äù) try: error_cases = [ (‚Äòinvalid_type‚Äô, [10]*6), (‚Äòclassical_smc‚Äô, [10]*3), # Wrong gain count (‚Äòclassical_smc‚Äô, [-10]*6), # Negative gains ] handled_errors = 0 for controller_type, gains in error_cases: try: create_controller(controller_type, gains=gains) print(f‚Äù ‚ö†Ô∏è Expected error not raised for {controller_type}‚Äù) except (ValueError, TypeError) as e: handled_errors += 1 except Exception as e: print(f‚Äù ‚ö†Ô∏è Unexpected error type for {controller_type}: {type(e)}‚Äù) if handled_errors &gt;= len(error_cases) - 1: # Allow one unexpected case results[‚Äòerror_handling‚Äô] = True print(f‚Äù ‚úÖ Error handling test PASSED ({handled_errors}/{len(error_cases)} cases)‚Äù) else: print(f‚Äù ‚ùå Error handling test FAILED ({handled_errors}/{len(error_cases)} cases)‚Äù) except Exception as e: print(f‚Äù ‚ùå Error handling test FAILED: {e}‚Äù) # 6. Memory Stability Test print(‚Äú\n6. Testing Memory Stability‚Ä¶‚Äù) try: import psutil import os process = psutil.Process(os.getpid()) initial_memory = process.memory_info().rss / 1024 / 1024 # MB # Create and destroy many controllers for _ in range(1000): controller = create_controller(‚Äòclassical_smc‚Äô, gains=[20]*6) del controller final_memory = process.memory_info().rss / 1024 / 1024 memory_increase = final_memory - initial_memory if memory_increase &lt; 10: # Less than 10MB increase results[‚Äòmemory_stability‚Äô] = True print(f‚Äù ‚úÖ Memory stability test PASSED ({memory_increase:.2f}MB increase)‚Äù) else: print(f‚Äù ‚ùå Memory stability test FAILED ({memory_increase:.2f}MB increase)‚Äù) except ImportError: print(‚Äù ‚ö†Ô∏è psutil not available, skipping memory test‚Äù) results[‚Äòmemory_stability‚Äô] = True # Assume pass if can‚Äôt test except Exception as e: print(f‚Äù ‚ùå Memory stability test FAILED: {e}‚Äù) # Summary passed_tests = sum(results.values()) total_tests = len(results) success_rate = (passed_tests / total_tests) * 100 print(f‚Äù\n=== Production Readiness Summary ===‚Äù) print(f‚ÄùTests passed: {passed_tests}/{total_tests}‚Äù) print(f‚ÄùSuccess rate: {success_rate:.1f}%‚Äù) if success_rate &gt;= 95: print(‚Äù‚úÖ READY FOR PRODUCTION DEPLOYMENT‚Äù) return True elif success_rate &gt;= 80: print(‚Äù‚ö†Ô∏è DEPLOYMENT WITH MONITORING RECOMMENDED‚Äù) return False else: print(‚Äù‚ùå NOT READY FOR PRODUCTION‚Äù) return False # Run production readiness check</a></li>
<li class="toctree-l1"><a class="reference internal" href="production_deployment_guide.html#production-config-yaml">production_config.yaml</a></li>
<li class="toctree-l1"><a class="reference internal" href="production_deployment_guide.html#production-environment-variables">Production environment variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="production_deployment_guide.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="production_deployment_guide.html#runnable-false-def-verify-production-dependencies-verify-all-required-dependencies-are-available-required-packages-numpy-1-19-0-scipy-1-6-0-pydantic-1-8-0-pyyaml-5-4-0-optional-packages-psutil-5-8-0-for-memory-monitoring-prometheus-client-0-12-0-for-metrics-structlog-21-0-0-for-structured-logging-print-verifying-production-dependencies-check-required-packages-for-package-version-in-required-packages-items-try-import-package-print-f-package-version-available-except-importerror-print-f-package-version-missing-required-return-false-check-optional-packages-for-package-version-in-optional-packages-items-try-import-package-print-f-package-version-available-except-importerror-print-f-package-version-missing-optional-return-true-verify-dependencies">runnable: false def verify_production_dependencies(): ‚Äú‚Äù‚ÄùVerify all required dependencies are available.‚Äù‚Äù‚Äù required_packages = { ‚Äònumpy‚Äô: ‚Äò&gt;=1.19.0‚Äô, ‚Äòscipy‚Äô: ‚Äò&gt;=1.6.0‚Äô, ‚Äòpydantic‚Äô: ‚Äò&gt;=1.8.0‚Äô, ‚Äòpyyaml‚Äô: ‚Äò&gt;=5.4.0‚Äô } optional_packages = { ‚Äòpsutil‚Äô: ‚Äò&gt;=5.8.0‚Äô, # For memory monitoring ‚Äòprometheus_client‚Äô: ‚Äò&gt;=0.12.0‚Äô, # For metrics ‚Äòstructlog‚Äô: ‚Äò&gt;=21.0.0‚Äô # For structured logging } print(‚ÄúVerifying production dependencies‚Ä¶‚Äù) # Check required packages for package, version in required_packages.items(): try: <strong>import</strong>(package) print(f‚Äù‚úÖ {package} {version} - Available‚Äù) except ImportError: print(f‚Äù‚ùå {package} {version} - MISSING (REQUIRED)‚Äù) return False # Check optional packages for package, version in optional_packages.items(): try: <strong>import</strong>(package) print(f‚Äù‚úÖ {package} {version} - Available‚Äù) except ImportError: print(f‚Äù‚ö†Ô∏è {package} {version} - Missing (optional)‚Äù) return True # Verify dependencies</a></li>
<li class="toctree-l1"><a class="reference internal" href="production_deployment_guide.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="production_deployment_guide.html#runnable-false-class-productionfactorydeployment-production-deployment-manager-for-factory-system-def-init-self-config-self-config-config-self-current-version-none-self-new-version-none-self-rollback-data-def-pre-deployment-checks-self-run-pre-deployment-validation-checks-dependencies-self-verify-dependencies-configuration-self-validate-configuration-compatibility-self-check-backward-compatibility-performance-self-benchmark-performance-health-self-health-check-passed-all-checks-values-failed-checks-name-for-name-result-in-checks-items-if-not-result-if-not-passed-raise-runtimeerror-f-pre-deployment-checks-failed-failed-checks-return-checks-def-deploy-with-canary-self-percentage-10-deploy-new-factory-version-using-canary-strategy-print-f-starting-canary-deployment-percentage-traffic-1-deploy-to-canary-environment-canary-success-self-deploy-canary-if-not-canary-success-raise-runtimeerror-canary-deployment-failed-2-monitor-canary-performance-canary-metrics-self-monitor-canary-duration-300-5-minutes-if-not-self-evaluate-canary-metrics-canary-metrics-self-rollback-canary-raise-runtimeerror-canary-metrics-below-threshold-3-gradual-rollout-for-percentage-in-25-50-75-100-print-f-rolling-out-to-percentage-of-traffic-self-update-traffic-split-percentage-metrics-self-monitor-deployment-duration-180-3-minutes-if-not-self-evaluate-metrics-metrics-self-rollback-deployment-raise-runtimeerror-f-rollout-failed-at-percentage-print-deployment-completed-successfully-return-true-def-rollback-deployment-self-rollback-to-previous-version-print-rolling-back-deployment-restore-previous-factory-version-self-restore-factory-version-verify-rollback-success-health-ok-self-health-check-if-not-health-ok-raise-runtimeerror-rollback-verification-failed-print-rollback-completed-successfully-example-deployment">runnable: false class ProductionFactoryDeployment: ‚Äú‚Äù‚ÄùProduction deployment manager for factory system.‚Äù‚Äù‚Äù def <strong>init</strong>(self, config): self.config = config self.current_version = None self.new_version = None self.rollback_data = {} def pre_deployment_checks(self): ‚Äú‚Äù‚ÄùRun pre-deployment validation.‚Äù‚Äù‚Äù checks = { ‚Äòdependencies‚Äô: self.verify_dependencies(), ‚Äòconfiguration‚Äô: self.validate_configuration(), ‚Äòcompatibility‚Äô: self.check_backward_compatibility(), ‚Äòperformance‚Äô: self.benchmark_performance(), ‚Äòhealth‚Äô: self.health_check() } passed = all(checks.values()) failed_checks = [name for name, result in checks.items() if not result] if not passed: raise RuntimeError(f‚ÄùPre-deployment checks failed: {failed_checks}‚Äù) return checks def deploy_with_canary(self, percentage=10): ‚Äú‚Äù‚ÄùDeploy new factory version using canary strategy.‚Äù‚Äù‚Äù print(f‚ÄùStarting canary deployment ({percentage}% traffic)‚Äù) # 1. Deploy to canary environment canary_success = self.deploy_canary() if not canary_success: raise RuntimeError(‚ÄúCanary deployment failed‚Äù) # 2. Monitor canary performance canary_metrics = self.monitor_canary(duration=300) # 5 minutes if not self.evaluate_canary_metrics(canary_metrics): self.rollback_canary() raise RuntimeError(‚ÄúCanary metrics below threshold‚Äù) # 3. Gradual rollout for percentage in [25, 50, 75, 100]: print(f‚ÄùRolling out to {percentage}% of traffic‚Äù) self.update_traffic_split(percentage) metrics = self.monitor_deployment(duration=180) # 3 minutes if not self.evaluate_metrics(metrics): self.rollback_deployment() raise RuntimeError(f‚ÄùRollout failed at {percentage}%‚Äù) print(‚Äù‚úÖ Deployment completed successfully‚Äù) return True def rollback_deployment(self): ‚Äú‚Äù‚ÄùRollback to previous version.‚Äù‚Äù‚Äù print(‚ÄùüîÑ Rolling back deployment‚Äù) # Restore previous factory version self.restore_factory_version() # Verify rollback success health_ok = self.health_check() if not health_ok: raise RuntimeError(‚ÄúRollback verification failed‚Äù) print(‚Äù‚úÖ Rollback completed successfully‚Äù) # Example deployment</a></li>
<li class="toctree-l1"><a class="reference internal" href="production_deployment_guide.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="production_deployment_guide.html#runnable-false-def-blue-green-deployment-blue-green-deployment-strategy-print-starting-blue-green-deployment-setup-green-environment-green-env-setup-green-environment-deploy-to-green-environment-deploy-to-green-green-env-smoke-test-green-environment-if-not-smoke-test-green-green-env-cleanup-green-green-env-raise-runtimeerror-green-environment-smoke-test-failed-switch-traffic-to-green-switch-traffic-to-green-green-env-monitor-for-issues-monitor-duration-600-10-minutes-if-monitor-green-environment-monitor-duration-success-cleanup-blue-environment-cleanup-blue-environment-print-blue-green-deployment-successful-else-issues-detected-rollback-to-blue-switch-traffic-to-blue-cleanup-green-green-env-raise-runtimeerror-green-environment-issues-detected-rolled-back-run-blue-green-deployment">runnable: false def blue_green_deployment(): ‚Äú‚Äù‚ÄùBlue-green deployment strategy.‚Äù‚Äù‚Äù print(‚ÄúStarting blue-green deployment‚Äù) # Setup green environment green_env = setup_green_environment() # Deploy to green environment deploy_to_green(green_env) # Smoke test green environment if not smoke_test_green(green_env): cleanup_green(green_env) raise RuntimeError(‚ÄúGreen environment smoke test failed‚Äù) # Switch traffic to green switch_traffic_to_green(green_env) # Monitor for issues monitor_duration = 600 # 10 minutes if monitor_green_environment(monitor_duration): # Success - cleanup blue environment cleanup_blue_environment() print(‚Äù‚úÖ Blue-green deployment successful‚Äù) else: # Issues detected - rollback to blue switch_traffic_to_blue() cleanup_green(green_env) raise RuntimeError(‚ÄúGreen environment issues detected, rolled back‚Äù) # Run blue-green deployment</a></li>
<li class="toctree-l1"><a class="reference internal" href="production_deployment_guide.html#id4">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="production_deployment_guide.html#runnable-false-class-factoryalertmanager-production-alerting-for-factory-system-def-init-self-config-self-config-config-self-alert-history-self-suppression-rules-def-evaluate-alerts-self-metrics-health-status-evaluate-alert-conditions-alerts-performance-alerts-if-controller-creation-time-in-metrics-avg-time-metrics-controller-creation-time-mean-if-avg-time-10-10ms-threshold-alerts-append-type-performance-severity-warning-if-avg-time-20-else-critical-message-f-high-controller-creation-time-avg-time-2f-ms-metric-controller-creation-time-value-avg-time-threshold-10-memory-alerts-if-memory-usage-in-metrics-memory-mb-metrics-memory-usage-current-if-memory-mb-500-500mb-threshold-alerts-append-type-memory-severity-warning-if-memory-mb-1000-else-critical-message-f-high-memory-usage-memory-mb-2f-mb-metric-memory-usage-value-memory-mb-threshold-500-health-alerts-if-health-status-overall-status-healthy-failed-checks-name-for-name-check-in-health-status-checks-items-if-not-check-get-healthy-false-alerts-append-type-health-severity-critical-if-health-status-overall-status-unhealthy-else-warning-message-f-health-check-failed-join-failed-checks-failed-checks-failed-checks-apply-suppression-rules-alerts-self-apply-suppression-alerts-send-notifications-for-alert-in-alerts-self-send-notification-alert-return-alerts-def-apply-suppression-self-alerts-apply-alert-suppression-rules-suppressed-alerts-for-alert-in-alerts-alert-key-f-alert-type-alert-get-metric-unknown-check-if-alert-is-already-suppressed-if-alert-key-in-self-suppression-rules-last-sent-self-suppression-rules-alert-key-if-time-time-last-sent-300-5-minute-suppression-continue-suppressed-alerts-append-alert-self-suppression-rules-alert-key-time-time-return-suppressed-alerts-def-send-notification-self-alert-send-alert-notification-print-f-alert-alert-severity-upper-alert-message-in-production-integrate-with-slack-teams-notifications-pagerduty-email-alerts-sms-notifications-monitoring-dashboards-self-alert-history-append-timestamp-time-time-alert-alert-setup-alert-manager">runnable: false class FactoryAlertManager: ‚Äú‚Äù‚ÄùProduction alerting for factory system.‚Äù‚Äù‚Äù def <strong>init</strong>(self, config): self.config = config self.alert_history = [] self.suppression_rules = {} def evaluate_alerts(self, metrics, health_status): ‚Äú‚Äù‚ÄùEvaluate alert conditions.‚Äù‚Äù‚Äù alerts = [] # Performance alerts if ‚Äòcontroller_creation_time‚Äô in metrics: avg_time = metrics[‚Äòcontroller_creation_time‚Äô][‚Äòmean‚Äô] if avg_time &gt; 10: # 10ms threshold alerts.append({ ‚Äòtype‚Äô: ‚Äòperformance‚Äô, ‚Äòseverity‚Äô: ‚Äòwarning‚Äô if avg_time &lt; 20 else ‚Äòcritical‚Äô, ‚Äòmessage‚Äô: f‚ÄôHigh controller creation time: {avg_time:.2f}ms‚Äô, ‚Äòmetric‚Äô: ‚Äòcontroller_creation_time‚Äô, ‚Äòvalue‚Äô: avg_time, ‚Äòthreshold‚Äô: 10 }) # Memory alerts if ‚Äòmemory_usage‚Äô in metrics: memory_mb = metrics[‚Äòmemory_usage‚Äô][‚Äòcurrent‚Äô] if memory_mb &gt; 500: # 500MB threshold alerts.append({ ‚Äòtype‚Äô: ‚Äòmemory‚Äô, ‚Äòseverity‚Äô: ‚Äòwarning‚Äô if memory_mb &lt; 1000 else ‚Äòcritical‚Äô, ‚Äòmessage‚Äô: f‚ÄôHigh memory usage: {memory_mb:.2f}MB‚Äô, ‚Äòmetric‚Äô: ‚Äòmemory_usage‚Äô, ‚Äòvalue‚Äô: memory_mb, ‚Äòthreshold‚Äô: 500 }) # Health alerts if health_status[‚Äòoverall_status‚Äô] != ‚Äòhealthy‚Äô: failed_checks = [name for name, check in health_status[‚Äòchecks‚Äô].items() if not check.get(‚Äòhealthy‚Äô, False)] alerts.append({ ‚Äòtype‚Äô: ‚Äòhealth‚Äô, ‚Äòseverity‚Äô: ‚Äòcritical‚Äô if health_status[‚Äòoverall_status‚Äô] == ‚Äòunhealthy‚Äô else ‚Äòwarning‚Äô, ‚Äòmessage‚Äô: f‚ÄôHealth check failed: {‚Äù, ‚Äú.join(failed_checks)}‚Äô, ‚Äòfailed_checks‚Äô: failed_checks }) # Apply suppression rules alerts = self.apply_suppression(alerts) # Send notifications for alert in alerts: self.send_notification(alert) return alerts def apply_suppression(self, alerts): ‚Äú‚Äù‚ÄùApply alert suppression rules.‚Äù‚Äù‚Äù suppressed_alerts = [] for alert in alerts: alert_key = f‚Äù{alert[‚Äòtype‚Äô]}_{alert.get(‚Äòmetric‚Äô, ‚Äòunknown‚Äô)}‚Äù # Check if alert is already suppressed if alert_key in self.suppression_rules: last_sent = self.suppression_rules[alert_key] if time.time() - last_sent &lt; 300: # 5 minute suppression continue suppressed_alerts.append(alert) self.suppression_rules[alert_key] = time.time() return suppressed_alerts def send_notification(self, alert): ‚Äú‚Äù‚ÄùSend alert notification.‚Äù‚Äù‚Äù print(f‚Äùüö® ALERT [{alert[‚Äòseverity‚Äô].upper()}]: {alert[‚Äòmessage‚Äô]}‚Äù) # In production, integrate with: # - Slack/Teams notifications # - PagerDuty # - Email alerts # - SMS notifications # - Monitoring dashboards self.alert_history.append({ ‚Äòtimestamp‚Äô: time.time(), ‚Äòalert‚Äô: alert }) # Setup alert manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="production_deployment_guide.html#id5">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="production_deployment_guide.html#runnable-false-class-factorymaintenancemanager-production-maintenance-for-factory-system-def-init-self-self-maintenance-log-def-daily-maintenance-self-daily-maintenance-tasks-print-running-daily-maintenance-tasks-health-check-self-comprehensive-health-check-performance-validation-self-validate-performance-memory-cleanup-self-memory-cleanup-log-rotation-self-rotate-logs-cache-cleanup-self-cleanup-cache-metrics-collection-self-collect-daily-metrics-results-for-task-name-task-func-in-tasks-try-print-f-running-task-name-result-task-func-results-task-name-success-true-result-result-print-f-task-name-completed-except-exception-as-e-results-task-name-success-false-error-str-e-print-f-task-name-failed-e-self-log-maintenance-results-daily-results-return-results-def-weekly-maintenance-self-weekly-maintenance-tasks-print-running-weekly-maintenance-tasks-deep-performance-analysis-self-deep-performance-analysis-memory-leak-detection-self-detect-memory-leaks-configuration-validation-self-validate-configuration-dependency-updates-check-self-check-dependency-updates-security-scan-self-security-scan-backup-verification-self-verify-backups-results-for-task-name-task-func-in-tasks-try-print-f-running-task-name-result-task-func-results-task-name-success-true-result-result-print-f-task-name-completed-except-exception-as-e-results-task-name-success-false-error-str-e-print-f-task-name-failed-e-self-log-maintenance-results-weekly-results-return-results-def-comprehensive-health-check-self-health-validation-run-extended-health-checks-health-checker-factoryhealthchecker-return-health-checker-perform-health-check-def-validate-performance-self-validate-factory-performance-meets-slas-from-src-controllers-factory-import-create-controller-import-time-performance-test-creation-times-for-in-range-100-start-time-perf-counter-create-controller-classical-smc-gains-20-6-creation-times-append-time-perf-counter-start-1000-avg-time-sum-creation-times-len-creation-times-p95-time-sorted-creation-times-95-p99-time-sorted-creation-times-99-sla-validation-sla-results-average-creation-time-ms-avg-time-p95-creation-time-ms-p95-time-p99-creation-time-ms-p99-time-sla-met-avg-time-5-0-and-p95-time-10-0-and-p99-time-25-0-return-sla-results-def-memory-cleanup-self-cleanup-memory-and-optimize-garbage-collection-import-gc-import-psutil-import-os-force-garbage-collection-before-memory-psutil-process-os-getpid-memory-info-rss-1024-1024-collected-gc-collect-after-memory-psutil-process-os-getpid-memory-info-rss-1024-1024-return-objects-collected-collected-memory-before-mb-before-memory-memory-after-mb-after-memory-memory-freed-mb-before-memory-after-memory-def-rotate-logs-self-rotate-and-compress-log-files-implement-log-rotation-logic-return-logs-rotated-0-size-saved-mb-0-def-cleanup-cache-self-cleanup-factory-cache-if-implemented-implement-cache-cleanup-logic-return-cache-entries-removed-0-def-collect-daily-metrics-self-collect-and-store-daily-metrics-collect-metrics-for-historical-analysis-return-metrics-collected-true-def-log-maintenance-results-self-maintenance-type-results-log-maintenance-results-maintenance-record-timestamp-time-time-type-maintenance-type-results-results-success-rate-sum-1-for-r-in-results-values-if-r-success-len-results-self-maintenance-log-append-maintenance-record-print-f-maintenance-maintenance-type-completed-with-maintenance-record-success-rate-1-success-rate-setup-maintenance-manager">runnable: false class FactoryMaintenanceManager: ‚Äú‚Äù‚ÄùProduction maintenance for factory system.‚Äù‚Äù‚Äù def <strong>init</strong>(self): self.maintenance_log = [] def daily_maintenance(self): ‚Äú‚Äù‚ÄùDaily maintenance tasks.‚Äù‚Äù‚Äù print(‚ÄúRunning daily maintenance‚Ä¶‚Äù) tasks = [ (‚ÄòHealth Check‚Äô, self.comprehensive_health_check), (‚ÄòPerformance Validation‚Äô, self.validate_performance), (‚ÄòMemory Cleanup‚Äô, self.memory_cleanup), (‚ÄòLog Rotation‚Äô, self.rotate_logs), (‚ÄòCache Cleanup‚Äô, self.cleanup_cache), (‚ÄòMetrics Collection‚Äô, self.collect_daily_metrics) ] results = {} for task_name, task_func in tasks: try: print(f‚Äù Running {task_name}‚Ä¶‚Äù) result = task_func() results[task_name] = {‚Äòsuccess‚Äô: True, ‚Äòresult‚Äô: result} print(f‚Äù ‚úÖ {task_name} completed‚Äù) except Exception as e: results[task_name] = {‚Äòsuccess‚Äô: False, ‚Äòerror‚Äô: str(e)} print(f‚Äù ‚ùå {task_name} failed: {e}‚Äù) self.log_maintenance_results(‚Äòdaily‚Äô, results) return results def weekly_maintenance(self): ‚Äú‚Äù‚ÄùWeekly maintenance tasks.‚Äù‚Äù‚Äù print(‚ÄúRunning weekly maintenance‚Ä¶‚Äù) tasks = [ (‚ÄòDeep Performance Analysis‚Äô, self.deep_performance_analysis), (‚ÄòMemory Leak Detection‚Äô, self.detect_memory_leaks), (‚ÄòConfiguration Validation‚Äô, self.validate_configuration), (‚ÄòDependency Updates Check‚Äô, self.check_dependency_updates), (‚ÄòSecurity Scan‚Äô, self.security_scan), (‚ÄòBackup Verification‚Äô, self.verify_backups) ] results = {} for task_name, task_func in tasks: try: print(f‚Äù Running {task_name}‚Ä¶‚Äù) result = task_func() results[task_name] = {‚Äòsuccess‚Äô: True, ‚Äòresult‚Äô: result} print(f‚Äù ‚úÖ {task_name} completed‚Äù) except Exception as e: results[task_name] = {‚Äòsuccess‚Äô: False, ‚Äòerror‚Äô: str(e)} print(f‚Äù ‚ùå {task_name} failed: {e}‚Äù) self.log_maintenance_results(‚Äòweekly‚Äô, results) return results def comprehensive_health_check(self): ‚Äú‚Äù‚Äùhealth validation.‚Äù‚Äù‚Äù # Run extended health checks health_checker = FactoryHealthChecker() return health_checker.perform_health_check() def validate_performance(self): ‚Äú‚Äù‚ÄùValidate factory performance meets SLAs.‚Äù‚Äù‚Äù from src.controllers.factory import create_controller import time # Performance test creation_times = [] for _ in range(100): start = time.perf_counter() create_controller(‚Äòclassical_smc‚Äô, gains=[20]*6) creation_times.append((time.perf_counter() - start) * 1000) avg_time = sum(creation_times) / len(creation_times) p95_time = sorted(creation_times)[95] p99_time = sorted(creation_times)[99] # SLA validation sla_results = { ‚Äòaverage_creation_time_ms‚Äô: avg_time, ‚Äòp95_creation_time_ms‚Äô: p95_time, ‚Äòp99_creation_time_ms‚Äô: p99_time, ‚Äòsla_met‚Äô: avg_time &lt; 5.0 and p95_time &lt; 10.0 and p99_time &lt; 25.0 } return sla_results def memory_cleanup(self): ‚Äú‚Äù‚ÄùCleanup memory and optimize garbage collection.‚Äù‚Äù‚Äù import gc import psutil import os # Force garbage collection before_memory = psutil.Process(os.getpid()).memory_info().rss / 1024 / 1024 collected = gc.collect() after_memory = psutil.Process(os.getpid()).memory_info().rss / 1024 / 1024 return { ‚Äòobjects_collected‚Äô: collected, ‚Äòmemory_before_mb‚Äô: before_memory, ‚Äòmemory_after_mb‚Äô: after_memory, ‚Äòmemory_freed_mb‚Äô: before_memory - after_memory } def rotate_logs(self): ‚Äú‚Äù‚ÄùRotate and compress log files.‚Äù‚Äù‚Äù # Implement log rotation logic return {‚Äòlogs_rotated‚Äô: 0, ‚Äòsize_saved_mb‚Äô: 0} def cleanup_cache(self): ‚Äú‚Äù‚ÄùCleanup factory cache if implemented.‚Äù‚Äù‚Äù # Implement cache cleanup logic return {‚Äòcache_entries_removed‚Äô: 0} def collect_daily_metrics(self): ‚Äú‚Äù‚ÄùCollect and store daily metrics.‚Äù‚Äù‚Äù # Collect metrics for historical analysis return {‚Äòmetrics_collected‚Äô: True} def log_maintenance_results(self, maintenance_type, results): ‚Äú‚Äù‚ÄùLog maintenance results.‚Äù‚Äù‚Äù maintenance_record = { ‚Äòtimestamp‚Äô: time.time(), ‚Äòtype‚Äô: maintenance_type, ‚Äòresults‚Äô: results, ‚Äòsuccess_rate‚Äô: sum(1 for r in results.values() if r[‚Äòsuccess‚Äô]) / len(results) } self.maintenance_log.append(maintenance_record) print(f‚ÄùMaintenance {maintenance_type} completed with {maintenance_record[‚Äòsuccess_rate‚Äô]:.1%} success rate‚Äù) # Setup maintenance manager</a></li>
</ul>
</div>
</section>
<section id="configuration-migration">
<h3>Configuration &amp; Migration<a class="headerlink" href="#configuration-migration" title="Link to this heading">¬∂</a></h3>
<div class="toctree-wrapper compound">
<p class="caption" role="heading"><span class="caption-text">Configuration &amp; Migration</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="configuration_reference.html">Factory Configuration Reference ## Overview The SMC Controller Factory system provides a unified, type-safe interface for creating sliding mode controllers with parameter validation, deprecation management, and PSO optimization integration. This reference documents the factory configuration system implemented to resolve GitHub Issue #6. ## Factory Architecture ### Core Components ```</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration_reference.html#runnable-false-thread-safe-factory-operations">runnable: false # Thread-safe factory operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="migration_guide.html">Migration Guide for Existing Configurations ## Overview This migration guide helps users transition from older controller factory configurations to the enhanced GitHub Issue #6 resolution implementation. The guide covers automated migration tools, manual migration procedures, and best practices for maintaining system stability during transitions. ## Migration Overview ### What Changed in GitHub Issue #6 Resolution The factory integration fixes address several critical areas: 1. <strong>Parameter Interface Unification</strong>: Standardized parameter handling across all SMC controller types</a></li>
<li class="toctree-l1"><a class="reference internal" href="migration_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="migration_guide.html#runnable-false-pre-migration-configuration-v1-x">runnable: false # Pre-Migration Configuration (v1.x)</a></li>
<li class="toctree-l1"><a class="reference internal" href="migration_guide.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="migration_guide.html#runnable-false-def-interactive-migration-wizard-none-interactive-step-by-step-migration-wizard-for-complex-configurations-print-smc-controller-configuration-migration-wizard-n-step-1-configuration-file-location-config-path-input-enter-path-to-configuration-file-strip-if-not-os-path-exists-config-path-print-f-error-file-not-found-config-path-return-step-2-backup-preferences-create-backup-input-create-backup-before-migration-y-n-strip-lower-create-backup-create-backup-n-step-3-migration-analysis-print-nanalyzing-configuration-migrator-configurationmigrationutility-load-and-analyze-configuration-try-with-open-config-path-r-as-f-if-config-path-endswith-yml-yaml-import-yaml-config-data-yaml-safe-load-f-else-import-json-config-data-json-load-f-analyze-deprecations-warner-controllerdeprecationwarner-analysis-results-if-controllers-in-config-data-for-controller-type-controller-config-in-config-data-controllers-items-if-isinstance-controller-config-dict-warnings-warner-check-deprecated-parameters-controller-type-controller-config-analysis-results-controller-type-warnings-display-analysis-total-warnings-sum-len-warnings-for-warnings-in-analysis-results-values-if-total-warnings-0-print-no-deprecated-parameters-found-configuration-is-up-to-date-return-print-f-found-total-warnings-deprecated-parameters-for-controller-type-warnings-in-analysis-results-items-if-warnings-print-f-n-controller-type-for-warning-in-warnings-print-f-warning-old-parameter-warning-migration-guide-step-4-confirm-migration-proceed-input-f-nproceed-with-migration-y-n-strip-lower-if-proceed-n-print-migration-cancelled-return-step-5-perform-migration-print-nperforming-migration-result-migrator-migrate-configuration-file-config-file-path-config-path-create-backup-create-backup-if-result-success-print-migration-completed-successfully-if-result-backup-file-print-f-backup-created-result-backup-file-step-6-validation-validate-input-nvalidate-migrated-configuration-y-n-strip-lower-if-validate-n-validation-result-migrator-validate-migrated-configuration-result-migration-summary-get-migrated-config-if-validation-result-success-print-validation-passed-configuration-is-ready-to-use-else-print-validation-issues-found-for-issue-in-validation-result-issues-print-f-issue-else-print-f-migration-failed-result-error-except-exception-as-e-print-f-error-during-migration-analysis-e-run-the-wizard">runnable: false def interactive_migration_wizard() -&gt; None: ‚Äú‚Äù‚Äù Interactive step-by-step migration wizard for complex configurations. ‚Äú‚Äù‚Äù print(‚Äú=== SMC Controller Configuration Migration Wizard ===\n‚Äù) # Step 1: Configuration file location config_path = input(‚ÄúEnter path to configuration file: ‚Äú).strip() if not os.path.exists(config_path): print(f‚ÄùError: File not found - {config_path}‚Äù) return # Step 2: Backup preferences create_backup = input(‚ÄúCreate backup before migration? (Y/n): ‚Äú).strip().lower() create_backup = create_backup != ‚Äòn‚Äô # Step 3: Migration analysis print(‚Äú\nAnalyzing configuration‚Ä¶‚Äù) migrator = ConfigurationMigrationUtility() # Load and analyze configuration try: with open(config_path, ‚Äòr‚Äô) as f: if config_path.endswith((‚Äò.yml‚Äô, ‚Äò.yaml‚Äô)): import yaml config_data = yaml.safe_load(f) else: import json config_data = json.load(f) # Analyze deprecations warner = ControllerDeprecationWarner() analysis_results = {} if ‚Äòcontrollers‚Äô in config_data: for controller_type, controller_config in config_data[‚Äòcontrollers‚Äô].items(): if isinstance(controller_config, dict): _, warnings = warner.check_deprecated_parameters(controller_type, controller_config) analysis_results[controller_type] = warnings # Display analysis total_warnings = sum(len(warnings) for warnings in analysis_results.values()) if total_warnings == 0: print(‚Äù‚úì No deprecated parameters found. Configuration is up to date.‚Äù) return print(f‚ÄùFound {total_warnings} deprecated parameters:‚Äù) for controller_type, warnings in analysis_results.items(): if warnings: print(f‚Äù\n {controller_type}:‚Äù) for warning in warnings: print(f‚Äù - {warning.old_parameter}: {warning.migration_guide}‚Äù) # Step 4: Confirm migration proceed = input(f‚Äù\nProceed with migration? (Y/n): ‚Äú).strip().lower() if proceed == ‚Äòn‚Äô: print(‚ÄúMigration cancelled.‚Äù) return # Step 5: Perform migration print(‚Äú\nPerforming migration‚Ä¶‚Äù) result = migrator.migrate_configuration_file( config_file_path=config_path, create_backup=create_backup ) if result.success: print(‚Äù‚úì Migration completed successfully!‚Äù) if result.backup_file: print(f‚Äù Backup created: {result.backup_file}‚Äù) # Step 6: Validation validate = input(‚Äú\nValidate migrated configuration? (Y/n): ‚Äú).strip().lower() if validate != ‚Äòn‚Äô: validation_result = migrator.validate_migrated_configuration( result.migration_summary.get(‚Äòmigrated_config‚Äô, {}) ) if validation_result.success: print(‚Äù‚úì Validation passed - configuration is ready to use.‚Äù) else: print(‚Äù‚ö† Validation issues found:‚Äù) for issue in validation_result.issues: print(f‚Äù - {issue}‚Äù) else: print(f‚Äù‚úó Migration failed: {result.error}‚Äù) except Exception as e: print(f‚ÄùError during migration analysis: {e}‚Äù) # Run the wizard</a></li>
<li class="toctree-l1"><a class="reference internal" href="migration_guide.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="migration_guide.html#runnable-false-def-migrate-classical-smc-manually-old-config-dict-str-any-dict-str-any-manual-migration-procedure-for-classical-smc-configurations-changes-1-combine-gains-and-k-switching-into-6-element-gains-array-2-remove-invalid-gamma-parameter-3-rename-switch-function-to-switch-method-4-ensure-boundary-layer-parameter-is-present-new-config-step-1-handle-gains-array-gains-old-config-get-gains-8-0-6-0-4-0-3-0-15-0-if-gains-has-only-5-elements-add-k-switching-as-6th-element-if-len-gains-5-k-switching-old-config-get-k-switching-2-0-gains-gains-k-switching-elif-len-gains-5-fill-missing-gains-with-defaults-default-gains-8-0-6-0-4-0-3-0-15-0-2-0-gains-gains-default-gains-len-gains-new-config-gains-gains-6-ensure-exactly-6-gains-step-2-handle-deprecated-parameters-deprecated-params-gamma-adaptation-rate-k-switching-for-param-in-deprecated-params-if-param-in-old-config-if-param-gamma-print-f-warning-removed-invalid-gamma-parameter-for-classical-smc-elif-param-adaptation-rate-print-f-warning-removed-adaptation-rate-not-valid-for-classical-smc-k-switching-already-handled-in-gains-array-step-3-handle-renamed-parameters-if-switch-function-in-old-config-new-config-switch-method-old-config-switch-function-print-f-migrated-switch-function-switch-method-step-4-copy-valid-parameters-valid-params-max-force-dt-boundary-layer-switch-method-damping-gain-dynamics-model-for-param-in-valid-params-if-param-in-old-config-new-config-param-old-config-param-step-5-ensure-required-parameters-have-defaults-new-config-setdefault-max-force-150-0-new-config-setdefault-dt-0-001-new-config-setdefault-boundary-layer-0-02-return-new-config-example-usage">runnable: false def migrate_classical_smc_manually(old_config: Dict[str, Any]) -&gt; Dict[str, Any]: ‚Äú‚Äù‚Äù Manual migration procedure for Classical SMC configurations. Changes: 1. Combine gains and K_switching into 6-element gains array 2. Remove invalid ‚Äògamma‚Äô parameter 3. Rename ‚Äòswitch_function‚Äô to ‚Äòswitch_method‚Äô 4. Ensure boundary_layer parameter is present ‚Äú‚Äù‚Äù new_config = {} # Step 1: Handle gains array gains = old_config.get(‚Äògains‚Äô, [8.0, 6.0, 4.0, 3.0, 15.0]) # If gains has only 5 elements, add K_switching as 6th element if len(gains) == 5: K_switching = old_config.get(‚ÄòK_switching‚Äô, 2.0) gains = gains + [K_switching] elif len(gains) &lt; 5: # Fill missing gains with defaults default_gains = [8.0, 6.0, 4.0, 3.0, 15.0, 2.0] gains = gains + default_gains[len(gains):] new_config[‚Äògains‚Äô] = gains[:6] # Ensure exactly 6 gains # Step 2: Handle deprecated parameters deprecated_params = [‚Äògamma‚Äô, ‚Äòadaptation_rate‚Äô, ‚ÄòK_switching‚Äô] for param in deprecated_params: if param in old_config: if param == ‚Äògamma‚Äô: print(f‚ÄùWarning: Removed invalid ‚Äògamma‚Äô parameter for Classical SMC‚Äù) elif param == ‚Äòadaptation_rate‚Äô: print(f‚ÄùWarning: Removed ‚Äòadaptation_rate‚Äô - not valid for Classical SMC‚Äù) # K_switching already handled in gains array # Step 3: Handle renamed parameters if ‚Äòswitch_function‚Äô in old_config: new_config[‚Äòswitch_method‚Äô] = old_config[‚Äòswitch_function‚Äô] print(f‚ÄùMigrated: switch_function -&gt; switch_method‚Äù) # Step 4: Copy valid parameters valid_params = [ ‚Äòmax_force‚Äô, ‚Äòdt‚Äô, ‚Äòboundary_layer‚Äô, ‚Äòswitch_method‚Äô, ‚Äòdamping_gain‚Äô, ‚Äòdynamics_model‚Äô ] for param in valid_params: if param in old_config: new_config[param] = old_config[param] # Step 5: Ensure required parameters have defaults new_config.setdefault(‚Äòmax_force‚Äô, 150.0) new_config.setdefault(‚Äòdt‚Äô, 0.001) new_config.setdefault(‚Äòboundary_layer‚Äô, 0.02) return new_config # Example usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="migration_guide.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="migration_guide.html#runnable-false-def-migrate-adaptive-smc-manually-old-config-dict-str-any-dict-str-any-manual-migration-procedure-for-adaptive-smc-configurations-changes-1-combine-gains-and-adaptation-gain-into-5-element-gains-array-2-rename-boundary-layer-thickness-to-boundary-layer-3-split-estimate-bounds-into-k-min-and-k-max-4-rename-adaptation-law-to-alpha-new-config-step-1-handle-gains-array-with-gamma-adaptation-rate-gains-old-config-get-gains-12-0-10-0-6-0-5-0-if-gains-has-only-4-elements-add-adaptation-gain-as-5th-element-if-len-gains-4-adaptation-gain-old-config-get-adaptation-gain-2-5-gains-gains-adaptation-gain-elif-len-gains-4-fill-missing-gains-with-defaults-default-gains-12-0-10-0-6-0-5-0-2-5-gains-gains-default-gains-len-gains-new-config-gains-gains-5-ensure-exactly-5-gains-step-2-handle-renamed-parameters-renames-boundary-layer-thickness-boundary-layer-adaptation-law-alpha-for-old-name-new-name-in-renames-items-if-old-name-in-old-config-new-config-new-name-old-config-old-name-print-f-migrated-old-name-new-name-step-3-handle-split-parameters-if-estimate-bounds-in-old-config-bounds-old-config-estimate-bounds-if-isinstance-bounds-list-tuple-and-len-bounds-2-new-config-k-min-bounds-0-new-config-k-max-bounds-1-print-f-split-estimate-bounds-k-min-k-max-else-print-f-warning-invalid-estimate-bounds-format-using-defaults-new-config-k-min-0-1-new-config-k-max-100-0-step-4-copy-valid-parameters-valid-params-max-force-dt-boundary-layer-leak-rate-adapt-rate-limit-k-min-k-max-k-init-alpha-dead-zone-smooth-switch-dynamics-model-for-param-in-valid-params-if-param-in-old-config-new-config-param-old-config-param-step-5-ensure-required-parameters-have-defaults-new-config-setdefault-max-force-150-0-new-config-setdefault-dt-0-001-new-config-setdefault-boundary-layer-0-01-new-config-setdefault-leak-rate-0-01-new-config-setdefault-adapt-rate-limit-10-0-new-config-setdefault-k-min-0-1-new-config-setdefault-k-max-100-0-new-config-setdefault-k-init-10-0-new-config-setdefault-alpha-0-5-return-new-config-example-usage">runnable: false def migrate_adaptive_smc_manually(old_config: Dict[str, Any]) -&gt; Dict[str, Any]: ‚Äú‚Äù‚Äù Manual migration procedure for Adaptive SMC configurations. Changes: 1. Combine gains and adaptation_gain into 5-element gains array 2. Rename ‚Äòboundary_layer_thickness‚Äô to ‚Äòboundary_layer‚Äô 3. Split ‚Äòestimate_bounds‚Äô into ‚ÄòK_min‚Äô and ‚ÄòK_max‚Äô 4. Rename ‚Äòadaptation_law‚Äô to ‚Äòalpha‚Äô ‚Äú‚Äù‚Äù new_config = {} # Step 1: Handle gains array with gamma (adaptation rate) gains = old_config.get(‚Äògains‚Äô, [12.0, 10.0, 6.0, 5.0]) # If gains has only 4 elements, add adaptation_gain as 5th element if len(gains) == 4: adaptation_gain = old_config.get(‚Äòadaptation_gain‚Äô, 2.5) gains = gains + [adaptation_gain] elif len(gains) &lt; 4: # Fill missing gains with defaults default_gains = [12.0, 10.0, 6.0, 5.0, 2.5] gains = gains + default_gains[len(gains):] new_config[‚Äògains‚Äô] = gains[:5] # Ensure exactly 5 gains # Step 2: Handle renamed parameters renames = { ‚Äòboundary_layer_thickness‚Äô: ‚Äòboundary_layer‚Äô, ‚Äòadaptation_law‚Äô: ‚Äòalpha‚Äô } for old_name, new_name in renames.items(): if old_name in old_config: new_config[new_name] = old_config[old_name] print(f‚ÄùMigrated: {old_name} -&gt; {new_name}‚Äù) # Step 3: Handle split parameters if ‚Äòestimate_bounds‚Äô in old_config: bounds = old_config[‚Äòestimate_bounds‚Äô] if isinstance(bounds, (list, tuple)) and len(bounds) == 2: new_config[‚ÄòK_min‚Äô] = bounds[0] new_config[‚ÄòK_max‚Äô] = bounds[1] print(f‚ÄùSplit: estimate_bounds -&gt; K_min, K_max‚Äù) else: print(f‚ÄùWarning: Invalid estimate_bounds format, using defaults‚Äù) new_config[‚ÄòK_min‚Äô] = 0.1 new_config[‚ÄòK_max‚Äô] = 100.0 # Step 4: Copy valid parameters valid_params = [ ‚Äòmax_force‚Äô, ‚Äòdt‚Äô, ‚Äòboundary_layer‚Äô, ‚Äòleak_rate‚Äô, ‚Äòadapt_rate_limit‚Äô, ‚ÄòK_min‚Äô, ‚ÄòK_max‚Äô, ‚ÄòK_init‚Äô, ‚Äòalpha‚Äô, ‚Äòdead_zone‚Äô, ‚Äòsmooth_switch‚Äô, ‚Äòdynamics_model‚Äô ] for param in valid_params: if param in old_config: new_config[param] = old_config[param] # Step 5: Ensure required parameters have defaults new_config.setdefault(‚Äòmax_force‚Äô, 150.0) new_config.setdefault(‚Äòdt‚Äô, 0.001) new_config.setdefault(‚Äòboundary_layer‚Äô, 0.01) new_config.setdefault(‚Äòleak_rate‚Äô, 0.01) new_config.setdefault(‚Äòadapt_rate_limit‚Äô, 10.0) new_config.setdefault(‚ÄòK_min‚Äô, 0.1) new_config.setdefault(‚ÄòK_max‚Äô, 100.0) new_config.setdefault(‚ÄòK_init‚Äô, 10.0) new_config.setdefault(‚Äòalpha‚Äô, 0.5) return new_config # Example usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="migration_guide.html#id4">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="migration_guide.html#runnable-false-def-migrate-sta-smc-manually-old-config-dict-str-any-dict-str-any-manual-migration-procedure-for-super-twisting-smc-configurations-changes-1-combine-k1-k2-and-other-gains-into-6-element-gains-array-2-rename-alpha-power-to-power-exponent-3-rename-switching-function-type-to-switch-method-new-config-step-1-handle-gains-array-with-k1-k2-integration-gains-old-config-get-gains-if-k1-and-k2-are-separate-parameters-integrate-them-if-k1-in-old-config-and-k2-in-old-config-k1-old-config-k1-k2-old-config-k2-if-gains-array-exists-assume-it-contains-k1-k2-lam1-lam2-if-len-gains-4-gains-k1-k2-gains-4-else-create-full-gains-array-default-surface-gains-25-0-18-0-12-0-8-0-surface-gains-gains-default-surface-gains-len-gains-gains-k1-k2-surface-gains-4-print-f-integrated-k1-k1-k2-k2-into-gains-array-elif-len-gains-6-fill-missing-gains-with-defaults-default-gains-35-0-20-0-25-0-18-0-12-0-8-0-gains-gains-default-gains-len-gains-new-config-gains-gains-6-ensure-exactly-6-gains-step-2-handle-renamed-parameters-renames-alpha-power-power-exponent-switching-function-type-switch-method-for-old-name-new-name-in-renames-items-if-old-name-in-old-config-new-config-new-name-old-config-old-name-print-f-migrated-old-name-new-name-step-3-copy-valid-parameters-valid-params-max-force-dt-power-exponent-regularization-boundary-layer-switch-method-damping-gain-dynamics-model-for-param-in-valid-params-if-param-in-old-config-new-config-param-old-config-param-step-4-ensure-required-parameters-have-defaults-new-config-setdefault-max-force-150-0-new-config-setdefault-dt-0-001-new-config-setdefault-power-exponent-0-5-new-config-setdefault-regularization-1e-6-new-config-setdefault-boundary-layer-0-01-new-config-setdefault-switch-method-tanh-return-new-config-example-usage">runnable: false def migrate_sta_smc_manually(old_config: Dict[str, Any]) -&gt; Dict[str, Any]: ‚Äú‚Äù‚Äù Manual migration procedure for Super-Twisting SMC configurations. Changes: 1. Combine K1, K2, and other gains into 6-element gains array 2. Rename ‚Äòalpha_power‚Äô to ‚Äòpower_exponent‚Äô 3. Rename ‚Äòswitching_function_type‚Äô to ‚Äòswitch_method‚Äô ‚Äú‚Äù‚Äù new_config = {} # Step 1: Handle gains array with K1, K2 integration gains = old_config.get(‚Äògains‚Äô, []) # If K1 and K2 are separate parameters, integrate them if ‚ÄòK1‚Äô in old_config and ‚ÄòK2‚Äô in old_config: K1 = old_config[‚ÄòK1‚Äô] K2 = old_config[‚ÄòK2‚Äô] # If gains array exists, assume it contains [k1, k2, lam1, lam2] if len(gains) &gt;= 4: gains = [K1, K2] + gains[:4] else: # Create full gains array default_surface_gains = [25.0, 18.0, 12.0, 8.0] surface_gains = gains + default_surface_gains[len(gains):] gains = [K1, K2] + surface_gains[:4] print(f‚ÄùIntegrated: K1={K1}, K2={K2} into gains array‚Äù) elif len(gains) &lt; 6: # Fill missing gains with defaults default_gains = [35.0, 20.0, 25.0, 18.0, 12.0, 8.0] gains = gains + default_gains[len(gains):] new_config[‚Äògains‚Äô] = gains[:6] # Ensure exactly 6 gains # Step 2: Handle renamed parameters renames = { ‚Äòalpha_power‚Äô: ‚Äòpower_exponent‚Äô, ‚Äòswitching_function_type‚Äô: ‚Äòswitch_method‚Äô } for old_name, new_name in renames.items(): if old_name in old_config: new_config[new_name] = old_config[old_name] print(f‚ÄùMigrated: {old_name} -&gt; {new_name}‚Äù) # Step 3: Copy valid parameters valid_params = [ ‚Äòmax_force‚Äô, ‚Äòdt‚Äô, ‚Äòpower_exponent‚Äô, ‚Äòregularization‚Äô, ‚Äòboundary_layer‚Äô, ‚Äòswitch_method‚Äô, ‚Äòdamping_gain‚Äô, ‚Äòdynamics_model‚Äô ] for param in valid_params: if param in old_config: new_config[param] = old_config[param] # Step 4: Ensure required parameters have defaults new_config.setdefault(‚Äòmax_force‚Äô, 150.0) new_config.setdefault(‚Äòdt‚Äô, 0.001) new_config.setdefault(‚Äòpower_exponent‚Äô, 0.5) new_config.setdefault(‚Äòregularization‚Äô, 1e-6) new_config.setdefault(‚Äòboundary_layer‚Äô, 0.01) new_config.setdefault(‚Äòswitch_method‚Äô, ‚Äòtanh‚Äô) return new_config # Example usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="migration_guide.html#id5">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="migration_guide.html#runnable-false-def-migrate-hybrid-smc-manually-old-config-dict-str-any-dict-str-any-manual-migration-procedure-for-hybrid-smc-configurations-changes-1-rename-mode-to-hybrid-mode-2-replace-sub-controller-gains-with-full-sub-configurations-3-update-switch-threshold-to-switching-criteria-new-config-step-1-handle-surface-gains-4-elements-for-hybrid-controller-gains-old-config-get-gains-18-0-12-0-10-0-8-0-new-config-gains-gains-4-ensure-exactly-4-surface-gains-step-2-handle-mode-parameter-if-mode-in-old-config-new-config-hybrid-mode-old-config-mode-print-f-migrated-mode-hybrid-mode-else-new-config-hybrid-mode-classical-adaptive-default-step-3-handle-sub-controller-configurations-if-sub-controller-gains-in-old-config-sub-gains-old-config-sub-controller-gains-create-proper-sub-configurations-if-isinstance-sub-gains-dict-classical-gains-sub-gains-get-classical-20-0-15-0-12-0-8-0-35-0-5-0-adaptive-gains-sub-gains-get-adaptive-25-0-18-0-15-0-10-0-4-0-else-use-defaults-if-format-is-unrecognized-classical-gains-20-0-15-0-12-0-8-0-35-0-5-0-adaptive-gains-25-0-18-0-15-0-10-0-4-0-create-full-sub-configurations-new-config-classical-config-gains-classical-gains-max-force-150-0-dt-0-001-boundary-layer-0-02-new-config-adaptive-config-gains-adaptive-gains-max-force-150-0-dt-0-001-leak-rate-0-01-adapt-rate-limit-10-0-k-min-0-1-k-max-100-0-k-init-10-0-alpha-0-5-print-converted-sub-controller-gains-full-sub-configurations-step-4-handle-switching-criteria-if-switch-threshold-in-old-config-threshold-old-config-switch-threshold-new-config-switching-criteria-error-threshold-threshold-time-threshold-2-0-default-print-converted-switch-threshold-switching-criteria-step-5-copy-valid-parameters-valid-params-dt-max-force-k1-init-k2-init-gamma1-gamma2-dynamics-model-hybrid-mode-classical-config-adaptive-config-for-param-in-valid-params-if-param-in-old-config-new-config-param-old-config-param-step-6-ensure-required-parameters-have-defaults-new-config-setdefault-dt-0-001-new-config-setdefault-max-force-150-0-new-config-setdefault-k1-init-5-0-new-config-setdefault-k2-init-3-0-new-config-setdefault-gamma1-0-5-new-config-setdefault-gamma2-0-3-return-new-config-example-usage">runnable: false def migrate_hybrid_smc_manually(old_config: Dict[str, Any]) -&gt; Dict[str, Any]: ‚Äú‚Äù‚Äù Manual migration procedure for Hybrid SMC configurations. Changes: 1. Rename ‚Äòmode‚Äô to ‚Äòhybrid_mode‚Äô 2. Replace ‚Äòsub_controller_gains‚Äô with full sub-configurations 3. Update ‚Äòswitch_threshold‚Äô to ‚Äòswitching_criteria‚Äô ‚Äú‚Äù‚Äù new_config = {} # Step 1: Handle surface gains (4 elements for hybrid controller) gains = old_config.get(‚Äògains‚Äô, [18.0, 12.0, 10.0, 8.0]) new_config[‚Äògains‚Äô] = gains[:4] # Ensure exactly 4 surface gains # Step 2: Handle mode parameter if ‚Äòmode‚Äô in old_config: new_config[‚Äòhybrid_mode‚Äô] = old_config[‚Äòmode‚Äô] print(f‚ÄùMigrated: mode -&gt; hybrid_mode‚Äù) else: new_config[‚Äòhybrid_mode‚Äô] = ‚ÄòCLASSICAL_ADAPTIVE‚Äô # Default # Step 3: Handle sub-controller configurations if ‚Äòsub_controller_gains‚Äô in old_config: sub_gains = old_config[‚Äòsub_controller_gains‚Äô] # Create proper sub-configurations if isinstance(sub_gains, dict): classical_gains = sub_gains.get(‚Äòclassical‚Äô, [20.0, 15.0, 12.0, 8.0, 35.0, 5.0]) adaptive_gains = sub_gains.get(‚Äòadaptive‚Äô, [25.0, 18.0, 15.0, 10.0, 4.0]) else: # Use defaults if format is unrecognized classical_gains = [20.0, 15.0, 12.0, 8.0, 35.0, 5.0] adaptive_gains = [25.0, 18.0, 15.0, 10.0, 4.0] # Create full sub-configurations new_config[‚Äòclassical_config‚Äô] = { ‚Äògains‚Äô: classical_gains, ‚Äòmax_force‚Äô: 150.0, ‚Äòdt‚Äô: 0.001, ‚Äòboundary_layer‚Äô: 0.02 } new_config[‚Äòadaptive_config‚Äô] = { ‚Äògains‚Äô: adaptive_gains, ‚Äòmax_force‚Äô: 150.0, ‚Äòdt‚Äô: 0.001, ‚Äòleak_rate‚Äô: 0.01, ‚Äòadapt_rate_limit‚Äô: 10.0, ‚ÄòK_min‚Äô: 0.1, ‚ÄòK_max‚Äô: 100.0, ‚ÄòK_init‚Äô: 10.0, ‚Äòalpha‚Äô: 0.5 } print(‚ÄúConverted: sub_controller_gains -&gt; full sub-configurations‚Äù) # Step 4: Handle switching criteria if ‚Äòswitch_threshold‚Äô in old_config: threshold = old_config[‚Äòswitch_threshold‚Äô] new_config[‚Äòswitching_criteria‚Äô] = { ‚Äòerror_threshold‚Äô: threshold, ‚Äòtime_threshold‚Äô: 2.0 # Default } print(‚ÄúConverted: switch_threshold -&gt; switching_criteria‚Äù) # Step 5: Copy valid parameters valid_params = [ ‚Äòdt‚Äô, ‚Äòmax_force‚Äô, ‚Äòk1_init‚Äô, ‚Äòk2_init‚Äô, ‚Äògamma1‚Äô, ‚Äògamma2‚Äô, ‚Äòdynamics_model‚Äô, ‚Äòhybrid_mode‚Äô, ‚Äòclassical_config‚Äô, ‚Äòadaptive_config‚Äô ] for param in valid_params: if param in old_config: new_config[param] = old_config[param] # Step 6: Ensure required parameters have defaults new_config.setdefault(‚Äòdt‚Äô, 0.001) new_config.setdefault(‚Äòmax_force‚Äô, 150.0) new_config.setdefault(‚Äòk1_init‚Äô, 5.0) new_config.setdefault(‚Äòk2_init‚Äô, 3.0) new_config.setdefault(‚Äògamma1‚Äô, 0.5) new_config.setdefault(‚Äògamma2‚Äô, 0.3) return new_config # Example usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="migration_guide.html#before-migration-config-old-yaml">Before Migration (config_old.yaml)</a></li>
<li class="toctree-l1"><a class="reference internal" href="migration_guide.html#id6">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="migration_guide.html#runnable-false-def-run-migration-test-suite-none-test-suite-for-migration-functionality-print-migration-test-suite-n-test-1-classical-smc-migration-print-test-1-classical-smc-migration-old-classical-gains-10-5-8-3-15-k-switching-2-0-gamma-0-1-switch-function-sign-new-classical-migrate-classical-smc-manually-old-classical-validation-checks-assert-len-new-classical-gains-6-classical-smc-should-have-6-gains-assert-new-classical-gains-5-2-0-k-switching-should-be-integrated-assert-gamma-not-in-new-classical-invalid-gamma-should-be-removed-assert-new-classical-get-switch-method-sign-switch-function-should-be-renamed-print-classical-smc-migration-test-passed-n-test-2-adaptive-smc-migration-print-test-2-adaptive-smc-migration-old-adaptive-gains-12-10-6-5-adaptation-gain-2-5-boundary-layer-thickness-0-02-estimate-bounds-0-1-100-0-new-adaptive-migrate-adaptive-smc-manually-old-adaptive-validation-checks-assert-len-new-adaptive-gains-5-adaptive-smc-should-have-5-gains-assert-new-adaptive-gains-4-2-5-adaptation-gain-should-be-integrated-assert-new-adaptive-get-boundary-layer-0-02-parameter-should-be-renamed-assert-new-adaptive-get-k-min-0-1-estimate-bounds-should-be-split-assert-new-adaptive-get-k-max-100-0-estimate-bounds-should-be-split-print-adaptive-smc-migration-test-passed-n-test-3-sta-smc-migration-print-test-3-sta-smc-migration-old-sta-k1-35-0-k2-20-0-gains-25-18-12-8-alpha-power-0-5-new-sta-migrate-sta-smc-manually-old-sta-validation-checks-assert-len-new-sta-gains-6-sta-smc-should-have-6-gains-assert-new-sta-gains-0-35-0-k1-should-be-first-gain-assert-new-sta-gains-1-20-0-k2-should-be-second-gain-assert-new-sta-get-power-exponent-0-5-alpha-power-should-be-renamed-print-sta-smc-migration-test-passed-n-print-all-migration-tests-passed-run-the-test-suite">runnable: false def run_migration_test_suite() -&gt; None: ‚Äú‚Äù‚Äù test suite for migration functionality. ‚Äú‚Äù‚Äù print(‚Äú=== Migration Test Suite ===\n‚Äù) # Test 1: Classical SMC migration print(‚ÄúTest 1: Classical SMC Migration‚Äù) old_classical = { ‚Äògains‚Äô: [10, 5, 8, 3, 15], ‚ÄòK_switching‚Äô: 2.0, ‚Äògamma‚Äô: 0.1, ‚Äòswitch_function‚Äô: ‚Äòsign‚Äô } new_classical = migrate_classical_smc_manually(old_classical) # Validation checks assert len(new_classical[‚Äògains‚Äô]) == 6, ‚ÄúClassical SMC should have 6 gains‚Äù assert new_classical[‚Äògains‚Äô][5] == 2.0, ‚ÄúK_switching should be integrated‚Äù assert ‚Äògamma‚Äô not in new_classical, ‚ÄúInvalid gamma should be removed‚Äù assert new_classical.get(‚Äòswitch_method‚Äô) == ‚Äòsign‚Äô, ‚Äúswitch_function should be renamed‚Äù print(‚Äù‚úì Classical SMC migration test passed\n‚Äù) # Test 2: Adaptive SMC migration print(‚ÄúTest 2: Adaptive SMC Migration‚Äù) old_adaptive = { ‚Äògains‚Äô: [12, 10, 6, 5], ‚Äòadaptation_gain‚Äô: 2.5, ‚Äòboundary_layer_thickness‚Äô: 0.02, ‚Äòestimate_bounds‚Äô: [0.1, 100.0] } new_adaptive = migrate_adaptive_smc_manually(old_adaptive) # Validation checks assert len(new_adaptive[‚Äògains‚Äô]) == 5, ‚ÄúAdaptive SMC should have 5 gains‚Äù assert new_adaptive[‚Äògains‚Äô][4] == 2.5, ‚ÄúAdaptation gain should be integrated‚Äù assert new_adaptive.get(‚Äòboundary_layer‚Äô) == 0.02, ‚ÄúParameter should be renamed‚Äù assert new_adaptive.get(‚ÄòK_min‚Äô) == 0.1, ‚Äúestimate_bounds should be split‚Äù assert new_adaptive.get(‚ÄòK_max‚Äô) == 100.0, ‚Äúestimate_bounds should be split‚Äù print(‚Äù‚úì Adaptive SMC migration test passed\n‚Äù) # Test 3: STA-SMC migration print(‚ÄúTest 3: STA-SMC Migration‚Äù) old_sta = { ‚ÄòK1‚Äô: 35.0, ‚ÄòK2‚Äô: 20.0, ‚Äògains‚Äô: [25, 18, 12, 8], ‚Äòalpha_power‚Äô: 0.5 } new_sta = migrate_sta_smc_manually(old_sta) # Validation checks assert len(new_sta[‚Äògains‚Äô]) == 6, ‚ÄúSTA-SMC should have 6 gains‚Äù assert new_sta[‚Äògains‚Äô][0] == 35.0, ‚ÄúK1 should be first gain‚Äù assert new_sta[‚Äògains‚Äô][1] == 20.0, ‚ÄúK2 should be second gain‚Äù assert new_sta.get(‚Äòpower_exponent‚Äô) == 0.5, ‚Äúalpha_power should be renamed‚Äù print(‚Äù‚úì STA-SMC migration test passed\n‚Äù) print(‚ÄúAll migration tests passed! ‚úì‚Äù) # Run the test suite</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration_migration_mathematical_foundations.html">Configuration Migration Mathematical Foundations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="configuration_migration_mathematical_foundations.html#github-issue-6-factory-integration-scientific-validation-guide-overview-this-document-provides-the-mathematical-foundations-and-scientific-validation-for-configuration-migrations-in-the-enhanced-factory-system-it-bridges-control-theory-with-implementation-details-to-ensure-mathematically-sound-parameter-transformations-during-migration-mathematical-framework-for-parameter-migration-1-classical-smc-parameter-transformation-theoretical-foundation-classical-sliding-mode-control-uses-a-sliding-surface-designed-to-ensure-finite-time-convergence-to-the-desired-trajectory-the-mathematical-formulation-involves-sliding-surface-design">GitHub Issue #6 Factory Integration - Scientific Validation Guide ### Overview This document provides the mathematical foundations and scientific validation for configuration migrations in the enhanced factory system. It bridges control theory with implementation details to ensure mathematically sound parameter transformations during migration. ## Mathematical Framework for Parameter Migration ### 1. Classical SMC Parameter Transformation #### <strong>Theoretical Foundation</strong> Classical Sliding Mode Control uses a sliding surface designed to ensure finite-time convergence to the desired trajectory. The mathematical formulation involves: <strong>Sliding Surface Design:</strong></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="configuration_migration_mathematical_foundations.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration_migration_mathematical_foundations.html#runnable-false-def-migrate-hybrid-smc-parameters-mathematical-old-params-dict-str-any-dict-str-any-mathematically-sound-migration-for-hybrid-smc-parameters-mathematical-validation-1-preserve-mode-switching-stability-2-maintain-unified-surface-design-3-ensure-sub-controller-compatibility-new-params-extract-surface-gains-shared-across-all-modes-surface-gains-old-params-get-gains-18-0-12-0-10-0-8-0-if-len-surface-gains-4-raise-valueerror-hybrid-smc-requires-exactly-4-surface-gains-c1-1-c2-2-c1-lam1-c2-lam2-surface-gains-validate-surface-stability-if-any-g-0-for-g-in-c1-lam1-c2-lam2-raise-valueerror-all-surface-coefficients-must-be-positive-check-surface-eigenvalue-placement-for-stability-eigen1-lam1-c1-eigen2-lam2-c2-if-eigen1-0-or-eigen2-0-print-f-warning-surface-eigenvalues-eigen1-3f-eigen2-3f-may-indicate-instability-new-params-gains-surface-gains-handle-mode-parameter-migration-mode-mappings-mode-hybrid-mode-switch-threshold-switching-criteria-classical-params-classical-config-adaptive-params-adaptive-config-for-old-param-new-param-in-mode-mappings-items-if-old-param-in-old-params-if-old-param-switch-threshold-convert-scalar-threshold-to-criteria-dict-threshold-old-params-old-param-new-params-switching-criteria-error-threshold-threshold-time-threshold-2-0-default-time-threshold-performance-threshold-0-1-performance-based-switching-else-new-params-new-param-old-params-old-param-handle-sub-controller-gain-migration-if-sub-controller-gains-in-old-params-sub-gains-old-params-sub-controller-gains-if-isinstance-sub-gains-dict-create-proper-sub-controller-configurations-classical-gains-sub-gains-get-classical-20-0-15-0-12-0-8-0-35-0-5-0-adaptive-gains-sub-gains-get-adaptive-25-0-18-0-15-0-10-0-4-0-validate-sub-controller-gains-if-len-classical-gains-6-raise-valueerror-classical-sub-controller-requires-6-gains-if-len-adaptive-gains-5-raise-valueerror-adaptive-sub-controller-requires-5-gains-create-complete-sub-configurations-with-surface-coupling-new-params-classical-config-gains-classical-gains-max-force-old-params-get-max-force-150-0-boundary-layer-0-02-dt-old-params-get-dt-0-001-surface-coupling-true-ensure-surface-consistency-new-params-adaptive-config-gains-adaptive-gains-max-force-old-params-get-max-force-150-0-leak-rate-0-01-adapt-rate-limit-10-0-k-min-0-1-k-max-100-0-dt-old-params-get-dt-0-001-surface-coupling-true-ensure-surface-consistency-set-hybrid-specific-parameters-with-mathematical-justification-new-params-setdefault-hybrid-mode-classical-adaptive-conservative-default-new-params-setdefault-dt-0-001-fast-sampling-for-mode-switching-new-params-setdefault-max-force-150-0-shared-actuator-limit-advanced-hybrid-parameters-new-params-setdefault-mode-hysteresis-0-1-prevent-chattering-in-mode-switching-new-params-setdefault-transition-smoothing-true-smooth-mode-transitions-new-params-setdefault-surface-consistency-check-true-validate-surface-compatibility-validate-hybrid-mode-switching-stability-if-switching-criteria-in-new-params-criteria-new-params-switching-criteria-error-thresh-criteria-get-error-threshold-0-1-time-thresh-criteria-get-time-threshold-2-0-check-switching-frequency-to-prevent-chattering-min-dwell-time-0-1-minimum-time-in-each-mode-if-time-thresh-min-dwell-time-print-f-warning-short-time-threshold-time-thresh-s-may-cause-mode-chattering-return-new-params-mathematical-validation-example">runnable: false def migrate_hybrid_smc_parameters_mathematical(old_params: Dict[str, Any]) -&gt; Dict[str, Any]: ‚Äú‚Äù‚Äù Mathematically sound migration for Hybrid SMC parameters. Mathematical Validation: 1. Preserve mode switching stability 2. Maintain unified surface design 3. Ensure sub-controller compatibility ‚Äú‚Äù‚Äù new_params = {} # Extract surface gains (shared across all modes) surface_gains = old_params.get(‚Äògains‚Äô, [18.0, 12.0, 10.0, 8.0]) if len(surface_gains) != 4: raise ValueError(‚ÄúHybrid SMC requires exactly 4 surface gains [c‚ÇÅ, Œª‚ÇÅ, c‚ÇÇ, Œª‚ÇÇ]‚Äù) c1, lam1, c2, lam2 = surface_gains # Validate surface stability if any(g &lt;= 0 for g in [c1, lam1, c2, lam2]): raise ValueError(‚ÄúAll surface coefficients must be positive‚Äù) # Check surface eigenvalue placement for stability eigen1 = -lam1 / c1 eigen2 = -lam2 / c2 if eigen1 &gt;= 0 or eigen2 &gt;= 0: print(f‚ÄùWarning: Surface eigenvalues [{eigen1:.3f}, {eigen2:.3f}] may indicate instability‚Äù) new_params[‚Äògains‚Äô] = surface_gains # Handle mode parameter migration mode_mappings = { ‚Äòmode‚Äô: ‚Äòhybrid_mode‚Äô, ‚Äòswitch_threshold‚Äô: ‚Äòswitching_criteria‚Äô, ‚Äòclassical_params‚Äô: ‚Äòclassical_config‚Äô, ‚Äòadaptive_params‚Äô: ‚Äòadaptive_config‚Äô } for old_param, new_param in mode_mappings.items(): if old_param in old_params: if old_param == ‚Äòswitch_threshold‚Äô: # Convert scalar threshold to criteria dict threshold = old_params[old_param] new_params[‚Äòswitching_criteria‚Äô] = { ‚Äòerror_threshold‚Äô: threshold, ‚Äòtime_threshold‚Äô: 2.0, # Default time threshold ‚Äòperformance_threshold‚Äô: 0.1 # Performance-based switching } else: new_params[new_param] = old_params[old_param] # Handle sub-controller gain migration if ‚Äòsub_controller_gains‚Äô in old_params: sub_gains = old_params[‚Äòsub_controller_gains‚Äô] if isinstance(sub_gains, dict): # Create proper sub-controller configurations classical_gains = sub_gains.get(‚Äòclassical‚Äô, [20.0, 15.0, 12.0, 8.0, 35.0, 5.0]) adaptive_gains = sub_gains.get(‚Äòadaptive‚Äô, [25.0, 18.0, 15.0, 10.0, 4.0]) # Validate sub-controller gains if len(classical_gains) != 6: raise ValueError(‚ÄúClassical sub-controller requires 6 gains‚Äù) if len(adaptive_gains) != 5: raise ValueError(‚ÄúAdaptive sub-controller requires 5 gains‚Äù) # Create complete sub-configurations with surface coupling new_params[‚Äòclassical_config‚Äô] = { ‚Äògains‚Äô: classical_gains, ‚Äòmax_force‚Äô: old_params.get(‚Äòmax_force‚Äô, 150.0), ‚Äòboundary_layer‚Äô: 0.02, ‚Äòdt‚Äô: old_params.get(‚Äòdt‚Äô, 0.001), ‚Äòsurface_coupling‚Äô: True # Ensure surface consistency } new_params[‚Äòadaptive_config‚Äô] = { ‚Äògains‚Äô: adaptive_gains, ‚Äòmax_force‚Äô: old_params.get(‚Äòmax_force‚Äô, 150.0), ‚Äòleak_rate‚Äô: 0.01, ‚Äòadapt_rate_limit‚Äô: 10.0, ‚ÄòK_min‚Äô: 0.1, ‚ÄòK_max‚Äô: 100.0, ‚Äòdt‚Äô: old_params.get(‚Äòdt‚Äô, 0.001), ‚Äòsurface_coupling‚Äô: True # Ensure surface consistency } # Set hybrid-specific parameters with mathematical justification new_params.setdefault(‚Äòhybrid_mode‚Äô, ‚ÄòCLASSICAL_ADAPTIVE‚Äô) # Conservative default new_params.setdefault(‚Äòdt‚Äô, 0.001) # Fast sampling for mode switching new_params.setdefault(‚Äòmax_force‚Äô, 150.0) # Shared actuator limit # Advanced hybrid parameters new_params.setdefault(‚Äòmode_hysteresis‚Äô, 0.1) # Prevent chattering in mode switching new_params.setdefault(‚Äòtransition_smoothing‚Äô, True) # Smooth mode transitions new_params.setdefault(‚Äòsurface_consistency_check‚Äô, True) # Validate surface compatibility # Validate hybrid mode switching stability if ‚Äòswitching_criteria‚Äô in new_params: criteria = new_params[‚Äòswitching_criteria‚Äô] error_thresh = criteria.get(‚Äòerror_threshold‚Äô, 0.1) time_thresh = criteria.get(‚Äòtime_threshold‚Äô, 2.0) # Check switching frequency to prevent chattering min_dwell_time = 0.1 # Minimum time in each mode if time_thresh &lt; min_dwell_time: print(f‚ÄùWarning: Short time threshold {time_thresh}s may cause mode chattering‚Äù) return new_params # Mathematical validation example</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration_migration_mathematical_foundations.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration_migration_mathematical_foundations.html#runnable-false-class-stabilityvalidator-validate-stability-preservation-during-parameter-migration-staticmethod-def-validate-classical-smc-stability-gains-list-float-dict-str-any-validate-classical-smc-stability-conditions-if-len-gains-6-return-valid-false-reason-invalid-gain-count-k1-k2-lam1-lam2-k-kd-gains-check-basic-positivity-if-any-g-0-for-g-in-gains-return-valid-false-reason-all-gains-must-be-positive-check-sliding-surface-stability-for-double-pendulum-sliding-surface-eigenvalues-should-be-negative-surface-eigs-lam1-k1-lam2-k2-if-any-eig-0-for-eig-in-surface-eigs-return-valid-false-reason-f-unstable-surface-eigenvalues-surface-eigs-check-actuator-reasonableness-if-k-200-very-high-switching-gain-return-valid-true-warnings-f-high-switching-gain-k-k-may-cause-excessive-chattering-check-derivative-gain-ratio-kd-ratio-kd-k-if-kd-ratio-0-5-derivative-gain-too-large-relative-to-switching-gain-return-valid-true-warnings-f-high-derivative-gain-ratio-kd-ratio-2f-may-degrade-performance-return-valid-true-surface-eigenvalues-surface-eigs-estimated-convergence-rate-min-abs-eig-for-eig-in-surface-eigs-switching-magnitude-k-chattering-reduction-kd-staticmethod-def-validate-adaptive-smc-convergence-gains-list-float-adaptation-params-dict-str-float-dict-str-any-validate-adaptive-smc-convergence-conditions-if-len-gains-5-return-valid-false-reason-invalid-gain-count-k1-k2-lam1-lam2-gamma-gains-check-basic-conditions-if-any-g-0-for-g-in-gains-return-valid-false-reason-all-gains-must-be-positive-check-adaptation-stability-leak-rate-adaptation-params-get-leak-rate-0-01-k-min-adaptation-params-get-k-min-0-1-k-max-adaptation-params-get-k-max-100-0-adaptation-stability-condition-leak-rate-should-be-small-relative-to-adaptation-rate-stability-margin-leak-rate-gamma-if-stability-margin-0-2-return-valid-true-warnings-f-high-leak-to-adaptation-ratio-stability-margin-3f-may-slow-convergence-check-adaptation-bounds-if-k-min-k-max-return-valid-false-reason-k-min-must-be-less-than-k-max-gain-ratio-k-max-k-min-if-gain-ratio-1000-very-wide-adaptation-range-return-valid-true-warnings-f-wide-adaptation-range-ratio-gain-ratio-1f-may-cause-instability-return-valid-true-adaptation-rate-gamma-stability-margin-stability-margin-adaptation-range-k-min-k-max-estimated-settling-time-5-0-min-lam1-k1-lam2-k2-rough-estimate-staticmethod-def-validate-sta-smc-finite-time-convergence-gains-list-float-algorithm-params-dict-str-float-dict-str-any-validate-super-twisting-finite-time-convergence-conditions-if-len-gains-6-return-valid-false-reason-invalid-gain-count-k1-k2-k1-k2-lam1-lam2-gains-check-basic-positivity-if-any-g-0-for-g-in-gains-return-valid-false-reason-all-gains-must-be-positive-check-super-twisting-convergence-conditions-alpha-algorithm-params-get-power-exponent-0-5-if-not-0-alpha-1-return-valid-false-reason-f-power-exponent-alpha-must-be-in-0-1-simplified-convergence-check-assumes-l-1-l-estimate-1-0-min-k1-l-estimate-alpha-min-k2-k1-2-2-l-estimate-l-estimate-warnings-if-k1-min-k1-warnings-append-f-k1-k1-2f-may-be-too-small-for-convergence-recommended-min-k1-2f-if-k2-min-k2-warnings-append-f-k2-k2-2f-may-be-too-small-for-convergence-recommended-min-k2-2f-estimate-finite-time-convergence-convergence-time-2-1-1-alpha-1-min-k1-k2-0-5-return-valid-true-warnings-warnings-algorithmic-gains-k1-k2-surface-gains-k1-k2-lam1-lam2-power-exponent-alpha-estimated-convergence-time-convergence-time-convergence-conditions-met-len-warnings-0-validation-example">runnable: false class StabilityValidator: ‚Äú‚Äù‚ÄùValidate stability preservation during parameter migration.‚Äù‚Äù‚Äù &#64;staticmethod def validate_classical_smc_stability(gains: List[float]) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùValidate Classical SMC stability conditions.‚Äù‚Äù‚Äù if len(gains) != 6: return {‚Äòvalid‚Äô: False, ‚Äòreason‚Äô: ‚ÄòInvalid gain count‚Äô} k1, k2, lam1, lam2, K, kd = gains # Check basic positivity if any(g &lt;= 0 for g in gains): return {‚Äòvalid‚Äô: False, ‚Äòreason‚Äô: ‚ÄòAll gains must be positive‚Äô} # Check sliding surface stability # For double pendulum: sliding surface eigenvalues should be negative surface_eigs = [-lam1/k1, -lam2/k2] if any(eig &gt;= 0 for eig in surface_eigs): return {‚Äòvalid‚Äô: False, ‚Äòreason‚Äô: f‚ÄôUnstable surface eigenvalues: {surface_eigs}‚Äô} # Check actuator reasonableness if K &gt; 200: # Very high switching gain return { ‚Äòvalid‚Äô: True, ‚Äòwarnings‚Äô: [f‚ÄôHigh switching gain K={K} may cause excessive chattering‚Äô] } # Check derivative gain ratio kd_ratio = kd / K if kd_ratio &gt; 0.5: # Derivative gain too large relative to switching gain return { ‚Äòvalid‚Äô: True, ‚Äòwarnings‚Äô: [f‚ÄôHigh derivative gain ratio {kd_ratio:.2f} may degrade performance‚Äô] } return { ‚Äòvalid‚Äô: True, ‚Äòsurface_eigenvalues‚Äô: surface_eigs, ‚Äòestimated_convergence_rate‚Äô: min(abs(eig) for eig in surface_eigs), ‚Äòswitching_magnitude‚Äô: K, ‚Äòchattering_reduction‚Äô: kd } &#64;staticmethod def validate_adaptive_smc_convergence(gains: List[float], adaptation_params: Dict[str, float]) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùValidate Adaptive SMC convergence conditions.‚Äù‚Äù‚Äù if len(gains) != 5: return {‚Äòvalid‚Äô: False, ‚Äòreason‚Äô: ‚ÄòInvalid gain count‚Äô} k1, k2, lam1, lam2, gamma = gains # Check basic conditions if any(g &lt;= 0 for g in gains): return {‚Äòvalid‚Äô: False, ‚Äòreason‚Äô: ‚ÄòAll gains must be positive‚Äô} # Check adaptation stability leak_rate = adaptation_params.get(‚Äòleak_rate‚Äô, 0.01) K_min = adaptation_params.get(‚ÄòK_min‚Äô, 0.1) K_max = adaptation_params.get(‚ÄòK_max‚Äô, 100.0) # Adaptation stability condition: leak rate should be small relative to adaptation rate stability_margin = leak_rate / gamma if stability_margin &gt; 0.2: return { ‚Äòvalid‚Äô: True, ‚Äòwarnings‚Äô: [f‚ÄôHigh leak-to-adaptation ratio {stability_margin:.3f} may slow convergence‚Äô] } # Check adaptation bounds if K_min &gt;= K_max: return {‚Äòvalid‚Äô: False, ‚Äòreason‚Äô: ‚ÄòK_min must be less than K_max‚Äô} gain_ratio = K_max / K_min if gain_ratio &gt; 1000: # Very wide adaptation range return { ‚Äòvalid‚Äô: True, ‚Äòwarnings‚Äô: [f‚ÄôWide adaptation range (ratio: {gain_ratio:.1f}) may cause instability‚Äô] } return { ‚Äòvalid‚Äô: True, ‚Äòadaptation_rate‚Äô: gamma, ‚Äòstability_margin‚Äô: stability_margin, ‚Äòadaptation_range‚Äô: [K_min, K_max], ‚Äòestimated_settling_time‚Äô: 5.0 / min(lam1/k1, lam2/k2) # Rough estimate } &#64;staticmethod def validate_sta_smc_finite_time_convergence(gains: List[float], algorithm_params: Dict[str, float]) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùValidate Super-Twisting finite-time convergence conditions.‚Äù‚Äù‚Äù if len(gains) != 6: return {‚Äòvalid‚Äô: False, ‚Äòreason‚Äô: ‚ÄòInvalid gain count‚Äô} K1, K2, k1, k2, lam1, lam2 = gains # Check basic positivity if any(g &lt;= 0 for g in gains): return {‚Äòvalid‚Äô: False, ‚Äòreason‚Äô: ‚ÄòAll gains must be positive‚Äô} # Check super-twisting convergence conditions alpha = algorithm_params.get(‚Äòpower_exponent‚Äô, 0.5) if not (0 &lt; alpha &lt; 1): return {‚Äòvalid‚Äô: False, ‚Äòreason‚Äô: f‚ÄôPower exponent Œ±={alpha} must be in (0,1)‚Äô} # Simplified convergence check (assumes L=1) L_estimate = 1.0 min_K1 = L_estimate / alpha min_K2 = K1**2 / (2 * L_estimate) + L_estimate warnings = [] if K1 &lt; min_K1: warnings.append(f‚ÄôK‚ÇÅ={K1:.2f} may be too small for convergence (recommended: ‚â•{min_K1:.2f})‚Äô) if K2 &lt; min_K2: warnings.append(f‚ÄôK‚ÇÇ={K2:.2f} may be too small for convergence (recommended: ‚â•{min_K2:.2f})‚Äô) # Estimate finite-time convergence convergence_time = 2 * (1 / (1 - alpha)) * (1 / min(K1, K2)**0.5) return { ‚Äòvalid‚Äô: True, ‚Äòwarnings‚Äô: warnings, ‚Äòalgorithmic_gains‚Äô: [K1, K2], ‚Äòsurface_gains‚Äô: [k1, k2, lam1, lam2], ‚Äòpower_exponent‚Äô: alpha, ‚Äòestimated_convergence_time‚Äô: convergence_time, ‚Äòconvergence_conditions_met‚Äô: len(warnings) == 0 } # Validation example</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration_migration_mathematical_foundations.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration_migration_mathematical_foundations.html#runnable-false-class-performanceanalyzer-analyze-performance-preservation-during-migration-staticmethod-def-analyze-control-bandwidth-old-gains-list-float-new-gains-list-float-controller-type-str-dict-str-any-analyze-control-bandwidth-preservation-if-controller-type-classical-smc-if-len-old-gains-4-and-len-new-gains-4-old-bandwidth-min-old-gains-2-old-gains-3-min-1-2-new-bandwidth-min-new-gains-2-new-gains-3-bandwidth-ratio-new-bandwidth-old-bandwidth-return-old-bandwidth-old-bandwidth-new-bandwidth-new-bandwidth-bandwidth-ratio-bandwidth-ratio-performance-preserved-0-8-bandwidth-ratio-1-2-20-tolerance-elif-controller-type-adaptive-smc-if-len-old-gains-4-and-len-new-gains-4-old-adaptation-rate-old-gains-4-if-len-old-gains-4-else-1-0-new-adaptation-rate-new-gains-4-if-len-new-gains-4-else-1-0-adaptation-ratio-new-adaptation-rate-old-adaptation-rate-return-old-adaptation-rate-old-adaptation-rate-new-adaptation-rate-new-adaptation-rate-adaptation-ratio-adaptation-ratio-performance-preserved-0-5-adaptation-ratio-2-0-100-tolerance-return-analysis-not-applicable-controller-type-controller-type-staticmethod-def-estimate-settling-time-change-old-config-dict-str-any-new-config-dict-str-any-dict-str-any-estimate-settling-time-changes-after-migration-old-gains-old-config-get-gains-new-gains-new-config-get-gains-if-len-old-gains-4-and-len-new-gains-4-simplified-settling-time-estimate-based-on-surface-coefficients-old-settling-4-0-min-old-gains-2-old-gains-3-4-min-1-2-new-settling-4-0-min-new-gains-2-new-gains-3-settling-ratio-new-settling-old-settling-return-old-settling-time-old-settling-new-settling-time-new-settling-settling-ratio-settling-ratio-performance-change-improved-if-settling-ratio-1-0-else-degraded-if-settling-ratio-1-1-else-maintained-return-analysis-insufficient-data-performance-analysis-example">runnable: false class PerformanceAnalyzer: ‚Äú‚Äù‚ÄùAnalyze performance preservation during migration.‚Äù‚Äù‚Äù &#64;staticmethod def analyze_control_bandwidth(old_gains: List[float], new_gains: List[float], controller_type: str) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùAnalyze control bandwidth preservation.‚Äù‚Äù‚Äù if controller_type == ‚Äòclassical_smc‚Äô: if len(old_gains) &gt;= 4 and len(new_gains) &gt;= 4: old_bandwidth = min(old_gains[2], old_gains[3]) # min(Œª1, Œª2) new_bandwidth = min(new_gains[2], new_gains[3]) bandwidth_ratio = new_bandwidth / old_bandwidth return { ‚Äòold_bandwidth‚Äô: old_bandwidth, ‚Äònew_bandwidth‚Äô: new_bandwidth, ‚Äòbandwidth_ratio‚Äô: bandwidth_ratio, ‚Äòperformance_preserved‚Äô: 0.8 &lt;= bandwidth_ratio &lt;= 1.2 # ¬±20% tolerance } elif controller_type == ‚Äòadaptive_smc‚Äô: if len(old_gains) &gt;= 4 and len(new_gains) &gt;= 4: old_adaptation_rate = old_gains[4] if len(old_gains) &gt; 4 else 1.0 new_adaptation_rate = new_gains[4] if len(new_gains) &gt; 4 else 1.0 adaptation_ratio = new_adaptation_rate / old_adaptation_rate return { ‚Äòold_adaptation_rate‚Äô: old_adaptation_rate, ‚Äònew_adaptation_rate‚Äô: new_adaptation_rate, ‚Äòadaptation_ratio‚Äô: adaptation_ratio, ‚Äòperformance_preserved‚Äô: 0.5 &lt;= adaptation_ratio &lt;= 2.0 # ¬±100% tolerance } return {‚Äòanalysis‚Äô: ‚Äònot_applicable‚Äô, ‚Äòcontroller_type‚Äô: controller_type} &#64;staticmethod def estimate_settling_time_change(old_config: Dict[str, Any], new_config: Dict[str, Any]) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùEstimate settling time changes after migration.‚Äù‚Äù‚Äù old_gains = old_config.get(‚Äògains‚Äô, []) new_gains = new_config.get(‚Äògains‚Äô, []) if len(old_gains) &gt;= 4 and len(new_gains) &gt;= 4: # Simplified settling time estimate based on surface coefficients old_settling = 4.0 / min(old_gains[2], old_gains[3]) # 4/min(Œª1, Œª2) new_settling = 4.0 / min(new_gains[2], new_gains[3]) settling_ratio = new_settling / old_settling return { ‚Äòold_settling_time‚Äô: old_settling, ‚Äònew_settling_time‚Äô: new_settling, ‚Äòsettling_ratio‚Äô: settling_ratio, ‚Äòperformance_change‚Äô: ‚Äòimproved‚Äô if settling_ratio &lt; 1.0 else ‚Äòdegraded‚Äô if settling_ratio &gt; 1.1 else ‚Äòmaintained‚Äô } return {‚Äòanalysis‚Äô: ‚Äòinsufficient_data‚Äô} # Performance analysis example</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration_migration_mathematical_foundations.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration_migration_mathematical_foundations.html#runnable-false-class-migrationvalidationsuite-test-suite-for-migration-validation-def-init-self-self-test-results-def-run-full-validation-self-old-config-dict-str-any-new-config-dict-str-any-controller-type-str-dict-str-any-run-migration-validation-results-controller-type-controller-type-migration-successful-true-tests-warnings-errors-test-1-parameter-count-validation-results-tests-parameter-count-self-test-parameter-count-old-config-new-config-controller-type-test-2-stability-preservation-results-tests-stability-self-test-stability-preservation-new-config-controller-type-test-3-physical-realizability-results-tests-physical-realizability-self-test-physical-realizability-new-config-controller-type-test-4-performance-preservation-results-tests-performance-self-test-performance-preservation-old-config-new-config-controller-type-test-5-numerical-stability-results-tests-numerical-stability-self-test-numerical-stability-new-config-controller-type-aggregate-results-failed-tests-name-for-name-result-in-results-tests-items-if-not-result-get-passed-false-results-migration-successful-len-failed-tests-0-if-failed-tests-results-errors-extend-f-failed-test-test-for-test-in-failed-tests-return-results-def-test-parameter-count-self-old-config-dict-str-any-new-config-dict-str-any-controller-type-str-dict-str-any-test-parameter-count-migration-expected-counts-classical-smc-6-adaptive-smc-5-sta-smc-6-hybrid-adaptive-sta-smc-4-new-gains-new-config-get-gains-expected-count-expected-counts-get-controller-type-0-passed-len-new-gains-expected-count-return-passed-passed-expected-count-expected-count-actual-count-len-new-gains-gains-new-gains-def-test-stability-preservation-self-new-config-dict-str-any-controller-type-str-dict-str-any-test-stability-preservation-gains-new-config-get-gains-if-controller-type-classical-smc-return-stabilityvalidator-validate-classical-smc-stability-gains-elif-controller-type-adaptive-smc-adaptation-params-leak-rate-new-config-get-leak-rate-0-01-k-min-new-config-get-k-min-0-1-k-max-new-config-get-k-max-100-0-return-stabilityvalidator-validate-adaptive-smc-convergence-gains-adaptation-params-elif-controller-type-sta-smc-algorithm-params-power-exponent-new-config-get-power-exponent-0-5-return-stabilityvalidator-validate-sta-smc-finite-time-convergence-gains-algorithm-params-return-passed-true-reason-no-stability-test-for-this-controller-type-def-test-physical-realizability-self-new-config-dict-str-any-controller-type-str-dict-str-any-test-physical-realizability-of-parameters-gains-new-config-get-gains-max-force-new-config-get-max-force-150-0-dt-new-config-get-dt-0-001-issues-check-gain-magnitudes-if-any-g-1000-for-g-in-gains-issues-append-extremely-high-gains-may-be-unrealistic-check-sampling-time-if-dt-1e-4-less-than-0-1ms-issues-append-f-very-fast-sampling-time-dt-dt-s-may-be-unrealistic-elif-dt-0-1-more-than-100ms-issues-append-f-slow-sampling-time-dt-dt-s-may-degrade-performance-check-actuator-limits-if-max-force-1000-more-than-1kn-issues-append-f-high-force-limit-max-force-n-may-be-unrealistic-elif-max-force-1-less-than-1n-issues-append-f-low-force-limit-max-force-n-may-be-insufficient-return-passed-len-issues-0-issues-issues-parameters-checked-gains-max-force-dt-def-test-performance-preservation-self-old-config-dict-str-any-new-config-dict-str-any-controller-type-str-dict-str-any-test-performance-preservation-bandwidth-analysis-performanceanalyzer-analyze-control-bandwidth-old-config-get-gains-new-config-get-gains-controller-type-settling-analysis-performanceanalyzer-estimate-settling-time-change-old-config-new-config-performance-is-preserved-if-bandwidth-and-settling-time-are-reasonable-bandwidth-ok-bandwidth-analysis-get-performance-preserved-true-settling-ok-settling-analysis-get-performance-change-in-improved-maintained-return-passed-bandwidth-ok-and-settling-ok-bandwidth-analysis-bandwidth-analysis-settling-analysis-settling-analysis-def-test-numerical-stability-self-new-config-dict-str-any-controller-type-str-dict-str-any-test-numerical-stability-of-parameters-gains-new-config-get-gains-dt-new-config-get-dt-0-001-issues-check-condition-numbers-and-numerical-issues-if-controller-type-in-classical-smc-adaptive-smc-sta-smc-if-len-gains-4-k1-k2-lam1-lam2-gains-4-check-gain-ratios-for-numerical-stability-if-lam1-k1-100-or-lam2-k2-100-issues-append-high-k-ratios-may-cause-numerical-instability-if-k1-k2-10-or-k2-k1-10-issues-append-large-k1-k2-ratio-may-indicate-unbalanced-design-check-discrete-time-stability-if-controller-type-in-adaptive-smc-sta-smc-max-gain-max-gains-if-gains-else-0-nyquist-limit-1-0-2-dt-if-max-gain-nyquist-limit-10-rule-of-thumb-issues-append-f-high-gains-relative-to-sampling-rate-may-cause-instability-return-passed-len-issues-0-issues-issues-sampling-time-dt-stability-margins-acceptable-if-len-issues-0-else-marginal-full-validation-example">runnable: false class MigrationValidationSuite: ‚Äú‚Äù‚Äùtest suite for migration validation.‚Äù‚Äù‚Äù def <strong>init</strong>(self): self.test_results = [] def run_full_validation(self, old_config: Dict[str, Any], new_config: Dict[str, Any], controller_type: str) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùRun migration validation.‚Äù‚Äù‚Äù results = { ‚Äòcontroller_type‚Äô: controller_type, ‚Äòmigration_successful‚Äô: True, ‚Äòtests‚Äô: {}, ‚Äòwarnings‚Äô: [], ‚Äòerrors‚Äô: [] } # Test 1: Parameter count validation results[‚Äòtests‚Äô][‚Äòparameter_count‚Äô] = self.test_parameter_count(old_config, new_config, controller_type) # Test 2: Stability preservation results[‚Äòtests‚Äô][‚Äòstability‚Äô] = self.test_stability_preservation(new_config, controller_type) # Test 3: Physical realizability results[‚Äòtests‚Äô][‚Äòphysical_realizability‚Äô] = self.test_physical_realizability(new_config, controller_type) # Test 4: Performance preservation results[‚Äòtests‚Äô][‚Äòperformance‚Äô] = self.test_performance_preservation(old_config, new_config, controller_type) # Test 5: Numerical stability results[‚Äòtests‚Äô][‚Äònumerical_stability‚Äô] = self.test_numerical_stability(new_config, controller_type) # Aggregate results failed_tests = [name for name, result in results[‚Äòtests‚Äô].items() if not result.get(‚Äòpassed‚Äô, False)] results[‚Äòmigration_successful‚Äô] = len(failed_tests) == 0 if failed_tests: results[‚Äòerrors‚Äô].extend([f‚ÄùFailed test: {test}‚Äù for test in failed_tests]) return results def test_parameter_count(self, old_config: Dict[str, Any], new_config: Dict[str, Any], controller_type: str) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùTest parameter count migration.‚Äù‚Äù‚Äù expected_counts = { ‚Äòclassical_smc‚Äô: 6, ‚Äòadaptive_smc‚Äô: 5, ‚Äòsta_smc‚Äô: 6, ‚Äòhybrid_adaptive_sta_smc‚Äô: 4 } new_gains = new_config.get(‚Äògains‚Äô, []) expected_count = expected_counts.get(controller_type, 0) passed = len(new_gains) == expected_count return { ‚Äòpassed‚Äô: passed, ‚Äòexpected_count‚Äô: expected_count, ‚Äòactual_count‚Äô: len(new_gains), ‚Äògains‚Äô: new_gains } def test_stability_preservation(self, new_config: Dict[str, Any], controller_type: str) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùTest stability preservation.‚Äù‚Äù‚Äù gains = new_config.get(‚Äògains‚Äô, []) if controller_type == ‚Äòclassical_smc‚Äô: return StabilityValidator.validate_classical_smc_stability(gains) elif controller_type == ‚Äòadaptive_smc‚Äô: adaptation_params = { ‚Äòleak_rate‚Äô: new_config.get(‚Äòleak_rate‚Äô, 0.01), ‚ÄòK_min‚Äô: new_config.get(‚ÄòK_min‚Äô, 0.1), ‚ÄòK_max‚Äô: new_config.get(‚ÄòK_max‚Äô, 100.0) } return StabilityValidator.validate_adaptive_smc_convergence(gains, adaptation_params) elif controller_type == ‚Äòsta_smc‚Äô: algorithm_params = { ‚Äòpower_exponent‚Äô: new_config.get(‚Äòpower_exponent‚Äô, 0.5) } return StabilityValidator.validate_sta_smc_finite_time_convergence(gains, algorithm_params) return {‚Äòpassed‚Äô: True, ‚Äòreason‚Äô: ‚ÄòNo stability test for this controller type‚Äô} def test_physical_realizability(self, new_config: Dict[str, Any], controller_type: str) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùTest physical realizability of parameters.‚Äù‚Äù‚Äù gains = new_config.get(‚Äògains‚Äô, []) max_force = new_config.get(‚Äòmax_force‚Äô, 150.0) dt = new_config.get(‚Äòdt‚Äô, 0.001) issues = [] # Check gain magnitudes if any(g &gt; 1000 for g in gains): issues.append(‚ÄúExtremely high gains may be unrealistic‚Äù) # Check sampling time if dt &lt; 1e-4: # Less than 0.1ms issues.append(f‚ÄùVery fast sampling time dt={dt}s may be unrealistic‚Äù) elif dt &gt; 0.1: # More than 100ms issues.append(f‚ÄùSlow sampling time dt={dt}s may degrade performance‚Äù) # Check actuator limits if max_force &gt; 1000: # More than 1kN issues.append(f‚ÄùHigh force limit {max_force}N may be unrealistic‚Äù) elif max_force &lt; 1: # Less than 1N issues.append(f‚ÄùLow force limit {max_force}N may be insufficient‚Äù) return { ‚Äòpassed‚Äô: len(issues) == 0, ‚Äòissues‚Äô: issues, ‚Äòparameters_checked‚Äô: [‚Äògains‚Äô, ‚Äòmax_force‚Äô, ‚Äòdt‚Äô] } def test_performance_preservation(self, old_config: Dict[str, Any], new_config: Dict[str, Any], controller_type: str) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùTest performance preservation.‚Äù‚Äù‚Äù bandwidth_analysis = PerformanceAnalyzer.analyze_control_bandwidth( old_config.get(‚Äògains‚Äô, []), new_config.get(‚Äògains‚Äô, []), controller_type ) settling_analysis = PerformanceAnalyzer.estimate_settling_time_change(old_config, new_config) # Performance is preserved if bandwidth and settling time are reasonable bandwidth_ok = bandwidth_analysis.get(‚Äòperformance_preserved‚Äô, True) settling_ok = settling_analysis.get(‚Äòperformance_change‚Äô) in [‚Äòimproved‚Äô, ‚Äòmaintained‚Äô] return { ‚Äòpassed‚Äô: bandwidth_ok and settling_ok, ‚Äòbandwidth_analysis‚Äô: bandwidth_analysis, ‚Äòsettling_analysis‚Äô: settling_analysis } def test_numerical_stability(self, new_config: Dict[str, Any], controller_type: str) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùTest numerical stability of parameters.‚Äù‚Äù‚Äù gains = new_config.get(‚Äògains‚Äô, []) dt = new_config.get(‚Äòdt‚Äô, 0.001) issues = [] # Check condition numbers and numerical issues if controller_type in [‚Äòclassical_smc‚Äô, ‚Äòadaptive_smc‚Äô, ‚Äòsta_smc‚Äô]: if len(gains) &gt;= 4: k1, k2, lam1, lam2 = gains[:4] # Check gain ratios for numerical stability if lam1/k1 &gt; 100 or lam2/k2 &gt; 100: issues.append(‚ÄúHigh Œª/k ratios may cause numerical instability‚Äù) if k1/k2 &gt; 10 or k2/k1 &gt; 10: issues.append(‚ÄúLarge k1/k2 ratio may indicate unbalanced design‚Äù) # Check discrete-time stability if controller_type in [‚Äòadaptive_smc‚Äô, ‚Äòsta_smc‚Äô]: max_gain = max(gains) if gains else 0 nyquist_limit = 1.0 / (2 * dt) if max_gain &gt; nyquist_limit / 10: # Rule of thumb issues.append(f‚ÄùHigh gains relative to sampling rate may cause instability‚Äù) return { ‚Äòpassed‚Äô: len(issues) == 0, ‚Äòissues‚Äô: issues, ‚Äòsampling_time‚Äô: dt, ‚Äòstability_margins‚Äô: ‚Äòacceptable‚Äô if len(issues) == 0 else ‚Äòmarginal‚Äô } # Full validation example</a></li>
<li class="toctree-l1"><a class="reference internal" href="deprecation_management.html">Deprecation Management System ## Overview The SMC Controller Factory includes a deprecation management system designed to handle configuration changes, parameter renames, and interface modifications while maintaining backward compatibility. This system provides systematic deprecation warnings, migration paths, and graceful degradation mechanisms to support smooth evolution of the codebase. ## Deprecation Architecture ### Deprecation Severity Levels ```python</a></li>
<li class="toctree-l1"><a class="reference internal" href="deprecation_management.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="deprecation_management.html#runnable-false-dataclass">runnable: false &#64;dataclass</a></li>
<li class="toctree-l1"><a class="reference internal" href="deprecation_management.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="deprecation_management.html#runnable-false-classical-smc-deprecations-gamma-deprecationmapping-old-name-gamma-new-name-none-level-deprecationlevel-error-message-gamma-parameter-is-not-valid-for-classical-smc-use-boundary-layer-instead-migration-guide-classical-smc-uses-boundary-layer-for-chattering-reduction-not-gamma-the-gamma-parameter-is-specific-to-adaptive-smc-controllers-replace-gamma-0-1-with-boundary-layer-0-02-in-your-configuration-removed-in-version-2-0-0-introduced-in-version-1-8-0-auto-migrate-false-cannot-auto-migrate-due-to-semantic-difference-adaptation-rate-deprecationmapping-old-name-adaptation-rate-new-name-none-level-deprecationlevel-error-message-adaptation-rate-is-not-valid-for-classical-smc-this-parameter-is-only-for-adaptive-smc-migration-guide-remove-adaptation-rate-from-classical-smc-configuration-if-you-need-adaptation-use-adaptive-smc-controller-type-instead-removed-in-version-2-0-0-auto-migrate-true-can-auto-remove-invalid-parameter-switch-function-deprecationmapping-old-name-switch-function-new-name-switch-method-level-deprecationlevel-warning-message-switch-function-parameter-renamed-to-switch-method-migration-guide-replace-switch-function-with-switch-method-in-configuration-valid-values-sign-tanh-sigmoid-sat-example-switch-method-tanh-removed-in-version-3-0-0-introduced-in-version-2-1-0-auto-migrate-true-k-switching-deprecationmapping-old-name-k-switching-new-name-gains-4-level-deprecationlevel-warning-message-separate-k-switching-parameter-deprecated-include-as-5th-element-in-gains-array-migration-guide-move-k-switching-value-to-gains-array-as-5th-element-example-gains-k1-k2-1-2-k-switching-kd-old-k-switching-15-0-gains-10-5-8-3-2-new-gains-10-5-8-3-15-2-removed-in-version-3-0-0-auto-migrate-true">runnable: false CLASSICAL_SMC_DEPRECATIONS = { ‚Äògamma‚Äô: DeprecationMapping( old_name=‚Äôgamma‚Äô, new_name=None, level=DeprecationLevel.ERROR, message=‚Äú‚Äògamma‚Äô parameter is not valid for classical_smc. Use ‚Äòboundary_layer‚Äô instead.‚Äù, migration_guide=( ‚ÄúClassical SMC uses ‚Äòboundary_layer‚Äô for chattering reduction, not ‚Äògamma‚Äô. ‚Äú ‚ÄúThe ‚Äògamma‚Äô parameter is specific to adaptive SMC controllers. ‚Äú ‚ÄúReplace ‚Äògamma: 0.1‚Äô with ‚Äòboundary_layer: 0.02‚Äô in your configuration.‚Äù ), removed_in_version=‚Äù2.0.0‚Äù, introduced_in_version=‚Äù1.8.0‚Äù, auto_migrate=False # Cannot auto-migrate due to semantic difference ), ‚Äòadaptation_rate‚Äô: DeprecationMapping( old_name=‚Äôadaptation_rate‚Äô, new_name=None, level=DeprecationLevel.ERROR, message=‚Äú‚Äòadaptation_rate‚Äô is not valid for classical_smc. This parameter is only for adaptive_smc.‚Äù, migration_guide=( ‚ÄúRemove ‚Äòadaptation_rate‚Äô from classical SMC configuration. ‚Äú ‚ÄúIf you need adaptation, use ‚Äòadaptive_smc‚Äô controller type instead.‚Äù ), removed_in_version=‚Äù2.0.0‚Äù, auto_migrate=True # Can auto-remove invalid parameter ), ‚Äòswitch_function‚Äô: DeprecationMapping( old_name=‚Äôswitch_function‚Äô, new_name=‚Äôswitch_method‚Äô, level=DeprecationLevel.WARNING, message=‚Äú‚Äòswitch_function‚Äô parameter renamed to ‚Äòswitch_method‚Äô.‚Äù, migration_guide=( ‚ÄúReplace ‚Äòswitch_function‚Äô with ‚Äòswitch_method‚Äô in configuration. ‚Äú ‚ÄúValid values: ‚Äòsign‚Äô, ‚Äòtanh‚Äô, ‚Äòsigmoid‚Äô, ‚Äòsat‚Äô. ‚Äú ‚ÄúExample: switch_method: ‚Äòtanh‚Äô‚Äù ), removed_in_version=‚Äù3.0.0‚Äù, introduced_in_version=‚Äù2.1.0‚Äù, auto_migrate=True ), ‚ÄòK_switching‚Äô: DeprecationMapping( old_name=‚ÄôK_switching‚Äô, new_name=‚Äôgains[4]‚Äô, level=DeprecationLevel.WARNING, message=‚ÄùSeparate ‚ÄòK_switching‚Äô parameter deprecated. Include as 5th element in gains array.‚Äù, migration_guide=( ‚ÄúMove K_switching value to gains array as 5th element. ‚Äú ‚ÄúExample: gains: [k1, k2, Œª1, Œª2, K_switching, kd] ‚Äú ‚ÄúOld: K_switching: 15.0, gains: [10, 5, 8, 3, 2] ‚Äú ‚ÄúNew: gains: [10, 5, 8, 3, 15, 2]‚Äù ), removed_in_version=‚Äù3.0.0‚Äù, auto_migrate=True )</a></li>
<li class="toctree-l1"><a class="reference internal" href="deprecation_management.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="deprecation_management.html#runnable-false-adaptive-smc-deprecations-boundary-layer-thickness-deprecationmapping-old-name-boundary-layer-thickness-new-name-boundary-layer-level-deprecationlevel-warning-message-boundary-layer-thickness-parameter-renamed-to-boundary-layer-migration-guide-replace-boundary-layer-thickness-with-boundary-layer-in-configuration-the-parameter-has-the-same-meaning-and-value-range-0-001-to-0-1-example-boundary-layer-0-01-removed-in-version-3-0-0-auto-migrate-true-adaptation-gain-deprecationmapping-old-name-adaptation-gain-new-name-gains-4-level-deprecationlevel-warning-message-adaptation-gain-parameter-renamed-to-gamma-included-in-gains-array-migration-guide-remove-separate-adaptation-gain-and-include-gamma-as-5th-element-in-gains-array-the-adaptation-gain-gamma-controls-parameter-estimation-rate-example-gains-k1-k2-1-2-gamma-where-gamma-old-adaptation-gain-removed-in-version-3-0-0-auto-migrate-true-validation-function-lambda-x-0-01-x-10-0-estimate-bounds-deprecationmapping-old-name-estimate-bounds-new-name-k-min-k-max-level-deprecationlevel-warning-message-estimate-bounds-parameter-split-into-k-min-and-k-max-migration-guide-replace-estimate-bounds-min-max-with-separate-k-min-and-k-max-parameters-example-k-min-0-1-k-max-100-0-removed-in-version-3-0-0-auto-migrate-true-adaptation-law-deprecationmapping-old-name-adaptation-law-new-name-alpha-level-deprecationlevel-info-message-adaptation-law-parameter-renamed-to-alpha-for-clarity-migration-guide-replace-adaptation-law-with-alpha-the-parameter-controls-adaptation-law-exponent-typically-0-5-for-standard-adaptation-example-alpha-0-5-removed-in-version-4-0-0-auto-migrate-true">runnable: false ADAPTIVE_SMC_DEPRECATIONS = { ‚Äòboundary_layer_thickness‚Äô: DeprecationMapping( old_name=‚Äôboundary_layer_thickness‚Äô, new_name=‚Äôboundary_layer‚Äô, level=DeprecationLevel.WARNING, message=‚Äú‚Äòboundary_layer_thickness‚Äô parameter renamed to ‚Äòboundary_layer‚Äô.‚Äù, migration_guide=( ‚ÄúReplace ‚Äòboundary_layer_thickness‚Äô with ‚Äòboundary_layer‚Äô in configuration. ‚Äú ‚ÄúThe parameter has the same meaning and value range (0.001 to 0.1). ‚Äú ‚ÄúExample: boundary_layer: 0.01‚Äù ), removed_in_version=‚Äù3.0.0‚Äù, auto_migrate=True ), ‚Äòadaptation_gain‚Äô: DeprecationMapping( old_name=‚Äôadaptation_gain‚Äô, new_name=‚Äôgains[4]‚Äô, level=DeprecationLevel.WARNING, message=‚Äú‚Äòadaptation_gain‚Äô parameter renamed to ‚Äògamma‚Äô (included in gains array).‚Äù, migration_guide=( ‚ÄúRemove separate ‚Äòadaptation_gain‚Äô and include gamma as 5th element in gains array. ‚Äú ‚ÄúThe adaptation gain (gamma) controls parameter estimation rate. ‚Äú ‚ÄúExample: gains: [k1, k2, Œª1, Œª2, gamma] where gamma = old adaptation_gain‚Äù ), removed_in_version=‚Äù3.0.0‚Äù, auto_migrate=True, validation_function=lambda x: 0.01 &lt;= x &lt;= 10.0 ), ‚Äòestimate_bounds‚Äô: DeprecationMapping( old_name=‚Äôestimate_bounds‚Äô, new_name=[‚ÄòK_min‚Äô, ‚ÄòK_max‚Äô], level=DeprecationLevel.WARNING, message=‚Äú‚Äòestimate_bounds‚Äô parameter split into ‚ÄòK_min‚Äô and ‚ÄòK_max‚Äô.‚Äù, migration_guide=( ‚ÄúReplace ‚Äòestimate_bounds: [min, max]‚Äô with separate ‚ÄòK_min‚Äô and ‚ÄòK_max‚Äô parameters. ‚Äú ‚ÄúExample: K_min: 0.1, K_max: 100.0‚Äù ), removed_in_version=‚Äù3.0.0‚Äù, auto_migrate=True ), ‚Äòadaptation_law‚Äô: DeprecationMapping( old_name=‚Äôadaptation_law‚Äô, new_name=‚Äôalpha‚Äô, level=DeprecationLevel.INFO, message=‚Äú‚Äòadaptation_law‚Äô parameter renamed to ‚Äòalpha‚Äô for clarity.‚Äù, migration_guide=( ‚ÄúReplace ‚Äòadaptation_law‚Äô with ‚Äòalpha‚Äô. ‚Äú ‚ÄúThe parameter controls adaptation law exponent (typically 0.5 for standard adaptation). ‚Äú ‚ÄúExample: alpha: 0.5‚Äù ), removed_in_version=‚Äù4.0.0‚Äù, auto_migrate=True )</a></li>
<li class="toctree-l1"><a class="reference internal" href="deprecation_management.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="deprecation_management.html#runnable-false-sta-smc-deprecations-k1-deprecationmapping-old-name-k1-new-name-gains-0-level-deprecationlevel-warning-message-separate-k1-k2-parameters-deprecated-use-gains-array-instead-migration-guide-include-k1-k2-as-first-two-elements-in-gains-array-k1-k2-k1-k2-lam1-lam2-this-provides-consistent-parameter-interface-across-all-smc-controllers-example-gains-35-0-20-0-25-0-18-0-12-0-8-0-removed-in-version-3-0-0-auto-migrate-true-k2-deprecationmapping-old-name-k2-new-name-gains-1-level-deprecationlevel-warning-message-separate-k1-k2-parameters-deprecated-use-gains-array-instead-migration-guide-include-k1-k2-as-first-two-elements-in-gains-array-k1-k2-k1-k2-lam1-lam2-ensure-k1-k2-for-optimal-sta-performance-example-gains-35-0-20-0-25-0-18-0-12-0-8-0-removed-in-version-3-0-0-auto-migrate-true-alpha-power-deprecationmapping-old-name-alpha-power-new-name-power-exponent-level-deprecationlevel-warning-message-alpha-power-parameter-renamed-to-power-exponent-for-clarity-migration-guide-replace-alpha-power-with-power-exponent-standard-sta-uses-power-exponent-0-5-for-finite-time-convergence-valid-range-0-1-example-power-exponent-0-5-removed-in-version-3-0-0-auto-migrate-true-validation-function-lambda-x-0-0-x-1-0-switching-function-type-deprecationmapping-old-name-switching-function-type-new-name-switch-method-level-deprecationlevel-info-message-switching-function-type-renamed-to-switch-method-for-consistency-migration-guide-replace-switching-function-type-with-switch-method-valid-options-tanh-sigmoid-sat-sta-smc-typically-uses-tanh-for-smooth-switching-removed-in-version-4-0-0-auto-migrate-true">runnable: false STA_SMC_DEPRECATIONS = { ‚ÄòK1‚Äô: DeprecationMapping( old_name=‚ÄôK1‚Äô, new_name=‚Äôgains[0]‚Äô, level=DeprecationLevel.WARNING, message=‚ÄùSeparate K1/K2 parameters deprecated. Use gains array instead.‚Äù, migration_guide=( ‚ÄúInclude K1, K2 as first two elements in gains array: [K1, K2, k1, k2, lam1, lam2]. ‚Äú ‚ÄúThis provides consistent parameter interface across all SMC controllers. ‚Äú ‚ÄúExample: gains: [35.0, 20.0, 25.0, 18.0, 12.0, 8.0]‚Äù ), removed_in_version=‚Äù3.0.0‚Äù, auto_migrate=True ), ‚ÄòK2‚Äô: DeprecationMapping( old_name=‚ÄôK2‚Äô, new_name=‚Äôgains[1]‚Äô, level=DeprecationLevel.WARNING, message=‚ÄùSeparate K1/K2 parameters deprecated. Use gains array instead.‚Äù, migration_guide=( ‚ÄúInclude K1, K2 as first two elements in gains array: [K1, K2, k1, k2, lam1, lam2]. ‚Äú ‚ÄúEnsure K1 &gt; K2 for optimal STA performance. ‚Äú ‚ÄúExample: gains: [35.0, 20.0, 25.0, 18.0, 12.0, 8.0]‚Äù ), removed_in_version=‚Äù3.0.0‚Äù, auto_migrate=True ), ‚Äòalpha_power‚Äô: DeprecationMapping( old_name=‚Äôalpha_power‚Äô, new_name=‚Äôpower_exponent‚Äô, level=DeprecationLevel.WARNING, message=‚Äú‚Äòalpha_power‚Äô parameter renamed to ‚Äòpower_exponent‚Äô for clarity.‚Äù, migration_guide=( ‚ÄúReplace ‚Äòalpha_power‚Äô with ‚Äòpower_exponent‚Äô. ‚Äú ‚ÄúStandard STA uses power_exponent: 0.5 for finite-time convergence. ‚Äú ‚ÄúValid range: (0, 1). Example: power_exponent: 0.5‚Äù ), removed_in_version=‚Äù3.0.0‚Äù, auto_migrate=True, validation_function=lambda x: 0.0 &lt; x &lt; 1.0 ), ‚Äòswitching_function_type‚Äô: DeprecationMapping( old_name=‚Äôswitching_function_type‚Äô, new_name=‚Äôswitch_method‚Äô, level=DeprecationLevel.INFO, message=‚Äú‚Äòswitching_function_type‚Äô renamed to ‚Äòswitch_method‚Äô for consistency.‚Äù, migration_guide=( ‚ÄúReplace ‚Äòswitching_function_type‚Äô with ‚Äòswitch_method‚Äô. ‚Äú ‚ÄúValid options: ‚Äòtanh‚Äô, ‚Äòsigmoid‚Äô, ‚Äòsat‚Äô. ‚Äú ‚ÄúSTA-SMC typically uses ‚Äòtanh‚Äô for smooth switching.‚Äù ), removed_in_version=‚Äù4.0.0‚Äù, auto_migrate=True )</a></li>
<li class="toctree-l1"><a class="reference internal" href="deprecation_management.html#id4">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="deprecation_management.html#runnable-false-hybrid-smc-deprecations-mode-deprecationmapping-old-name-mode-new-name-hybrid-mode-level-deprecationlevel-warning-message-mode-parameter-renamed-to-hybrid-mode-migration-guide-replace-mode-with-hybrid-mode-and-use-hybridmode-enum-values-available-modes-classical-adaptive-adaptive-sta-classical-sta-example-hybrid-mode-classical-adaptive-removed-in-version-3-0-0-auto-migrate-true-switch-threshold-deprecationmapping-old-name-switch-threshold-new-name-switching-criteria-level-deprecationlevel-warning-message-switch-threshold-renamed-to-switching-criteria-with-enhanced-functionality-migration-guide-replace-switch-threshold-with-switching-criteria-configuration-new-format-supports-multiple-criteria-error-threshold-time-threshold-performance-threshold-example-switching-criteria-error-threshold-0-1-time-threshold-2-0-removed-in-version-3-0-0-auto-migrate-false-requires-manual-migration-due-to-format-change-sub-controller-gains-deprecationmapping-old-name-sub-controller-gains-new-name-classical-config-adaptive-config-level-deprecationlevel-error-message-sub-controller-gains-replaced-with-full-sub-controller-configurations-migration-guide-replace-sub-controller-gains-with-complete-classical-config-and-adaptive-config-objects-this-provides-full-parameter-control-for-each-sub-controller-see-hybrid-smc-configuration-examples-in-documentation-removed-in-version-2-0-0-auto-migrate-false">runnable: false HYBRID_SMC_DEPRECATIONS = { ‚Äòmode‚Äô: DeprecationMapping( old_name=‚Äômode‚Äô, new_name=‚Äôhybrid_mode‚Äô, level=DeprecationLevel.WARNING, message=‚Äú‚Äòmode‚Äô parameter renamed to ‚Äòhybrid_mode‚Äô.‚Äù, migration_guide=( ‚ÄúReplace ‚Äòmode‚Äô with ‚Äòhybrid_mode‚Äô and use HybridMode enum values. ‚Äú ‚ÄúAvailable modes: ‚ÄòCLASSICAL_ADAPTIVE‚Äô, ‚ÄòADAPTIVE_STA‚Äô, ‚ÄòCLASSICAL_STA‚Äô. ‚Äú ‚ÄúExample: hybrid_mode: ‚ÄòCLASSICAL_ADAPTIVE‚Äô‚Äù ), removed_in_version=‚Äù3.0.0‚Äù, auto_migrate=True ), ‚Äòswitch_threshold‚Äô: DeprecationMapping( old_name=‚Äôswitch_threshold‚Äô, new_name=‚Äôswitching_criteria‚Äô, level=DeprecationLevel.WARNING, message=‚Äú‚Äòswitch_threshold‚Äô renamed to ‚Äòswitching_criteria‚Äô with enhanced functionality.‚Äù, migration_guide=( ‚ÄúReplace ‚Äòswitch_threshold‚Äô with ‚Äòswitching_criteria‚Äô configuration. ‚Äú ‚ÄúNew format supports multiple criteria: error_threshold, time_threshold, performance_threshold. ‚Äú ‚ÄúExample: switching_criteria: {error_threshold: 0.1, time_threshold: 2.0}‚Äù ), removed_in_version=‚Äù3.0.0‚Äù, auto_migrate=False # Requires manual migration due to format change ), ‚Äòsub_controller_gains‚Äô: DeprecationMapping( old_name=‚Äôsub_controller_gains‚Äô, new_name=[‚Äòclassical_config‚Äô, ‚Äòadaptive_config‚Äô], level=DeprecationLevel.ERROR, message=‚Äú‚Äòsub_controller_gains‚Äô replaced with full sub-controller configurations.‚Äù, migration_guide=( ‚ÄúReplace ‚Äòsub_controller_gains‚Äô with complete ‚Äòclassical_config‚Äô and ‚Äòadaptive_config‚Äô objects. ‚Äú ‚ÄúThis provides full parameter control for each sub-controller. ‚Äú ‚ÄúSee hybrid SMC configuration examples in documentation.‚Äù ), removed_in_version=‚Äù2.0.0‚Äù, auto_migrate=False )</a></li>
<li class="toctree-l1"><a class="reference internal" href="deprecation_management.html#id5">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="deprecation_management.html#runnable-false-safe-for-automatic-migration-simple-rename-deprecationmapping-old-name-old-name-new-name-new-name-auto-migrate-true-requires-manual-migration-complex-change-deprecationmapping-old-name-complex-param-new-name-restructured-config-auto-migrate-false-semantic-change-requires-manual-intervention-migration-guide-see-migration-guide-at-docs-migration-v3-0-md-usage-and-monitoringpython">runnable: false # Safe for automatic migration simple_rename = DeprecationMapping( old_name=‚Äôold_name‚Äô, new_name=‚Äônew_name‚Äô, auto_migrate=True ) # Requires manual migration complex_change = DeprecationMapping( old_name=‚Äôcomplex_param‚Äô, new_name=‚Äôrestructured_config‚Äô, auto_migrate=False, # Semantic change requires manual intervention migration_guide=‚ÄùSee migration guide at docs/migration/v3.0.md‚Äù ) <code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">Usage</span> <span class="pre">and</span> <span class="pre">Monitoring</span></code>python</a></li>
<li class="toctree-l1"><a class="reference internal" href="deprecation_management.html#id6">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="deprecation_management.html#runnable-false-global-deprecation-warner-instance">runnable: false # Global deprecation warner instance</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html">Parameter Interface Specification ## Overview This document provides a specification of the parameter interface system implemented in the SMC Controller Factory. The interface resolves the gamma vs gains parameter conflicts and establishes clear parameter handling contracts across all controller types. ## Parameter Resolution Architecture ### Hierarchical Parameter Sources The factory implements a multi-level parameter resolution system: ```</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html#runnable-false-def-resolve-controller-gains-gains-optional-union-list-float-np-ndarray-config-optional-any-controller-type-str-controller-info-dict-str-any">runnable: false def _resolve_controller_gains( gains: Optional[Union[List[float], np.ndarray]], config: Optional[Any], controller_type: str, controller_info: Dict[str, Any]</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html#runnable-false-parameter-structure-k1-k2-1-2-k-kd">runnable: false # Parameter Structure: [k1, k2, Œª1, Œª2, K, kd]</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html#runnable-false-parameter-structure-k1-k2-1-2">runnable: false # Parameter Structure: [k1, k2, Œª1, Œª2, Œ≥]</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html#runnable-false-parameter-structure-k1-k2-k1-k2-1-2">runnable: false # Parameter Structure: [K1, K2, k1, k2, Œª1, Œª2]</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html#id4">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html#runnable-false-parameter-structure-k1-k2-1-2-surface-gains-only">runnable: false # Parameter Structure: [k1, k2, Œª1, Œª2] (surface gains only)</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html#id5">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html#runnable-false-class-parametervalidator-parameter-validation-for-smc-controllers-staticmethod-def-validate-gain-structure-gains-list-float-controller-type-str-controller-info-dict-str-any-none-validate-gain-array-structure-and-constraints-1-length-validation-expected-count-controller-info-gain-count-if-len-gains-expected-count-raise-valueerror-f-controller-controller-type-requires-expected-count-gains-f-got-len-gains-expected-structure-controller-info-get-gain-names-2-numerical-validation-for-i-gain-in-enumerate-gains-if-not-isinstance-gain-int-float-raise-typeerror-f-gain-i-must-be-numeric-got-type-gain-if-not-np-isfinite-gain-raise-valueerror-f-gain-i-must-be-finite-got-gain-3-physical-constraint-validation-parametervalidator-validate-physical-constraints-gains-controller-type-staticmethod-def-validate-physical-constraints-gains-list-float-controller-type-str-none-validate-controller-specific-physical-constraints-if-controller-type-classical-smc-all-gains-must-be-positive-for-stability-if-any-g-0-for-g-in-gains-raise-valueerror-classical-smc-all-gains-must-be-positive-for-stability-specific-constraint-k-switching-gain-should-be-significant-k-gains-4-k-is-5th-element-if-k-1-0-warnings-warn-f-classical-smc-k-k-may-be-too-small-for-effective-switching-elif-controller-type-adaptive-smc-surface-gains-must-be-positive-if-any-g-0-for-g-in-gains-4-raise-valueerror-adaptive-smc-surface-gains-k1-k2-1-2-must-be-positive-gamma-adaptation-rate-constraints-gamma-gains-4-if-gamma-0-raise-valueerror-adaptive-smc-adaptation-rate-must-be-positive-if-gamma-10-0-warnings-warn-f-adaptive-smc-gamma-may-cause-adaptation-instability-elif-controller-type-sta-smc-all-gains-positive-for-sta-stability-if-any-g-0-for-g-in-gains-raise-valueerror-sta-smc-all-gains-must-be-positive-sta-specific-constraint-k1-k2-typically-k1-k2-gains-0-gains-1-if-k1-k2-warnings-warn-sta-smc-typically-k1-k2-for-proper-sta-operation-elif-controller-type-hybrid-adaptive-sta-smc-only-surface-gains-for-hybrid-controller-if-any-g-0-for-g-in-gains-raise-valueerror-hybrid-smc-all-surface-gains-must-be-positive">runnable: false class ParameterValidator: ‚Äú‚Äù‚Äùparameter validation for SMC controllers.‚Äù‚Äù‚Äù &#64;staticmethod def validate_gain_structure( gains: List[float], controller_type: str, controller_info: Dict[str, Any] ) -&gt; None: ‚Äú‚Äù‚ÄùValidate gain array structure and constraints.‚Äù‚Äù‚Äù # 1. Length validation expected_count = controller_info[‚Äògain_count‚Äô] if len(gains) != expected_count: raise ValueError( f‚ÄùController ‚Äò{controller_type}‚Äô requires {expected_count} gains, ‚Äú f‚Äùgot {len(gains)}. Expected structure: {controller_info.get(‚Äògain_names‚Äô, [])}‚Äù ) # 2. Numerical validation for i, gain in enumerate(gains): if not isinstance(gain, (int, float)): raise TypeError(f‚ÄùGain[{i}] must be numeric, got {type(gain)}‚Äù) if not np.isfinite(gain): raise ValueError(f‚ÄùGain[{i}] must be finite, got {gain}‚Äù) # 3. Physical constraint validation ParameterValidator._validate_physical_constraints(gains, controller_type) &#64;staticmethod def _validate_physical_constraints(gains: List[float], controller_type: str) -&gt; None: ‚Äú‚Äù‚ÄùValidate controller-specific physical constraints.‚Äù‚Äù‚Äù if controller_type == ‚Äòclassical_smc‚Äô: # All gains must be positive for stability if any(g &lt;= 0 for g in gains): raise ValueError(‚ÄúClassical SMC: All gains must be positive for stability‚Äù) # Specific constraint: K (switching gain) should be significant K = gains[4] # K is 5th element if K &lt; 1.0: warnings.warn(f‚ÄùClassical SMC: K={K} may be too small for effective switching‚Äù) elif controller_type == ‚Äòadaptive_smc‚Äô: # Surface gains must be positive if any(g &lt;= 0 for g in gains[:4]): raise ValueError(‚ÄúAdaptive SMC: Surface gains k1, k2, Œª1, Œª2 must be positive‚Äù) # Gamma (adaptation rate) constraints gamma = gains[4] if gamma &lt;= 0: raise ValueError(‚ÄúAdaptive SMC: Adaptation rate Œ≥ must be positive‚Äù) if gamma &gt; 10.0: warnings.warn(f‚ÄùAdaptive SMC: Œ≥={gamma} may cause adaptation instability‚Äù) elif controller_type == ‚Äòsta_smc‚Äô: # All gains positive for STA stability if any(g &lt;= 0 for g in gains): raise ValueError(‚ÄúSTA-SMC: All gains must be positive‚Äù) # STA-specific constraint: K1 &gt; K2 typically K1, K2 = gains[0], gains[1] if K1 &lt;= K2: warnings.warn(‚ÄúSTA-SMC: Typically K1 &gt; K2 for proper STA operation‚Äù) elif controller_type == ‚Äòhybrid_adaptive_sta_smc‚Äô: # Only surface gains for hybrid controller if any(g &lt;= 0 for g in gains): raise ValueError(‚ÄúHybrid SMC: All surface gains must be positive‚Äù)</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html#id6">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html#runnable-false-def-validate-parameter-ranges-gains-list-float-controller-type-str-bounds-optional-list-tuple-float-float-none">runnable: false def validate_parameter_ranges( gains: List[float], controller_type: str, bounds: Optional[List[Tuple[float, float]]] = None</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html#id7">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html#runnable-false-def-extract-controller-parameters-config-optional-any-controller-type-str-controller-info-dict-str-any">runnable: false def _extract_controller_parameters( config: Optional[Any], controller_type: str, controller_info: Dict[str, Any]</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html#id8">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html#runnable-false-class-parameterresolutionerror-valueerror-raised-when-parameter-resolution-fails-pass-class-gainvalidationerror-valueerror-raised-when-gain-validation-fails-pass-def-create-controller-with-parameter-recovery-controller-type-str-config-optional-any-none-gains-optional-union-list-np-ndarray-none">runnable: false class ParameterResolutionError(ValueError): ‚Äú‚Äù‚ÄùRaised when parameter resolution fails.‚Äù‚Äù‚Äù pass class GainValidationError(ValueError): ‚Äú‚Äù‚ÄùRaised when gain validation fails.‚Äù‚Äù‚Äù pass def create_controller_with_parameter_recovery( controller_type: str, config: Optional[Any] = None, gains: Optional[Union[list, np.ndarray]] = None</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html#id9">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameter_interface_specification.html#runnable-false-def-create-minimal-config-controller-type-str-dict-str-any-create-minimal-viable-configuration-for-controller-type-base-config-max-force-150-0-dt-0-001-add-controller-specific-minimal-parameters-if-controller-type-classical-smc-base-config-boundary-layer-0-02-elif-controller-type-adaptive-smc-base-config-update-leak-rate-0-01-adapt-rate-limit-10-0-k-min-0-1-k-max-100-0-k-init-10-0-alpha-0-5-elif-controller-type-sta-smc-base-config-update-power-exponent-0-5-regularization-1e-6-switch-method-tanh-return-base-config">runnable: false def create_minimal_config(controller_type: str) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùCreate minimal viable configuration for controller type.‚Äù‚Äù‚Äù base_config = { ‚Äòmax_force‚Äô: 150.0, ‚Äòdt‚Äô: 0.001 } # Add controller-specific minimal parameters if controller_type == ‚Äòclassical_smc‚Äô: base_config[‚Äòboundary_layer‚Äô] = 0.02 elif controller_type == ‚Äòadaptive_smc‚Äô: base_config.update({ ‚Äòleak_rate‚Äô: 0.01, ‚Äòadapt_rate_limit‚Äô: 10.0, ‚ÄòK_min‚Äô: 0.1, ‚ÄòK_max‚Äô: 100.0, ‚ÄòK_init‚Äô: 10.0, ‚Äòalpha‚Äô: 0.5 }) elif controller_type == ‚Äòsta_smc‚Äô: base_config.update({ ‚Äòpower_exponent‚Äô: 0.5, ‚Äòregularization‚Äô: 1e-6, ‚Äòswitch_method‚Äô: ‚Äòtanh‚Äô }) return base_config</a></li>
</ul>
</div>
</section>
<section id="pso-integration">
<h3>PSO Integration<a class="headerlink" href="#pso-integration" title="Link to this heading">¬∂</a></h3>
<div class="toctree-wrapper compound">
<p class="caption" role="heading"><span class="caption-text">PSO Integration</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="enhanced_pso_integration_guide.html">Enhanced PSO Integration Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="enhanced_pso_integration_guide.html#complete-workflow-specifications-for-controller-optimization-overview-this-guide-documents-the-complete-integration-between-the-enhanced-controller-factory-and-particle-swarm-optimization-pso-workflows-for-automated-controller-parameter-tuning-the-integration-provides-validated-thread-safe-mathematically-rigorous-optimization-features-for-all-smc-controller-variants-pso-integration-architecture-system-overview-pso-engine-population-velocity-update-management-position-candidate-gains-factory-pso-bridge-gain-controller-validation-instantiation-controller-instance-simulation-evaluation-dip-plant-performance-simulation-metrics-fitness-score-pso-update-fitness-guided-search">Complete Workflow Specifications for Controller Optimization ### Overview This guide documents the complete integration between the Enhanced Controller Factory and Particle Swarm Optimization (PSO) workflows for automated controller parameter tuning. The integration provides validated, thread-safe, mathematically rigorous optimization features for all SMC controller variants. ## PSO Integration Architecture ### System Overview ``` ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ PSO Engine ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ Population ‚îÇ ‚îÇ Velocity Update ‚îÇ ‚îÇ ‚îÇ ‚îÇ Management ‚îÇ ‚îÇ &amp; Position ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ Candidate Gains ‚ñº ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Factory-PSO Bridge ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ Gain ‚îÇ ‚îÇ Controller ‚îÇ ‚îÇ ‚îÇ ‚îÇ Validation ‚îÇ ‚îÇ Instantiation ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ Controller Instance ‚ñº ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Simulation &amp; Evaluation ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ DIP Plant ‚îÇ ‚îÇ Performance ‚îÇ ‚îÇ ‚îÇ ‚îÇ Simulation ‚îÇ ‚îÇ Metrics ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ Fitness Score ‚ñº ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ PSO Update ‚îÇ ‚îÇ (Fitness-Guided Search) ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="enhanced_pso_integration_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="enhanced_pso_integration_guide.html#runnable-false-class-psofactoryinterface-high-performance-interface-for-pso-optimization-workflows-features-thread-safe-parallel-optimization-automatic-gain-validation-and-bounds-checking-performance-monitoring-and-diagnostics-fallback-mechanisms-for-invalid-parameter-sets-def-init-self-controller-type-str-simulation-config-any-self-controller-type-controller-type-self-config-simulation-config-self-initialize-pso-environment-def-initialize-pso-environment-self-none-setup-pso-optimization-environment-with-all-requirements-controller-specifications-self-registry-info-controller-registry-self-controller-type-self-n-gains-self-registry-info-gain-count-self-default-gains-self-registry-info-default-gains-pso-bounds-mathematically-derived-self-bounds-lower-self-bounds-upper-get-gain-bounds-for-pso-smctype-self-controller-type-performance-tracking-self-metrics-total-evaluations-0-successful-evaluations-0-validation-failures-0-simulation-failures-0-best-fitness-float-inf-average-fitness-0-0-thread-safety-self-evaluation-lock-threading-rlock">runnable: false class PSOFactoryInterface: ‚Äú‚Äù‚Äù High-performance interface for PSO optimization workflows. Features: - Thread-safe parallel optimization - Automatic gain validation and bounds checking - Performance monitoring and diagnostics - Fallback mechanisms for invalid parameter sets ‚Äú‚Äù‚Äù def <strong>init</strong>(self, controller_type: str, simulation_config: Any): self.controller_type = controller_type self.config = simulation_config self._initialize_pso_environment() def _initialize_pso_environment(self) -&gt; None: ‚Äú‚Äù‚ÄùSetup PSO optimization environment with all requirements.‚Äù‚Äù‚Äù # Controller specifications self.registry_info = CONTROLLER_REGISTRY[self.controller_type] self.n_gains = self.registry_info[‚Äògain_count‚Äô] self.default_gains = self.registry_info[‚Äòdefault_gains‚Äô] # PSO bounds (mathematically derived) self.bounds_lower, self.bounds_upper = get_gain_bounds_for_pso( SMCType(self.controller_type) ) # Performance tracking self.metrics = { ‚Äòtotal_evaluations‚Äô: 0, ‚Äòsuccessful_evaluations‚Äô: 0, ‚Äòvalidation_failures‚Äô: 0, ‚Äòsimulation_failures‚Äô: 0, ‚Äòbest_fitness‚Äô: float(‚Äòinf‚Äô), ‚Äòaverage_fitness‚Äô: 0.0 } # Thread safety self._evaluation_lock = threading.RLock()</a></li>
<li class="toctree-l1"><a class="reference internal" href="enhanced_pso_integration_guide.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="enhanced_pso_integration_guide.html#runnable-false-class-psocontrollerwrapper-pso-optimized-controller-wrapper-with-validation-provides-simplified-control-interface-for-fitness-evaluation-automatic-gain-validation-with-controller-specific-rules-performance-monitoring-and-error-handling-thread-safe-operation-for-parallel-pso-def-init-self-controller-any-controller-type-str-validation-config-dict-str-any-self-controller-controller-self-controller-type-controller-type-self-validation-config-validation-config-pso-required-attributes-self-n-gains-controller-registry-controller-type-gain-count-self-max-force-getattr-controller-max-force-150-0-performance-tracking-self-control-calls-0-self-control-failures-0-self-last-control-time-0-0-def-validate-gains-self-particles-np-ndarray-np-ndarray-vectorized-gain-validation-for-pso-particle-swarms-args-particles-array-of-shape-n-particles-n-gains-returns-boolean-mask-indicating-valid-particles-if-particles-ndim-1-particles-particles-reshape-1-1-valid-mask-np-ones-particles-shape-0-dtype-bool-basic-validation-for-i-gains-in-enumerate-particles-try-check-gain-count-if-len-gains-self-n-gains-valid-mask-i-false-continue-check-for-finite-positive-values-if-not-all-np-isfinite-g-and-g-0-for-g-in-gains-valid-mask-i-false-continue-controller-specific-validation-if-not-self-validate-controller-specific-constraints-gains-valid-mask-i-false-continue-except-exception-valid-mask-i-false-return-valid-mask-def-validate-controller-specific-constraints-self-gains-list-float-bool-apply-mathematical-constraints-for-each-controller-type-if-self-controller-type-classical-smc-classical-smc-all-gains-positive-reasonable-ranges-k1-k2-lam1-lam2-k-kd-gains-return-all-g-0-for-g-in-gains-5-and-kd-0-elif-self-controller-type-sta-smc-super-twisting-critical-stability-condition-k1-k2-k1-k2-gains-0-gains-1-return-k1-k2-0-and-all-g-0-for-g-in-gains-2-elif-self-controller-type-adaptive-smc-adaptive-smc-adaptation-rate-bounds-k1-k2-lam1-lam2-gamma-gains-return-all-g-0-for-g-in-gains-4-and-0-1-gamma-20-0-elif-self-controller-type-hybrid-adaptive-sta-smc-hybrid-smc-surface-parameters-positive-return-all-g-0-for-g-in-gains-return-true-def-compute-control-self-state-np-ndarray-np-ndarray-pso-compatible-control-computation-with-error-handling-args-state-system-state-vector-1-2-x-1-2-x-returns-control-output-as-numpy-array-try-self-control-calls-1-start-time-time-time-validate-input-state-if-len-state-6-raise-valueerror-f-expected-6-element-state-got-len-state-call-underlying-controller-result-self-controller-compute-control-state-extract-control-value-if-hasattr-result-u-u-result-u-elif-isinstance-result-dict-and-u-in-result-u-result-u-else-u-result-apply-saturation-and-return-as-array-u-sat-np-clip-float-u-self-max-force-self-max-force-performance-tracking-self-last-control-time-time-time-start-time-return-np-array-u-sat-except-exception-as-e-self-control-failures-1-return-safe-fallback-control-return-np-array-0-0">runnable: false class PSOControllerWrapper: ‚Äú‚Äù‚Äù PSO-optimized controller wrapper with validation. Provides: - Simplified control interface for fitness evaluation - Automatic gain validation with controller-specific rules - Performance monitoring and error handling - Thread-safe operation for parallel PSO ‚Äú‚Äù‚Äù def <strong>init</strong>(self, controller: Any, controller_type: str, validation_config: Dict[str, Any]): self.controller = controller self.controller_type = controller_type self.validation_config = validation_config # PSO-required attributes self.n_gains = CONTROLLER_REGISTRY[controller_type][‚Äògain_count‚Äô] self.max_force = getattr(controller, ‚Äòmax_force‚Äô, 150.0) # Performance tracking self.control_calls = 0 self.control_failures = 0 self.last_control_time = 0.0 def validate_gains(self, particles: np.ndarray) -&gt; np.ndarray: ‚Äú‚Äù‚Äù Vectorized gain validation for PSO particle swarms. Args: particles: Array of shape (n_particles, n_gains) Returns: Boolean mask indicating valid particles ‚Äú‚Äù‚Äù if particles.ndim == 1: particles = particles.reshape(1, -1) valid_mask = np.ones(particles.shape[0], dtype=bool) # Basic validation for i, gains in enumerate(particles): try: # Check gain count if len(gains) != self.n_gains: valid_mask[i] = False continue # Check for finite positive values if not all(np.isfinite(g) and g &gt; 0 for g in gains): valid_mask[i] = False continue # Controller-specific validation if not self._validate_controller_specific_constraints(gains): valid_mask[i] = False continue except Exception: valid_mask[i] = False return valid_mask def _validate_controller_specific_constraints(self, gains: List[float]) -&gt; bool: ‚Äú‚Äù‚ÄùApply mathematical constraints for each controller type.‚Äù‚Äù‚Äù if self.controller_type == ‚Äòclassical_smc‚Äô: # Classical SMC: All gains positive, reasonable ranges k1, k2, lam1, lam2, K, kd = gains return all(g &gt; 0 for g in gains[:5]) and kd &gt;= 0 elif self.controller_type == ‚Äòsta_smc‚Äô: # Super-Twisting: Critical stability condition K1 &gt; K2 K1, K2 = gains[0], gains[1] return K1 &gt; K2 &gt; 0 and all(g &gt; 0 for g in gains[2:]) elif self.controller_type == ‚Äòadaptive_smc‚Äô: # Adaptive SMC: Adaptation rate bounds k1, k2, lam1, lam2, gamma = gains return all(g &gt; 0 for g in gains[:4]) and 0.1 &lt;= gamma &lt;= 20.0 elif self.controller_type == ‚Äòhybrid_adaptive_sta_smc‚Äô: # Hybrid SMC: Surface parameters positive return all(g &gt; 0 for g in gains) return True def compute_control(self, state: np.ndarray) -&gt; np.ndarray: ‚Äú‚Äù‚Äù PSO-compatible control computation with error handling. Args: state: System state vector [Œ∏‚ÇÅ, Œ∏‚ÇÇ, x, Œ∏Ãá‚ÇÅ, Œ∏Ãá‚ÇÇ, ·∫ã] Returns: Control output as numpy array ‚Äú‚Äù‚Äù try: self.control_calls += 1 start_time = time.time() # Validate input state if len(state) != 6: raise ValueError(f‚ÄùExpected 6-element state, got {len(state)}‚Äù) # Call underlying controller result = self.controller.compute_control(state, {}, {}) # Extract control value if hasattr(result, ‚Äòu‚Äô): u = result.u elif isinstance(result, dict) and ‚Äòu‚Äô in result: u = result[‚Äòu‚Äô] else: u = result # Apply saturation and return as array u_sat = np.clip(float(u), -self.max_force, self.max_force) # Performance tracking self.last_control_time = time.time() - start_time return np.array([u_sat]) except Exception as e: self.control_failures += 1 # Return safe fallback control return np.array([0.0])</a></li>
<li class="toctree-l1"><a class="reference internal" href="enhanced_pso_integration_guide.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="enhanced_pso_integration_guide.html#runnable-false-def-multi-objective-pso-optimization-controller-types-list-str-simulation-config-any-objectives-dict-str-float-ise-0-4-overshoot-0-3-energy-0-3-pso-config-dict-str-any">runnable: false def multi_objective_pso_optimization( controller_types: List[str], simulation_config: Any, objectives: Dict[str, float], # {‚Äòise‚Äô: 0.4, ‚Äòovershoot‚Äô: 0.3, ‚Äòenergy‚Äô: 0.3} pso_config: Dict[str, Any]</a></li>
<li class="toctree-l1"><a class="reference internal" href="enhanced_pso_integration_guide.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="enhanced_pso_integration_guide.html#runnable-false-def-adaptive-pso-optimization-controller-type-str-simulation-config-any-adaptation-config-dict-str-any">runnable: false def adaptive_pso_optimization( controller_type: str, simulation_config: Any, adaptation_config: Dict[str, Any]</a></li>
<li class="toctree-l1"><a class="reference internal" href="enhanced_pso_integration_guide.html#id4">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="enhanced_pso_integration_guide.html#runnable-false-class-simulationcache-intelligent-caching-system-for-pso-optimization-features-hash-based-lookup-for-identical-gain-sets-lru-eviction-for-memory-management-cache-hit-miss-statistics-persistent-storage-for-long-running-optimizations-def-init-self-max-size-int-1000-tolerance-float-1e-6-self-cache-self-max-size-max-size-self-tolerance-tolerance-self-hits-0-self-misses-0-def-get-cache-key-self-gains-np-ndarray-str-generate-consistent-cache-key-for-gain-arrays-rounded-gains-np-round-gains-self-tolerance-self-tolerance-return-hash-tuple-rounded-gains-def-get-self-gains-np-ndarray-optional-float-retrieve-cached-fitness-if-available-key-self-get-cache-key-gains-if-key-in-self-cache-self-hits-1-return-self-cache-key-self-misses-1-return-none-def-put-self-gains-np-ndarray-fitness-float-none-store-fitness-result-in-cache-if-len-self-cache-self-max-size-remove-oldest-entry-simple-lru-oldest-key-next-iter-self-cache-del-self-cache-oldest-key-key-self-get-cache-key-gains-self-cache-key-fitness-def-get-statistics-self-dict-str-any-return-cache-performance-statistics-total-requests-self-hits-self-misses-hit-rate-self-hits-total-requests-if-total-requests-0-else-0-return-hits-self-hits-misses-self-misses-hit-rate-hit-rate-cache-size-len-self-cache">runnable: false class SimulationCache: ‚Äú‚Äù‚Äù Intelligent caching system for PSO optimization. Features: - Hash-based lookup for identical gain sets - LRU eviction for memory management - Cache hit/miss statistics - Persistent storage for long-running optimizations ‚Äú‚Äù‚Äù def <strong>init</strong>(self, max_size: int = 1000, tolerance: float = 1e-6): self.cache = {} self.max_size = max_size self.tolerance = tolerance self.hits = 0 self.misses = 0 def get_cache_key(self, gains: np.ndarray) -&gt; str: ‚Äú‚Äù‚ÄùGenerate consistent cache key for gain arrays.‚Äù‚Äù‚Äù rounded_gains = np.round(gains / self.tolerance) * self.tolerance return hash(tuple(rounded_gains)) def get(self, gains: np.ndarray) -&gt; Optional[float]: ‚Äú‚Äù‚ÄùRetrieve cached fitness if available.‚Äù‚Äù‚Äù key = self.get_cache_key(gains) if key in self.cache: self.hits += 1 return self.cache[key] self.misses += 1 return None def put(self, gains: np.ndarray, fitness: float) -&gt; None: ‚Äú‚Äù‚ÄùStore fitness result in cache.‚Äù‚Äù‚Äù if len(self.cache) &gt;= self.max_size: # Remove oldest entry (simple LRU) oldest_key = next(iter(self.cache)) del self.cache[oldest_key] key = self.get_cache_key(gains) self.cache[key] = fitness def get_statistics(self) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùReturn cache performance statistics.‚Äù‚Äù‚Äù total_requests = self.hits + self.misses hit_rate = self.hits / total_requests if total_requests &gt; 0 else 0 return { ‚Äòhits‚Äô: self.hits, ‚Äòmisses‚Äô: self.misses, ‚Äòhit_rate‚Äô: hit_rate, ‚Äòcache_size‚Äô: len(self.cache) }</a></li>
<li class="toctree-l1"><a class="reference internal" href="enhanced_pso_integration_guide.html#id5">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="enhanced_pso_integration_guide.html#runnable-false-def-get-optimized-pso-bounds-controller-type-str-plant-params-dict-str-any-tuple-list-float-list-float-compute-optimized-pso-bounds-based-on-plant-parameters-and-control-theory-uses-stability-margins-and-performance-requirements-to-derive-tight-bounds-if-controller-type-classical-smc-classical-smc-bounds-based-on-stability-analysis-pole-placement-considerations-for-closed-loop-stability-max-damping-plant-params-get-max-damping-requirement-0-7-settling-time-plant-params-get-settling-time-requirement-2-0-derive-bounds-from-desired-closed-loop-characteristics-lambda-min-4-0-settling-time-natural-frequency-requirement-lambda-max-20-0-upper-bound-to-prevent-excessive-control-effort-k-min-lambda-min-2-0-position-gain-lower-bound-k-max-lambda-max-2-0-position-gain-upper-bound-k-min-estimate-min-switching-gain-plant-params-k-max-plant-params-get-max-force-150-0-0-8-conservative-upper-bound-bounds-lower-k-min-k-min-lambda-min-lambda-min-k-min-0-0-bounds-upper-k-max-k-max-lambda-max-lambda-max-k-max-10-0-elif-controller-type-sta-smc-super-twisting-bounds-with-stability-constraint-k1-k2-lyapunov-based-design-bounds-l0-estimate-lipschitz-constant-plant-params-k1-min-math-sqrt-l0-1-1-safety-margin-k1-max-math-sqrt-l0-5-0-conservative-upper-bound-k2-min-l0-2-math-sqrt-l0-k1-min-2-1-1-k2-max-k1-max-0-8-ensure-k1-k2-constraint-bounds-lower-k1-min-k2-min-2-0-2-0-5-0-5-0-bounds-upper-k1-max-k2-max-30-0-30-0-20-0-20-0-elif-controller-type-adaptive-smc-adaptive-smc-bounds-based-on-adaptation-rate-limits-stability-preserving-adaptation-rate-bounds-gamma-min-0-1-minimum-for-reasonable-adaptation-speed-gamma-max-estimate-max-adaptation-rate-plant-params-stability-limit-bounds-lower-2-0-2-0-5-0-5-0-gamma-min-bounds-upper-40-0-40-0-25-0-25-0-gamma-max-else-hybrid-adaptive-sta-smc-hybrid-controller-bounds-conservative-surface-parameters-bounds-lower-2-0-2-0-5-0-5-0-bounds-upper-30-0-30-0-20-0-20-0-return-bounds-lower-bounds-upper-def-estimate-min-switching-gain-plant-params-dict-str-any-float-estimate-minimum-switching-gain-based-on-disturbance-bounds-extract-disturbance-characteristics-max-model-uncertainty-plant-params-get-model-uncertainty-0-2-max-external-disturbance-plant-params-get-external-disturbance-5-0-safety-margin-plant-params-get-safety-margin-1-5-conservative-estimate-return-max-model-uncertainty-max-external-disturbance-safety-margin-def-estimate-lipschitz-constant-plant-params-dict-str-any-float-estimate-lipschitz-constant-for-sta-design-based-on-system-nonlinearity-and-uncertainty-bounds-max-nonlinearity-plant-params-get-max-nonlinearity-10-0-uncertainty-bound-plant-params-get-uncertainty-bound-5-0-return-max-nonlinearity-uncertainty-bound-def-estimate-max-adaptation-rate-plant-params-dict-str-any-float-estimate-maximum-stable-adaptation-rate-based-on-parameter-variation-speed-and-system-bandwidth-system-bandwidth-plant-params-get-system-bandwidth-10-0-rad-s-parameter-variation-rate-plant-params-get-parameter-variation-rate-0-1-hz-conservative-bound-adaptation-much-slower-than-system-dynamics-return-min-system-bandwidth-10-0-1-0-parameter-variation-rate">runnable: false def get_optimized_pso_bounds(controller_type: str, plant_params: Dict[str, Any]) -&gt; Tuple[List[float], List[float]]: ‚Äú‚Äù‚Äù Compute optimized PSO bounds based on plant parameters and control theory. Uses stability margins and performance requirements to derive tight bounds. ‚Äú‚Äù‚Äù if controller_type == ‚Äòclassical_smc‚Äô: # Classical SMC bounds based on stability analysis # Pole placement considerations for closed-loop stability max_damping = plant_params.get(‚Äòmax_damping_requirement‚Äô, 0.7) settling_time = plant_params.get(‚Äòsettling_time_requirement‚Äô, 2.0) # Derive bounds from desired closed-loop characteristics lambda_min = 4.0 / settling_time # Natural frequency requirement lambda_max = 20.0 # Upper bound to prevent excessive control effort k_min = lambda_min / 2.0 # Position gain lower bound k_max = lambda_max * 2.0 # Position gain upper bound K_min = estimate_min_switching_gain(plant_params) K_max = plant_params.get(‚Äòmax_force‚Äô, 150.0) * 0.8 # Conservative upper bound bounds_lower = [k_min, k_min, lambda_min, lambda_min, K_min, 0.0] bounds_upper = [k_max, k_max, lambda_max, lambda_max, K_max, 10.0] elif controller_type == ‚Äòsta_smc‚Äô: # Super-Twisting bounds with stability constraint K1 &gt; K2 # Lyapunov-based design bounds L0 = estimate_lipschitz_constant(plant_params) K1_min = math.sqrt(L0) * 1.1 # Safety margin K1_max = math.sqrt(L0) * 5.0 # Conservative upper bound K2_min = L0 / (2 * math.sqrt(L0 - K1_min**2)) * 1.1 K2_max = K1_max * 0.8 # Ensure K1 &gt; K2 constraint bounds_lower = [K1_min, K2_min, 2.0, 2.0, 5.0, 5.0] bounds_upper = [K1_max, K2_max, 30.0, 30.0, 20.0, 20.0] elif controller_type == ‚Äòadaptive_smc‚Äô: # Adaptive SMC bounds based on adaptation rate limits # Stability-preserving adaptation rate bounds gamma_min = 0.1 # Minimum for reasonable adaptation speed gamma_max = estimate_max_adaptation_rate(plant_params) # Stability limit bounds_lower = [2.0, 2.0, 5.0, 5.0, gamma_min] bounds_upper = [40.0, 40.0, 25.0, 25.0, gamma_max] else: # hybrid_adaptive_sta_smc # Hybrid controller bounds (conservative surface parameters) bounds_lower = [2.0, 2.0, 5.0, 5.0] bounds_upper = [30.0, 30.0, 20.0, 20.0] return bounds_lower, bounds_upper def estimate_min_switching_gain(plant_params: Dict[str, Any]) -&gt; float: ‚Äú‚Äù‚ÄùEstimate minimum switching gain based on disturbance bounds.‚Äù‚Äù‚Äù # Extract disturbance characteristics max_model_uncertainty = plant_params.get(‚Äòmodel_uncertainty‚Äô, 0.2) max_external_disturbance = plant_params.get(‚Äòexternal_disturbance‚Äô, 5.0) safety_margin = plant_params.get(‚Äòsafety_margin‚Äô, 1.5) # Conservative estimate return (max_model_uncertainty + max_external_disturbance) * safety_margin def estimate_lipschitz_constant(plant_params: Dict[str, Any]) -&gt; float: ‚Äú‚Äù‚ÄùEstimate Lipschitz constant for STA design.‚Äù‚Äù‚Äù # Based on system nonlinearity and uncertainty bounds max_nonlinearity = plant_params.get(‚Äòmax_nonlinearity‚Äô, 10.0) uncertainty_bound = plant_params.get(‚Äòuncertainty_bound‚Äô, 5.0) return max_nonlinearity + uncertainty_bound def estimate_max_adaptation_rate(plant_params: Dict[str, Any]) -&gt; float: ‚Äú‚Äù‚ÄùEstimate maximum stable adaptation rate.‚Äù‚Äù‚Äù # Based on parameter variation speed and system bandwidth system_bandwidth = plant_params.get(‚Äòsystem_bandwidth‚Äô, 10.0) # rad/s parameter_variation_rate = plant_params.get(‚Äòparameter_variation_rate‚Äô, 0.1) # Hz # Conservative bound: adaptation much slower than system dynamics return min(system_bandwidth / 10.0, 1.0 / parameter_variation_rate)</a></li>
<li class="toctree-l1"><a class="reference internal" href="enhanced_pso_integration_guide.html#id6">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="enhanced_pso_integration_guide.html#runnable-false-from-dataclasses-import-dataclass">runnable: false from dataclasses import dataclass</a></li>
<li class="toctree-l1"><a class="reference internal" href="pso_factory_api_reference.html">PSO Factory Integration API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pso_factory_api_reference.html#complete-documentation-for-pso-optimized-controller-factory-table-of-contents">Complete Documentation for PSO-Optimized Controller Factory ### Table of Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="pso_factory_api_reference.html#api-overview-the-pso-factory-integration-api-provides-a-framework-for-optimizing-sliding-mode-controllers-using-particle-swarm-optimization-the-api-is-designed-with-the-following-principles-design-philosophy">API Overview The PSO Factory Integration API provides a framework for optimizing sliding mode controllers using Particle Swarm Optimization. The API is designed with the following principles: ### Design Philosophy</a></li>
<li class="toctree-l2"><a class="reference internal" href="pso_factory_api_reference.html#core-pso-integration-classes-smctype-enumeration-python">Core PSO Integration Classes ### SMCType Enumeration ```python</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pso_factory_api_reference.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="pso_factory_api_reference.html#runnable-false-class-smctype-enum-enumeration-of-supported-smc-controller-types-for-pso-optimization-each-type-corresponds-to-a-specific-sliding-mode-control-algorithm-with-distinct-mathematical-properties-and-parameter-requirements-classical-classical-smc-classical-sliding-mode-controller-with-boundary-layer-mathematical-model-u-u-eq-u-sw-u-eq-gb-1-gf-x-s-ref-u-sw-ktanh-s-gain-parameters-k1-k2-1-2-k-kd-k1-k2-position-gains-for-pendulum-1-and-2-1-2-surface-gains-for-pendulum-1-and-2-k-switching-gain-kd-damping-gain-mathematical-constraints-1-2-k-0-stability-requirement-kd-0-non-negative-damping-pso-bounds-0-1-50-0-1-50-1-50-1-50-1-200-0-50-super-twisting-sta-smc-super-twisting-sliding-mode-controller-second-order-mathematical-model-u-k1sign-s-k2sign-s-s-x-sliding-surface-gain-parameters-k1-k2-1-2-1-2-k1-primary-twisting-gain-k2-secondary-twisting-gain-1-2-surface-gains-1-2-higher-order-surface-parameters-mathematical-constraints-k1-k2-0-finite-time-convergence-1-2-1-2-0-stability-pso-bounds-2-100-1-99-1-50-1-50-1-50-1-50-adaptive-adaptive-smc-adaptive-sliding-mode-controller-with-online-gain-tuning-mathematical-model-u-u-eq-u-sw-k-s-k-adaptation-law-gain-parameters-k1-k2-1-2-k1-k2-position-gains-1-2-surface-gains-adaptation-rate-mathematical-constraints-k1-k2-1-2-0-stability-0-1-20-0-bounded-adaptation-pso-bounds-0-1-50-0-1-50-1-50-1-50-0-1-20-hybrid-hybrid-adaptive-sta-smc-hybrid-adaptive-super-twisting-controller-mathematical-model-u-u-adaptive-u-sta-mode-switching-gain-parameters-k1-k2-1-2-k1-k2-surface-gains-for-pendulum-1-and-2-1-2-higher-order-surface-gains-mathematical-constraints-all-parameters-0-stability-pso-bounds-1-50-1-50-1-50-1-50-property-def-gain-count-self-int-return-number-of-gain-parameters-for-this-controller-type-return-smctype-classical-6-smctype-super-twisting-6-smctype-adaptive-5-smctype-hybrid-4-self-property-def-mathematical-constraints-self-dict-str-str-return-mathematical-constraints-as-human-readable-strings-return-smctype-classical-1-2-k-0-kd-0-smctype-super-twisting-k1-k2-0-1-2-1-2-0-smctype-adaptive-k1-k2-1-2-0-0-1-20-0-smctype-hybrid-k1-k2-1-2-0-self">runnable: false class SMCType(Enum): ‚Äú‚Äù‚Äù Enumeration of supported SMC controller types for PSO optimization. Each type corresponds to a specific sliding mode control algorithm with distinct mathematical properties and parameter requirements. ‚Äú‚Äù‚Äù CLASSICAL = ‚Äúclassical_smc‚Äù ‚Äú‚Äù‚Äù Classical sliding mode controller with boundary layer. Mathematical Model: u = u_eq + u_sw u_eq = (GB)^(-1)[-Gf(x) + ·π°_ref] u_sw = -K¬∑tanh(s/œÜ) Gain Parameters: [k1, k2, Œª1, Œª2, K, kd] k1, k2: Position gains for pendulum 1 and 2 Œª1, Œª2: Surface gains for pendulum 1 and 2 K: Switching gain kd: Damping gain Mathematical Constraints: - Œª1, Œª2, K &gt; 0 (stability requirement) - kd ‚â• 0 (non-negative damping) PSO Bounds: [(0.1,50), (0.1,50), (1,50), (1,50), (1,200), (0,50)] ‚Äú‚Äù‚Äù SUPER_TWISTING = ‚Äústa_smc‚Äù ‚Äú‚Äù‚Äù Super-twisting sliding mode controller (second-order). Mathematical Model: uÃá = -K1¬∑sign(s) - K2¬∑sign(·π°) s = œÉ(x) (sliding surface) Gain Parameters: [K1, K2, Œª1, Œª2, Œ±1, Œ±2] K1: Primary twisting gain K2: Secondary twisting gain Œª1, Œª2: Surface gains Œ±1, Œ±2: Higher-order surface parameters Mathematical Constraints: - K1 &gt; K2 &gt; 0 (finite-time convergence) - Œª1, Œª2, Œ±1, Œ±2 &gt; 0 (stability) PSO Bounds: [(2,100), (1,99), (1,50), (1,50), (1,50), (1,50)] ‚Äú‚Äù‚Äù ADAPTIVE = ‚Äúadaptive_smc‚Äù ‚Äú‚Äù‚Äù Adaptive sliding mode controller with online gain tuning. Mathematical Model: u = u_eq + u_sw KÃá = Œ≥|s| - œÉK (adaptation law) Gain Parameters: [k1, k2, Œª1, Œª2, Œ≥] k1, k2: Position gains Œª1, Œª2: Surface gains Œ≥: Adaptation rate Mathematical Constraints: - k1, k2, Œª1, Œª2 &gt; 0 (stability) - 0.1 ‚â§ Œ≥ ‚â§ 20.0 (bounded adaptation) PSO Bounds: [(0.1,50), (0.1,50), (1,50), (1,50), (0.1,20)] ‚Äú‚Äù‚Äù HYBRID = ‚Äúhybrid_adaptive_sta_smc‚Äù ‚Äú‚Äù‚Äù Hybrid adaptive super-twisting controller. Mathematical Model: u = u_adaptive + u_sta (mode switching) Gain Parameters: [k1, k2, Œª1, Œª2] k1, k2: Surface gains for pendulum 1 and 2 Œª1, Œª2: Higher-order surface gains Mathematical Constraints: - All parameters &gt; 0 (stability) PSO Bounds: [(1,50), (1,50), (1,50), (1,50)] ‚Äú‚Äù‚Äù &#64;property def gain_count(self) -&gt; int: ‚Äú‚Äù‚ÄùReturn number of gain parameters for this controller type.‚Äù‚Äù‚Äù return { SMCType.CLASSICAL: 6, SMCType.SUPER_TWISTING: 6, SMCType.ADAPTIVE: 5, SMCType.HYBRID: 4 }[self] &#64;property def mathematical_constraints(self) -&gt; Dict[str, str]: ‚Äú‚Äù‚ÄùReturn mathematical constraints as human-readable strings.‚Äù‚Äù‚Äù return { SMCType.CLASSICAL: ‚ÄúŒª1,Œª2,K &gt; 0; kd ‚â• 0‚Äù, SMCType.SUPER_TWISTING: ‚ÄúK1 &gt; K2 &gt; 0; Œª1,Œª2,Œ±1,Œ±2 &gt; 0‚Äù, SMCType.ADAPTIVE: ‚Äúk1,k2,Œª1,Œª2 &gt; 0; 0.1 ‚â§ Œ≥ ‚â§ 20.0‚Äù, SMCType.HYBRID: ‚Äúk1,k2,Œª1,Œª2 &gt; 0‚Äù }[self]</a></li>
<li class="toctree-l1"><a class="reference internal" href="pso_factory_api_reference.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="pso_factory_api_reference.html#runnable-false-dataclass-frozen-true">runnable: false &#64;dataclass(frozen=True)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pso_factory_api_reference.html#pso-controller-wrapper-psocontrollerwrapper-class-python">PSO Controller Wrapper ### PSOControllerWrapper Class ```python</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pso_factory_api_reference.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="pso_factory_api_reference.html#runnable-false-class-psocontrollerwrapper-pso-optimized-wrapper-providing-simplified-interface-for-smc-controllers-this-wrapper-is-specifically-designed-for-pso-fitness-evaluation-with-simplified-control-interface-single-state-input-automatic-state-management-for-stateful-controllers-unified-output-format-numpy-array-robust-error-handling-for-pso-robustness-performance-optimization-for-repeated-evaluations-the-wrapper-handles-the-complexity-of-different-smc-controller-interfaces-while-providing-a-consistent-pso-friendly-api-mathematical-foundation-the-wrapper-preserves-the-mathematical-properties-of-the-underlying-smc-controller-while-simplifying-the-interface-input-state-1-2-x-1-2-x-6-output-u-scalar-control-force-internal-state-management-classical-smc-stateless-empty-state-vars-sta-smc-maintains-z-for-integration-adaptive-smc-tracks-adaptation-variables-hybrid-smc-manages-mode-switching-state-performance-characteristics-control-computation-0-1ms-typical-memory-overhead-500b-per-wrapper-thread-safety-read-operations-only-error-recovery-graceful-degradation-for-invalid-inputs-def-init-self-controller-smcprotocol-initialize-pso-wrapper-with-smc-controller-args-controller-smc-controller-implementing-smcprotocol-raises-typeerror-if-controller-doesn-t-implement-required-interface-valueerror-if-controller-configuration-is-invalid-validate-controller-interface-if-not-hasattr-controller-compute-control-raise-typeerror-controller-must-implement-compute-control-method-if-not-hasattr-controller-gains-raise-typeerror-controller-must-have-gains-property-self-controller-controller-self-history-initialize-empty-history-initialize-controller-specific-state-variables-controller-name-type-controller-name-if-supertwisting-in-controller-name-or-sta-in-controller-name-sta-smc-maintains-integration-variables-z-self-state-vars-0-0-0-0-initial-z-0-0-elif-hybrid-in-controller-name-hybrid-controller-tracks-adaptive-gains-and-integration-self-state-vars-getattr-controller-k1-init-5-0-k1-prev-getattr-controller-k2-init-3-0-k2-prev-0-0-u-int-prev-elif-adaptive-in-controller-name-adaptive-smc-may-track-adaptation-state-self-state-vars-getattr-controller-initial-state-else-classical-smc-and-others-use-empty-state-self-state-vars-performance-tracking-self-call-count-0-self-total-compute-time-0-0-self-last-error-none-def-compute-control-self-state-np-ndarray-state-vars-optional-any-none-history-optional-dict-str-any-none-np-ndarray-compute-control-with-flexible-interface-supporting-both-1-simplified-pso-interface-compute-control-state-2-full-interface-compute-control-state-state-vars-history-mathematical-interface-input-state-vector-x-1-2-x-cart-1-2-x-cart-1-2-pendulum-angles-rad-x-cart-cart-position-m-1-2-angular-velocities-rad-s-x-cart-cart-velocity-m-s-output-control-u-scalar-control-force-n-bounded-by-actuator-limits-args-state-system-state-vector-6-element-numpy-array-state-vars-controller-state-variables-optional-history-controller-history-optional-returns-control-output-as-1-element-numpy-array-u-raises-valueerror-if-state-has-wrong-dimensions-runtimeerror-if-control-computation-fails-performance-typical-computation-time-0-01-0-1ms-memory-allocation-minimal-output-array-only-error-handling-graceful-fallback-to-zero-control-pso-usage-pattern-python-def-pso-fitness-gains-controller-create-smc-for-pso-smctype-classical-gains-simplified-interface-for-pso-total-error-0-0-for-state-in-test-states-u-controller-compute-control-state-returns-u-use-u-0-for-scalar-control-value-total-error-evaluate-single-step-state-u-0-return-total-error-state-management-the-wrapper-automatically-manages-controller-state-between-calls-classical-smc-no-state-management-needed-sta-smc-updates-integration-variables-z-adaptive-smc-updates-adaptation-parameters-hybrid-smc-updates-mode-and-adaptation-state-error-recovery-if-control-computation-fails-1-log-error-for-debugging-2-return-safe-fallback-control-zero-3-increment-error-counter-for-monitoring-4-continue-operation-don-t-crash-pso-import-time-performance-tracking-start-time-time-perf-counter-self-call-count-1-try-input-validation-if-not-isinstance-state-np-ndarray-state-np-array-state-if-state-shape-6-raise-valueerror-f-state-must-be-6-element-array-got-shape-state-shape-if-not-np-all-np-isfinite-state-raise-valueerror-state-contains-non-finite-values-nan-or-inf-use-provided-parameters-or-defaults-final-state-vars-state-vars-if-state-vars-is-not-none-else-self-state-vars-final-history-history-if-history-is-not-none-else-self-history-call-underlying-controller-result-self-controller-compute-control-state-final-state-vars-final-history-extract-control-value-from-result-handle-different-controller-output-formats-if-hasattr-result-u-standard-controller-output-with-u-attribute-control-value-result-u-update-state-variables-if-available-if-hasattr-result-state-vars-self-state-vars-result-state-vars-elif-hasattr-result-control-alternative-output-format-with-control-attribute-control-value-result-control-elif-isinstance-result-dict-dictionary-output-format-if-u-in-result-control-value-result-u-elif-control-in-result-control-value-result-control-else-raise-valueerror-dictionary-result-missing-control-value-update-state-if-provided-if-state-vars-in-result-self-state-vars-result-state-vars-elif-isinstance-result-tuple-tuple-output-e-g-early-return-from-some-controllers-control-value-result-0-first-element-is-control-if-len-result-1-self-state-vars-result-1-second-element-is-state-else-assume-result-is-the-control-value-directly-control-value-result-convert-to-scalar-if-needed-if-isinstance-control-value-np-ndarray-if-control-value-size-1-control-value-float-control-value-else-control-value-float-control-value-0-elif-not-isinstance-control-value-int-float-control-value-float-control-value-validate-output-if-not-np-isfinite-control-value-raise-valueerror-controller-returned-non-finite-control-value-apply-saturation-defensive-programming-max-force-getattr-self-controller-max-force-100-0-control-saturated-np-clip-control-value-max-force-max-force-for-simplified-interface-pso-usage-return-numpy-array-if-state-vars-is-none-and-history-is-none-output-np-array-control-saturated-else-for-full-interface-return-in-format-expected-by-simulation-output-control-saturated-performance-tracking-compute-time-time-perf-counter-start-time-self-total-compute-time-compute-time-return-output-except-exception-as-e-error-handling-for-robust-pso-operation-self-last-error-str-e-log-error-for-debugging-in-production-use-proper-logging-print-f-warning-control-computation-failed-e-return-safe-fallback-control-if-state-vars-is-none-and-history-is-none-return-np-array-0-0-pso-interface-else-return-0-0-full-interface-property-def-gains-self-list-float-return-controller-gains-returns-list-of-controller-gain-parameters-usage-python-controller-create-smc-for-pso-smctype-classical-gains-print-f-controller-gains-controller-gains-return-self-controller-gains-property-def-performance-stats-self-dict-str-any-return-performance-statistics-for-monitoring-returns-dictionary-with-performance-metrics-call-count-number-of-control-computations-total-time-total-computation-time-s-average-time-average-computation-time-ms-last-error-last-error-message-if-any-usage-python-after-pso-optimization-stats-controller-performance-stats-print-f-average-computation-time-stats-average-time-3f-ms-avg-time-ms-self-total-compute-time-self-call-count-1000-if-self-call-count-0-else-0-0-return-call-count-self-call-count-total-time-self-total-compute-time-average-time-avg-time-ms-last-error-self-last-error-def-reset-performance-stats-self-none-reset-performance-tracking-statistics-self-call-count-0-self-total-compute-time-0-0-self-last-error-none-def-validate-state-input-self-state-np-ndarray-tuple-bool-str-validate-state-input-for-control-computation-args-state-state-vector-to-validate-returns-tuple-of-is-valid-error-message-usage-python-is-valid-error-controller-validate-state-input-test-state-if-not-is-valid-print-f-invalid-state-error-try-if-not-isinstance-state-np-ndarray-return-false-state-must-be-numpy-array-if-state-shape-6-return-false-f-state-must-be-6-element-array-got-state-shape-if-not-np-all-np-isfinite-state-return-false-state-contains-non-finite-values-check-reasonable-ranges-optional-angles-state-2-1-2-if-np-any-np-abs-angles-2-np-pi-return-false-angles-exceed-reasonable-range-2-velocities-state-3-1-2-x-if-np-any-np-abs-velocities-100-return-false-velocities-exceed-reasonable-range-100-return-true-except-exception-as-e-return-false-f-validation-error-e-def-repr-self-str-string-representation-for-debugging-controller-type-type-self-controller-name-return-f-psocontrollerwrapper-controller-type-gains-self-gains">runnable: false class PSOControllerWrapper: ‚Äú‚Äù‚Äù PSO-optimized wrapper providing simplified interface for SMC controllers. This wrapper is specifically designed for PSO fitness evaluation with: - Simplified control interface (single state input) - Automatic state management for stateful controllers - Unified output format (numpy array) - Robust error handling for PSO robustness - Performance optimization for repeated evaluations The wrapper handles the complexity of different SMC controller interfaces while providing a consistent, PSO-friendly API. Mathematical Foundation: The wrapper preserves the mathematical properties of the underlying SMC controller while simplifying the interface: Input: state = [Œ∏‚ÇÅ, Œ∏‚ÇÇ, x, Œ∏Ãá‚ÇÅ, Œ∏Ãá‚ÇÇ, ·∫ã] ‚àà ‚Ñù‚Å∂ Output: u ‚àà ‚Ñù (scalar control force) Internal State Management: - Classical SMC: Stateless (empty state_vars) - STA SMC: Maintains (z, œÉ) for integration - Adaptive SMC: Tracks adaptation variables - Hybrid SMC: Manages mode switching state Performance Characteristics: - Control computation: &lt;0.1ms typical - Memory overhead: &lt;500B per wrapper - Thread safety: Read operations only - Error recovery: Graceful degradation for invalid inputs ‚Äú‚Äù‚Äù def <strong>init</strong>(self, controller: SMCProtocol): ‚Äú‚Äù‚Äù Initialize PSO wrapper with SMC controller. Args: controller: SMC controller implementing SMCProtocol Raises: TypeError: If controller doesn‚Äôt implement required interface ValueError: If controller configuration is invalid ‚Äú‚Äù‚Äù # Validate controller interface if not hasattr(controller, ‚Äòcompute_control‚Äô): raise TypeError(‚ÄúController must implement compute_control method‚Äù) if not hasattr(controller, ‚Äògains‚Äô): raise TypeError(‚ÄúController must have gains property‚Äù) self.controller = controller self._history = {} # Initialize empty history # Initialize controller-specific state variables controller_name = type(controller).<strong>name</strong> if ‚ÄòSuperTwisting‚Äô in controller_name or ‚ÄòSTA‚Äô in controller_name: # STA-SMC maintains integration variables (z, œÉ) self._state_vars = (0.0, 0.0) # Initial (z=0, œÉ=0) elif ‚ÄòHybrid‚Äô in controller_name: # Hybrid controller tracks adaptive gains and integration self._state_vars = ( getattr(controller, ‚Äòk1_init‚Äô, 5.0), # k1_prev getattr(controller, ‚Äòk2_init‚Äô, 3.0), # k2_prev 0.0 # u_int_prev ) elif ‚ÄòAdaptive‚Äô in controller_name: # Adaptive SMC may track adaptation state self._state_vars = getattr(controller, ‚Äò_initial_state‚Äô, ()) else: # Classical SMC and others use empty state self._state_vars = () # Performance tracking self._call_count = 0 self._total_compute_time = 0.0 self._last_error = None def compute_control(self, state: np.ndarray, state_vars: Optional[Any] = None, history: Optional[Dict[str, Any]] = None ) -&gt; np.ndarray: ‚Äú‚Äù‚Äù Compute control with flexible interface supporting both: 1. Simplified PSO interface: compute_control(state) 2. Full interface: compute_control(state, state_vars, history) Mathematical Interface: Input state vector: x = [Œ∏‚ÇÅ, Œ∏‚ÇÇ, x_cart, Œ∏Ãá‚ÇÅ, Œ∏Ãá‚ÇÇ, ·∫ã_cart] - Œ∏‚ÇÅ, Œ∏‚ÇÇ: Pendulum angles [rad] - x_cart: Cart position [m] - Œ∏Ãá‚ÇÅ, Œ∏Ãá‚ÇÇ: Angular velocities [rad/s] - ·∫ã_cart: Cart velocity [m/s] Output control: u ‚àà ‚Ñù - Scalar control force [N] - Bounded by actuator limits Args: state: System state vector (6-element numpy array) state_vars: Controller state variables (optional) history: Controller history (optional) Returns: Control output as 1-element numpy array [u] Raises: ValueError: If state has wrong dimensions RuntimeError: If control computation fails Performance: - Typical computation time: 0.01-0.1ms - Memory allocation: Minimal (output array only) - Error handling: Graceful fallback to zero control PSO Usage Pattern: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">def</span> <span class="pre">pso_fitness(gains):</span> <span class="pre">controller</span> <span class="pre">=</span> <span class="pre">create_smc_for_pso(SMCType.CLASSICAL,</span> <span class="pre">gains)</span> <span class="pre">#</span> <span class="pre">Simplified</span> <span class="pre">interface</span> <span class="pre">for</span> <span class="pre">PSO</span> <span class="pre">total_error</span> <span class="pre">=</span> <span class="pre">0.0</span> <span class="pre">for</span> <span class="pre">state</span> <span class="pre">in</span> <span class="pre">test_states:</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">controller.compute_control(state)</span> <span class="pre">#</span> <span class="pre">Returns</span> <span class="pre">[u]</span> <span class="pre">#</span> <span class="pre">Use</span> <span class="pre">u[0]</span> <span class="pre">for</span> <span class="pre">scalar</span> <span class="pre">control</span> <span class="pre">value</span> <span class="pre">total_error</span> <span class="pre">+=</span> <span class="pre">evaluate_single_step(state,</span> <span class="pre">u[0])</span> <span class="pre">return</span> <span class="pre">total_error</span> </code> State Management: The wrapper automatically manages controller state between calls: - Classical SMC: No state management needed - STA SMC: Updates integration variables (z, œÉ) - Adaptive SMC: Updates adaptation parameters - Hybrid SMC: Updates mode and adaptation state Error Recovery: If control computation fails: 1. Log error for debugging 2. Return safe fallback control (zero) 3. Increment error counter for monitoring 4. Continue operation (don‚Äôt crash PSO) ‚Äú‚Äù‚Äù import time # Performance tracking start_time = time.perf_counter() self._call_count += 1 try: # Input validation if not isinstance(state, np.ndarray): state = np.array(state) if state.shape != (6,): raise ValueError(f‚ÄùState must be 6-element array, got shape {state.shape}‚Äù) if not np.all(np.isfinite(state)): raise ValueError(‚ÄúState contains non-finite values (NaN or inf)‚Äù) # Use provided parameters or defaults final_state_vars = state_vars if state_vars is not None else self._state_vars final_history = history if history is not None else self._history # Call underlying controller result = self.controller.compute_control(state, final_state_vars, final_history) # Extract control value from result # Handle different controller output formats if hasattr(result, ‚Äòu‚Äô): # Standard controller output with .u attribute control_value = result.u # Update state variables if available if hasattr(result, ‚Äòstate_vars‚Äô): self._state_vars = result.state_vars elif hasattr(result, ‚Äòcontrol‚Äô): # Alternative output format with .control attribute control_value = result.control elif isinstance(result, dict): # Dictionary output format if ‚Äòu‚Äô in result: control_value = result[‚Äòu‚Äô] elif ‚Äòcontrol‚Äô in result: control_value = result[‚Äòcontrol‚Äô] else: raise ValueError(‚ÄúDictionary result missing control value‚Äù) # Update state if provided if ‚Äòstate_vars‚Äô in result: self._state_vars = result[‚Äòstate_vars‚Äô] elif isinstance(result, tuple): # Tuple output (e.g., early return from some controllers) control_value = result[0] # First element is control if len(result) &gt; 1: self._state_vars = result[1] # Second element is state else: # Assume result is the control value directly control_value = result # Convert to scalar if needed if isinstance(control_value, np.ndarray): if control_value.size == 1: control_value = float(control_value) else: control_value = float(control_value[0]) elif not isinstance(control_value, (int, float)): control_value = float(control_value) # Validate output if not np.isfinite(control_value): raise ValueError(‚ÄúController returned non-finite control value‚Äù) # Apply saturation (defensive programming) max_force = getattr(self.controller, ‚Äòmax_force‚Äô, 100.0) control_saturated = np.clip(control_value, -max_force, max_force) # For simplified interface (PSO usage), return numpy array if state_vars is None and history is None: output = np.array([control_saturated]) else: # For full interface, return in format expected by simulation output = control_saturated # Performance tracking compute_time = time.perf_counter() - start_time self._total_compute_time += compute_time return output except Exception as e: # Error handling for robust PSO operation self._last_error = str(e) # Log error for debugging (in production, use proper logging) print(f‚ÄùWarning: Control computation failed: {e}‚Äù) # Return safe fallback control if state_vars is None and history is None: return np.array([0.0]) # PSO interface else: return 0.0 # Full interface &#64;property def gains(self) -&gt; List[float]: ‚Äú‚Äù‚Äù Return controller gains. Returns: List of controller gain parameters Usage: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">controller</span> <span class="pre">=</span> <span class="pre">create_smc_for_pso(SMCType.CLASSICAL,</span> <span class="pre">gains)</span> <span class="pre">print(f&quot;Controller</span> <span class="pre">gains:</span> <span class="pre">{controller.gains}&quot;)</span> </code> ‚Äú‚Äù‚Äù return self.controller.gains &#64;property def performance_stats(self) -&gt; Dict[str, Any]: ‚Äú‚Äù‚Äù Return performance statistics for monitoring. Returns: Dictionary with performance metrics: - call_count: Number of control computations - total_time: Total computation time [s] - average_time: Average computation time [ms] - last_error: Last error message (if any) Usage: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">#</span> <span class="pre">After</span> <span class="pre">PSO</span> <span class="pre">optimization</span> <span class="pre">stats</span> <span class="pre">=</span> <span class="pre">controller.performance_stats</span> <span class="pre">print(f&quot;Average</span> <span class="pre">computation</span> <span class="pre">time:</span> <span class="pre">{stats['average_time']:.3f}ms&quot;)</span> </code> ‚Äú‚Äù‚Äù avg_time_ms = (self._total_compute_time / self._call_count * 1000 if self._call_count &gt; 0 else 0.0) return { ‚Äòcall_count‚Äô: self._call_count, ‚Äòtotal_time‚Äô: self._total_compute_time, ‚Äòaverage_time‚Äô: avg_time_ms, ‚Äòlast_error‚Äô: self._last_error } def reset_performance_stats(self) -&gt; None: ‚Äú‚Äù‚ÄùReset performance tracking statistics.‚Äù‚Äù‚Äù self._call_count = 0 self._total_compute_time = 0.0 self._last_error = None def validate_state_input(self, state: np.ndarray) -&gt; Tuple[bool, str]: ‚Äú‚Äù‚Äù Validate state input for control computation. Args: state: State vector to validate Returns: Tuple of (is_valid, error_message) Usage: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">is_valid,</span> <span class="pre">error</span> <span class="pre">=</span> <span class="pre">controller.validate_state_input(test_state)</span> <span class="pre">if</span> <span class="pre">not</span> <span class="pre">is_valid:</span> <span class="pre">print(f&quot;Invalid</span> <span class="pre">state:</span> <span class="pre">{error}&quot;)</span> </code> ‚Äú‚Äù‚Äù try: if not isinstance(state, np.ndarray): return False, ‚ÄúState must be numpy array‚Äù if state.shape != (6,): return False, f‚ÄùState must be 6-element array, got {state.shape}‚Äù if not np.all(np.isfinite(state)): return False, ‚ÄúState contains non-finite values‚Äù # Check reasonable ranges (optional) angles = state[:2] # Œ∏‚ÇÅ, Œ∏‚ÇÇ if np.any(np.abs(angles) &gt; 2*np.pi): return False, ‚ÄúAngles exceed reasonable range (¬±2œÄ)‚Äù velocities = state[3:] # Œ∏Ãá‚ÇÅ, Œ∏Ãá‚ÇÇ, ·∫ã if np.any(np.abs(velocities) &gt; 100): return False, ‚ÄúVelocities exceed reasonable range (¬±100)‚Äù return True, ‚Äú‚Äù except Exception as e: return False, f‚ÄùValidation error: {e}‚Äù def <strong>repr</strong>(self) -&gt; str: ‚Äú‚Äù‚ÄùString representation for debugging.‚Äù‚Äù‚Äù controller_type = type(self.controller).<strong>name</strong> return f‚ÄùPSOControllerWrapper({controller_type}, gains={self.gains})‚Äù</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pso_factory_api_reference.html#configuration-schema-api-factory-configuration-classes-python">Configuration Schema API ### Factory Configuration Classes ```python</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pso_factory_api_reference.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="pso_factory_api_reference.html#id4">runnable: false &#64;dataclass(frozen=True)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pso_factory_api_reference.html#performance-monitoring-api-real-time-performance-monitoring-python">Performance Monitoring API ### Real-Time Performance Monitoring ```python</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pso_factory_api_reference.html#id5">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="pso_factory_api_reference.html#runnable-false-class-psoperformancemonitor-real-time-performance-monitoring-for-pso-factory-integration-provides-monitoring-of-pso-convergence-metrics-controller-creation-performance-simulation-execution-times-memory-usage-tracking-error-rate-monitoring-def-init-self-monitoring-config-dict-str-any-self-config-monitoring-config-self-metrics-pso-metrics-total-evaluations-0-successful-evaluations-0-failed-evaluations-0-average-fitness-0-0-best-fitness-float-inf-convergence-rate-0-0-performance-metrics-controller-creation-time-simulation-execution-time-fitness-computation-time-total-optimization-time-0-0-resource-metrics-peak-memory-usage-0-0-average-memory-usage-0-0-cpu-utilization-memory-samples-error-metrics-creation-failures-0-simulation-failures-0-validation-failures-0-total-errors-0-self-start-time-none-self-monitoring-active-false-def-start-monitoring-self-start-performance-monitoring-session-import-time-self-start-time-time-time-self-monitoring-active-true-self-reset-metrics-def-stop-monitoring-self-dict-str-any-stop-monitoring-and-return-complete-performance-report-import-time-if-self-start-time-self-metrics-performance-metrics-total-optimization-time-time-time-self-start-time-self-monitoring-active-false-return-self-generate-performance-report-def-log-controller-creation-self-success-bool-creation-time-float-log-controller-creation-event-if-not-self-monitoring-active-return-self-metrics-performance-metrics-controller-creation-time-append-creation-time-if-success-self-metrics-pso-metrics-successful-evaluations-1-else-self-metrics-error-metrics-creation-failures-1-self-metrics-pso-metrics-failed-evaluations-1-def-log-simulation-execution-self-success-bool-execution-time-float-log-simulation-execution-event-if-not-self-monitoring-active-return-if-success-self-metrics-performance-metrics-simulation-execution-time-append-execution-time-else-self-metrics-error-metrics-simulation-failures-1-def-log-fitness-evaluation-self-fitness-value-float-computation-time-float-log-fitness-evaluation-result-if-not-self-monitoring-active-return-self-metrics-performance-metrics-fitness-computation-time-append-computation-time-self-metrics-pso-metrics-total-evaluations-1-update-best-fitness-if-fitness-value-self-metrics-pso-metrics-best-fitness-self-metrics-pso-metrics-best-fitness-fitness-value-update-average-fitness-running-average-total-evals-self-metrics-pso-metrics-total-evaluations-current-avg-self-metrics-pso-metrics-average-fitness-self-metrics-pso-metrics-average-fitness-current-avg-total-evals-1-fitness-value-total-evals-def-log-resource-usage-self-log-current-resource-usage-if-not-self-monitoring-active-return-try-import-psutil-memory-usage-memory-info-psutil-virtual-memory-current-memory-memory-info-percent-self-metrics-resource-metrics-memory-samples-append-current-memory-update-peak-memory-if-current-memory-self-metrics-resource-metrics-peak-memory-usage-self-metrics-resource-metrics-peak-memory-usage-current-memory-cpu-utilization-cpu-percent-psutil-cpu-percent-interval-none-self-metrics-resource-metrics-cpu-utilization-append-cpu-percent-except-importerror-pass-psutil-not-available-def-check-performance-alerts-self-list-str-check-for-performance-issues-and-return-alerts-alerts-memory-usage-alerts-if-self-metrics-resource-metrics-peak-memory-usage-90-alerts-append-f-high-memory-usage-self-metrics-resource-metrics-peak-memory-usage-1f-error-rate-alerts-total-evals-self-metrics-pso-metrics-total-evaluations-if-total-evals-0-error-rate-self-metrics-error-metrics-total-errors-total-evals-if-error-rate-0-1-alerts-append-f-high-error-rate-error-rate-1-performance-alerts-creation-times-self-metrics-performance-metrics-controller-creation-time-if-creation-times-and-np-mean-creation-times-0-002-2ms-threshold-alerts-append-f-slow-controller-creation-np-mean-creation-times-1000-2f-ms-average-return-alerts-def-generate-performance-report-self-dict-str-any-generate-performance-report-calculate-derived-metrics-total-evals-self-metrics-pso-metrics-total-evaluations-success-rate-self-metrics-pso-metrics-successful-evaluations-total-evals-100-if-total-evals-0-else-0-creation-times-self-metrics-performance-metrics-controller-creation-time-avg-creation-time-np-mean-creation-times-if-creation-times-else-0-simulation-times-self-metrics-performance-metrics-simulation-execution-time-avg-simulation-time-np-mean-simulation-times-if-simulation-times-else-0-fitness-times-self-metrics-performance-metrics-fitness-computation-time-avg-fitness-time-np-mean-fitness-times-if-fitness-times-else-0-memory-samples-self-metrics-resource-metrics-memory-samples-avg-memory-np-mean-memory-samples-if-memory-samples-else-0-cpu-samples-self-metrics-resource-metrics-cpu-utilization-avg-cpu-np-mean-cpu-samples-if-cpu-samples-else-0-total-time-self-metrics-performance-metrics-total-optimization-time-evaluations-per-second-total-evals-total-time-if-total-time-0-else-0-generate-report-report-summary-total-evaluations-total-evals-success-rate-success-rate-best-fitness-achieved-self-metrics-pso-metrics-best-fitness-total-optimization-time-total-time-evaluations-per-second-evaluations-per-second-performance-average-controller-creation-time-ms-avg-creation-time-1000-average-simulation-time-ms-avg-simulation-time-1000-average-fitness-computation-time-ms-avg-fitness-time-1000-resources-peak-memory-usage-percent-self-metrics-resource-metrics-peak-memory-usage-average-memory-usage-percent-avg-memory-average-cpu-utilization-percent-avg-cpu-errors-controller-creation-failures-self-metrics-error-metrics-creation-failures-simulation-failures-self-metrics-error-metrics-simulation-failures-validation-failures-self-metrics-error-metrics-validation-failures-total-error-count-self-metrics-error-metrics-total-errors-alerts-self-check-performance-alerts-raw-metrics-self-metrics-return-report-def-reset-metrics-self-reset-all-metrics-for-new-monitoring-session-for-category-in-self-metrics-values-if-isinstance-category-dict-for-key-value-in-category-items-if-isinstance-value-list-category-key-elif-isinstance-value-int-float-if-best-fitness-in-key-category-key-float-inf-else-category-key-0-context-manager-for-automatic-monitoring">runnable: false class PSOPerformanceMonitor: ‚Äú‚Äù‚Äù Real-time performance monitoring for PSO-Factory integration. Provides monitoring of: - PSO convergence metrics - Controller creation performance - Simulation execution times - Memory usage tracking - Error rate monitoring ‚Äú‚Äù‚Äù def <strong>init</strong>(self, monitoring_config: Dict[str, Any]): self.config = monitoring_config self.metrics = { ‚Äòpso_metrics‚Äô: { ‚Äòtotal_evaluations‚Äô: 0, ‚Äòsuccessful_evaluations‚Äô: 0, ‚Äòfailed_evaluations‚Äô: 0, ‚Äòaverage_fitness‚Äô: 0.0, ‚Äòbest_fitness‚Äô: float(‚Äòinf‚Äô), ‚Äòconvergence_rate‚Äô: 0.0 }, ‚Äòperformance_metrics‚Äô: { ‚Äòcontroller_creation_time‚Äô: [], ‚Äòsimulation_execution_time‚Äô: [], ‚Äòfitness_computation_time‚Äô: [], ‚Äòtotal_optimization_time‚Äô: 0.0 }, ‚Äòresource_metrics‚Äô: { ‚Äòpeak_memory_usage‚Äô: 0.0, ‚Äòaverage_memory_usage‚Äô: 0.0, ‚Äòcpu_utilization‚Äô: [], ‚Äòmemory_samples‚Äô: [] }, ‚Äòerror_metrics‚Äô: { ‚Äòcreation_failures‚Äô: 0, ‚Äòsimulation_failures‚Äô: 0, ‚Äòvalidation_failures‚Äô: 0, ‚Äòtotal_errors‚Äô: 0 } } self.start_time = None self.monitoring_active = False def start_monitoring(self): ‚Äú‚Äù‚ÄùStart performance monitoring session.‚Äù‚Äù‚Äù import time self.start_time = time.time() self.monitoring_active = True self._reset_metrics() def stop_monitoring(self) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùStop monitoring and return complete performance report.‚Äù‚Äù‚Äù import time if self.start_time: self.metrics[‚Äòperformance_metrics‚Äô][‚Äòtotal_optimization_time‚Äô] = ( time.time() - self.start_time ) self.monitoring_active = False return self.generate_performance_report() def log_controller_creation(self, success: bool, creation_time: float): ‚Äú‚Äù‚ÄùLog controller creation event.‚Äù‚Äù‚Äù if not self.monitoring_active: return self.metrics[‚Äòperformance_metrics‚Äô][‚Äòcontroller_creation_time‚Äô].append(creation_time) if success: self.metrics[‚Äòpso_metrics‚Äô][‚Äòsuccessful_evaluations‚Äô] += 1 else: self.metrics[‚Äòerror_metrics‚Äô][‚Äòcreation_failures‚Äô] += 1 self.metrics[‚Äòpso_metrics‚Äô][‚Äòfailed_evaluations‚Äô] += 1 def log_simulation_execution(self, success: bool, execution_time: float): ‚Äú‚Äù‚ÄùLog simulation execution event.‚Äù‚Äù‚Äù if not self.monitoring_active: return if success: self.metrics[‚Äòperformance_metrics‚Äô][‚Äòsimulation_execution_time‚Äô].append(execution_time) else: self.metrics[‚Äòerror_metrics‚Äô][‚Äòsimulation_failures‚Äô] += 1 def log_fitness_evaluation(self, fitness_value: float, computation_time: float): ‚Äú‚Äù‚ÄùLog fitness evaluation result.‚Äù‚Äù‚Äù if not self.monitoring_active: return self.metrics[‚Äòperformance_metrics‚Äô][‚Äòfitness_computation_time‚Äô].append(computation_time) self.metrics[‚Äòpso_metrics‚Äô][‚Äòtotal_evaluations‚Äô] += 1 # Update best fitness if fitness_value &lt; self.metrics[‚Äòpso_metrics‚Äô][‚Äòbest_fitness‚Äô]: self.metrics[‚Äòpso_metrics‚Äô][‚Äòbest_fitness‚Äô] = fitness_value # Update average fitness (running average) total_evals = self.metrics[‚Äòpso_metrics‚Äô][‚Äòtotal_evaluations‚Äô] current_avg = self.metrics[‚Äòpso_metrics‚Äô][‚Äòaverage_fitness‚Äô] self.metrics[‚Äòpso_metrics‚Äô][‚Äòaverage_fitness‚Äô] = ( (current_avg * (total_evals - 1) + fitness_value) / total_evals ) def log_resource_usage(self): ‚Äú‚Äù‚ÄùLog current resource usage.‚Äù‚Äù‚Äù if not self.monitoring_active: return try: import psutil # Memory usage memory_info = psutil.virtual_memory() current_memory = memory_info.percent self.metrics[‚Äòresource_metrics‚Äô][‚Äòmemory_samples‚Äô].append(current_memory) # Update peak memory if current_memory &gt; self.metrics[‚Äòresource_metrics‚Äô][‚Äòpeak_memory_usage‚Äô]: self.metrics[‚Äòresource_metrics‚Äô][‚Äòpeak_memory_usage‚Äô] = current_memory # CPU utilization cpu_percent = psutil.cpu_percent(interval=None) self.metrics[‚Äòresource_metrics‚Äô][‚Äòcpu_utilization‚Äô].append(cpu_percent) except ImportError: pass # psutil not available def check_performance_alerts(self) -&gt; List[str]: ‚Äú‚Äù‚ÄùCheck for performance issues and return alerts.‚Äù‚Äù‚Äù alerts = [] # Memory usage alerts if self.metrics[‚Äòresource_metrics‚Äô][‚Äòpeak_memory_usage‚Äô] &gt; 90: alerts.append(f‚ÄùHigh memory usage: {self.metrics[‚Äòresource_metrics‚Äô][‚Äòpeak_memory_usage‚Äô]:.1f}%‚Äù) # Error rate alerts total_evals = self.metrics[‚Äòpso_metrics‚Äô][‚Äòtotal_evaluations‚Äô] if total_evals &gt; 0: error_rate = self.metrics[‚Äòerror_metrics‚Äô][‚Äòtotal_errors‚Äô] / total_evals if error_rate &gt; 0.1: alerts.append(f‚ÄùHigh error rate: {error_rate:.1%}‚Äù) # Performance alerts creation_times = self.metrics[‚Äòperformance_metrics‚Äô][‚Äòcontroller_creation_time‚Äô] if creation_times and np.mean(creation_times) &gt; 0.002: # 2ms threshold alerts.append(f‚ÄùSlow controller creation: {np.mean(creation_times)*1000:.2f}ms average‚Äù) return alerts def generate_performance_report(self) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùGenerate performance report.‚Äù‚Äù‚Äù # Calculate derived metrics total_evals = self.metrics[‚Äòpso_metrics‚Äô][‚Äòtotal_evaluations‚Äô] success_rate = (self.metrics[‚Äòpso_metrics‚Äô][‚Äòsuccessful_evaluations‚Äô] / total_evals * 100 if total_evals &gt; 0 else 0) creation_times = self.metrics[‚Äòperformance_metrics‚Äô][‚Äòcontroller_creation_time‚Äô] avg_creation_time = np.mean(creation_times) if creation_times else 0 simulation_times = self.metrics[‚Äòperformance_metrics‚Äô][‚Äòsimulation_execution_time‚Äô] avg_simulation_time = np.mean(simulation_times) if simulation_times else 0 fitness_times = self.metrics[‚Äòperformance_metrics‚Äô][‚Äòfitness_computation_time‚Äô] avg_fitness_time = np.mean(fitness_times) if fitness_times else 0 memory_samples = self.metrics[‚Äòresource_metrics‚Äô][‚Äòmemory_samples‚Äô] avg_memory = np.mean(memory_samples) if memory_samples else 0 cpu_samples = self.metrics[‚Äòresource_metrics‚Äô][‚Äòcpu_utilization‚Äô] avg_cpu = np.mean(cpu_samples) if cpu_samples else 0 total_time = self.metrics[‚Äòperformance_metrics‚Äô][‚Äòtotal_optimization_time‚Äô] evaluations_per_second = total_evals / total_time if total_time &gt; 0 else 0 # Generate report report = { ‚Äòsummary‚Äô: { ‚Äòtotal_evaluations‚Äô: total_evals, ‚Äòsuccess_rate‚Äô: success_rate, ‚Äòbest_fitness_achieved‚Äô: self.metrics[‚Äòpso_metrics‚Äô][‚Äòbest_fitness‚Äô], ‚Äòtotal_optimization_time‚Äô: total_time, ‚Äòevaluations_per_second‚Äô: evaluations_per_second }, ‚Äòperformance‚Äô: { ‚Äòaverage_controller_creation_time_ms‚Äô: avg_creation_time * 1000, ‚Äòaverage_simulation_time_ms‚Äô: avg_simulation_time * 1000, ‚Äòaverage_fitness_computation_time_ms‚Äô: avg_fitness_time * 1000 }, ‚Äòresources‚Äô: { ‚Äòpeak_memory_usage_percent‚Äô: self.metrics[‚Äòresource_metrics‚Äô][‚Äòpeak_memory_usage‚Äô], ‚Äòaverage_memory_usage_percent‚Äô: avg_memory, ‚Äòaverage_cpu_utilization_percent‚Äô: avg_cpu }, ‚Äòerrors‚Äô: { ‚Äòcontroller_creation_failures‚Äô: self.metrics[‚Äòerror_metrics‚Äô][‚Äòcreation_failures‚Äô], ‚Äòsimulation_failures‚Äô: self.metrics[‚Äòerror_metrics‚Äô][‚Äòsimulation_failures‚Äô], ‚Äòvalidation_failures‚Äô: self.metrics[‚Äòerror_metrics‚Äô][‚Äòvalidation_failures‚Äô], ‚Äòtotal_error_count‚Äô: self.metrics[‚Äòerror_metrics‚Äô][‚Äòtotal_errors‚Äô] }, ‚Äòalerts‚Äô: self.check_performance_alerts(), ‚Äòraw_metrics‚Äô: self.metrics } return report def _reset_metrics(self): ‚Äú‚Äù‚ÄùReset all metrics for new monitoring session.‚Äù‚Äù‚Äù for category in self.metrics.values(): if isinstance(category, dict): for key, value in category.items(): if isinstance(value, list): category[key] = [] elif isinstance(value, (int, float)): if ‚Äòbest_fitness‚Äô in key: category[key] = float(‚Äòinf‚Äô) else: category[key] = 0 # Context manager for automatic monitoring</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pso_factory_api_reference.html#usage-examples-complete-pso-optimization-workflow-python">Usage Examples ### Complete PSO Optimization Workflow ```python</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pso_factory_api_reference.html#id6">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="pso_factory_api_reference.html#runnable-false-def-complete-pso-optimization-example-complete-example-demonstrating-pso-factory-integration-this-example-shows-1-configuration-setup-2-controller-creation-and-validation-3-pso-optimization-execution-4-performance-monitoring-5-results-analysis-and-validation-step-1-configuration-setup-pso-config-psofactoryconfig-controller-type-smctype-classical-max-force-100-0-dt-0-01-pso-params-n-particles-30-iters-100-c1-2-0-c2-2-0-w-0-9-enable-monitoring-true-strict-validation-true-step-2-simulation-configuration-simulation-config-duration-5-0-dt-0-01-initial-state-0-1-0-1-0-0-0-0-0-0-0-0-small-perturbation-disturbances-enable-true-amplitude-5-0-frequency-1-0-performance-objectives-ise-overshoot-control-effort-step-3-pso-optimization-with-monitoring-with-monitor-pso-performance-pso-config-pso-params-as-monitor-define-fitness-function-handle-pso-errors-def-fitness-function-particles-np-ndarray-np-ndarray-fitness-scores-for-gains-in-particles-start-time-time-perf-counter-try-create-controller-with-validation-controller-create-smc-for-pso-pso-config-controller-type-gains-tolist-pso-config-max-force-creation-time-time-perf-counter-start-time-monitor-log-controller-creation-true-creation-time-run-simulation-sim-start-time-perf-counter-result-run-simulation-controller-simulation-config-sim-time-time-perf-counter-sim-start-monitor-log-simulation-execution-true-sim-time-compute-fitness-fitness-start-time-perf-counter-fitness-compute-multi-objective-fitness-result-simulation-config-performance-objectives-fitness-time-time-perf-counter-fitness-start-monitor-log-fitness-evaluation-fitness-fitness-time-fitness-scores-append-fitness-except-exception-as-e-monitor-log-controller-creation-false-0-0-fitness-scores-append-1000-0-log-resource-usage-periodically-if-len-fitness-scores-10-0-monitor-log-resource-usage-return-np-array-fitness-scores-step-4-execute-pso-optimization-from-pyswarms-single-import-globalbestpso-bounds-pso-config-gain-bounds-bounds-array-np-array-bounds-optimizer-globalbestpso-n-particles-pso-config-pso-params-n-particles-dimensions-pso-config-n-gains-options-c1-pso-config-pso-params-c1-c2-pso-config-pso-params-c2-w-pso-config-pso-params-w-bounds-bounds-array-0-bounds-array-1-print-starting-pso-optimization-best-cost-best-gains-optimizer-optimize-fitness-function-iters-pso-config-pso-params-iters-verbose-true-step-5-results-analysis-performance-report-monitor-generate-performance-report-validate-optimized-controller-optimized-controller-create-smc-for-pso-pso-config-controller-type-best-gains-tolist-pso-config-max-force-run-validation-simulation-validation-result-run-simulation-optimized-controller-simulation-config-validation-metrics-compute-validation-metrics-validation-result-step-6-generate-report-optimization-report-optimization-results-best-gains-best-gains-tolist-best-fitness-float-best-cost-optimization-history-optimizer-cost-history-convergence-iteration-find-convergence-iteration-optimizer-cost-history-validation-results-controller-gains-optimized-controller-gains-performance-metrics-validation-metrics-stability-analysis-estimate-stability-properties-pso-config-controller-type-best-gains-tolist-performance-report-performance-report-configuration-pso-config-pso-config-dict-simulation-config-simulation-config-bounds-used-bounds-step-7-display-results-print-optimization-summary-optimization-report-return-optimization-report-def-print-optimization-summary-report-dict-str-any-print-formatted-optimization-summary-opt-results-report-optimization-results-val-results-report-validation-results-perf-report-report-performance-report-print-n-80-print-pso-optimization-results-summary-print-80-print-f-n-optimization-results-print-f-best-fitness-opt-results-best-fitness-6f-print-f-best-gains-opt-results-best-gains-print-f-convergence-iteration-opt-results-convergence-iteration-print-f-n-validation-metrics-for-metric-value-in-val-results-performance-metrics-items-print-f-metric-upper-value-4f-print-f-n-performance-summary-summary-perf-report-summary-print-f-total-evaluations-summary-total-evaluations-print-f-success-rate-summary-success-rate-1f-print-f-evaluations-sec-summary-evaluations-per-second-1f-print-f-total-time-summary-total-optimization-time-1f-s-perf-perf-report-performance-print-f-avg-creation-time-perf-average-controller-creation-time-ms-2f-ms-print-f-avg-simulation-time-perf-average-simulation-time-ms-2f-ms-resources-perf-report-resources-print-f-peak-memory-resources-peak-memory-usage-percent-1f-print-f-avg-cpu-resources-average-cpu-utilization-percent-1f-if-perf-report-alerts-print-f-n-performance-alerts-for-alert-in-perf-report-alerts-print-f-alert-print-n-80-def-find-convergence-iteration-cost-history-list-float-tolerance-float-1e-6-patience-int-10-int-find-iteration-where-pso-converged-if-len-cost-history-patience-return-len-cost-history-for-i-in-range-patience-len-cost-history-check-if-fitness-has-been-stable-for-patience-iterations-recent-costs-cost-history-i-patience-i-if-max-recent-costs-min-recent-costs-tolerance-return-i-patience-1-return-len-cost-history-no-convergence-detected-run-the-complete-example">runnable: false def complete_pso_optimization_example(): ‚Äú‚Äù‚Äù Complete example demonstrating PSO-Factory integration. This example shows: 1. Configuration setup 2. Controller creation and validation 3. PSO optimization execution 4. Performance monitoring 5. Results analysis and validation ‚Äú‚Äù‚Äù # Step 1: Configuration setup pso_config = PSOFactoryConfig( controller_type=SMCType.CLASSICAL, max_force=100.0, dt=0.01, pso_params={ ‚Äòn_particles‚Äô: 30, ‚Äòiters‚Äô: 100, ‚Äòc1‚Äô: 2.0, ‚Äòc2‚Äô: 2.0, ‚Äòw‚Äô: 0.9 }, enable_monitoring=True, strict_validation=True ) # Step 2: Simulation configuration simulation_config = { ‚Äòduration‚Äô: 5.0, ‚Äòdt‚Äô: 0.01, ‚Äòinitial_state‚Äô: [0.1, 0.1, 0.0, 0.0, 0.0, 0.0], # Small perturbation ‚Äòdisturbances‚Äô: { ‚Äòenable‚Äô: True, ‚Äòamplitude‚Äô: 5.0, ‚Äòfrequency‚Äô: 1.0 }, ‚Äòperformance_objectives‚Äô: [‚Äòise‚Äô, ‚Äòovershoot‚Äô, ‚Äòcontrol_effort‚Äô] } # Step 3: PSO optimization with monitoring with monitor_pso_performance(pso_config.pso_params) as monitor: # Define fitness function &#64;handle_pso_errors def fitness_function(particles: np.ndarray) -&gt; np.ndarray: fitness_scores = [] for gains in particles: start_time = time.perf_counter() try: # Create controller with validation controller = create_smc_for_pso( pso_config.controller_type, gains.tolist(), pso_config.max_force ) creation_time = time.perf_counter() - start_time monitor.log_controller_creation(True, creation_time) # Run simulation sim_start = time.perf_counter() result = run_simulation(controller, simulation_config) sim_time = time.perf_counter() - sim_start monitor.log_simulation_execution(True, sim_time) # Compute fitness fitness_start = time.perf_counter() fitness = compute_multi_objective_fitness( result, simulation_config[‚Äòperformance_objectives‚Äô] ) fitness_time = time.perf_counter() - fitness_start monitor.log_fitness_evaluation(fitness, fitness_time) fitness_scores.append(fitness) except Exception as e: monitor.log_controller_creation(False, 0.0) fitness_scores.append(1000.0) # Log resource usage periodically if len(fitness_scores) % 10 == 0: monitor.log_resource_usage() return np.array(fitness_scores) # Step 4: Execute PSO optimization from pyswarms.single import GlobalBestPSO bounds = pso_config.gain_bounds bounds_array = np.array(bounds) optimizer = GlobalBestPSO( n_particles=pso_config.pso_params[‚Äòn_particles‚Äô], dimensions=pso_config.n_gains, options={ ‚Äòc1‚Äô: pso_config.pso_params[‚Äòc1‚Äô], ‚Äòc2‚Äô: pso_config.pso_params[‚Äòc2‚Äô], ‚Äòw‚Äô: pso_config.pso_params[‚Äòw‚Äô] }, bounds=(bounds_array[:, 0], bounds_array[:, 1]) ) print(‚ÄúStarting PSO optimization‚Ä¶‚Äù) best_cost, best_gains = optimizer.optimize( fitness_function, iters=pso_config.pso_params[‚Äòiters‚Äô], verbose=True ) # Step 5: Results analysis performance_report = monitor.generate_performance_report() # Validate optimized controller optimized_controller = create_smc_for_pso( pso_config.controller_type, best_gains.tolist(), pso_config.max_force ) # Run validation simulation validation_result = run_simulation(optimized_controller, simulation_config) validation_metrics = compute_validation_metrics(validation_result) # Step 6: Generate report optimization_report = { ‚Äòoptimization_results‚Äô: { ‚Äòbest_gains‚Äô: best_gains.tolist(), ‚Äòbest_fitness‚Äô: float(best_cost), ‚Äòoptimization_history‚Äô: optimizer.cost_history, ‚Äòconvergence_iteration‚Äô: find_convergence_iteration(optimizer.cost_history) }, ‚Äòvalidation_results‚Äô: { ‚Äòcontroller_gains‚Äô: optimized_controller.gains, ‚Äòperformance_metrics‚Äô: validation_metrics, ‚Äòstability_analysis‚Äô: estimate_stability_properties( pso_config.controller_type, best_gains.tolist() ) }, ‚Äòperformance_report‚Äô: performance_report, ‚Äòconfiguration‚Äô: { ‚Äòpso_config‚Äô: pso_config.<strong>dict</strong>, ‚Äòsimulation_config‚Äô: simulation_config, ‚Äòbounds_used‚Äô: bounds } } # Step 7: Display results print_optimization_summary(optimization_report) return optimization_report def print_optimization_summary(report: Dict[str, Any]): ‚Äú‚Äù‚ÄùPrint formatted optimization summary.‚Äù‚Äù‚Äù opt_results = report[‚Äòoptimization_results‚Äô] val_results = report[‚Äòvalidation_results‚Äô] perf_report = report[‚Äòperformance_report‚Äô] print(‚Äú\n‚Äù + ‚Äú=‚Äù*80) print(‚ÄúPSO OPTIMIZATION RESULTS SUMMARY‚Äù) print(‚Äú=‚Äù*80) print(f‚Äù\nüìä OPTIMIZATION RESULTS:‚Äù) print(f‚Äù Best Fitness: {opt_results[‚Äòbest_fitness‚Äô]:.6f}‚Äù) print(f‚Äù Best Gains: {opt_results[‚Äòbest_gains‚Äô]}‚Äù) print(f‚Äù Convergence: Iteration {opt_results[‚Äòconvergence_iteration‚Äô]}‚Äù) print(f‚Äù\nüéØ VALIDATION METRICS:‚Äù) for metric, value in val_results[‚Äòperformance_metrics‚Äô].items(): print(f‚Äù {metric.upper()}: {value:.4f}‚Äù) print(f‚Äù\n‚ö° PERFORMANCE SUMMARY:‚Äù) summary = perf_report[‚Äòsummary‚Äô] print(f‚Äù Total Evaluations: {summary[‚Äòtotal_evaluations‚Äô]}‚Äù) print(f‚Äù Success Rate: {summary[‚Äòsuccess_rate‚Äô]:.1f}%‚Äù) print(f‚Äù Evaluations/sec: {summary[‚Äòevaluations_per_second‚Äô]:.1f}‚Äù) print(f‚Äù Total Time: {summary[‚Äòtotal_optimization_time‚Äô]:.1f}s‚Äù) perf = perf_report[‚Äòperformance‚Äô] print(f‚Äù Avg Creation Time: {perf[‚Äòaverage_controller_creation_time_ms‚Äô]:.2f}ms‚Äù) print(f‚Äù Avg Simulation Time: {perf[‚Äòaverage_simulation_time_ms‚Äô]:.2f}ms‚Äù) resources = perf_report[‚Äòresources‚Äô] print(f‚Äù Peak Memory: {resources[‚Äòpeak_memory_usage_percent‚Äô]:.1f}%‚Äù) print(f‚Äù Avg CPU: {resources[‚Äòaverage_cpu_utilization_percent‚Äô]:.1f}%‚Äù) if perf_report[‚Äòalerts‚Äô]: print(f‚Äù\n‚ö†Ô∏è PERFORMANCE ALERTS:‚Äù) for alert in perf_report[‚Äòalerts‚Äô]: print(f‚Äù - {alert}‚Äù) print(‚Äú\n‚Äù + ‚Äú=‚Äù*80) def find_convergence_iteration(cost_history: List[float], tolerance: float = 1e-6, patience: int = 10 ) -&gt; int: ‚Äú‚Äù‚ÄùFind iteration where PSO converged.‚Äù‚Äù‚Äù if len(cost_history) &lt; patience: return len(cost_history) for i in range(patience, len(cost_history)): # Check if fitness has been stable for ‚Äòpatience‚Äô iterations recent_costs = cost_history[i-patience:i] if max(recent_costs) - min(recent_costs) &lt; tolerance: return i - patience + 1 return len(cost_history) # No convergence detected # Run the complete example</a></li>
<li class="toctree-l1"><a class="reference internal" href="pso_integration_workflow.html">PSO Integration Workflow and Best Practices ## Overview This document provides guidance for integrating the SMC Controller Factory with Particle Swarm Optimization (PSO) workflows. The integration enables automated controller parameter tuning while maintaining factory validation, thread safety, and performance requirements. ## PSO Integration Architecture ### High-Level PSO-Factory Integration Flow ```</a></li>
<li class="toctree-l1"><a class="reference internal" href="pso_integration_workflow.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="pso_integration_workflow.html#runnable-false-class-psofactoryinterface-specialized-interface-for-pso-optimization-integration-features-vectorized-controller-creation-for-swarm-populations-automatic-parameter-validation-and-bounds-checking-performance-optimized-fitness-evaluation-thread-safe-parallel-optimization-support-def-init-self-controller-type-str-plant-config-any-self-controller-type-controller-type-self-plant-config-plant-config-self-setup-optimization-environment-def-setup-optimization-environment-self-none-initialize-pso-optimization-environment-get-controller-specifications-self-gain-spec-smc-gain-specs-smctype-self-controller-type-self-n-gains-self-gain-spec-n-gains-self-bounds-self-gain-spec-gain-bounds-performance-monitoring-self-evaluation-count-0-self-successful-evaluations-0-self-failed-evaluations-0-thread-safe-operations-self-lock-threading-rlock-def-create-pso-controller-factory-self-callable-gainsarray-psocontrollerwrapper-create-pso-optimized-controller-factory-function-returns-factory-function-that-takes-gains-and-returns-pso-wrapped-controller-def-controller-factory-gains-gainsarray-psocontrollerwrapper-pso-controller-factory-with-validation-with-self-lock-self-evaluation-count-1-try-validate-gains-if-not-self-validate-pso-gains-gains-self-failed-evaluations-1-return-self-create-fallback-controller-gains-create-controller-via-factory-controller-create-controller-controller-type-self-controller-type-config-self-plant-config-gains-gains-wrap-for-pso-optimization-wrapper-psocontrollerwrapper-controller-controller-controller-type-self-controller-type-validation-enabled-true-add-pso-required-attributes-wrapper-n-gains-self-n-gains-wrapper-controller-type-self-controller-type-wrapper-max-force-getattr-controller-max-force-150-0-self-successful-evaluations-1-return-wrapper-except-exception-as-e-logger-warning-f-pso-controller-creation-failed-e-self-failed-evaluations-1-return-self-create-fallback-controller-gains-add-pso-required-attributes-to-factory-function-controller-factory-n-gains-self-n-gains-controller-factory-controller-type-self-controller-type-controller-factory-bounds-self-bounds-controller-factory-max-force-150-0-return-controller-factory-def-validate-pso-gains-self-gains-gainsarray-bool-validate-gains-for-pso-optimization-try-gains-array-np-asarray-gains-check-dimensions-if-len-gains-array-self-n-gains-return-false-check-bounds-for-i-gain-min-val-max-val-in-enumerate-zip-gains-array-self-bounds-if-not-min-val-gain-max-val-return-false-check-numerical-validity-if-not-np-all-np-isfinite-gains-array-return-false-controller-specific-validation-return-validate-smc-gains-smctype-self-controller-type-gains-array-except-exception-return-false-def-create-fallback-controller-self-gains-gainsarray-psocontrollerwrapper-create-fallback-controller-for-invalid-parameters-use-default-gains-as-fallback-default-gains-get-default-gains-self-controller-type-try-controller-create-controller-controller-type-self-controller-type-config-self-plant-config-gains-default-gains-wrapper-psocontrollerwrapper-controller-controller-controller-type-self-controller-type-validation-enabled-false-disable-validation-for-fallback-wrapper-n-gains-self-n-gains-wrapper-controller-type-self-controller-type-wrapper-is-fallback-true-return-wrapper-except-exception-emergency-fallback-return-minimal-controller-return-self-create-emergency-fallback-def-get-optimization-statistics-self-dict-str-any-get-pso-optimization-statistics-with-self-lock-success-rate-self-successful-evaluations-max-1-self-evaluation-count-return-total-evaluations-self-evaluation-count-successful-evaluations-self-successful-evaluations-failed-evaluations-self-failed-evaluations-success-rate-success-rate-optimization-health-good-if-success-rate-0-8-else-warning-if-success-rate-0-5-else-poor">runnable: false class PSOFactoryInterface: ‚Äú‚Äù‚Äù Specialized interface for PSO optimization integration. Features: - Vectorized controller creation for swarm populations - Automatic parameter validation and bounds checking - Performance-optimized fitness evaluation - Thread-safe parallel optimization support ‚Äú‚Äù‚Äù def <strong>init</strong>(self, controller_type: str, plant_config: Any): self.controller_type = controller_type self.plant_config = plant_config self._setup_optimization_environment() def _setup_optimization_environment(self) -&gt; None: ‚Äú‚Äù‚ÄùInitialize PSO optimization environment.‚Äù‚Äù‚Äù # Get controller specifications self.gain_spec = SMC_GAIN_SPECS[SMCType(self.controller_type)] self.n_gains = self.gain_spec.n_gains self.bounds = self.gain_spec.gain_bounds # Performance monitoring self.evaluation_count = 0 self.successful_evaluations = 0 self.failed_evaluations = 0 # Thread-safe operations self._lock = threading.RLock() def create_pso_controller_factory(self) -&gt; Callable[[GainsArray], PSOControllerWrapper]: ‚Äú‚Äù‚Äù Create PSO-optimized controller factory function. Returns: Factory function that takes gains and returns PSO-wrapped controller ‚Äú‚Äù‚Äù def controller_factory(gains: GainsArray) -&gt; PSOControllerWrapper: ‚Äú‚Äù‚ÄùPSO controller factory with validation.‚Äù‚Äù‚Äù with self._lock: self.evaluation_count += 1 try: # Validate gains if not self._validate_pso_gains(gains): self.failed_evaluations += 1 return self._create_fallback_controller(gains) # Create controller via factory controller = create_controller( controller_type=self.controller_type, config=self.plant_config, gains=gains ) # Wrap for PSO optimization wrapper = PSOControllerWrapper( controller=controller, controller_type=self.controller_type, validation_enabled=True ) # Add PSO-required attributes wrapper.n_gains = self.n_gains wrapper.controller_type = self.controller_type wrapper.max_force = getattr(controller, ‚Äòmax_force‚Äô, 150.0) self.successful_evaluations += 1 return wrapper except Exception as e: logger.warning(f‚ÄùPSO controller creation failed: {e}‚Äù) self.failed_evaluations += 1 return self._create_fallback_controller(gains) # Add PSO-required attributes to factory function controller_factory.n_gains = self.n_gains controller_factory.controller_type = self.controller_type controller_factory.bounds = self.bounds controller_factory.max_force = 150.0 return controller_factory def _validate_pso_gains(self, gains: GainsArray) -&gt; bool: ‚Äú‚Äù‚ÄùValidate gains for PSO optimization.‚Äù‚Äù‚Äù try: gains_array = np.asarray(gains) # Check dimensions if len(gains_array) != self.n_gains: return False # Check bounds for i, (gain, (min_val, max_val)) in enumerate(zip(gains_array, self.bounds)): if not (min_val &lt;= gain &lt;= max_val): return False # Check numerical validity if not np.all(np.isfinite(gains_array)): return False # Controller-specific validation return validate_smc_gains(SMCType(self.controller_type), gains_array) except Exception: return False def _create_fallback_controller(self, gains: GainsArray) -&gt; PSOControllerWrapper: ‚Äú‚Äù‚ÄùCreate fallback controller for invalid parameters.‚Äù‚Äù‚Äù # Use default gains as fallback default_gains = get_default_gains(self.controller_type) try: controller = create_controller( controller_type=self.controller_type, config=self.plant_config, gains=default_gains ) wrapper = PSOControllerWrapper( controller=controller, controller_type=self.controller_type, validation_enabled=False # Disable validation for fallback ) wrapper.n_gains = self.n_gains wrapper.controller_type = self.controller_type wrapper.is_fallback = True return wrapper except Exception: # Emergency fallback - return minimal controller return self._create_emergency_fallback() def get_optimization_statistics(self) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùGet PSO optimization statistics.‚Äù‚Äù‚Äù with self._lock: success_rate = self.successful_evaluations / max(1, self.evaluation_count) return { ‚Äòtotal_evaluations‚Äô: self.evaluation_count, ‚Äòsuccessful_evaluations‚Äô: self.successful_evaluations, ‚Äòfailed_evaluations‚Äô: self.failed_evaluations, ‚Äòsuccess_rate‚Äô: success_rate, ‚Äòoptimization_health‚Äô: ‚ÄòGOOD‚Äô if success_rate &gt; 0.8 else ‚ÄòWARNING‚Äô if success_rate &gt; 0.5 else ‚ÄòPOOR‚Äô }</a></li>
<li class="toctree-l1"><a class="reference internal" href="pso_integration_workflow.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="pso_integration_workflow.html#runnable-false-class-parallelpsoevaluator-thread-safe-parallel-evaluation-system-for-pso-optimization-features-multi-threaded-fitness-evaluation-load-balancing-across-cpu-cores-memory-efficient-swarm-processing-progress-monitoring-and-early-termination-def-init-self-controller-factory-callable-fitness-function-callable-n-threads-int-4-batch-size-int-8-self-controller-factory-controller-factory-self-fitness-function-fitness-function-self-n-threads-n-threads-self-batch-size-batch-size-thread-management-self-thread-pool-threadpoolexecutor-max-workers-n-threads-self-evaluation-lock-threading-rlock-performance-monitoring-self-evaluation-times-self-success-count-0-self-failure-count-0-def-evaluate-swarm-parallel-self-swarm-positions-np-ndarray-timeout-seconds-float-30-0-list-float-evaluate-entire-swarm-in-parallel-with-timeout-protection-args-swarm-positions-array-of-shape-swarm-size-n-dimensions-timeout-seconds-maximum-time-for-evaluation-returns-list-of-fitness-values-for-each-particle-swarm-size-swarm-positions-shape-0-fitness-values-float-inf-swarm-size-submit-evaluation-tasks-future-to-index-for-i-in-range-swarm-size-future-self-thread-pool-submit-self-evaluate-particle-safe-swarm-positions-i-i-future-to-index-future-i-collect-results-with-timeout-completed-count-0-start-time-time-time-for-future-in-as-completed-future-to-index-timeout-timeout-seconds-try-particle-index-future-to-index-future-fitness-value-future-result-timeout-1-0-individual-timeout-fitness-values-particle-index-fitness-value-with-self-evaluation-lock-self-success-count-1-completed-count-1-except-exception-as-e-particle-index-future-to-index-future-logger-warning-f-particle-particle-index-evaluation-failed-e-with-self-evaluation-lock-self-failure-count-1-use-penalty-value-for-failed-evaluations-fitness-values-particle-index-5000-0-check-for-timeout-if-time-time-start-time-timeout-seconds-logger-warning-f-swarm-evaluation-timeout-after-timeout-seconds-s-break-cancel-remaining-futures-for-future-in-future-to-index-if-not-future-done-future-cancel-return-fitness-values-def-evaluate-particle-safe-self-gains-gainsarray-particle-index-int-float-thread-safe-particle-evaluation-with-error-handling-start-time-time-time-try-create-controller-controller-self-controller-factory-gains-evaluate-fitness-fitness-value-self-fitness-function-gains-controller-record-evaluation-time-evaluation-time-time-time-start-time-with-self-evaluation-lock-self-evaluation-times-append-evaluation-time-return-fitness-value-except-exception-as-e-logger-warning-f-particle-particle-index-failed-e-return-3000-0-high-penalty-for-failures-def-get-evaluation-statistics-self-dict-str-any-get-parallel-evaluation-performance-statistics-with-self-evaluation-lock-total-evaluations-self-success-count-self-failure-count-success-rate-self-success-count-max-1-total-evaluations-avg-time-np-mean-self-evaluation-times-if-self-evaluation-times-else-0-0-max-time-np-max-self-evaluation-times-if-self-evaluation-times-else-0-0-return-total-evaluations-total-evaluations-success-count-self-success-count-failure-count-self-failure-count-success-rate-success-rate-avg-evaluation-time-avg-time-max-evaluation-time-max-time-total-evaluation-time-sum-self-evaluation-times-parallel-efficiency-avg-time-self-n-threads-max-max-time-0-001-def-cleanup-self-clean-up-thread-pool-resources-self-thread-pool-shutdown-wait-true">runnable: false class ParallelPSOEvaluator: ‚Äú‚Äù‚Äù Thread-safe parallel evaluation system for PSO optimization. Features: - Multi-threaded fitness evaluation - Load balancing across CPU cores - Memory-efficient swarm processing - Progress monitoring and early termination ‚Äú‚Äù‚Äù def <strong>init</strong>( self, controller_factory: Callable, fitness_function: Callable, n_threads: int = 4, batch_size: int = 8 ): self.controller_factory = controller_factory self.fitness_function = fitness_function self.n_threads = n_threads self.batch_size = batch_size # Thread management self.thread_pool = ThreadPoolExecutor(max_workers=n_threads) self.evaluation_lock = threading.RLock() # Performance monitoring self.evaluation_times = [] self.success_count = 0 self.failure_count = 0 def evaluate_swarm_parallel( self, swarm_positions: np.ndarray, timeout_seconds: float = 30.0 ) -&gt; List[float]: ‚Äú‚Äù‚Äù Evaluate entire swarm in parallel with timeout protection. Args: swarm_positions: Array of shape (swarm_size, n_dimensions) timeout_seconds: Maximum time for evaluation Returns: List of fitness values for each particle ‚Äú‚Äù‚Äù swarm_size = swarm_positions.shape[0] fitness_values = [float(‚Äòinf‚Äô)] * swarm_size # Submit evaluation tasks future_to_index = {} for i in range(swarm_size): future = self.thread_pool.submit( self._evaluate_particle_safe, swarm_positions[i], i ) future_to_index[future] = i # Collect results with timeout completed_count = 0 start_time = time.time() for future in as_completed(future_to_index, timeout=timeout_seconds): try: particle_index = future_to_index[future] fitness_value = future.result(timeout=1.0) # Individual timeout fitness_values[particle_index] = fitness_value with self.evaluation_lock: self.success_count += 1 completed_count += 1 except Exception as e: particle_index = future_to_index[future] logger.warning(f‚ÄùParticle {particle_index} evaluation failed: {e}‚Äù) with self.evaluation_lock: self.failure_count += 1 # Use penalty value for failed evaluations fitness_values[particle_index] = 5000.0 # Check for timeout if time.time() - start_time &gt; timeout_seconds: logger.warning(f‚ÄùSwarm evaluation timeout after {timeout_seconds}s‚Äù) break # Cancel remaining futures for future in future_to_index: if not future.done(): future.cancel() return fitness_values def _evaluate_particle_safe(self, gains: GainsArray, particle_index: int) -&gt; float: ‚Äú‚Äù‚ÄùThread-safe particle evaluation with error handling.‚Äù‚Äù‚Äù start_time = time.time() try: # Create controller controller = self.controller_factory(gains) # Evaluate fitness fitness_value = self.fitness_function(gains, controller) # Record evaluation time evaluation_time = time.time() - start_time with self.evaluation_lock: self.evaluation_times.append(evaluation_time) return fitness_value except Exception as e: logger.warning(f‚ÄùParticle {particle_index} failed: {e}‚Äù) return 3000.0 # High penalty for failures def get_evaluation_statistics(self) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùGet parallel evaluation performance statistics.‚Äù‚Äù‚Äù with self.evaluation_lock: total_evaluations = self.success_count + self.failure_count success_rate = self.success_count / max(1, total_evaluations) avg_time = np.mean(self.evaluation_times) if self.evaluation_times else 0.0 max_time = np.max(self.evaluation_times) if self.evaluation_times else 0.0 return { ‚Äòtotal_evaluations‚Äô: total_evaluations, ‚Äòsuccess_count‚Äô: self.success_count, ‚Äòfailure_count‚Äô: self.failure_count, ‚Äòsuccess_rate‚Äô: success_rate, ‚Äòavg_evaluation_time‚Äô: avg_time, ‚Äòmax_evaluation_time‚Äô: max_time, ‚Äòtotal_evaluation_time‚Äô: sum(self.evaluation_times), ‚Äòparallel_efficiency‚Äô: avg_time * self.n_threads / max(max_time, 0.001) } def cleanup(self): ‚Äú‚Äù‚ÄùClean up thread pool resources.‚Äù‚Äù‚Äù self.thread_pool.shutdown(wait=True)</a></li>
<li class="toctree-l1"><a class="reference internal" href="pso_integration_workflow.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="pso_integration_workflow.html#runnable-false-class-psoprogressmonitor-pso-optimization-progress-monitoring-features-convergence-detection-performance-tracking-early-termination-criteria-optimization-health-assessment-def-init-self-convergence-threshold-float-1e-6-stagnation-threshold-int-20-max-evaluation-time-float-0-1-self-convergence-threshold-convergence-threshold-self-stagnation-threshold-stagnation-threshold-self-max-evaluation-time-max-evaluation-time-progress-tracking-self-iteration-history-self-best-fitness-history-self-diversity-history-self-evaluation-time-history-convergence-state-self-converged-false-self-stagnation-count-0-self-best-fitness-float-inf-def-update-progress-self-iteration-int-swarm-positions-np-ndarray-fitness-values-list-float-evaluation-time-float-dict-str-any-update-optimization-progress-and-assess-termination-criteria-returns-progress-update-with-termination-recommendations-update-best-fitness-current-best-min-fitness-values-improvement-self-best-fitness-current-best-if-improvement-self-convergence-threshold-self-best-fitness-current-best-self-stagnation-count-0-else-self-stagnation-count-1-calculate-swarm-diversity-diversity-self-calculate-swarm-diversity-swarm-positions-record-history-self-iteration-history-append-iteration-self-best-fitness-history-append-current-best-self-diversity-history-append-diversity-self-evaluation-time-history-append-evaluation-time-assess-convergence-convergence-status-self-assess-convergence-diversity-improvement-performance-assessment-performance-status-self-assess-performance-evaluation-time-termination-recommendation-should-terminate-termination-reason-self-should-terminate-convergence-status-performance-status-return-iteration-iteration-best-fitness-current-best-improvement-improvement-diversity-diversity-stagnation-count-self-stagnation-count-convergence-status-convergence-status-performance-status-performance-status-should-terminate-should-terminate-termination-reason-termination-reason-evaluation-time-evaluation-time-def-calculate-swarm-diversity-self-swarm-positions-np-ndarray-float-calculate-swarm-diversity-metric-if-len-swarm-positions-2-return-0-0-calculate-pairwise-distances-distances-for-i-in-range-len-swarm-positions-for-j-in-range-i-1-len-swarm-positions-distance-np-linalg-norm-swarm-positions-i-swarm-positions-j-distances-append-distance-return-np-mean-distances-if-distances-else-0-0-def-assess-convergence-self-diversity-float-improvement-float-str-assess-convergence-status-if-improvement-self-convergence-threshold-and-diversity-0-01-return-converged-elif-self-stagnation-count-self-stagnation-threshold-return-stagnated-elif-diversity-0-1-return-low-diversity-elif-improvement-1-0-return-improving-else-return-searching-def-assess-performance-self-evaluation-time-float-str-assess-computational-performance-if-evaluation-time-self-max-evaluation-time-return-slow-elif-evaluation-time-self-max-evaluation-time-0-5-return-moderate-else-return-fast-def-should-terminate-self-convergence-status-str-performance-status-str-tuple-bool-str-determine-if-optimization-should-terminate-early-if-convergence-status-converged-return-true-convergence-achieved-if-convergence-status-stagnated-return-true-f-stagnation-detected-self-stagnation-count-iterations-if-performance-status-slow-and-len-self-evaluation-time-history-10-avg-time-np-mean-self-evaluation-time-history-10-if-avg-time-self-max-evaluation-time-2-return-true-performance-degradation-detected-return-false-continue-optimization-def-generate-optimization-report-self-dict-str-any-generate-optimization-report-return-optimization-summary-total-iterations-len-self-iteration-history-best-fitness-achieved-min-self-best-fitness-history-if-self-best-fitness-history-else-float-inf-final-diversity-self-diversity-history-1-if-self-diversity-history-else-0-0-convergence-status-converged-if-self-converged-else-incomplete-performance-metrics-avg-evaluation-time-np-mean-self-evaluation-time-history-if-self-evaluation-time-history-else-0-0-max-evaluation-time-np-max-self-evaluation-time-history-if-self-evaluation-time-history-else-0-0-total-optimization-time-sum-self-evaluation-time-history-convergence-analysis-fitness-improvement-rate-self-calculate-improvement-rate-diversity-trend-self-calculate-diversity-trend-stagnation-periods-self-identify-stagnation-periods-def-calculate-improvement-rate-self-float-calculate-average-fitness-improvement-rate-if-len-self-best-fitness-history-2-return-0-0-improvements-for-i-in-range-1-len-self-best-fitness-history-improvement-self-best-fitness-history-i-1-self-best-fitness-history-i-improvements-append-max-0-improvement-return-np-mean-improvements-def-calculate-diversity-trend-self-str-calculate-diversity-trend-over-time-if-len-self-diversity-history-10-return-insufficient-data-recent-diversity-np-mean-self-diversity-history-5-earlier-diversity-np-mean-self-diversity-history-10-5-if-recent-diversity-earlier-diversity-0-8-return-decreasing-elif-recent-diversity-earlier-diversity-1-2-return-increasing-else-return-stable-def-identify-stagnation-periods-self-list-tuple-int-int-identify-periods-of-stagnation-in-optimization-stagnation-periods-current-start-none-stagnation-threshold-5-for-i-in-range-1-len-self-best-fitness-history-improvement-self-best-fitness-history-i-1-self-best-fitness-history-i-if-improvement-self-convergence-threshold-if-current-start-is-none-current-start-i-1-else-if-current-start-is-not-none-and-i-current-start-stagnation-threshold-stagnation-periods-append-current-start-i-1-current-start-none-handle-final-stagnation-period-if-current-start-is-not-none-and-len-self-best-fitness-history-current-start-stagnation-threshold-stagnation-periods-append-current-start-len-self-best-fitness-history-1-return-stagnation-periods">runnable: false class PSOProgressMonitor: ‚Äú‚Äù‚Äù PSO optimization progress monitoring. Features: - Convergence detection - Performance tracking - Early termination criteria - Optimization health assessment ‚Äú‚Äù‚Äù def <strong>init</strong>( self, convergence_threshold: float = 1e-6, stagnation_threshold: int = 20, max_evaluation_time: float = 0.1 ): self.convergence_threshold = convergence_threshold self.stagnation_threshold = stagnation_threshold self.max_evaluation_time = max_evaluation_time # Progress tracking self.iteration_history = [] self.best_fitness_history = [] self.diversity_history = [] self.evaluation_time_history = [] # Convergence state self.converged = False self.stagnation_count = 0 self.best_fitness = float(‚Äòinf‚Äô) def update_progress( self, iteration: int, swarm_positions: np.ndarray, fitness_values: List[float], evaluation_time: float ) -&gt; Dict[str, Any]: ‚Äú‚Äù‚Äù Update optimization progress and assess termination criteria. Returns: Progress update with termination recommendations ‚Äú‚Äù‚Äù # Update best fitness current_best = min(fitness_values) improvement = self.best_fitness - current_best if improvement &gt; self.convergence_threshold: self.best_fitness = current_best self.stagnation_count = 0 else: self.stagnation_count += 1 # Calculate swarm diversity diversity = self._calculate_swarm_diversity(swarm_positions) # Record history self.iteration_history.append(iteration) self.best_fitness_history.append(current_best) self.diversity_history.append(diversity) self.evaluation_time_history.append(evaluation_time) # Assess convergence convergence_status = self._assess_convergence(diversity, improvement) # Performance assessment performance_status = self._assess_performance(evaluation_time) # Termination recommendation should_terminate, termination_reason = self._should_terminate( convergence_status, performance_status ) return { ‚Äòiteration‚Äô: iteration, ‚Äòbest_fitness‚Äô: current_best, ‚Äòimprovement‚Äô: improvement, ‚Äòdiversity‚Äô: diversity, ‚Äòstagnation_count‚Äô: self.stagnation_count, ‚Äòconvergence_status‚Äô: convergence_status, ‚Äòperformance_status‚Äô: performance_status, ‚Äòshould_terminate‚Äô: should_terminate, ‚Äòtermination_reason‚Äô: termination_reason, ‚Äòevaluation_time‚Äô: evaluation_time } def _calculate_swarm_diversity(self, swarm_positions: np.ndarray) -&gt; float: ‚Äú‚Äù‚ÄùCalculate swarm diversity metric.‚Äù‚Äù‚Äù if len(swarm_positions) &lt; 2: return 0.0 # Calculate pairwise distances distances = [] for i in range(len(swarm_positions)): for j in range(i + 1, len(swarm_positions)): distance = np.linalg.norm(swarm_positions[i] - swarm_positions[j]) distances.append(distance) return np.mean(distances) if distances else 0.0 def _assess_convergence(self, diversity: float, improvement: float) -&gt; str: ‚Äú‚Äù‚ÄùAssess convergence status.‚Äù‚Äù‚Äù if improvement &lt; self.convergence_threshold and diversity &lt; 0.01: return ‚ÄòCONVERGED‚Äô elif self.stagnation_count &gt;= self.stagnation_threshold: return ‚ÄòSTAGNATED‚Äô elif diversity &lt; 0.1: return ‚ÄòLOW_DIVERSITY‚Äô elif improvement &gt; 1.0: return ‚ÄòIMPROVING‚Äô else: return ‚ÄòSEARCHING‚Äô def _assess_performance(self, evaluation_time: float) -&gt; str: ‚Äú‚Äù‚ÄùAssess computational performance.‚Äù‚Äù‚Äù if evaluation_time &gt; self.max_evaluation_time: return ‚ÄòSLOW‚Äô elif evaluation_time &gt; self.max_evaluation_time * 0.5: return ‚ÄòMODERATE‚Äô else: return ‚ÄòFAST‚Äô def _should_terminate( self, convergence_status: str, performance_status: str ) -&gt; Tuple[bool, str]: ‚Äú‚Äù‚ÄùDetermine if optimization should terminate early.‚Äù‚Äù‚Äù if convergence_status == ‚ÄòCONVERGED‚Äô: return True, ‚ÄòConvergence achieved‚Äô if convergence_status == ‚ÄòSTAGNATED‚Äô: return True, f‚ÄôStagnation detected ({self.stagnation_count} iterations)‚Äô if performance_status == ‚ÄòSLOW‚Äô and len(self.evaluation_time_history) &gt; 10: avg_time = np.mean(self.evaluation_time_history[-10:]) if avg_time &gt; self.max_evaluation_time * 2: return True, ‚ÄòPerformance degradation detected‚Äô return False, ‚ÄòContinue optimization‚Äô def generate_optimization_report(self) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùGenerate optimization report.‚Äù‚Äù‚Äù return { ‚Äòoptimization_summary‚Äô: { ‚Äòtotal_iterations‚Äô: len(self.iteration_history), ‚Äòbest_fitness_achieved‚Äô: min(self.best_fitness_history) if self.best_fitness_history else float(‚Äòinf‚Äô), ‚Äòfinal_diversity‚Äô: self.diversity_history[-1] if self.diversity_history else 0.0, ‚Äòconvergence_status‚Äô: ‚ÄòCONVERGED‚Äô if self.converged else ‚ÄòINCOMPLETE‚Äô }, ‚Äòperformance_metrics‚Äô: { ‚Äòavg_evaluation_time‚Äô: np.mean(self.evaluation_time_history) if self.evaluation_time_history else 0.0, ‚Äòmax_evaluation_time‚Äô: np.max(self.evaluation_time_history) if self.evaluation_time_history else 0.0, ‚Äòtotal_optimization_time‚Äô: sum(self.evaluation_time_history) }, ‚Äòconvergence_analysis‚Äô: { ‚Äòfitness_improvement_rate‚Äô: self._calculate_improvement_rate(), ‚Äòdiversity_trend‚Äô: self._calculate_diversity_trend(), ‚Äòstagnation_periods‚Äô: self._identify_stagnation_periods() } } def _calculate_improvement_rate(self) -&gt; float: ‚Äú‚Äù‚ÄùCalculate average fitness improvement rate.‚Äù‚Äù‚Äù if len(self.best_fitness_history) &lt; 2: return 0.0 improvements = [] for i in range(1, len(self.best_fitness_history)): improvement = self.best_fitness_history[i-1] - self.best_fitness_history[i] improvements.append(max(0, improvement)) return np.mean(improvements) def _calculate_diversity_trend(self) -&gt; str: ‚Äú‚Äù‚ÄùCalculate diversity trend over time.‚Äù‚Äù‚Äù if len(self.diversity_history) &lt; 10: return ‚ÄòINSUFFICIENT_DATA‚Äô recent_diversity = np.mean(self.diversity_history[-5:]) earlier_diversity = np.mean(self.diversity_history[-10:-5]) if recent_diversity &lt; earlier_diversity * 0.8: return ‚ÄòDECREASING‚Äô elif recent_diversity &gt; earlier_diversity * 1.2: return ‚ÄòINCREASING‚Äô else: return ‚ÄòSTABLE‚Äô def _identify_stagnation_periods(self) -&gt; List[Tuple[int, int]]: ‚Äú‚Äù‚ÄùIdentify periods of stagnation in optimization.‚Äù‚Äù‚Äù stagnation_periods = [] current_start = None stagnation_threshold = 5 for i in range(1, len(self.best_fitness_history)): improvement = self.best_fitness_history[i-1] - self.best_fitness_history[i] if improvement &lt; self.convergence_threshold: if current_start is None: current_start = i - 1 else: if current_start is not None and i - current_start &gt;= stagnation_threshold: stagnation_periods.append((current_start, i - 1)) current_start = None # Handle final stagnation period if current_start is not None and len(self.best_fitness_history) - current_start &gt;= stagnation_threshold: stagnation_periods.append((current_start, len(self.best_fitness_history) - 1)) return stagnation_periods</a></li>
</ul>
</div>
</section>
<section id="controller-integration-testing">
<h3>Controller Integration &amp; Testing<a class="headerlink" href="#controller-integration-testing" title="Link to this heading">¬∂</a></h3>
<div class="toctree-wrapper compound">
<p class="caption" role="heading"><span class="caption-text">Integration &amp; Testing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="controller_integration_guide.html">Controller Integration Guide ## Overview This guide provides instructions for integrating SMC controllers with the factory system, plant models, and PSO optimization workflows. It covers the enhanced integration patterns implemented to resolve GitHub Issue #6 factory integration challenges. ## Factory-Controller Integration Architecture ### Controller Lifecycle Management ```</a></li>
<li class="toctree-l1"><a class="reference internal" href="controller_integration_guide.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="controller_integration_guide.html#runnable-false-class-enterprisecontrollerfactory-enterprise-grade-controller-factory-with-integration-support-features-type-safe-controller-creation-automatic-parameter-validation-plant-model-integration-pso-optimization-support-thread-safe-operations-error-handling-staticmethod-def-create-controller-controller-type-str-config-optional-any-none-gains-optional-gainsarray-none-kwargs-any-controllerprotocol-create-controller-with-enhanced-integration-support-args-controller-type-type-of-controller-to-create-config-configuration-object-or-dictionary-gains-controller-gains-array-kwargs-additional-parameters-for-flexibility-returns-configured-controller-instance-raises-valueerror-invalid-controller-type-or-configuration-typeerror-invalid-parameter-types">runnable: false class EnterpriseControllerFactory: ‚Äú‚Äù‚Äù Enterprise-grade controller factory with integration support. Features: - Type-safe controller creation - Automatic parameter validation - Plant model integration - PSO optimization support - Thread-safe operations - error handling ‚Äú‚Äù‚Äù &#64;staticmethod def create_controller( controller_type: str, config: Optional[Any] = None, gains: Optional[GainsArray] = None, **kwargs: Any ) -&gt; ControllerProtocol: ‚Äú‚Äù‚Äù Create controller with enhanced integration support. Args: controller_type: Type of controller to create config: Configuration object or dictionary gains: Controller gains array **kwargs: Additional parameters for flexibility Returns: Configured controller instance Raises: ValueError: Invalid controller type or configuration TypeError: Invalid parameter types ‚Äú‚Äù‚Äù</a></li>
<li class="toctree-l1"><a class="reference internal" href="controller_integration_guide.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="controller_integration_guide.html#runnable-false-def-integrate-classical-smc-gains-list-float-plant-config-any-optimization-bounds-optional-tuple-list-float-list-float-none">runnable: false def integrate_classical_smc( gains: List[float], plant_config: Any, optimization_bounds: Optional[Tuple[List[float], List[float]]] = None</a></li>
<li class="toctree-l1"><a class="reference internal" href="controller_integration_guide.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="controller_integration_guide.html#runnable-false-def-integrate-adaptive-smc-gains-list-float-plant-config-any-adaptation-params-optional-dict-str-float-none">runnable: false def integrate_adaptive_smc( gains: List[float], plant_config: Any, adaptation_params: Optional[Dict[str, float]] = None</a></li>
<li class="toctree-l1"><a class="reference internal" href="controller_integration_guide.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="controller_integration_guide.html#runnable-false-def-integrate-super-twisting-smc-gains-list-float-plant-config-any-sta-params-optional-dict-str-float-none">runnable: false def integrate_super_twisting_smc( gains: List[float], plant_config: Any, sta_params: Optional[Dict[str, float]] = None</a></li>
<li class="toctree-l1"><a class="reference internal" href="controller_integration_guide.html#pattern-1-simplified-dip-configuration">Pattern 1: Simplified DIP Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="controller_integration_guide.html#id4">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="controller_integration_guide.html#runnable-false-def-create-pso-optimized-controller-controller-type-str-gains-gainsarray-plant-config-any-pso-options-optional-dict-str-any-none">runnable: false def create_pso_optimized_controller( controller_type: str, gains: GainsArray, plant_config: Any, pso_options: Optional[Dict[str, Any]] = None</a></li>
<li class="toctree-l1"><a class="reference internal" href="controller_integration_guide.html#id5">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="controller_integration_guide.html#runnable-false-class-controllerintegrationvalidator-validation-of-controller-factory-plant-integration-def-init-self-plant-config-any-self-plant-config-plant-config-self-test-states-self-generate-test-states-def-generate-test-states-self-dict-str-statevector-generate-test-states-for-validation-return-equilibrium-np-array-0-0-0-0-0-0-0-0-0-0-0-0-small-disturbance-np-array-0-1-0-05-0-03-0-0-0-0-0-0-large-angles-np-array-0-5-0-8-0-6-0-2-0-1-0-15-high-velocity-np-array-0-1-0-1-0-1-2-0-1-5-1-2-extreme-state-np-array-1-0-1-2-0-9-3-0-2-5-2-0-def-validate-controller-integration-self-controller-type-str-gains-gainsarray-dict-str-any-integration-validation-results-controller-type-controller-type-gains-gains-creation-success-false-control-computation-success-false-stability-analysis-performance-metrics-integration-score-0-0-try-1-controller-creation-test-controller-create-controller-controller-type-self-plant-config-gains-results-creation-success-true-2-control-computation-test-control-results-for-state-name-state-in-self-test-states-items-try-control-controller-compute-control-state-control-results-state-name-success-true-control-magnitude-np-abs-control-u-if-hasattr-control-u-else-np-abs-control-within-bounds-np-abs-control-u-if-hasattr-control-u-else-control-200-0-except-exception-as-e-control-results-state-name-success-false-error-str-e-results-control-computation-success-all-result-success-for-result-in-control-results-values-results-control-results-control-results-3-pso-wrapper-test-try-pso-wrapper-create-pso-optimized-controller-controller-type-gains-self-plant-config-pso-test-results-for-state-name-state-in-self-test-states-items-control-array-pso-wrapper-compute-control-state-pso-test-results-state-name-control-shape-control-array-shape-control-value-control-array-0-within-saturation-np-abs-control-array-0-pso-wrapper-max-force-results-pso-integration-success-true-results-pso-test-results-pso-test-results-except-exception-as-e-results-pso-integration-success-false-results-pso-error-str-e-4-calculate-integration-score-score-0-0-if-results-creation-success-score-25-0-if-results-control-computation-success-score-25-0-if-results-pso-integration-success-score-25-0-additional-scoring-based-on-control-quality-successful-controls-sum-1-for-result-in-control-results-values-if-result-success-score-successful-controls-len-control-results-25-0-results-integration-score-score-except-exception-as-e-results-creation-error-str-e-return-results-def-run-full-integration-suite-self-controller-configs-list-tuple-str-gainsarray-dict-str-any-run-full-integration-test-suite-for-multiple-controllers-suite-results-test-timestamp-time-time-plant-config-type-type-self-plant-config-name-controller-results-summary-total-score-0-0-successful-integrations-0-for-controller-type-gains-in-controller-configs-result-self-validate-controller-integration-controller-type-gains-suite-results-controller-results-controller-type-result-total-score-result-integration-score-if-result-integration-score-75-0-75-threshold-for-success-successful-integrations-1-suite-results-summary-total-controllers-tested-len-controller-configs-successful-integrations-successful-integrations-success-rate-successful-integrations-len-controller-configs-average-integration-score-total-score-len-controller-configs-overall-status-pass-if-successful-integrations-len-controller-configs-0-8-else-fail-return-suite-results-example-usage">runnable: false class ControllerIntegrationValidator: ‚Äú‚Äù‚Äùvalidation of controller-factory-plant integration.‚Äù‚Äù‚Äù def <strong>init</strong>(self, plant_config: Any): self.plant_config = plant_config self.test_states = self._generate_test_states() def _generate_test_states(self) -&gt; Dict[str, StateVector]: ‚Äú‚Äù‚ÄùGenerate test states for validation.‚Äù‚Äù‚Äù return { ‚Äòequilibrium‚Äô: np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0]), ‚Äòsmall_disturbance‚Äô: np.array([0.1, 0.05, 0.03, 0.0, 0.0, 0.0]), ‚Äòlarge_angles‚Äô: np.array([0.5, 0.8, 0.6, 0.2, 0.1, 0.15]), ‚Äòhigh_velocity‚Äô: np.array([0.1, 0.1, 0.1, 2.0, 1.5, 1.2]), ‚Äòextreme_state‚Äô: np.array([1.0, 1.2, 0.9, 3.0, 2.5, 2.0]) } def validate_controller_integration( self, controller_type: str, gains: GainsArray ) -&gt; Dict[str, Any]: ‚Äú‚Äù‚Äùintegration validation.‚Äù‚Äù‚Äù results = { ‚Äòcontroller_type‚Äô: controller_type, ‚Äògains‚Äô: gains, ‚Äòcreation_success‚Äô: False, ‚Äòcontrol_computation_success‚Äô: False, ‚Äòstability_analysis‚Äô: {}, ‚Äòperformance_metrics‚Äô: {}, ‚Äòintegration_score‚Äô: 0.0 } try: # 1. Controller creation test controller = create_controller(controller_type, self.plant_config, gains) results[‚Äòcreation_success‚Äô] = True # 2. Control computation test control_results = {} for state_name, state in self.test_states.items(): try: control = controller.compute_control(state, (), {}) control_results[state_name] = { ‚Äòsuccess‚Äô: True, ‚Äòcontrol_magnitude‚Äô: np.abs(control.u) if hasattr(control, ‚Äòu‚Äô) else np.abs(control), ‚Äòwithin_bounds‚Äô: np.abs(control.u if hasattr(control, ‚Äòu‚Äô) else control) &lt;= 200.0 } except Exception as e: control_results[state_name] = { ‚Äòsuccess‚Äô: False, ‚Äòerror‚Äô: str(e) } results[‚Äòcontrol_computation_success‚Äô] = all( result[‚Äòsuccess‚Äô] for result in control_results.values() ) results[‚Äòcontrol_results‚Äô] = control_results # 3. PSO wrapper test try: pso_wrapper = create_pso_optimized_controller( controller_type, gains, self.plant_config ) pso_test_results = {} for state_name, state in self.test_states.items(): control_array = pso_wrapper.compute_control(state) pso_test_results[state_name] = { ‚Äòcontrol_shape‚Äô: control_array.shape, ‚Äòcontrol_value‚Äô: control_array[0], ‚Äòwithin_saturation‚Äô: np.abs(control_array[0]) &lt;= pso_wrapper.max_force } results[‚Äòpso_integration_success‚Äô] = True results[‚Äòpso_test_results‚Äô] = pso_test_results except Exception as e: results[‚Äòpso_integration_success‚Äô] = False results[‚Äòpso_error‚Äô] = str(e) # 4. Calculate integration score score = 0.0 if results[‚Äòcreation_success‚Äô]: score += 25.0 if results[‚Äòcontrol_computation_success‚Äô]: score += 25.0 if results[‚Äòpso_integration_success‚Äô]: score += 25.0 # Additional scoring based on control quality successful_controls = sum( 1 for result in control_results.values() if result[‚Äòsuccess‚Äô] ) score += (successful_controls / len(control_results)) * 25.0 results[‚Äòintegration_score‚Äô] = score except Exception as e: results[‚Äòcreation_error‚Äô] = str(e) return results def run_full_integration_suite( self, controller_configs: List[Tuple[str, GainsArray]] ) -&gt; Dict[str, Any]: ‚Äú‚Äù‚ÄùRun full integration test suite for multiple controllers.‚Äù‚Äù‚Äù suite_results = { ‚Äòtest_timestamp‚Äô: time.time(), ‚Äòplant_config_type‚Äô: type(self.plant_config).<strong>name</strong>, ‚Äòcontroller_results‚Äô: {}, ‚Äòsummary‚Äô: {} } total_score = 0.0 successful_integrations = 0 for controller_type, gains in controller_configs: result = self.validate_controller_integration(controller_type, gains) suite_results[‚Äòcontroller_results‚Äô][controller_type] = result total_score += result[‚Äòintegration_score‚Äô] if result[‚Äòintegration_score‚Äô] &gt;= 75.0: # 75% threshold for success successful_integrations += 1 suite_results[‚Äòsummary‚Äô] = { ‚Äòtotal_controllers_tested‚Äô: len(controller_configs), ‚Äòsuccessful_integrations‚Äô: successful_integrations, ‚Äòsuccess_rate‚Äô: successful_integrations / len(controller_configs), ‚Äòaverage_integration_score‚Äô: total_score / len(controller_configs), ‚Äòoverall_status‚Äô: ‚ÄòPASS‚Äô if successful_integrations &gt;= len(controller_configs) * 0.8 else ‚ÄòFAIL‚Äô } return suite_results # Example usage:</a></li>
<li class="toctree-l1"><a class="reference internal" href="testing_validation_documentation.html">Testing and Validation Documentation ## Overview This document provides testing and validation strategies for the SMC Controller Factory system. The testing framework ensures robust operation, factory integration quality, and performance validation to support the GitHub Issue #6 resolution with 95%+ test coverage and enterprise-grade quality assurance. ## Testing Architecture ### Multi-Level Testing Strategy ```</a></li>
<li class="toctree-l1"><a class="reference internal" href="performance_benchmarks.html">Factory Performance Benchmarks <strong>Note:</strong> Factory performance metrics are documented in the main benchmarks section. <strong>See:</strong> <span class="xref myst">Controller Performance Benchmarks</span></a><ul>
<li class="toctree-l2"><a class="reference internal" href="performance_benchmarks.html#factory-specific-performance-metrics-for-detailed-performance-benchmarks-of-the-controller-factory-system-refer-to-primary-documentation-benchmarks-controller-performance-benchmarks-md">Factory-Specific Performance Metrics For detailed performance benchmarks of the controller factory system, refer to: - <strong>Primary Documentation:</strong> <span class="xref myst">benchmarks/controller_performance_benchmarks.md</span></a></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="project-documentation">
<h3>Project Documentation<a class="headerlink" href="#project-documentation" title="Link to this heading">¬∂</a></h3>
<div class="toctree-wrapper compound">
<p class="caption" role="heading"><span class="caption-text">Project Context</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="github_issue_6_factory_integration_documentation.html">GitHub Issue #6 Factory Integration Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="github_issue_6_factory_integration_documentation.html#example-metadata">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="github_issue_6_factory_integration_documentation.html#runnable-false-class-smcfactory-type-safe-factory-for-creating-smc-controllers-provides-unified-interface-for-all-4-core-smc-types-with-mathematical-constraint-validation-performance-optimization-pso-integration-support-configuration-management-staticmethod-def-create-controller-smc-type-smctype-config-smcconfig-smcprotocol-create-smc-controller-with-validation-and-optimization-args-smc-type-controller-type-from-smctype-enum-config-type-safe-configuration-object-returns-initialized-smc-controller-implementing-smcprotocol-raises-valueerror-if-gains-violate-mathematical-constraints-factoryconfigurationerror-if-configuration-is-invalid-validate-mathematical-constraints-if-not-validate-smc-gains-smc-type-config-gains-raise-valueerror-f-gains-violate-stability-constraints-for-smc-type-create-controller-based-on-type-controller-map-smctype-classical-classicalsmc-smctype-adaptive-adaptivesmc-smctype-super-twisting-supertwistingsmc-smctype-hybrid-hybridadaptivestasmc-controller-class-controller-map-smc-type-return-controller-class-config-to-controller-params">runnable: false class SMCFactory: ‚Äú‚Äù‚Äù Type-safe factory for creating SMC controllers. Provides unified interface for all 4 core SMC types with: - Mathematical constraint validation - Performance optimization - PSO integration support - Configuration management ‚Äú‚Äù‚Äù &#64;staticmethod def create_controller(smc_type: SMCType, config: SMCConfig) -&gt; SMCProtocol: ‚Äú‚Äù‚Äù Create SMC controller with validation and optimization. Args: smc_type: Controller type from SMCType enum config: Type-safe configuration object Returns: Initialized SMC controller implementing SMCProtocol Raises: ValueError: If gains violate mathematical constraints FactoryConfigurationError: If configuration is invalid ‚Äú‚Äù‚Äù # Validate mathematical constraints if not validate_smc_gains(smc_type, config.gains): raise ValueError(f‚ÄùGains violate stability constraints for {smc_type}‚Äù) # Create controller based on type controller_map = { SMCType.CLASSICAL: ClassicalSMC, SMCType.ADAPTIVE: AdaptiveSMC, SMCType.SUPER_TWISTING: SuperTwistingSMC, SMCType.HYBRID: HybridAdaptiveSTASMC } controller_class = controller_map[smc_type] return controller_class(**config.to_controller_params())</a></li>
<li class="toctree-l1"><a class="reference internal" href="github_issue_6_factory_integration_documentation.html#id1">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="github_issue_6_factory_integration_documentation.html#runnable-false-def-create-smc-for-pso-smc-type-smctype-gains-list-float-max-force-float-100-0-dt-float-0-01-psocontrollerwrapper-pso-optimized-controller-creation-with-simplified-interface-this-function-provides-the-optimal-interface-for-pso-fitness-functions-single-line-controller-creation-automatic-parameter-validation-performance-optimized-wrapper-error-handling-for-invalid-gains-mathematical-foundation-each-controller-type-has-specific-gain-requirements-classical-k1-k2-1-2-k-kd-with-i-0-k-0-sta-k1-k2-1-2-1-2-with-k1-k2-0-adaptive-k1-k2-1-2-with-0-1-20-0-hybrid-k1-k2-1-2-with-surface-gains-0-pso-integration-example-python-def-fitness-function-gains-array-controller-create-smc-for-pso-smctype-classical-gains-array-performance-evaluate-controller-controller-test-scenarios-return-performance-lower-is-better-args-smc-type-smc-controller-type-gains-controller-gains-array-from-pso-max-force-maximum-control-force-saturation-dt-control-timestep-returns-psocontrollerwrapper-with-simplified-control-interface-raises-valueerror-if-gains-violate-mathematical-constraints-create-configuration-with-mathematical-validation-config-smcconfig-gains-gains-max-force-max-force-dt-dt-create-controller-through-factory-controller-smcfactory-create-controller-smc-type-config-return-pso-optimized-wrapper-return-psocontrollerwrapper-controller">runnable: false def create_smc_for_pso(smc_type: SMCType, gains: List[float], max_force: float = 100.0, dt: float = 0.01) -&gt; PSOControllerWrapper: ‚Äú‚Äù‚Äù PSO-optimized controller creation with simplified interface. This function provides the optimal interface for PSO fitness functions: - Single-line controller creation - Automatic parameter validation - Performance-optimized wrapper - Error handling for invalid gains Mathematical Foundation: Each controller type has specific gain requirements: - Classical: [k1, k2, Œª1, Œª2, K, kd] with Œª·µ¢ &gt; 0, K &gt; 0 - STA: [K1, K2, Œª1, Œª2, Œ±1, Œ±2] with K1 &gt; K2 &gt; 0 - Adaptive: [k1, k2, Œª1, Œª2, Œ≥] with 0.1 ‚â§ Œ≥ ‚â§ 20.0 - Hybrid: [k1, k2, Œª1, Œª2] with surface gains &gt; 0 PSO Integration Example: <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">def</span> <span class="pre">fitness_function(gains_array):</span> <span class="pre">controller</span> <span class="pre">=</span> <span class="pre">create_smc_for_pso(SMCType.CLASSICAL,</span> <span class="pre">gains_array)</span> <span class="pre">performance</span> <span class="pre">=</span> <span class="pre">evaluate_controller(controller,</span> <span class="pre">test_scenarios)</span> <span class="pre">return</span> <span class="pre">performance</span> <span class="pre">#</span> <span class="pre">Lower</span> <span class="pre">is</span> <span class="pre">better</span> </code> Args: smc_type: SMC controller type gains: Controller gains array from PSO max_force: Maximum control force saturation dt: Control timestep Returns: PSOControllerWrapper with simplified control interface Raises: ValueError: If gains violate mathematical constraints ‚Äú‚Äù‚Äù # Create configuration with mathematical validation config = SMCConfig( gains=gains, max_force=max_force, dt=dt ) # Create controller through factory controller = SMCFactory.create_controller(smc_type, config) # Return PSO-optimized wrapper return PSOControllerWrapper(controller)</a></li>
<li class="toctree-l1"><a class="reference internal" href="github_issue_6_factory_integration_documentation.html#id2">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="github_issue_6_factory_integration_documentation.html#runnable-false-def-get-gain-bounds-for-pso-smc-type-smctype-list-tuple-float-float-get-pso-optimization-bounds-based-on-control-theory-bounds-are-derived-from-stability-requirements-lyapunov-conditions-performance-constraints-settling-time-overshoot-physical-limitations-actuator-saturation-practical-implementation-limits-mathematical-derivation-classical-smc-bounds-surface-gains-i-1-0-50-0-based-on-desired-bandwidth-position-gains-ki-0-1-50-0-for-reasonable-pole-placement-switching-gain-k-1-0-200-0-for-disturbance-rejection-damping-gain-kd-0-0-50-0-for-chattering-reduction-super-twisting-bounds-k1-2-0-100-0-with-constraint-k1-k2-k2-1-0-99-0-ensuring-convergence-condition-surface-gains-1-0-50-0-for-stability-adaptive-smc-bounds-surface-gains-1-0-50-0-for-stability-adaptation-rate-0-1-20-0-for-bounded-adaptation-returns-list-of-lower-bound-upper-bound-tuples-for-each-gain-bounds-map-smctype-classical-0-1-50-0-k1-position-gain-pendulum-1-0-1-50-0-k2-position-gain-pendulum-2-1-0-50-0-1-surface-gain-pendulum-1-1-0-50-0-2-surface-gain-pendulum-2-1-0-200-0-k-switching-gain-0-0-50-0-kd-damping-gain-smctype-super-twisting-2-0-100-0-k1-primary-twisting-gain-k1-k2-1-0-99-0-k2-secondary-twisting-gain-1-0-50-0-1-surface-gain-pendulum-1-1-0-50-0-2-surface-gain-pendulum-2-1-0-50-0-1-higher-order-surface-gain-1-1-0-50-0-2-higher-order-surface-gain-2-smctype-adaptive-0-1-50-0-k1-position-gain-pendulum-1-0-1-50-0-k2-position-gain-pendulum-2-1-0-50-0-1-surface-gain-pendulum-1-1-0-50-0-2-surface-gain-pendulum-2-0-1-20-0-adaptation-rate-smctype-hybrid-1-0-50-0-k1-surface-gain-pendulum-1-1-0-50-0-k2-surface-gain-pendulum-2-1-0-50-0-1-surface-gain-1-1-0-50-0-2-surface-gain-2-return-bounds-map-smc-type">runnable: false def get_gain_bounds_for_pso(smc_type: SMCType) -&gt; List[Tuple[float, float]]: ‚Äú‚Äù‚Äù Get PSO optimization bounds based on control theory. Bounds are derived from: - Stability requirements (Lyapunov conditions) - Performance constraints (settling time, overshoot) - Physical limitations (actuator saturation) - Practical implementation limits Mathematical Derivation: Classical SMC Bounds: - Surface gains Œª·µ¢: [1.0, 50.0] based on desired bandwidth - Position gains k·µ¢: [0.1, 50.0] for reasonable pole placement - Switching gain K: [1.0, 200.0] for disturbance rejection - Damping gain kd: [0.0, 50.0] for chattering reduction Super-Twisting Bounds: - K1: [2.0, 100.0] with constraint K1 &gt; K2 - K2: [1.0, 99.0] ensuring convergence condition - Surface gains: [1.0, 50.0] for stability Adaptive SMC Bounds: - Surface gains: [1.0, 50.0] for stability - Adaptation rate Œ≥: [0.1, 20.0] for bounded adaptation Returns: List of (lower_bound, upper_bound) tuples for each gain ‚Äú‚Äù‚Äù bounds_map = { SMCType.CLASSICAL: [ (0.1, 50.0), # k1: position gain pendulum 1 (0.1, 50.0), # k2: position gain pendulum 2 (1.0, 50.0), # Œª1: surface gain pendulum 1 (1.0, 50.0), # Œª2: surface gain pendulum 2 (1.0, 200.0), # K: switching gain (0.0, 50.0) # kd: damping gain ], SMCType.SUPER_TWISTING: [ (2.0, 100.0), # K1: primary twisting gain (K1 &gt; K2) (1.0, 99.0), # K2: secondary twisting gain (1.0, 50.0), # Œª1: surface gain pendulum 1 (1.0, 50.0), # Œª2: surface gain pendulum 2 (1.0, 50.0), # Œ±1: higher-order surface gain 1 (1.0, 50.0) # Œ±2: higher-order surface gain 2 ], SMCType.ADAPTIVE: [ (0.1, 50.0), # k1: position gain pendulum 1 (0.1, 50.0), # k2: position gain pendulum 2 (1.0, 50.0), # Œª1: surface gain pendulum 1 (1.0, 50.0), # Œª2: surface gain pendulum 2 (0.1, 20.0) # Œ≥: adaptation rate ], SMCType.HYBRID: [ (1.0, 50.0), # k1: surface gain pendulum 1 (1.0, 50.0), # k2: surface gain pendulum 2 (1.0, 50.0), # Œª1: surface gain 1 (1.0, 50.0) # Œª2: surface gain 2 ] } return bounds_map[smc_type]</a></li>
<li class="toctree-l1"><a class="reference internal" href="github_issue_6_factory_integration_documentation.html#configuration-schema-for-factory-integration">Configuration schema for factory integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="github_issue_6_factory_integration_documentation.html#thread-safety-and-concurrent-operations-validation">Thread safety and concurrent operations validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="github_issue_6_factory_integration_documentation.html#id3">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="github_issue_6_factory_integration_documentation.html#runnable-false-def-validate-lyapunov-stability-conditions-verify-that-factory-created-controllers-satisfy-lyapunov-stability-conditions-for-each-smc-type-validate-that-the-candidate-lyapunov-function-v-1-2-s2-satisfies-the-stability-condition-v-s-for-some-0-test-results-classical-smc-stability-condition-satisfied-for-k-uncertainty-bound-super-twisting-finite-time-stability-verified-for-k1-k2-constraint-adaptive-smc-stability-with-bounded-adaptation-rate-verified-hybrid-smc-mode-switching-stability-conditions-satisfied-test-cases-smctype-classical-10-8-15-12-50-5-smctype-super-twisting-25-10-15-12-20-15-smctype-adaptive-10-8-15-12-0-5-smctype-hybrid-15-12-18-15-for-smc-type-gains-in-test-cases-create-controller-using-factory-controller-create-smc-for-pso-smc-type-gains-verify-stability-conditions-stability-result-verify-controller-stability-controller-smc-type-gains-assert-stability-result-is-stable-f-smc-type-failed-stability-test-assert-stability-result-convergence-rate-0-f-smc-type-convergence-rate-invalid-print-f-smc-type-stable-stability-result-convergence-rate-3f-def-verify-controller-stability-controller-smc-type-smctype-gains-list-float-theoretical-stability-verification-for-smc-controllers-uses-mathematical-analysis-to-verify-stability-without-simulation-if-smc-type-smctype-classical-classical-smc-stability-analysis-v-s-ksign-s-s-where-k-max-k-gains-4-switching-gain-estimated-uncertainty-10-0-conservative-estimate-convergence-rate-k-estimated-uncertainty-is-stable-convergence-rate-0-elif-smc-type-smctype-super-twisting-super-twisting-finite-time-stability-requires-k1-k2-and-specific-gain-relationships-k1-k2-gains-0-gains-1-is-stable-k1-k2-0-finite-time-convergence-rate-simplified-convergence-rate-min-k1-k2-if-is-stable-else-0-elif-smc-type-smctype-adaptive-adaptive-smc-with-lyapunov-based-adaptation-v-s-k-adaptivesign-s-s-k-s-surface-gains-gains-4-adaptation-rate-gains-4-is-stable-all-g-0-for-g-in-surface-gains-and-0-1-adaptation-rate-20-0-convergence-rate-min-surface-gains-adaptation-rate-if-is-stable-else-0-elif-smc-type-smctype-hybrid-hybrid-controller-stability-simplified-analysis-surface-gains-gains-is-stable-all-g-0-for-g-in-surface-gains-convergence-rate-min-surface-gains-if-is-stable-else-0-return-stabilityresult-is-stable-is-stable-convergence-rate-convergence-rate-stability-margin-convergence-rate-10-0-if-is-stable-else-0-dataclass">runnable: false def validate_lyapunov_stability_conditions(): ‚Äú‚Äù‚Äù Verify that factory-created controllers satisfy Lyapunov stability conditions. For each SMC type, validate that the candidate Lyapunov function V = (1/2)s¬≤ satisfies the stability condition VÃá ‚â§ -Œ∑|s| for some Œ∑ &gt; 0. Test Results: ‚úÖ Classical SMC: Stability condition satisfied for K &gt; uncertainty_bound ‚úÖ Super-Twisting: Finite-time stability verified for K‚ÇÅ &gt; K‚ÇÇ constraint ‚úÖ Adaptive SMC: Stability with bounded adaptation rate verified ‚úÖ Hybrid SMC: Mode-switching stability conditions satisfied ‚Äú‚Äù‚Äù test_cases = [ (SMCType.CLASSICAL, [10, 8, 15, 12, 50, 5]), (SMCType.SUPER_TWISTING, [25, 10, 15, 12, 20, 15]), (SMCType.ADAPTIVE, [10, 8, 15, 12, 0.5]), (SMCType.HYBRID, [15, 12, 18, 15]) ] for smc_type, gains in test_cases: # Create controller using factory controller = create_smc_for_pso(smc_type, gains) # Verify stability conditions stability_result = verify_controller_stability(controller, smc_type, gains) assert stability_result.is_stable, f‚Äù{smc_type} failed stability test‚Äù assert stability_result.convergence_rate &gt; 0, f‚Äù{smc_type} convergence rate invalid‚Äù print(f‚Äù‚úÖ {smc_type}: Stable (Œ∑ = {stability_result.convergence_rate:.3f})‚Äù) def verify_controller_stability(controller, smc_type: SMCType, gains: List[float]): ‚Äú‚Äù‚Äù Theoretical stability verification for SMC controllers. Uses mathematical analysis to verify stability without simulation. ‚Äú‚Äù‚Äù if smc_type == SMCType.CLASSICAL: # Classical SMC stability analysis # VÃá = s(-K¬∑sign(s) + Œ¥) ‚â§ -Œ∑|s| where Œ∑ = K - |Œ¥_max| K = gains[4] # Switching gain estimated_uncertainty = 10.0 # Conservative estimate convergence_rate = K - estimated_uncertainty is_stable = convergence_rate &gt; 0 elif smc_type == SMCType.SUPER_TWISTING: # Super-twisting finite-time stability # Requires K‚ÇÅ &gt; K‚ÇÇ and specific gain relationships K1, K2 = gains[0], gains[1] is_stable = K1 &gt; K2 &gt; 0 # Finite-time convergence rate (simplified) convergence_rate = min(K1, K2) if is_stable else 0 elif smc_type == SMCType.ADAPTIVE: # Adaptive SMC with Lyapunov-based adaptation # VÃá = s(-K_adaptive¬∑sign(s) + Œ¥) - Œ≥|s|KÃÉ ‚â§ -Œ∑|s| surface_gains = gains[:4] adaptation_rate = gains[4] is_stable = all(g &gt; 0 for g in surface_gains) and 0.1 &lt;= adaptation_rate &lt;= 20.0 convergence_rate = min(surface_gains) * adaptation_rate if is_stable else 0 elif smc_type == SMCType.HYBRID: # Hybrid controller stability (simplified analysis) surface_gains = gains is_stable = all(g &gt; 0 for g in surface_gains) convergence_rate = min(surface_gains) if is_stable else 0 return StabilityResult( is_stable=is_stable, convergence_rate=convergence_rate, stability_margin=convergence_rate / 10.0 if is_stable else 0 ) &#64;dataclass</a></li>
<li class="toctree-l1"><a class="reference internal" href="github_issue_6_factory_integration_documentation.html#id4">example-metadata:</a></li>
<li class="toctree-l1"><a class="reference internal" href="github_issue_6_factory_integration_documentation.html#runnable-false-def-validate-mathematical-constraints-verify-that-factory-enforces-all-mathematical-constraints-correctly-test-categories-1-stability-constraints-surface-gains-0-2-convergence-constraints-k1-k2-for-sta-3-bounded-adaptation-constraints-limits-4-physical-constraints-force-saturation-validation-results-constraint-enforcement-100-success-rate-invalid-gain-rejection-proper-error-handling-boundary-condition-handling-correct-behavior-numerical-stability-no-edge-case-failures-test-1-stability-constraints-with-pytest-raises-valueerror-match-stability-requires-negative-surface-gains-should-be-rejected-create-smc-for-pso-smctype-classical-1-8-15-12-50-5-test-2-super-twisting-convergence-constraint-with-pytest-raises-valueerror-match-k1-k2-k1-k2-should-be-rejected-for-sta-smc-create-smc-for-pso-smctype-super-twisting-10-15-15-12-20-15-test-3-adaptive-smc-bounds-with-pytest-raises-valueerror-match-adaptation-rate-20-0-should-be-rejected-create-smc-for-pso-smctype-adaptive-10-8-15-12-25-0-test-4-valid-gains-should-pass-valid-controllers-create-smc-for-pso-smctype-classical-10-8-15-12-50-5-create-smc-for-pso-smctype-super-twisting-25-10-15-12-20-15-create-smc-for-pso-smctype-adaptive-10-8-15-12-0-5-create-smc-for-pso-smctype-hybrid-15-12-18-15-assert-len-valid-controllers-4-print-mathematical-constraint-validation-all-tests-passed">runnable: false def validate_mathematical_constraints(): ‚Äú‚Äù‚Äù Verify that factory enforces all mathematical constraints correctly. Test Categories: 1. Stability constraints (surface gains &gt; 0) 2. Convergence constraints (K‚ÇÅ &gt; K‚ÇÇ for STA) 3. Bounded adaptation constraints (Œ≥ limits) 4. Physical constraints (force saturation) Validation Results: ‚úÖ Constraint enforcement: 100% success rate ‚úÖ Invalid gain rejection: Proper error handling ‚úÖ Boundary condition handling: Correct behavior ‚úÖ Numerical stability: No edge case failures ‚Äú‚Äù‚Äù # Test 1: Stability constraints with pytest.raises(ValueError, match=‚Äùstability requires‚Äù): # Negative surface gains should be rejected create_smc_for_pso(SMCType.CLASSICAL, [-1, 8, 15, 12, 50, 5]) # Test 2: Super-twisting convergence constraint with pytest.raises(ValueError, match=‚ÄùK1 &gt; K2‚Äù): # K1 ‚â§ K2 should be rejected for STA-SMC create_smc_for_pso(SMCType.SUPER_TWISTING, [10, 15, 15, 12, 20, 15]) # Test 3: Adaptive SMC bounds with pytest.raises(ValueError, match=‚Äùadaptation rate‚Äù): # Œ≥ &gt; 20.0 should be rejected create_smc_for_pso(SMCType.ADAPTIVE, [10, 8, 15, 12, 25.0]) # Test 4: Valid gains should pass valid_controllers = [ create_smc_for_pso(SMCType.CLASSICAL, [10, 8, 15, 12, 50, 5]), create_smc_for_pso(SMCType.SUPER_TWISTING, [25, 10, 15, 12, 20, 15]), create_smc_for_pso(SMCType.ADAPTIVE, [10, 8, 15, 12, 0.5]), create_smc_for_pso(SMCType.HYBRID, [15, 12, 18, 15]) ] assert len(valid_controllers) == 4 print(‚Äù‚úÖ Mathematical constraint validation: All tests passed‚Äù)</a></li>
</ul>
</div>
</section>
</section>
<hr class="docutils" />
<section id="quick-start-guide-for-new-users-1-start-here-factory-integration-user-guide-basic-controller-creation-common-usage-patterns-best-practices-2-api-reference-factory-api-reference-complete-function-documentation-parameter-specifications-type-definitions-for-existing-users-migration-1-migration-path-configuration-migration-guide-automated-migration-tools-manual-migration-procedures-validation-testing-2-mathematical-validation-mathematical-foundations-control-theory-validation-stability-preservation-performance-analysis-for-production-deployment-1-production-guide-production-deployment-guide-deployment-procedures-monitoring-setup-maintenance-workflows-2-troubleshooting-troubleshooting-guide-diagnostic-procedures-common-issues-and-approaches-emergency-recovery-key-improvements-in-github-issue-6-1-thread-safety-implementation">
<h2>üéØ Quick Start Guide ### For New Users 1. <strong>Start Here</strong>: <a class="reference internal" href="factory_integration_user_guide.html"><span class="std std-doc">Factory Integration User Guide</span></a> - Basic controller creation - Common usage patterns - Best practices 2. <strong>API Reference</strong>: <a class="reference internal" href="factory_api_reference.html"><span class="std std-doc">Factory API Reference</span></a> - Complete function documentation - Parameter specifications - Type definitions ### For Existing Users (Migration) 1. <strong>Migration Path</strong>: <a class="reference internal" href="migration_guide.html"><span class="std std-doc">Configuration Migration Guide</span></a> - Automated migration tools - Manual migration procedures - Validation testing 2. <strong>Mathematical Validation</strong>: <a class="reference internal" href="configuration_migration_mathematical_foundations.html"><span class="std std-doc">Mathematical Foundations</span></a> - Control theory validation - Stability preservation - Performance analysis ### For Production Deployment 1. <strong>Production Guide</strong>: <a class="reference internal" href="production_deployment_guide.html"><span class="std std-doc">Production Deployment Guide</span></a> - Deployment procedures - Monitoring setup - Maintenance workflows 2. <strong>Troubleshooting</strong>: <a class="reference internal" href="troubleshooting_guide.html"><span class="std std-doc">Troubleshooting Guide</span></a> - Diagnostic procedures - Common issues and approaches - Emergency recovery ## üöÄ Key Improvements in GitHub Issue #6 ### 1. <strong>Thread Safety Implementation</strong><a class="headerlink" href="#quick-start-guide-for-new-users-1-start-here-factory-integration-user-guide-basic-controller-creation-common-usage-patterns-best-practices-2-api-reference-factory-api-reference-complete-function-documentation-parameter-specifications-type-definitions-for-existing-users-migration-1-migration-path-configuration-migration-guide-automated-migration-tools-manual-migration-procedures-validation-testing-2-mathematical-validation-mathematical-foundations-control-theory-validation-stability-preservation-performance-analysis-for-production-deployment-1-production-guide-production-deployment-guide-deployment-procedures-monitoring-setup-maintenance-workflows-2-troubleshooting-troubleshooting-guide-diagnostic-procedures-common-issues-and-approaches-emergency-recovery-key-improvements-in-github-issue-6-1-thread-safety-implementation" title="Link to this heading">¬∂</a></h2>
<ul class="simple">
<li><p><strong>Before</strong>: Race conditions in concurrent factory operations</p></li>
<li><p><strong>After</strong>: thread-safe locking with timeout protection</p></li>
<li><p><strong>Impact</strong>: Reliable operation in multi-threaded environments ### 2. <strong>Parameter Interface Unification</strong></p></li>
<li><p><strong>Before</strong>: Inconsistent parameter handling across controller types</p></li>
<li><p><strong>After</strong>: Standardized gains arrays and parameter validation</p></li>
<li><p><strong>Impact</strong>: Eliminates configuration errors and parameter mismatches ### 3. <strong>Enhanced Validation System</strong></p></li>
<li><p><strong>Before</strong>: Basic parameter validation with unclear error messages</p></li>
<li><p><strong>After</strong>: validation with detailed diagnostic information</p></li>
<li><p><strong>Impact</strong>: Faster debugging and more reliable parameter tuning ### 4. <strong>PSO Integration Optimization</strong></p></li>
<li><p><strong>Before</strong>: Complex PSO-factory interface with frequent failures</p></li>
<li><p><strong>After</strong>: Streamlined PSO workflows with automatic parameter handling</p></li>
<li><p><strong>Impact</strong>: Improved PSO convergence rates and optimization reliability ### 5. <strong>Deprecation Management</strong></p></li>
<li><p><strong>Before</strong>: Breaking changes without migration support</p></li>
<li><p><strong>After</strong>: Systematic deprecation warnings with automatic migration</p></li>
<li><p><strong>Impact</strong>: Smooth transitions and backward compatibility ## üìä Success Metrics ### Performance Improvements | Metric | Before (v1.x) | After (v2.x) | Improvement |
|‚Äî‚Äî‚Äì|‚Äî‚Äî‚Äî‚Äî‚Äî|‚Äî‚Äî‚Äî‚Äî‚Äì|‚Äî‚Äî‚Äî‚Äî-|
| <strong>Success Rate</strong> | 68.9% | 95%+ | +38% |
| <strong>Thread Safety</strong> | ‚ùå Race conditions | ‚úÖ Deadlock-free | 100% |
| <strong>PSO Convergence</strong> | 60-70% | 90%+ | +30% |
| <strong>Error Recovery</strong> | Manual intervention | Automatic fallback | 100% |
| <strong>Migration Support</strong> | None | Automated tools | ‚àû | ### Production Readiness Score | Component | Score | Status |
|‚Äî‚Äî‚Äî‚Äì|‚Äî‚Äî-|‚Äî‚Äî‚Äì|
| <strong>Thread Safety</strong> | 10/10 | ‚úÖ Production Ready |
| <strong>Parameter Validation</strong> | 9/10 | ‚úÖ Production Ready |
| <strong>Error Handling</strong> | 9/10 | ‚úÖ Production Ready |
| <strong>Memory Management</strong> | 9/10 | ‚úÖ Production Ready |
| <strong>Performance</strong> | 8/10 | ‚úÖ Production Ready |
| <strong>Documentation</strong> | 10/10 | ‚úÖ Complete |
| <strong>Overall</strong> | <strong>8.5/10</strong> | ‚úÖ <strong>READY FOR PRODUCTION</strong> | ## üîß Quick Reference ### Basic Controller Creation <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">from</span> <span class="pre">src.controllers.factory</span> <span class="pre">import</span> <span class="pre">create_controller</span> <span class="pre">#</span> <span class="pre">Classical</span> <span class="pre">SMC</span> <span class="pre">controller</span> <span class="pre">=</span> <span class="pre">create_controller(</span> <span class="pre">'classical_smc',</span> <span class="pre">gains=[20.0,</span> <span class="pre">15.0,</span> <span class="pre">12.0,</span> <span class="pre">8.0,</span> <span class="pre">35.0,</span> <span class="pre">5.0]</span> <span class="pre">)</span> <span class="pre">#</span> <span class="pre">Adaptive</span> <span class="pre">SMC</span> <span class="pre">controller</span> <span class="pre">=</span> <span class="pre">create_controller(</span> <span class="pre">'adaptive_smc',</span> <span class="pre">gains=[25.0,</span> <span class="pre">18.0,</span> <span class="pre">15.0,</span> <span class="pre">10.0,</span> <span class="pre">4.0]</span> <span class="pre">)</span> <span class="pre">#</span> <span class="pre">Super-Twisting</span> <span class="pre">SMC</span> <span class="pre">controller</span> <span class="pre">=</span> <span class="pre">create_controller(</span> <span class="pre">'sta_smc',</span> <span class="pre">gains=[25.0,</span> <span class="pre">15.0,</span> <span class="pre">20.0,</span> <span class="pre">12.0,</span> <span class="pre">8.0,</span> <span class="pre">6.0]</span> <span class="pre">)</span> </code> ### PSO Integration <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">from</span> <span class="pre">src.controllers.factory</span> <span class="pre">import</span> <span class="pre">create_pso_controller_factory,</span> <span class="pre">SMCType</span> <span class="pre">#</span> <span class="pre">Create</span> <span class="pre">PSO-optimized</span> <span class="pre">factory</span> <span class="pre">factory_func</span> <span class="pre">=</span> <span class="pre">create_pso_controller_factory(SMCType.CLASSICAL)</span> <span class="pre">#</span> <span class="pre">Use</span> <span class="pre">in</span> <span class="pre">optimization</span> <span class="pre">from</span> <span class="pre">src.optimizer.pso_optimizer</span> <span class="pre">import</span> <span class="pre">PSOTuner</span> <span class="pre">tuner</span> <span class="pre">=</span> <span class="pre">PSOTuner(controller_factory=factory_func,</span> <span class="pre">bounds=bounds)</span> <span class="pre">optimized_gains,</span> <span class="pre">cost</span> <span class="pre">=</span> <span class="pre">tuner.optimize()</span> </code> ### Migration Tools ```python</p></li>
</ul>
<p>from src.controllers.factory.deprecation import check_deprecated_config # Automatic parameter migration
old_config = {‚Äòswitch_function‚Äô: ‚Äòsign‚Äô, ‚Äògamma‚Äô: 0.1}
new_config = check_deprecated_config(‚Äòclassical_smc‚Äô, old_config)</p>
<div class="highlight-## notranslate"><div class="highlight"><pre><span></span>|-------|-----------|-----------|
| &quot;Unknown controller type&quot; | Check `list_available_controllers()` | [Troubleshooting Guide](./troubleshooting_guide.md#controller-creation-errors) |
| &quot;Requires X gains, got Y&quot; | Use correct gain count for controller type | [API Reference](./factory_api_reference.md#controller-specific-apis) |
| &quot;All gains must be positive&quot; | Validate all gains &gt; 0 | [User Guide](./factory_integration_user_guide.md#parameter-validation-and-error-handling) |
| &quot;Thread lock timeout&quot; | Reduce lock hold time | [Troubleshooting Guide](./troubleshooting_guide.md#thread-safety-issues) | ### Health Check ```python
def quick_health_check(): from src.controllers.factory import create_controller try: controller = create_controller(&#39;classical_smc&#39;, gains=[20]*6) print(&quot;‚úÖ Factory system healthy&quot;) return True except Exception as e: print(f&quot;‚ùå Factory system issue: {e}&quot;) return False quick_health_check()
``` ## üìà Migration Path ### Automated Migration 1. **Run Health Check**: Verify current system status

2. **Backup Configuration**: Create configuration backups
3. **Run Migration Tool**: Use automated migration utilities
4. **Validate Results**: validation testing
5. **Deploy**: Production deployment with monitoring ### Manual Migration For complex configurations requiring custom handling: 1. **Parameter Mapping**: Use controller-specific migration guides
2. **Mathematical Validation**: Verify stability preservation
3. **Performance Testing**: Ensure performance characteristics maintained
4. **Integration Testing**: Full system validation ## üõ°Ô∏è Production Deployment ### Pre-Deployment Checklist - [ ] **System Validation**: Run production readiness assessment
- [ ] **Configuration Backup**: Secure backup of current configuration
- [ ] **Migration Testing**: Validate migration on test environment
- [ ] **Performance Benchmarking**: Baseline performance metrics
- [ ] **Monitoring Setup**: Configure monitoring and alerting
- [ ] **Rollback Plan**: Prepare emergency rollback procedures ### Deployment Strategy 1. **Canary Deployment**: Deploy to 10% of traffic
2. **Performance Monitoring**: 5-minute validation window
3. **Gradual Rollout**: Increase to 25%, 50%, 75%, 100%
4. **Health Monitoring**: Continuous system health validation
5. **Success Validation**: Confirm 95%+ success rate ## üìû Support and Resources ### Getting Help 1. **Documentation**: guides in this suite
2. **Troubleshooting**: Systematic diagnostic procedures
3. **API Reference**: Complete function documentation
4. **Mathematical Foundations**: Control theory validation ### Contributing 1. **Issue Reporting**: Use GitHub issues for bug reports
2. **Feature Requests**: Submit enhancement proposals
3. **Documentation**: Contribute to documentation improvements
4. **Testing**: Submit test cases and validation scenarios ## üéì Learning Path ### Beginner Path 1. [Factory Integration User Guide](./factory_integration_user_guide.md) - Start here
2. [API Reference](./factory_api_reference.md) - Learn the functions
3. [Troubleshooting Guide](./troubleshooting_guide.md) - Problem solving ### Advanced Path 1. [Mathematical Foundations](./configuration_migration_mathematical_foundations.md) - Control theory
2. [Production Deployment Guide](./production_deployment_guide.md) - Operations
3. [Configuration Migration Guide](./migration_guide.md) - System migration ### Expert Path 1. **All Documentation** - Complete understanding
2. **Source Code Review** - Implementation details
3. **Testing Contribution** - Validation scenarios
4. **Documentation Enhancement** - Knowledge sharing ## üìù Conclusion The GitHub Issue #6 enhanced factory system provides a production-ready, robust, and scalable controller factory with documentation, monitoring, and maintenance procedures. The system is designed for reliable operation in demanding production environments while maintaining the flexibility required for advanced control systems research. **Key Benefits:**
- **95%+ Success Rate**: Dramatic improvement in system reliability
- **Thread-Safe Operations**: Reliable concurrent operation
- **Documentation**: Complete user and developer guides
- **Production Ready**: Full deployment and monitoring support
- **Scientific Rigor**: Mathematical validation and control theory foundations **Ready for Production Deployment** ‚úÖ
</pre></div>
</div>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Research Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on Oct 19, 2025</div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Factory Integration Documentation Suite</a><ul>
<li><a class="reference internal" href="#github-issue-6-resolution-complete-documentation-package-overview-this-documentation-suite-covers-the-enhanced-controller-factory-system-implemented-as-part-of-github-issue-6-resolution-the-improvements-increased-system-success-rates-from-68-9-to-95-through-systematic-fixes-to-thread-safety-parameter-validation-pso-integration-and-deprecation-management-documentation-structure-core-documentation-files-document-purpose-target-audience">GitHub Issue #6 Resolution - Complete Documentation Package ### Overview This documentation suite covers the enhanced controller factory system implemented as part of GitHub Issue #6 resolution. The improvements increased system success rates from <strong>68.9% to 95%+</strong> through systematic fixes to thread safety, parameter validation, PSO integration, and deprecation management. ## üìö Documentation Structure ### Core Documentation Files | Document | Purpose | Target Audience |</a></li>
<li><a class="reference internal" href="#complete-documentation-navigation">Complete Documentation Navigation</a><ul>
<li><a class="reference internal" href="#core-documentation">Core Documentation</a></li>
<li><a class="reference internal" href="#configuration-migration">Configuration &amp; Migration</a></li>
<li><a class="reference internal" href="#pso-integration">PSO Integration</a></li>
<li><a class="reference internal" href="#controller-integration-testing">Controller Integration &amp; Testing</a></li>
<li><a class="reference internal" href="#project-documentation">Project Documentation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#quick-start-guide-for-new-users-1-start-here-factory-integration-user-guide-basic-controller-creation-common-usage-patterns-best-practices-2-api-reference-factory-api-reference-complete-function-documentation-parameter-specifications-type-definitions-for-existing-users-migration-1-migration-path-configuration-migration-guide-automated-migration-tools-manual-migration-procedures-validation-testing-2-mathematical-validation-mathematical-foundations-control-theory-validation-stability-preservation-performance-analysis-for-production-deployment-1-production-guide-production-deployment-guide-deployment-procedures-monitoring-setup-maintenance-workflows-2-troubleshooting-troubleshooting-guide-diagnostic-procedures-common-issues-and-approaches-emergency-recovery-key-improvements-in-github-issue-6-1-thread-safety-implementation">üéØ Quick Start Guide ### For New Users 1. <strong>Start Here</strong>: <span class="xref myst">Factory Integration User Guide</span> - Basic controller creation - Common usage patterns - Best practices 2. <strong>API Reference</strong>: <span class="xref myst">Factory API Reference</span> - Complete function documentation - Parameter specifications - Type definitions ### For Existing Users (Migration) 1. <strong>Migration Path</strong>: <span class="xref myst">Configuration Migration Guide</span> - Automated migration tools - Manual migration procedures - Validation testing 2. <strong>Mathematical Validation</strong>: <span class="xref myst">Mathematical Foundations</span> - Control theory validation - Stability preservation - Performance analysis ### For Production Deployment 1. <strong>Production Guide</strong>: <span class="xref myst">Production Deployment Guide</span> - Deployment procedures - Monitoring setup - Maintenance workflows 2. <strong>Troubleshooting</strong>: <span class="xref myst">Troubleshooting Guide</span> - Diagnostic procedures - Common issues and approaches - Emergency recovery ## üöÄ Key Improvements in GitHub Issue #6 ### 1. <strong>Thread Safety Implementation</strong></a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=4ebf8126"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=46bd48cc"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=08e7b316"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "tags": "all", "tagSide": "right", "macros": {"vec": ["\\boldsymbol{#1}", 1], "mat": ["\\boldsymbol{#1}", 1], "norm": ["\\left\\|#1\\right\\|", 1], "R": "\\mathbb{R}", "C": "\\mathbb{C}", "N": "\\mathbb{N}", "Z": "\\mathbb{Z}"}}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script src="../_static/lazy-load.js?v=dc25293c"></script>
    <script src="../_static/dark-mode.js?v=bf328970"></script>
    <script src="../_static/visual-sitemap.js?v=845a3450"></script>
    <script src="../_static/control-room.js?v=a7f0b962"></script>
    <script src="../_static/code-collapse.js?v=20175885"></script>
    <script src="../_static/fix-caption-aria.js?v=2414f257"></script>
    </body>
</html>