<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
.chartjs-container {
    margin: 1.5em auto;
    padding: 1em;
    background: #f8f9fa;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.chart-note {
    text-align: center;
    color: #6c757d;
    font-size: 0.9em;
    margin-top: 0.5em;
}
</style>
<link rel="index" title="Index" href="../genindex.html"><link rel="search" title="Search" href="../search.html">

    <!-- Generated with Sphinx 8.2.3 and Furo 2025.09.25 -->
        <title>Complete Sliding Mode Control Mathematical Theory - DIP_SMC_PSO Documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5349f25f" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=580074bf" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=8dab3a3b" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=8a7e329d" />
    
    


<style>
  body {
    --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">DIP_SMC_PSO Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  <span class="sidebar-brand-text">DIP_SMC_PSO Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">ğŸ“š Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Optimal Sliding Mode Control for a Double-Inverted Pendulum via PSO  ## How to validate a ResearchPlan JSON Run the validator locally: ```bash</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory_overview.html">Theory Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../architecture.html">3. System Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plant_model.html">1.x Plant Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hil_quickstart.html">Hardware-in-the-Loop (HIL) Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../streamlit_dashboard_guide.html">Streamlit Dashboard User Guide</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/blob/main/docs/mathematical_foundations/smc_complete_theory.md?plain=true" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div><div class="edit-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/edit/main/docs/mathematical_foundations/smc_complete_theory.md" rel="edit" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section class="tex2jax_ignore mathjax_ignore" id="complete-sliding-mode-control-mathematical-theory">
<h1>Complete Sliding Mode Control Mathematical Theory<a class="headerlink" href="#complete-sliding-mode-control-mathematical-theory" title="Link to this heading">Â¶</a></h1>
<p><strong>Double-Inverted Pendulum Control System</strong> <strong>Document Version</strong>: 1.0
<strong>Created</strong>: 2025-10-04
<strong>Status</strong>: Research-Grade Reference <strong>Purpose</strong>: Unified mathematical foundation for all SMC variants in the DIP-SMC-PSO system, including rigorous Lyapunov stability proofs, convergence analysis, finite-time convergence theory, and implementation considerations.</p>
<hr class="docutils" />
<section id="table-of-contents-1-introduction-and-fundamentals">
<h2>Table of Contents 1. <a class="reference internal" href="#1-introduction-and-fundamentals"><span class="xref myst">Introduction and Fundamentals</span></a><a class="headerlink" href="#table-of-contents-1-introduction-and-fundamentals" title="Link to this heading">Â¶</a></h2>
<ol class="arabic simple" start="2">
<li><p><a class="reference internal" href="#2-classical-smc-theory"><span class="xref myst">Classical SMC Theory</span></a></p></li>
<li><p><a class="reference internal" href="#3-super-twisting-smc-theory"><span class="xref myst">Super-Twisting SMC Theory</span></a></p></li>
<li><p><a class="reference internal" href="#4-adaptive-smc-theory"><span class="xref myst">Adaptive SMC Theory</span></a></p></li>
<li><p><a class="reference internal" href="#5-hybrid-adaptive-sta-smc-theory"><span class="xref myst">Hybrid Adaptive STA-SMC Theory</span></a></p></li>
<li><p><a class="reference internal" href="#6-convergence-analysis-comparison"><span class="xref myst">Convergence Analysis Comparison</span></a></p></li>
<li><p><a class="reference internal" href="#7-numerical-considerations"><span class="xref myst">Numerical Considerations</span></a></p></li>
<li><p><a class="reference internal" href="#8-references"><span class="xref myst">References</span></a></p></li>
</ol>
</section>
<hr class="docutils" />
<section id="introduction-and-fundamentals-1-1-overview-the-double-inverted-pendulum-dip-is-a-canonical-benchmark-for-nonlinear-underactuated-control-systems-with-two-pendula-attached-in-series-to-a-horizontally-moving-cart-the-system-has-fewer-actuators-than-degrees-of-freedom-making-it-both-underactuated-and-strongly-nonlinear-conventional-linear-controllers-struggle-with-large-deflections-parameter-variations-and-model-uncertainty-sliding-mode-control-smc-addresses-these-challenges-by-forcing-the-system-state-onto-a-pre-defined-sliding-manifold-when-the-state-reaches-this-manifold-the-resulting-closed-loop-dynamics-become-insensitive-to-matched-disturbances-and-uncertainties-the-control-law-compensates-modeling-errors-through-the-control-input-channel-causing-the-plant-to-behave-according-to-the-reduced-order-dynamics-on-the-manifold-this-robustness-and-finite-time-convergence-for-higher-order-smc-make-smc-attractive-for-underactuated-systems-however-the-discontinuous-switching-law-of-classical-smc-induces-chattering-a-high-frequency-oscillation-caused-by-rapid-control-switching-when-the-state-crosses-the-sliding-surface-chattering-increases-control-effort-excites-unmodeled-high-frequency-modes-and-can-cause-wear-in-actuators-introducing-a-boundary-layer-around-the-sliding-surface-alleviates-chattering-but-enlarges-the-tracking-error-this-document-presents-the-unified-mathematical-theory-for-four-smc-variants-implemented-in-this-project">
<h2>1. Introduction and Fundamentals ### 1.1 Overview The double-inverted pendulum (DIP) is a canonical benchmark for nonlinear, underactuated control systems. With two pendula attached in series to a horizontally moving cart, the system has fewer actuators than degrees of freedom, making it both <strong>underactuated</strong> and <strong>strongly nonlinear</strong>. Conventional linear controllers struggle with large deflections, parameter variations, and model uncertainty. Sliding Mode Control (SMC) addresses these challenges by forcing the system state onto a pre-defined <strong>sliding manifold</strong>. When the state reaches this manifold, the resulting closed-loop dynamics become insensitive to matched disturbances and uncertainties. The control law compensates modeling errors through the control input channel, causing the plant to behave according to the reduced-order dynamics on the manifold. This robustness and finite-time convergence (for higher-order SMC) make SMC attractive for underactuated systems. However, the discontinuous switching law of classical SMC induces <strong>chattering</strong>, a high-frequency oscillation caused by rapid control switching when the state crosses the sliding surface. Chattering increases control effort, excites unmodeled high-frequency modes, and can cause wear in actuators. Introducing a boundary layer around the sliding surface alleviates chattering but enlarges the tracking error. This document presents the unified mathematical theory for four SMC variants implemented in this project:<a class="headerlink" href="#introduction-and-fundamentals-1-1-overview-the-double-inverted-pendulum-dip-is-a-canonical-benchmark-for-nonlinear-underactuated-control-systems-with-two-pendula-attached-in-series-to-a-horizontally-moving-cart-the-system-has-fewer-actuators-than-degrees-of-freedom-making-it-both-underactuated-and-strongly-nonlinear-conventional-linear-controllers-struggle-with-large-deflections-parameter-variations-and-model-uncertainty-sliding-mode-control-smc-addresses-these-challenges-by-forcing-the-system-state-onto-a-pre-defined-sliding-manifold-when-the-state-reaches-this-manifold-the-resulting-closed-loop-dynamics-become-insensitive-to-matched-disturbances-and-uncertainties-the-control-law-compensates-modeling-errors-through-the-control-input-channel-causing-the-plant-to-behave-according-to-the-reduced-order-dynamics-on-the-manifold-this-robustness-and-finite-time-convergence-for-higher-order-smc-make-smc-attractive-for-underactuated-systems-however-the-discontinuous-switching-law-of-classical-smc-induces-chattering-a-high-frequency-oscillation-caused-by-rapid-control-switching-when-the-state-crosses-the-sliding-surface-chattering-increases-control-effort-excites-unmodeled-high-frequency-modes-and-can-cause-wear-in-actuators-introducing-a-boundary-layer-around-the-sliding-surface-alleviates-chattering-but-enlarges-the-tracking-error-this-document-presents-the-unified-mathematical-theory-for-four-smc-variants-implemented-in-this-project" title="Link to this heading">Â¶</a></h2>
<ol class="arabic simple">
<li><p><strong>Classical SMC</strong>: First-order sliding mode with boundary layer</p></li>
<li><p><strong>Super-Twisting SMC (STA)</strong>: Second-order sliding mode for continuous control</p></li>
<li><p><strong>Adaptive SMC</strong>: Online gain adaptation for unknown disturbances</p></li>
<li><p><strong>Hybrid Adaptive STA-SMC</strong>: Combined adaptive and super-twisting algorithms ### 1.2 State Space Formulation The dynamics of the double-inverted pendulum are described by the Euler-Lagrange equations: ```
M(q)qÌˆ + C(q,qÌ‡)qÌ‡ + G(q) = Bu</p></li>
</ol>
<div class="highlight-where: notranslate"><div class="highlight"><pre><span></span>- **q** = [x, Î¸â‚, Î¸â‚‚]áµ€ is the generalized coordinate vector (cart position, pendulum angles)
- **M(q)** âˆˆ â„Â³Ë£Â³ is the inertia matrix (configuration-dependent)
- **C(q,qÌ‡)qÌ‡** represents Coriolis and centrifugal forces
- **G(q)** is the gravitational force vector
- **B** = [1, 0, 0]áµ€ is the input distribution matrix
- **u** âˆˆ â„ is the control force applied to the cart **State vector**: x = [x, Î¸â‚, Î¸â‚‚, áº‹, Î¸Ì‡â‚, Î¸Ì‡â‚‚]áµ€ âˆˆ â„â¶ **Key Properties**:
- **Underactuated**: rank(B) = 1 &lt; 3 (fewer actuators than degrees of freedom)
- **Matched disturbances**: Disturbances d entering through the same channel as control input
- **Controllability**: The system is locally controllable around the upright equilibrium ### 1.3 Sliding Mode Fundamentals **Sliding Surface**: A hypersurface Ïƒ(x) = 0 in the state space, designed such that the system exhibits desired behavior when constrained to this surface. **Reachability Condition**: The fundamental condition ensuring the system state reaches the sliding surface: ```
ÏƒÏƒÌ‡ &lt; 0 whenever Ïƒ â‰  0
``` This condition guarantees that Ïƒ acts as a Lyapunov function, driving the system toward the surface. **Invariance Property**: Once on the sliding surface (Ïƒ = 0), the system remains on it under ideal conditions (no disturbances, perfect control implementation). **Equivalent Control Method**: The equivalent control u_eq is the control required to maintain ÏƒÌ‡ = 0, derived by setting: ```

ÏƒÌ‡ = (âˆ‚Ïƒ/âˆ‚x)áº‹ = (âˆ‚Ïƒ/âˆ‚x)f(x, u_eq) = 0
``` Solving for u_eq gives the **ideal** control that keeps the system on the sliding surface, assuming perfect knowledge of the dynamics. ### 1.4 Matched vs Unmatched Disturbances **Matched Disturbances**: Disturbances that enter through the same channel as the control input: ```
M(q)qÌˆ + C(q,qÌ‡)qÌ‡ + G(q) = B(u + d)
``` SMC can **completely reject** matched disturbances by choosing switching gain K &gt; ||d||âˆ. **Unmatched Disturbances**: Disturbances entering through different channels. Classical SMC provides limited robustness against unmatched disturbances. Advanced techniques (integral SMC, higher-order SMC) can handle certain classes of unmatched disturbances.

---

## 2. Classical SMC Theory ### 2.1 Sliding Surface Design The sliding surface for the DIP system is defined as: ```

Ïƒ = Î»â‚Î¸â‚ + Î»â‚‚Î¸â‚‚ + kâ‚Î¸Ì‡â‚ + kâ‚‚Î¸Ì‡â‚‚
``` where:
- **Î¸â‚, Î¸â‚‚**: pendulum angles
- **Î¸Ì‡â‚, Î¸Ì‡â‚‚**: pendulum angular velocities
- **Î»â‚, Î»â‚‚ &gt; 0**: sliding surface slope parameters (must be strictly positive)
- **kâ‚, kâ‚‚ &gt; 0**: velocity feedback gains (must be strictly positive) **Mathematical Properties**: 1. **Hurwitz Stability Requirement**: The characteristic polynomial of the sliding dynamics must have all roots in the left half-plane: ``` sÂ² + kâ‚s + Î»â‚ = 0 (for pendulum 1) sÂ² + kâ‚‚s + Î»â‚‚ = 0 (for pendulum 2) ``` 2. **Positivity Constraints**: For asymptotic stability: ``` Î»â‚, Î»â‚‚ &gt; 0 (slope parameters ensure stable surface) kâ‚, kâ‚‚ &gt; 0 (damping parameters) ``` 3. **Pole Placement Interpretation**: The sliding surface parameters define the poles of the reduced-order dynamics: - **Critically damped**: kÂ²áµ¢ = 4Î»áµ¢ â†’ poles at s = -káµ¢/2 (repeated real poles) - **Underdamped**: kÂ²áµ¢ &lt; 4Î»áµ¢ â†’ complex conjugate poles (faster, oscillatory) - **Overdamped**: kÂ²áµ¢ &gt; 4Î»áµ¢ â†’ distinct real poles (slower, smooth) **Design Guidelines**:
- Start with critically damped case: káµ¢ = 2âˆšÎ»áµ¢
- Increase káµ¢ for more damping (slower convergence, smoother response)
- Decrease káµ¢ for less damping (faster convergence, more oscillation) ### 2.2 Control Law Decomposition The control input u is decomposed into **equivalent control** and **robust switching**: ```
u = u_eq - KÂ·sat(Ïƒ/Îµ) - k_dÂ·Ïƒ
``` **Components**: 1. **Equivalent Control (u_eq)**: Cancels the nominal dynamics. Derived from ÏƒÌ‡ = 0: ``` ÏƒÌ‡ = L(Mâ»Â¹(Bu + d) - Mâ»Â¹(C(q,qÌ‡)qÌ‡ + G(q))) = 0 ``` where L = [Î»â‚, Î»â‚‚, kâ‚, kâ‚‚, 0, 0] is the sliding surface gradient. Solving for u: ``` u_eq = (LMâ»Â¹B)â»Â¹ Â· L(Mâ»Â¹(C(q,qÌ‡)qÌ‡ + G(q)) - [kâ‚Î»â‚Î¸Ì‡â‚ + kâ‚‚Î»â‚‚Î¸Ì‡â‚‚]) ``` 2. **Switching Term (-KÂ·sat(Ïƒ/Îµ))**: Provides robustness against disturbances. The gain K must satisfy: ``` K &gt; ||d||âˆ ``` 3. **Damping Term (-k_dÂ·Ïƒ)**: Improves transient response, reduces overshoot. ### 2.3 Boundary Layer Theory The discontinuous sign function is approximated within a boundary layer of width Îµ &gt; 0 to reduce chattering: **Linear Saturation**:

</pre></div>
</div>
<p>sat(Ïƒ/Îµ) = { Ïƒ/Îµ, if |Ïƒ| â‰¤ Îµ sign(Ïƒ), if |Ïƒ| &gt; Îµ
}</p>
<div class="highlight-**Hyperbolic notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<p>sat(Ïƒ/Îµ) = tanh(Ïƒ/Îµ)</p>
<div class="highlight-**Properties**: notranslate"><div class="highlight"><pre><span></span>
- **Continuity**: Linear saturation is continuous at Ïƒ = Â±Îµ
- **Smoothness**: tanh is Câˆ everywhere
- **Approximation Error**: Bounded by Îµ **Trade-offs**:
- **Smaller Îµ** â†’ Better tracking, more chattering
- **Larger Îµ** â†’ Smoother control, larger steady-state error
- **Adaptive boundary layer**: Îµ = Îµâ‚€ + Îµâ‚||Ïƒ|| adjusts based on sliding surface magnitude ### 2.4 Lyapunov Stability Analysis **Lyapunov Function**:
</pre></div>
</div>
<p>V = Â½ÏƒÂ²
<code class="docutils literal notranslate"><span class="pre">**Proof</span> <span class="pre">of</span> <span class="pre">Stability**:</span> <span class="pre">1.</span> <span class="pre">**Positive</span> <span class="pre">Definiteness**:</span> <span class="pre">V</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">for</span> <span class="pre">Ïƒ</span> <span class="pre">â‰ </span> <span class="pre">0,</span> <span class="pre">V(0)</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">âœ“</span> <span class="pre">2.</span> <span class="pre">**Time</span> <span class="pre">Derivative**:</span></code> VÌ‡ = ÏƒÏƒÌ‡ = Ïƒ[Î»â‚Î¸Ì‡â‚ + Î»â‚‚Î¸Ì‡â‚‚ + kâ‚Î¸Ìˆâ‚ + kâ‚‚Î¸Ìˆâ‚‚] <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Substitute</span> <span class="pre">Dynamics**:</span> <span class="pre">M(q)qÌˆ</span> <span class="pre">=</span> <span class="pre">Bu</span> <span class="pre">-</span> <span class="pre">C(q,qÌ‡)qÌ‡</span> <span class="pre">-</span> <span class="pre">G(q)</span> <span class="pre">+</span> <span class="pre">d</span> <span class="pre">Solving</span> <span class="pre">for</span> <span class="pre">qÌˆ</span> <span class="pre">and</span> <span class="pre">substituting:</span></code> VÌ‡ = Ïƒ Â· L Â· Mâ»Â¹ Â· (B(u_eq - KÂ·sign(Ïƒ) - k_dÂ·Ïƒ + d) - C(q,qÌ‡)qÌ‡ - G(q)) <code class="docutils literal notranslate"><span class="pre">4.</span> <span class="pre">**Simplification</span> <span class="pre">using</span> <span class="pre">ÏƒÌ‡</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">for</span> <span class="pre">u_eq**:</span> <span class="pre">The</span> <span class="pre">equivalent</span> <span class="pre">control</span> <span class="pre">u_eq</span> <span class="pre">is</span> <span class="pre">designed</span> <span class="pre">such</span> <span class="pre">that</span> <span class="pre">ÏƒÌ‡</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">when</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">0.</span> <span class="pre">Therefore:</span></code> VÌ‡ = Ïƒ Â· L Â· Mâ»Â¹ Â· B Â· (-KÂ·sign(Ïƒ) + d - k_dÂ·Ïƒ) <code class="docutils literal notranslate"><span class="pre">Let</span> <span class="pre">Î·_c</span> <span class="pre">=</span> <span class="pre">LÂ·Mâ»Â¹Â·B</span> <span class="pre">(controllability</span> <span class="pre">measure).</span> <span class="pre">Then:</span></code> VÌ‡ = Î·_c Â· Ïƒ Â· (-KÂ·sign(Ïƒ) + d - k_dÂ·Ïƒ) = Î·_c Â· (-K|Ïƒ| + Ïƒd - k_dÂ·ÏƒÂ²) â‰¤ Î·_c Â· (-K|Ïƒ| + |d|Â·|Ïƒ| - k_dÂ·ÏƒÂ²) = Î·_c Â· (-(K - ||d||âˆ)|Ïƒ| - k_dÂ·ÏƒÂ²) <code class="docutils literal notranslate"><span class="pre">5.</span> <span class="pre">**Negative</span> <span class="pre">Definiteness**:</span> <span class="pre">If</span> <span class="pre">K</span> <span class="pre">&gt;</span> <span class="pre">||d||âˆ,</span> <span class="pre">then:</span></code> VÌ‡ â‰¤ -Î·_cÂ·Î·|Ïƒ| where Î· = K - ||d||âˆ &gt; 0 <code class="docutils literal notranslate"><span class="pre">Since</span> <span class="pre">Î·_c</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">(controllability</span> <span class="pre">condition)</span> <span class="pre">and</span> <span class="pre">Î·</span> <span class="pre">&gt;</span> <span class="pre">0,</span> <span class="pre">we</span> <span class="pre">have</span> <span class="pre">VÌ‡</span> <span class="pre">&lt;</span> <span class="pre">0</span> <span class="pre">for</span> <span class="pre">all</span> <span class="pre">Ïƒ</span> <span class="pre">â‰ </span> <span class="pre">0.</span> <span class="pre">6.</span> <span class="pre">**Conclusion**:</span> <span class="pre">By</span> <span class="pre">Lyapunov's</span> <span class="pre">theorem,</span> <span class="pre">Ïƒ</span> <span class="pre">â†’</span> <span class="pre">0</span> <span class="pre">asymptotically.</span> <span class="pre">###</span> <span class="pre">2.5</span> <span class="pre">Convergence</span> <span class="pre">Rate</span> <span class="pre">Analysis</span> <span class="pre">**Exponential</span> <span class="pre">Convergence**:</span> <span class="pre">From</span> <span class="pre">VÌ‡</span> <span class="pre">â‰¤</span> <span class="pre">-Î·_cÂ·Î·|Ïƒ|,</span> <span class="pre">we</span> <span class="pre">can</span> <span class="pre">derive:</span></code></p>
<p>|Ïƒ(t)| â‰¤ |Ïƒ(0)|e^(-Î·t)
<code class="docutils literal notranslate"><span class="pre">**Time</span> <span class="pre">Constants**:</span> <span class="pre">On</span> <span class="pre">the</span> <span class="pre">sliding</span> <span class="pre">surface</span> <span class="pre">(Ïƒ</span> <span class="pre">=</span> <span class="pre">0),</span> <span class="pre">the</span> <span class="pre">reduced-order</span> <span class="pre">dynamics</span> <span class="pre">are:</span></code>
Î»â‚Î¸â‚ + Î»â‚‚Î¸â‚‚ + kâ‚Î¸Ì‡â‚ + kâ‚‚Î¸Ì‡â‚‚ = 0
<code class="docutils literal notranslate"><span class="pre">For</span> <span class="pre">the</span> <span class="pre">critically</span> <span class="pre">damped</span> <span class="pre">case</span> <span class="pre">(kÂ²áµ¢</span> <span class="pre">=</span> <span class="pre">4Î»áµ¢):</span></code></p>
<p>Ï„áµ¢ = 2/káµ¢ (time constant for pendulum i)</p>
<div class="highlight-**Practical notranslate"><div class="highlight"><pre><span></span>- Classical SMC achieves **exponential convergence** (not finite-time)
- Convergence rate determined by gains kâ‚, kâ‚‚
- Larger káµ¢ â†’ Faster convergence but potentially more oscillation

---

## 3. Super-Twisting SMC Theory ### 3.1 Second-Order Sliding Mode Concept The **super-twisting algorithm** (STA) is a second-order sliding mode technique that suppresses chattering by applying the discontinuity on the **derivative** of the control signal rather than on the control itself. **Key Innovation**: Move discontinuity to uÌ‡ instead of u:
- **Classical SMC**: u contains sign(Ïƒ) â†’ discontinuous control
- **STA SMC**: uÌ‡ contains sign(Ïƒ) â†’ continuous control, discontinuous derivative **Result**:
- u is continuous
- Both Ïƒ and ÏƒÌ‡ converge to zero in **finite time** **Sliding Variable** (for STA):
</pre></div>
</div>
<p>Ïƒ = kâ‚(Î¸Ì‡â‚ + Î»â‚Î¸â‚) + kâ‚‚(Î¸Ì‡â‚‚ + Î»â‚‚Î¸â‚‚)
<code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">3.2</span> <span class="pre">Super-Twisting</span> <span class="pre">Algorithm</span> <span class="pre">The</span> <span class="pre">STA</span> <span class="pre">control</span> <span class="pre">law</span> <span class="pre">consists</span> <span class="pre">of</span> <span class="pre">two</span> <span class="pre">components:</span></code>
u = u_c + u_i + u_eq</p>
<div class="highlight-**1. notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<p>u_c = -Kâ‚âˆš|Ïƒ|Â·sign(Ïƒ)</p>
<div class="highlight-- notranslate"><div class="highlight"><pre><span></span>
- Continuous but non-smooth at Ïƒ = 0
- Acts as nonlinear damping proportional to âˆš|Ïƒ| **2. Integral Term**:
</pre></div>
</div>
<p>uÌ‡_i = -Kâ‚‚Â·sign(Ïƒ)</p>
<div class="highlight-- notranslate"><div class="highlight"><pre><span></span>
- Integrated to produce continuous u_i **Discrete Implementation**:
</pre></div>
</div>
<p>u_i(t+dt) = u_i(t) - Kâ‚‚Â·sign(Ïƒ)Â·dt
<code class="docutils literal notranslate"><span class="pre">**3.</span> <span class="pre">Equivalent</span> <span class="pre">Control**:</span> <span class="pre">Model-based</span> <span class="pre">feedforward</span> <span class="pre">(same</span> <span class="pre">as</span> <span class="pre">classical</span> <span class="pre">SMC)</span> <span class="pre">###</span> <span class="pre">3.3</span> <span class="pre">Lyapunov</span> <span class="pre">Function</span> <span class="pre">for</span> <span class="pre">STA</span> <span class="pre">**Candidate</span> <span class="pre">Lyapunov</span> <span class="pre">Function**</span> <span class="pre">(Moreno</span> <span class="pre">&amp;</span> <span class="pre">Osorio,</span> <span class="pre">2012):</span></code></p>
<p>V = kâ‚|Ïƒ|^(3/2) + Â½zÂ²
<code class="docutils literal notranslate"><span class="pre">where</span> <span class="pre">z</span> <span class="pre">is</span> <span class="pre">an</span> <span class="pre">auxiliary</span> <span class="pre">variable</span> <span class="pre">related</span> <span class="pre">to</span> <span class="pre">ÏƒÌ‡.</span> <span class="pre">**Finite-Time</span> <span class="pre">Convergence</span> <span class="pre">Proof</span> <span class="pre">(Sketch)**:</span> <span class="pre">1.</span> <span class="pre">**Positive</span> <span class="pre">Definiteness**:</span> <span class="pre">V</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">for</span> <span class="pre">(Ïƒ,</span> <span class="pre">z)</span> <span class="pre">â‰ </span> <span class="pre">(0,</span> <span class="pre">0)</span> <span class="pre">âœ“</span> <span class="pre">2.</span> <span class="pre">**Time</span> <span class="pre">Derivative**</span> <span class="pre">(using</span> <span class="pre">homogeneity</span> <span class="pre">argument):</span></code> VÌ‡ = (3kâ‚/2)|Ïƒ|^(1/2)Â·ÏƒÌ‡Â·sign(Ïƒ) + zÂ·Å¼ <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Substitute</span> <span class="pre">STA</span> <span class="pre">Dynamics**:</span> <span class="pre">-</span> <span class="pre">ÏƒÌ‡</span> <span class="pre">is</span> <span class="pre">related</span> <span class="pre">to</span> <span class="pre">z</span> <span class="pre">through</span> <span class="pre">system</span> <span class="pre">dynamics</span> <span class="pre">-</span> <span class="pre">Å¼</span> <span class="pre">=</span> <span class="pre">-Kâ‚‚Â·sign(Ïƒ)</span> <span class="pre">from</span> <span class="pre">control</span> <span class="pre">law</span> <span class="pre">4.</span> <span class="pre">**Gain</span> <span class="pre">Conditions**:</span> <span class="pre">-</span> <span class="pre">Kâ‚</span> <span class="pre">&gt;</span> <span class="pre">L</span> <span class="pre">(L</span> <span class="pre">=</span> <span class="pre">Lipschitz</span> <span class="pre">constant</span> <span class="pre">of</span> <span class="pre">disturbance</span> <span class="pre">derivative)</span> <span class="pre">-</span> <span class="pre">Kâ‚‚</span> <span class="pre">&gt;</span> <span class="pre">Kâ‚Â·C</span> <span class="pre">(C</span> <span class="pre">depends</span> <span class="pre">on</span> <span class="pre">system</span> <span class="pre">parameters)</span> <span class="pre">5.</span> <span class="pre">**Result**:</span> <span class="pre">Under</span> <span class="pre">these</span> <span class="pre">conditions:</span></code> VÌ‡ â‰¤ -Î²Â·V^(1/2) for some Î² &gt; 0 <code class="docutils literal notranslate"><span class="pre">6.</span> <span class="pre">**Finite-Time</span> <span class="pre">Convergence**:</span> <span class="pre">Integrating</span> <span class="pre">VÌ‡</span> <span class="pre">â‰¤</span> <span class="pre">-Î²Â·V^(1/2)</span> <span class="pre">gives:</span></code> V(t) = 0 for all t â‰¥ T_reach <code class="docutils literal notranslate"><span class="pre">where:</span></code> T_reach â‰¤ 2V(0)^(1/2)/Î² â‰¤ 2|Ïƒ(0)|^(1/2)/(Kâ‚^(1/2)) ``` <strong>Key Takeaway</strong>: Both Ïƒ and ÏƒÌ‡ reach zero in finite time, unlike classical SMC which only achieves exponential convergence. ### 3.4 Gain Selection Guidelines <strong>Kâ‚ Selection</strong>:</p>
<ul class="simple">
<li><p>Must exceed max disturbance derivative: Kâ‚ &gt; L</p></li>
<li><p>Larger Kâ‚ â†’ Faster convergence, higher control effort</p></li>
<li><p>Typical range: Kâ‚ âˆˆ [1, 50] <strong>Kâ‚‚ Selection</strong>:</p></li>
<li><p>Sufficient condition: Kâ‚‚ â‰¥ Kâ‚Â·C (C depends on system)</p></li>
<li><p>Practical guideline: Kâ‚‚ â‰ˆ Kâ‚ balances proportional/integral action</p></li>
<li><p>Too large Kâ‚‚ â†’ Oscillations, potential instability <strong>Tuning Strategy</strong>:</p></li>
</ul>
<ol class="arabic simple">
<li><p>Start with Kâ‚ = 5, Kâ‚‚ = 5</p></li>
<li><p>Increase Kâ‚ if convergence is too slow</p></li>
<li><p>Adjust Kâ‚‚ to balance integral action (typically Kâ‚‚ â‰ˆ Kâ‚)</p></li>
<li><p>Use PSO optimization for fine-tuning <strong>Advantages</strong>:</p></li>
</ol>
<ul class="simple">
<li><p>Finite-time convergence</p></li>
<li><p>Continuous control (reduced chattering)</p></li>
<li><p>Robustness against matched uncertainties <strong>Disadvantages</strong>:</p></li>
<li><p>More complex tuning (2 gains vs 1 for classical)</p></li>
<li><p>Higher computational cost (square root, integration)</p></li>
</ul>
</section>
<hr class="docutils" />
<section id="adaptive-smc-theory-4-1-motivation-and-problem-statement-challenge-classical-smc-requires-prior-knowledge-of-disturbance-bounds-k-d-in-practice">
<h2>4. Adaptive SMC Theory ### 4.1 Motivation and Problem Statement <strong>Challenge</strong>: Classical SMC requires prior knowledge of disturbance bounds (K &gt; ||d||âˆ). In practice:<a class="headerlink" href="#adaptive-smc-theory-4-1-motivation-and-problem-statement-challenge-classical-smc-requires-prior-knowledge-of-disturbance-bounds-k-d-in-practice" title="Link to this heading">Â¶</a></h2>
<ul class="simple">
<li><p>Disturbance bounds may be unknown</p></li>
<li><p>Conservative estimates lead to excessive control effort</p></li>
<li><p>Time-varying disturbances require adaptive response <strong>Solution</strong>: Adaptive SMC adjusts the switching gain K(t) online based on observed sliding surface magnitude. <strong>Advantages</strong>:</p></li>
<li><p>No need for disturbance bound knowledge a priori</p></li>
<li><p>Avoids overly conservative gains</p></li>
<li><p>Maintains robustness to unknown disturbances ### 4.2 Adaptation Law <strong>Piecewise Adaptation with Dead Zone</strong>: ```
KÌ‡(t) = { Î³|Ïƒ|, if |Ïƒ| &gt; Î´ (outside dead zone - adaptation active) -Î±K, if |Ïƒ| â‰¤ Î´ (inside dead zone - leak prevents windup)
}</p></li>
</ul>
<div class="highlight-**Parameters**: notranslate"><div class="highlight"><pre><span></span>
- **Î³ &gt; 0**: Adaptation rate (how fast K grows)
- **Î´ &gt; 0**: Dead zone width (noise tolerance threshold)
- **Î± â‰¥ 0**: Leak rate (prevents unbounded growth) **Bounded Adaptation**:
</pre></div>
</div>
<p>K_min â‰¤ K(t) â‰¤ K_max</p>
<div class="highlight-**Rate notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<p>|KÌ‡| â‰¤ Î“_max</p>
<div class="highlight-**Rationale**: notranslate"><div class="highlight"><pre><span></span>
- **Outside dead zone** (|Ïƒ| &gt; Î´): System is far from sliding surface â†’ increase gain to dominate disturbances
- **Inside dead zone** (|Ïƒ| â‰¤ Î´): Near sliding surface â†’ hold or decay gain to prevent noise-induced windup
- **Leak term** (-Î±K): Prevents indefinite growth, allows gain to decrease when disturbances subside
- **Bounds**: Safety constraints prevent numerical issues and actuator saturation ### 4.3 Lyapunov Stability with Adaptation **Extended Lyapunov Function**: ```
V = Â½ÏƒÂ² + 1/(2Î³)(K - K*)Â²
``` where K* is the ideal (unknown) switching gain that would perfectly dominate disturbances. **Proof of Bounded Adaptation and Convergence**: 1. **Positive Definiteness**: V â‰¥ 0 for all (Ïƒ, K) âœ“ 2. **Time Derivative**: ``` VÌ‡ = ÏƒÏƒÌ‡ + 1/Î³Â·(K - K*)Â·KÌ‡ ``` 3. **Substitute Control Law**: u = u_eq - KÂ·sat(Ïƒ/Îµ) ``` ÏƒÏƒÌ‡ = Ïƒ(LÂ·Mâ»Â¹Â·BÂ·(-KÂ·sat(Ïƒ/Îµ) + d)) ``` Assuming |Ïƒ| &gt; Îµ (outside boundary layer): ``` ÏƒÏƒÌ‡ = Ïƒ(-KÂ·sign(Ïƒ) + d) = -K|Ïƒ| + Ïƒd ``` 4. **Substitute Adaptation Law**: KÌ‡ = Î³|Ïƒ| when |Ïƒ| &gt; Î´ ``` VÌ‡ = (-K|Ïƒ| + Ïƒd) + (K - K*)|Ïƒ| = -K|Ïƒ| + Ïƒd + K|Ïƒ| - K*|Ïƒ| = Ïƒd - K*|Ïƒ| ``` 5. **Bound Using Disturbance Magnitude**: ``` VÌ‡ â‰¤ ||d||âˆ|Ïƒ| - K*|Ïƒ| = (||d||âˆ - K*)|Ïƒ| ``` 6. **Negative Definiteness**: Since K* &gt; ||d||âˆ by definition: ``` VÌ‡ â‰¤ -Î·|Ïƒ| where Î· = K* - ||d||âˆ &gt; 0 ``` 7. **Conclusion**: - VÌ‡ &lt; 0 whenever |Ïƒ| &gt; Î´ â†’ Ïƒ converges to dead zone - (K - K*)Â² remains bounded â†’ K remains bounded - Inside dead zone: leak term prevents unbounded growth **Key Result**: Both Ïƒ â†’ 0 and K remains bounded, ensuring stable adaptation without prior knowledge of ||d||âˆ. ### 4.4 Dead Zone Trade-offs **Benefits**:
- Prevents chattering from sensor noise
- Avoids gain windup in steady state
- Reduces control effort when near equilibrium
- Allows adaptation to focus on significant errors **Drawbacks**:
- Introduces small steady-state error (|Ïƒ| â‰¤ Î´)
- Slows convergence near sliding surface
- Requires tuning of Î´ **Optimal Sizing**: Î´ â‰ˆ 2-3Ã— sensor noise magnitude **Leak Rate Selection**:
- **Small Î±** (Î± â‰ˆ 10â»Â³): Slow decay, maintains gain for persistent disturbances
- **Large Î±** (Î± â‰ˆ 10â»Â¹): Fast decay, quickly forgets past disturbances **Practical Guidelines**:
- Start with Î´ = 0.01, Î± = 0.001
- Increase Î´ if chattering persists despite adaptation
- Increase Î± if gain grows excessively during transients

---

## 5. Hybrid Adaptive STA-SMC Theory ### 5.1 Unified Sliding Surface The hybrid controller combines the adaptive law with the super-twisting algorithm using a **single sliding surface** that captures both pendulum dynamics and cart recentering. **Absolute Formulation** (default): ```
Ïƒ = câ‚(Î¸Ì‡â‚ + Î»â‚Î¸â‚) + câ‚‚(Î¸Ì‡â‚‚ + Î»â‚‚Î¸â‚‚) + k_c(áº‹ + Î»_c x)
``` **Relative Formulation** (optional, `use_relative_surface=True`): ```

Ïƒ = câ‚(Î¸Ì‡â‚ + Î»â‚Î¸â‚) + câ‚‚((Î¸Ì‡â‚‚-Î¸Ì‡â‚) + Î»â‚‚(Î¸â‚‚-Î¸â‚)) + k_c(áº‹ + Î»_c x)
``` **Design Principles**:
- **Positive Coefficients**: cáµ¢, Î»áµ¢, k_c, Î»_c &gt; 0 (Hurwitz stability requirement)
- **Cart Recentering**: k_c, Î»_c terms encourage cart to return to center
- **Relative Formulation**: Improves decoupling between pendulums but complicates analysis **Stability Condition**: All coefficients must be positive to ensure the sliding manifold is attractive and defines a stable reduced-order error surface. ### 5.2 Combined Super-Twisting with Adaptive Gains **Control Law**: ```
u = -kâ‚(t)âˆš|Ïƒ|Â·sat(Ïƒ) + u_int - k_dÂ·Ïƒ + u_eq
``` where:

- **kâ‚(t), kâ‚‚(t)**: Adaptive gains (time-varying)
- **u_int**: Integral term satisfying uÌ‡_int = -kâ‚‚(t)Â·sat(Ïƒ)
- **k_d**: Damping gain (fixed)
- **u_eq**: Equivalent control (model-based feedforward) **Adaptive Law for Both Gains**: ```
kÌ‡áµ¢(t) = { Î³áµ¢|Ïƒ|Â·Ï„(Ïƒ), if |Ïƒ| &gt; Î´ -leak, otherwise
}
``` **Self-Tapering Function**: ```
Ï„(Ïƒ) = |Ïƒ|/(|Ïƒ| + Îµ_taper)
``` **Properties**:

- Ï„(Ïƒ) â†’ 1 as |Ïƒ| â†’ âˆ (full adaptation when far from surface)
- Ï„(Ïƒ) â†’ 0 as |Ïƒ| â†’ 0 (adaptation slows near surface)
- Prevents overshoot and oscillation as Ïƒ â†’ 0 **Bounded Adaptation**:
</pre></div>
</div>
<p>0 â‰¤ kâ‚(t) â‰¤ kâ‚_max
0 â‰¤ kâ‚‚(t) â‰¤ kâ‚‚_max
|u_int| â‰¤ u_int_max
<code class="docutils literal notranslate"><span class="pre">Separating</span> <span class="pre">integral</span> <span class="pre">windup</span> <span class="pre">limit</span> <span class="pre">from</span> <span class="pre">actuator</span> <span class="pre">saturation</span> <span class="pre">ensures</span> <span class="pre">adaptation</span> <span class="pre">can</span> <span class="pre">proceed</span> <span class="pre">even</span> <span class="pre">when</span> <span class="pre">actuator</span> <span class="pre">saturates.</span> <span class="pre">###</span> <span class="pre">5.3</span> <span class="pre">Lyapunov</span> <span class="pre">Analysis</span> <span class="pre">**Composite</span> <span class="pre">Lyapunov</span> <span class="pre">Function**:</span></code></p>
<p>V = kâ‚|Ïƒ|^(3/2) + Â½zÂ² + 1/(2Î³â‚)(kâ‚ - kâ‚*)Â² + 1/(2Î³â‚‚)(kâ‚‚ - kâ‚‚*)Â²
<code class="docutils literal notranslate"><span class="pre">**Proof</span> <span class="pre">Sketch**:</span> <span class="pre">1.</span> <span class="pre">**Combines</span> <span class="pre">STA</span> <span class="pre">and</span> <span class="pre">Adaptive</span> <span class="pre">Terms**:</span> <span class="pre">-</span> <span class="pre">First</span> <span class="pre">two</span> <span class="pre">terms:</span> <span class="pre">STA</span> <span class="pre">Lyapunov</span> <span class="pre">function</span> <span class="pre">(finite-time</span> <span class="pre">convergence)</span> <span class="pre">-</span> <span class="pre">Last</span> <span class="pre">two</span> <span class="pre">terms:</span> <span class="pre">Adaptive</span> <span class="pre">parameter</span> <span class="pre">error</span> <span class="pre">(bounded</span> <span class="pre">adaptation)</span> <span class="pre">2.</span> <span class="pre">**Time</span> <span class="pre">Derivative</span> <span class="pre">Analysis**:</span></code> VÌ‡ = (âˆ‚V/âˆ‚Ïƒ)ÏƒÌ‡ + (âˆ‚V/âˆ‚z)Å¼ + (âˆ‚V/âˆ‚kâ‚)kÌ‡â‚ + (âˆ‚V/âˆ‚kâ‚‚)kÌ‡â‚‚ <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Substitute</span> <span class="pre">Dynamics**:</span> <span class="pre">-</span> <span class="pre">ÏƒÌ‡</span> <span class="pre">from</span> <span class="pre">STA</span> <span class="pre">control</span> <span class="pre">law</span> <span class="pre">with</span> <span class="pre">adaptive</span> <span class="pre">gains</span> <span class="pre">-</span> <span class="pre">Å¼</span> <span class="pre">=</span> <span class="pre">-kâ‚‚(t)Â·sign(Ïƒ)</span> <span class="pre">-</span> <span class="pre">kÌ‡â‚,</span> <span class="pre">kÌ‡â‚‚</span> <span class="pre">from</span> <span class="pre">adaptation</span> <span class="pre">law</span> <span class="pre">with</span> <span class="pre">self-tapering</span> <span class="pre">4.</span> <span class="pre">**Negative</span> <span class="pre">Definiteness**:</span> <span class="pre">Under</span> <span class="pre">appropriate</span> <span class="pre">gain</span> <span class="pre">conditions</span> <span class="pre">(kâ‚</span> <span class="pre">&gt;</span> <span class="pre">L,</span> <span class="pre">kâ‚‚</span> <span class="pre">&gt;</span> <span class="pre">kâ‚Â·C):</span></code> VÌ‡ â‰¤ -Î²Â·V^(1/2) for some Î² &gt; 0 ``` 5. <strong>Key Results</strong>: - <strong>Finite-time convergence</strong>: Ïƒ â†’ 0 in finite time T â‰¤ 2V(0)^(1/2)/Î² - <strong>Bounded gains</strong>: kâ‚(t), kâ‚‚(t) remain in [0, k_max] - <strong>Unknown disturbances</strong>: No prior knowledge of ||d||âˆ required ### 5.4 Advantages and Complexity <strong>Advantages</strong>:</p>
<ul class="simple">
<li><p><strong>Finite-time convergence</strong> (from STA)</p></li>
<li><p><strong>Continuous control</strong> (low chattering from STA)</p></li>
<li><p><strong>Adaptive to unknown disturbances</strong> (from adaptation)</p></li>
<li><p><strong>Single sliding surface</strong> (simpler than dual-surface designs)</p></li>
<li><p><strong>Cart recentering</strong> (unified treatment of cart and pendulum dynamics) <strong>Complexity</strong>:</p></li>
<li><p><strong>More parameters to tune</strong>: câ‚, Î»â‚, câ‚‚, Î»â‚‚, k_c, Î»_c, Î³â‚, Î³â‚‚, Î´, Îµ_taper, k_d, â€¦</p></li>
<li><p><strong>Higher computational cost</strong>: Square root, integral update, adaptation law</p></li>
<li><p><strong>Careful tuning required</strong>: PSO optimization recommended <strong>Recommended Use Cases</strong>:</p></li>
<li><p>Complex, highly coupled systems (âœ“ double-inverted pendulum)</p></li>
<li><p>High uncertainty environments</p></li>
<li><p>Research applications requiring maximum performance</p></li>
<li><p>Systems needing finite-time convergence with minimal chattering</p></li>
</ul>
</section>
<hr class="docutils" />
<section id="convergence-analysis-comparison-6-1-convergence-rate-summary-controller-convergence-type-rate-time-to-surface-steady-state-error">
<h2>6. Convergence Analysis Comparison ### 6.1 Convergence Rate Summary | Controller | Convergence Type | Rate | Time to Surface | Steady-State Error |<a class="headerlink" href="#convergence-analysis-comparison-6-1-convergence-rate-summary-controller-convergence-type-rate-time-to-surface-steady-state-error" title="Link to this heading">Â¶</a></h2>
<p>|â€”â€”â€”â€“|â€”â€”â€”â€”â€”â€”|â€”â€”|â€”â€”â€”â€”â€”â€“|â€”â€”â€”â€”â€”â€”-|
| <strong>Classical SMC</strong> | Asymptotic | Exponential: O(e^(-Î·t)) | Infinite (theoretically) | Bounded by Îµ (boundary layer) |
| <strong>Adaptive SMC</strong> | Asymptotic | Exponential: O(e^(-Î·t)) | Infinite (theoretically) | Zero (if no dead zone) or bounded by Î´ |
| <strong>STA SMC</strong> | Finite-time | O(t^(1/2)) | T â‰¤ 2|Ïƒâ‚€|^(1/2)/Kâ‚^(1/2) | Zero (exact convergence) |
| <strong>Hybrid SMC</strong> | Finite-time | O(t^(1/2)) | T â‰¤ 2|Ïƒâ‚€|^(1/2)/kâ‚(0)^(1/2) | Zero (exact convergence) | ### 6.2 Mathematical Definitions <strong>Exponential Convergence</strong>: ```
|Ïƒ(t)| â‰¤ Ce^(-Î·t)|Ïƒ(0)|</p>
<div class="highlight-- notranslate"><div class="highlight"><pre><span></span>
- **Practical convergence**: Reaches Îµ-neighborhood quickly
- **Advantage**: Simple analysis, well-understood
- **Disadvantage**: Technically never achieves perfect tracking **Finite-Time Convergence**: ```
âˆƒ T &lt; âˆ : Ïƒ(t) = 0 for all t â‰¥ T
``` - **Exact convergence** in finite time T
- **Requires higher-order sliding modes** (e.g., STA)
- **Advantage**: Exact tracking after convergence time
- **Disadvantage**: More complex control law, higher computational cost ### 6.3 Convergence Time Bounds **Classical SMC** (95% settling time): ```
t_95% â‰ˆ 3/Î· where Î· = K - ||d||âˆ
``` **STA SMC**: ```

T_reach â‰¤ 2|Ïƒ(0)|^(1/2)/(Kâ‚^(1/2))
``` For typical initial condition |Ïƒ(0)| = 1.0 and Kâ‚ = 25:
</pre></div>
</div>
<p>T_reach â‰¤ 2Â·1.0^(1/2)/25^(1/2) = 2/5 = 0.4 seconds</p>
<div class="highlight-**Practical notranslate"><div class="highlight"><pre><span></span>- **STA converges faster** for large initial errors
- **Classical SMC** can be competitive with well-tuned gains
- **Adaptive SMC** convergence time depends on adaptation rate ### 6.4 Phase Portrait Analysis **Classical SMC**:
- Spiral approach to Ïƒ = 0 line in (Ïƒ, ÏƒÌ‡) plane
- Exponential decay of both Ïƒ and ÏƒÌ‡
- Never reaches origin exactly **STA SMC**:
- Direct finite-time reach to origin in (Ïƒ, ÏƒÌ‡) plane
- Both Ïƒ and ÏƒÌ‡ reach zero simultaneously
- Twisting motion around origin during convergence **Adaptive SMC**:
- Spiral approach with varying damping (due to adaptive gain)
- Convergence rate changes as K(t) evolves
- Dead zone creates limit cycle around origin **Hybrid SMC**:
- Direct finite-time reach with adaptive rate
- Combines advantages of STA (finite-time) and adaptive (robustness)
- Self-tapering prevents overshoot near origin

---

## 7. Numerical Considerations ### 7.1 Matrix Regularization **Problem**: The inertia matrix M(q) can become ill-conditioned near singular configurations, leading to large rounding errors in inversion. **Tikhonov Regularization**: ```
M_reg = M(q) + Î±I, Î± &gt; 0
``` **Benefits**:

- Prevents singularity when det(M) â‰ˆ 0
- Shifts eigenvalues: Î»áµ¢ â†’ Î»áµ¢ + Î± (all eigenvalues become â‰¥ Î±)
- Converts nearly-singular matrix to well-conditioned **Trade-off**: Introduces small approximation error in equivalent control **Typical Value**: Î± = 10â»â¸ to 10â»â¶ **Mathematical Justification**: Adding a positive constant to the diagonal of a symmetric matrix shifts all eigenvalues upward, converting an indefinite or singular matrix into a positive-definite one. ### 7.2 Condition Number Monitoring **Definition**: ```
Îº(M) = ||M|| Â· ||Mâ»Â¹||
``` **Thresholds**:
- **Îº &lt; 10Â³**: Well-conditioned (safe for direct inversion)
- **10Â³ &lt; Îº &lt; 10â¶**: Moderate conditioning (use with caution)
- **Îº &gt; 10â¶**: Ill-conditioned â†’ **use pseudo-inverse** **Pseudo-Inverse**: ```
Mâº = (Máµ€M + Î±I)â»Â¹Máµ€ (Moore-Penrose pseudo-inverse)
``` - Provides least-squares solution

- Minimizes effect of noise
- More robust than direct inversion for ill-conditioned systems **Implementation**:
```python
if np.linalg.cond(M) &gt; 1e6: M_inv = np.linalg.pinv(M) # Use pseudo-inverse
else: M_inv = np.linalg.inv(M) # Direct inversion safe
``` ### 7.3 Discrete-Time Implementation **Euler Integration** (for adaptive gains and STA integral): ```

u_int(k+1) = u_int(k) - Kâ‚‚Â·sign(Ïƒ(k))Â·dt
K(k+1) = K(k) + Î³|Ïƒ(k)|Â·dt
``` **Sampling Effects**:
- **dt too large** â†’ Discrete chattering (control jumps between bounds)
- **dt too small** â†’ Computational cost increases, numerical precision issues
- **Recommended**: dt â‰¤ 0.01s for DIP system **Discrete Chattering**: When dt is large relative to system dynamics, the control oscillates between saturation limits even though Ïƒ â‰ˆ 0. Solution: Reduce dt or increase boundary layer Îµ. ### 7.4 Numerical Stability Checks **Implementation Safeguards**: 1. **Finite Value Checking**: ```python if not np.isfinite(u): u = 0.0 # Emergency fallback log_error(&quot;Non-finite control value detected&quot;) ``` 2. **Controllability Check**: ```python controllability = abs(L @ M_inv @ B) if controllability &lt; Îµ_threshold: # System near uncontrollable configuration u_eq = 0.0 # Disable equivalent control ``` Typical threshold: Îµ_threshold = 10â»â´ 3. **Actuator Saturation**: ```python u_sat = np.clip(u, -max_force, max_force) ``` 4. **Emergency Reset**: ```python if state_norm &gt; 10.0 or velocity_norm &gt; 50.0: # System diverging - reset controller state u_int = 0.0 K = K_init ``` **Robustness Best Practices**:
- Always validate outputs before applying control
- Monitor condition numbers of matrix operations
- Implement fallback strategies for edge cases
- Log warnings for numerical issues without crashing

---

## 8. References ### Primary SMC References [1] **Utkin, V.I.** (1992). &quot;Sliding Modes in Control and Optimization&quot;. Springer-Verlag, Berlin. doi: 10.1007/978-3-642-84379-2
*Foundational text on SMC theory, sliding mode equations, and exponential stability.* [2] **Edwards, C. and Spurgeon, S.K.** (1998). &quot;Sliding Mode Control: Theory and Applications&quot;. CRC Press, Boca Raton, FL. ISBN: 978-0748406012
*Chapter 3: Sliding Surface Design - pole placement via surface parameters.* [3] **Slotine, J.-J.E. and Li, W.** (1991). &quot;Applied Nonlinear Control&quot;. Prentice Hall, Englewood Cliffs, NJ. ISBN: 0-13-040890-5
*Practical implementation of SMC for nonlinear systems.* ### Higher-Order SMC References [4] **Levant, A.** (2003). &quot;Higher-order sliding modes, differentiation and output-feedback control&quot;. International Journal of Control, 76(9-10):924-941. doi: 10.1080/0020717031000099029
*Foundations of higher-order sliding modes and super-twisting algorithms.* [5] **Levant, A.** (2007). &quot;Principles of 2-sliding mode design&quot;. Automatica, 43(4):576-586. doi: 10.1016/j.automatica.2006.10.008
*Systematic design methodology for second-order sliding modes.* [6] **Moreno, J.A. and Osorio, M.** (2012). &quot;Strict Lyapunov Functions for the Super-Twisting Algorithm&quot;. IEEE Transactions on Automatic Control, 57(4):1035-1040.
*Rigorous Lyapunov analysis proving finite-time convergence of STA.* ### Adaptive SMC References [7] **Yang, Y., Meng, M.Q.-H., and Tan, K.K.** (2007). &quot;Adaptive sliding mode control for uncertain systems&quot;. Automatica, 43(2):201-207.
*Online gain adaptation for unknown disturbance bounds.* [8] **Huang, J., Yao, B., and Tao, G.** (2008). &quot;Adaptive second-order sliding-mode control of nonlinear systems&quot;. IEEE Transactions on Automatic Control, 53(11):2689-2694.
*Combines adaptation with second-order sliding modes.* ### Chattering Reduction References [9] **Burton, J.A. and Zinober, A.S.I.** (1986). &quot;Continuous approximation of variable structure control&quot;. International Journal of Systems Science, 17(6):875-885. doi: 10.1080/00207728608926853
*Boundary layer theory for chattering reduction.* [10] **Utkin, V.I., Guldner, J., and Shi, J.** (2009). &quot;Sliding Mode Control in Electro-Mechanical Systems&quot; (2nd ed.). CRC Press, Boca Raton, FL. doi: 10.1201/9781420065619
*Practical techniques for chattering mitigation.* ### Control Theory Fundamentals [11] **Utkin, V.I.** (1977). &quot;Variable structure systems with sliding modes&quot;. IEEE Transactions on Automatic Control, 22(2):212-222.
*Seminal paper establishing sliding mode control theory.* [12] **Slotine, J.-J. and Sastry, S.** (1983). &quot;Tracking control of nonlinear systems using sliding surfaces&quot;. International Journal of Control, 38(2):465-492.
*Application of SMC to tracking problems.* [13] **Young, K.D., Utkin, V.I., and Ã–zgÃ¼ner, Ãœ.** (1999). &quot;A control engineer&#39;s guide to sliding mode control&quot;. IEEE Transactions on Control Systems Technology, 7(3):328-342. doi: 10.1109/87.761053
*Practical guide for implementing SMC in engineering applications.* ### Recent Advances [14] **Shtessel, Y., Edwards, C., Fridman, L., and Levant, A.** (2014). &quot;Sliding Mode Control and Observation&quot;. BirkhÃ¤user, New York, NY. doi: 10.1007/978-0-8176-4893-0
*modern treatment of SMC and observation techniques.* [15] **Levant, A.** (1993). &quot;Sliding order and sliding accuracy in sliding mode control&quot;. International Journal of Control, 58(6):1247-1263. doi: 10.1080/00207179308923053
*Analysis of sliding accuracy and convergence properties.* ### Optimization and Tuning [16] **Messina, A., Lanzafame, R., and Tomarchio, S.** (2013). &quot;Multi-objective optimal tuning of sliding mode controllers by evolutionary algorithms&quot;. IEEE/ASME Transactions on Mechatronics, 18(5):1446-1454.
*PSO and evolutionary algorithms for SMC gain tuning.* ### Underactuated Systems [17] **Utkin, V.I.** (1993). &quot;Sliding mode control design principles and applications to electric drives&quot;. IEEE Transactions on Industrial Electronics, 40(1):23-36. doi: 10.1109/41.184818
*Application of SMC to underactuated mechanical systems.* [18] **Gong, Z., Ba, Y., Zhang, M., and Guo, Y.** (2022). &quot;Robust sliding mode control of the permanent magnet synchronous motor with an improved power reaching law&quot;. Energies, 15(5):1935.
*Modern applications of adaptive reaching laws.*

---

**Document Classification**: Research-Grade Mathematical Theory
**Maintenance**: Update when new SMC variants are added
**Next Review**: 2025-11-04
**Version History**: v1.0 (2025-10-04) - Initial theory document
</pre></div>
</div>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Research Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on Oct 10, 2025</div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Complete Sliding Mode Control Mathematical Theory</a><ul>
<li><a class="reference internal" href="#table-of-contents-1-introduction-and-fundamentals">Table of Contents 1. <span class="xref myst">Introduction and Fundamentals</span></a></li>
<li><a class="reference internal" href="#introduction-and-fundamentals-1-1-overview-the-double-inverted-pendulum-dip-is-a-canonical-benchmark-for-nonlinear-underactuated-control-systems-with-two-pendula-attached-in-series-to-a-horizontally-moving-cart-the-system-has-fewer-actuators-than-degrees-of-freedom-making-it-both-underactuated-and-strongly-nonlinear-conventional-linear-controllers-struggle-with-large-deflections-parameter-variations-and-model-uncertainty-sliding-mode-control-smc-addresses-these-challenges-by-forcing-the-system-state-onto-a-pre-defined-sliding-manifold-when-the-state-reaches-this-manifold-the-resulting-closed-loop-dynamics-become-insensitive-to-matched-disturbances-and-uncertainties-the-control-law-compensates-modeling-errors-through-the-control-input-channel-causing-the-plant-to-behave-according-to-the-reduced-order-dynamics-on-the-manifold-this-robustness-and-finite-time-convergence-for-higher-order-smc-make-smc-attractive-for-underactuated-systems-however-the-discontinuous-switching-law-of-classical-smc-induces-chattering-a-high-frequency-oscillation-caused-by-rapid-control-switching-when-the-state-crosses-the-sliding-surface-chattering-increases-control-effort-excites-unmodeled-high-frequency-modes-and-can-cause-wear-in-actuators-introducing-a-boundary-layer-around-the-sliding-surface-alleviates-chattering-but-enlarges-the-tracking-error-this-document-presents-the-unified-mathematical-theory-for-four-smc-variants-implemented-in-this-project">1. Introduction and Fundamentals ### 1.1 Overview The double-inverted pendulum (DIP) is a canonical benchmark for nonlinear, underactuated control systems. With two pendula attached in series to a horizontally moving cart, the system has fewer actuators than degrees of freedom, making it both <strong>underactuated</strong> and <strong>strongly nonlinear</strong>. Conventional linear controllers struggle with large deflections, parameter variations, and model uncertainty. Sliding Mode Control (SMC) addresses these challenges by forcing the system state onto a pre-defined <strong>sliding manifold</strong>. When the state reaches this manifold, the resulting closed-loop dynamics become insensitive to matched disturbances and uncertainties. The control law compensates modeling errors through the control input channel, causing the plant to behave according to the reduced-order dynamics on the manifold. This robustness and finite-time convergence (for higher-order SMC) make SMC attractive for underactuated systems. However, the discontinuous switching law of classical SMC induces <strong>chattering</strong>, a high-frequency oscillation caused by rapid control switching when the state crosses the sliding surface. Chattering increases control effort, excites unmodeled high-frequency modes, and can cause wear in actuators. Introducing a boundary layer around the sliding surface alleviates chattering but enlarges the tracking error. This document presents the unified mathematical theory for four SMC variants implemented in this project:</a></li>
<li><a class="reference internal" href="#adaptive-smc-theory-4-1-motivation-and-problem-statement-challenge-classical-smc-requires-prior-knowledge-of-disturbance-bounds-k-d-in-practice">4. Adaptive SMC Theory ### 4.1 Motivation and Problem Statement <strong>Challenge</strong>: Classical SMC requires prior knowledge of disturbance bounds (K &gt; ||d||âˆ). In practice:</a></li>
<li><a class="reference internal" href="#convergence-analysis-comparison-6-1-convergence-rate-summary-controller-convergence-type-rate-time-to-surface-steady-state-error">6. Convergence Analysis Comparison ### 6.1 Convergence Rate Summary | Controller | Convergence Type | Rate | Time to Surface | Steady-State Error |</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=4ebf8126"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=46bd48cc"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=08e7b316"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../_static/back-to-top.js?v=840797bb"></script>
    <script src="../_static/lazy-load.js?v=dc25293c"></script>
    <script src="../_static/dark-mode.js?v=bf328970"></script>
    </body>
</html>