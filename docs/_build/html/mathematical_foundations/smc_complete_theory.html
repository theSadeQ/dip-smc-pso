<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
.chartjs-container {
    margin: 1.5em auto;
    padding: 1em;
    background: #f8f9fa;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.chart-note {
    text-align: center;
    color: #6c757d;
    font-size: 0.9em;
    margin-top: 0.5em;
}
</style>
<link rel="index" title="Index" href="../genindex.html"><link rel="search" title="Search" href="../search.html">

    <!-- Generated with Sphinx 8.2.3 and Furo 2025.09.25 -->
        <title>Complete Sliding Mode Control Mathematical Theory - DIP_SMC_PSO Documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5349f25f" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=580074bf" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=8dab3a3b" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=8a7e329d" />
    
    


<style>
  body {
    --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">DIP_SMC_PSO Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  <span class="sidebar-brand-text">DIP_SMC_PSO Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">📚 Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Optimal Sliding Mode Control for a Double-Inverted Pendulum via PSO  ## How to validate a ResearchPlan JSON Run the validator locally: ```bash</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory_overview.html">Theory Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../architecture.html">3. System Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plant_model.html">1.x Plant Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hil_quickstart.html">Hardware-in-the-Loop (HIL) Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../streamlit_dashboard_guide.html">Streamlit Dashboard User Guide</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/blob/main/docs/mathematical_foundations/smc_complete_theory.md?plain=true" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div><div class="edit-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/edit/main/docs/mathematical_foundations/smc_complete_theory.md" rel="edit" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section class="tex2jax_ignore mathjax_ignore" id="complete-sliding-mode-control-mathematical-theory">
<h1>Complete Sliding Mode Control Mathematical Theory<a class="headerlink" href="#complete-sliding-mode-control-mathematical-theory" title="Link to this heading">¶</a></h1>
<p><strong>Double-Inverted Pendulum Control System</strong> <strong>Document Version</strong>: 1.0
<strong>Created</strong>: 2025-10-04
<strong>Status</strong>: Research-Grade Reference <strong>Purpose</strong>: Unified mathematical foundation for all SMC variants in the DIP-SMC-PSO system, including rigorous Lyapunov stability proofs, convergence analysis, finite-time convergence theory, and implementation considerations.</p>
<hr class="docutils" />
<section id="table-of-contents-1-introduction-and-fundamentals">
<h2>Table of Contents 1. <a class="reference internal" href="#1-introduction-and-fundamentals"><span class="xref myst">Introduction and Fundamentals</span></a><a class="headerlink" href="#table-of-contents-1-introduction-and-fundamentals" title="Link to this heading">¶</a></h2>
<ol class="arabic simple" start="2">
<li><p><a class="reference internal" href="#2-classical-smc-theory"><span class="xref myst">Classical SMC Theory</span></a></p></li>
<li><p><a class="reference internal" href="#3-super-twisting-smc-theory"><span class="xref myst">Super-Twisting SMC Theory</span></a></p></li>
<li><p><a class="reference internal" href="#4-adaptive-smc-theory"><span class="xref myst">Adaptive SMC Theory</span></a></p></li>
<li><p><a class="reference internal" href="#5-hybrid-adaptive-sta-smc-theory"><span class="xref myst">Hybrid Adaptive STA-SMC Theory</span></a></p></li>
<li><p><a class="reference internal" href="#6-convergence-analysis-comparison"><span class="xref myst">Convergence Analysis Comparison</span></a></p></li>
<li><p><a class="reference internal" href="#7-numerical-considerations"><span class="xref myst">Numerical Considerations</span></a></p></li>
<li><p><a class="reference internal" href="#8-references"><span class="xref myst">References</span></a></p></li>
</ol>
</section>
<hr class="docutils" />
<section id="introduction-and-fundamentals-1-1-overview-the-double-inverted-pendulum-dip-is-a-canonical-benchmark-for-nonlinear-underactuated-control-systems-with-two-pendula-attached-in-series-to-a-horizontally-moving-cart-the-system-has-fewer-actuators-than-degrees-of-freedom-making-it-both-underactuated-and-strongly-nonlinear-conventional-linear-controllers-struggle-with-large-deflections-parameter-variations-and-model-uncertainty-sliding-mode-control-smc-addresses-these-challenges-by-forcing-the-system-state-onto-a-pre-defined-sliding-manifold-when-the-state-reaches-this-manifold-the-resulting-closed-loop-dynamics-become-insensitive-to-matched-disturbances-and-uncertainties-the-control-law-compensates-modeling-errors-through-the-control-input-channel-causing-the-plant-to-behave-according-to-the-reduced-order-dynamics-on-the-manifold-this-robustness-and-finite-time-convergence-for-higher-order-smc-make-smc-attractive-for-underactuated-systems-however-the-discontinuous-switching-law-of-classical-smc-induces-chattering-a-high-frequency-oscillation-caused-by-rapid-control-switching-when-the-state-crosses-the-sliding-surface-chattering-increases-control-effort-excites-unmodeled-high-frequency-modes-and-can-cause-wear-in-actuators-introducing-a-boundary-layer-around-the-sliding-surface-alleviates-chattering-but-enlarges-the-tracking-error-this-document-presents-the-unified-mathematical-theory-for-four-smc-variants-implemented-in-this-project">
<h2>1. Introduction and Fundamentals ### 1.1 Overview The double-inverted pendulum (DIP) is a canonical benchmark for nonlinear, underactuated control systems. With two pendula attached in series to a horizontally moving cart, the system has fewer actuators than degrees of freedom, making it both <strong>underactuated</strong> and <strong>strongly nonlinear</strong>. Conventional linear controllers struggle with large deflections, parameter variations, and model uncertainty. Sliding Mode Control (SMC) addresses these challenges by forcing the system state onto a pre-defined <strong>sliding manifold</strong>. When the state reaches this manifold, the resulting closed-loop dynamics become insensitive to matched disturbances and uncertainties. The control law compensates modeling errors through the control input channel, causing the plant to behave according to the reduced-order dynamics on the manifold. This robustness and finite-time convergence (for higher-order SMC) make SMC attractive for underactuated systems. However, the discontinuous switching law of classical SMC induces <strong>chattering</strong>, a high-frequency oscillation caused by rapid control switching when the state crosses the sliding surface. Chattering increases control effort, excites unmodeled high-frequency modes, and can cause wear in actuators. Introducing a boundary layer around the sliding surface alleviates chattering but enlarges the tracking error. This document presents the unified mathematical theory for four SMC variants implemented in this project:<a class="headerlink" href="#introduction-and-fundamentals-1-1-overview-the-double-inverted-pendulum-dip-is-a-canonical-benchmark-for-nonlinear-underactuated-control-systems-with-two-pendula-attached-in-series-to-a-horizontally-moving-cart-the-system-has-fewer-actuators-than-degrees-of-freedom-making-it-both-underactuated-and-strongly-nonlinear-conventional-linear-controllers-struggle-with-large-deflections-parameter-variations-and-model-uncertainty-sliding-mode-control-smc-addresses-these-challenges-by-forcing-the-system-state-onto-a-pre-defined-sliding-manifold-when-the-state-reaches-this-manifold-the-resulting-closed-loop-dynamics-become-insensitive-to-matched-disturbances-and-uncertainties-the-control-law-compensates-modeling-errors-through-the-control-input-channel-causing-the-plant-to-behave-according-to-the-reduced-order-dynamics-on-the-manifold-this-robustness-and-finite-time-convergence-for-higher-order-smc-make-smc-attractive-for-underactuated-systems-however-the-discontinuous-switching-law-of-classical-smc-induces-chattering-a-high-frequency-oscillation-caused-by-rapid-control-switching-when-the-state-crosses-the-sliding-surface-chattering-increases-control-effort-excites-unmodeled-high-frequency-modes-and-can-cause-wear-in-actuators-introducing-a-boundary-layer-around-the-sliding-surface-alleviates-chattering-but-enlarges-the-tracking-error-this-document-presents-the-unified-mathematical-theory-for-four-smc-variants-implemented-in-this-project" title="Link to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p><strong>Classical SMC</strong>: First-order sliding mode with boundary layer</p></li>
<li><p><strong>Super-Twisting SMC (STA)</strong>: Second-order sliding mode for continuous control</p></li>
<li><p><strong>Adaptive SMC</strong>: Online gain adaptation for unknown disturbances</p></li>
<li><p><strong>Hybrid Adaptive STA-SMC</strong>: Combined adaptive and super-twisting algorithms ### 1.2 State Space Formulation The dynamics of the double-inverted pendulum are described by the Euler-Lagrange equations: ```
M(q)q̈ + C(q,q̇)q̇ + G(q) = Bu</p></li>
</ol>
<div class="highlight-where: notranslate"><div class="highlight"><pre><span></span>- **q** = [x, θ₁, θ₂]ᵀ is the generalized coordinate vector (cart position, pendulum angles)
- **M(q)** ∈ ℝ³ˣ³ is the inertia matrix (configuration-dependent)
- **C(q,q̇)q̇** represents Coriolis and centrifugal forces
- **G(q)** is the gravitational force vector
- **B** = [1, 0, 0]ᵀ is the input distribution matrix
- **u** ∈ ℝ is the control force applied to the cart **State vector**: x = [x, θ₁, θ₂, ẋ, θ̇₁, θ̇₂]ᵀ ∈ ℝ⁶ **Key Properties**:
- **Underactuated**: rank(B) = 1 &lt; 3 (fewer actuators than degrees of freedom)
- **Matched disturbances**: Disturbances d entering through the same channel as control input
- **Controllability**: The system is locally controllable around the upright equilibrium ### 1.3 Sliding Mode Fundamentals **Sliding Surface**: A hypersurface σ(x) = 0 in the state space, designed such that the system exhibits desired behavior when constrained to this surface. **Reachability Condition**: The fundamental condition ensuring the system state reaches the sliding surface: ```
σσ̇ &lt; 0 whenever σ ≠ 0
``` This condition guarantees that σ acts as a Lyapunov function, driving the system toward the surface. **Invariance Property**: Once on the sliding surface (σ = 0), the system remains on it under ideal conditions (no disturbances, perfect control implementation). **Equivalent Control Method**: The equivalent control u_eq is the control required to maintain σ̇ = 0, derived by setting: ```

σ̇ = (∂σ/∂x)ẋ = (∂σ/∂x)f(x, u_eq) = 0
``` Solving for u_eq gives the **ideal** control that keeps the system on the sliding surface, assuming perfect knowledge of the dynamics. ### 1.4 Matched vs Unmatched Disturbances **Matched Disturbances**: Disturbances that enter through the same channel as the control input: ```
M(q)q̈ + C(q,q̇)q̇ + G(q) = B(u + d)
``` SMC can **completely reject** matched disturbances by choosing switching gain K &gt; ||d||∞. **Unmatched Disturbances**: Disturbances entering through different channels. Classical SMC provides limited robustness against unmatched disturbances. Advanced techniques (integral SMC, higher-order SMC) can handle certain classes of unmatched disturbances.

---

## 2. Classical SMC Theory ### 2.1 Sliding Surface Design The sliding surface for the DIP system is defined as: ```

σ = λ₁θ₁ + λ₂θ₂ + k₁θ̇₁ + k₂θ̇₂
``` where:
- **θ₁, θ₂**: pendulum angles
- **θ̇₁, θ̇₂**: pendulum angular velocities
- **λ₁, λ₂ &gt; 0**: sliding surface slope parameters (must be strictly positive)
- **k₁, k₂ &gt; 0**: velocity feedback gains (must be strictly positive) **Mathematical Properties**: 1. **Hurwitz Stability Requirement**: The characteristic polynomial of the sliding dynamics must have all roots in the left half-plane: ``` s² + k₁s + λ₁ = 0 (for pendulum 1) s² + k₂s + λ₂ = 0 (for pendulum 2) ``` 2. **Positivity Constraints**: For asymptotic stability: ``` λ₁, λ₂ &gt; 0 (slope parameters ensure stable surface) k₁, k₂ &gt; 0 (damping parameters) ``` 3. **Pole Placement Interpretation**: The sliding surface parameters define the poles of the reduced-order dynamics: - **Critically damped**: k²ᵢ = 4λᵢ → poles at s = -kᵢ/2 (repeated real poles) - **Underdamped**: k²ᵢ &lt; 4λᵢ → complex conjugate poles (faster, oscillatory) - **Overdamped**: k²ᵢ &gt; 4λᵢ → distinct real poles (slower, smooth) **Design Guidelines**:
- Start with critically damped case: kᵢ = 2√λᵢ
- Increase kᵢ for more damping (slower convergence, smoother response)
- Decrease kᵢ for less damping (faster convergence, more oscillation) ### 2.2 Control Law Decomposition The control input u is decomposed into **equivalent control** and **robust switching**: ```
u = u_eq - K·sat(σ/ε) - k_d·σ
``` **Components**: 1. **Equivalent Control (u_eq)**: Cancels the nominal dynamics. Derived from σ̇ = 0: ``` σ̇ = L(M⁻¹(Bu + d) - M⁻¹(C(q,q̇)q̇ + G(q))) = 0 ``` where L = [λ₁, λ₂, k₁, k₂, 0, 0] is the sliding surface gradient. Solving for u: ``` u_eq = (LM⁻¹B)⁻¹ · L(M⁻¹(C(q,q̇)q̇ + G(q)) - [k₁λ₁θ̇₁ + k₂λ₂θ̇₂]) ``` 2. **Switching Term (-K·sat(σ/ε))**: Provides robustness against disturbances. The gain K must satisfy: ``` K &gt; ||d||∞ ``` 3. **Damping Term (-k_d·σ)**: Improves transient response, reduces overshoot. ### 2.3 Boundary Layer Theory The discontinuous sign function is approximated within a boundary layer of width ε &gt; 0 to reduce chattering: **Linear Saturation**:

</pre></div>
</div>
<p>sat(σ/ε) = { σ/ε, if |σ| ≤ ε sign(σ), if |σ| &gt; ε
}</p>
<div class="highlight-**Hyperbolic notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<p>sat(σ/ε) = tanh(σ/ε)</p>
<div class="highlight-**Properties**: notranslate"><div class="highlight"><pre><span></span>
- **Continuity**: Linear saturation is continuous at σ = ±ε
- **Smoothness**: tanh is C∞ everywhere
- **Approximation Error**: Bounded by ε **Trade-offs**:
- **Smaller ε** → Better tracking, more chattering
- **Larger ε** → Smoother control, larger steady-state error
- **Adaptive boundary layer**: ε = ε₀ + ε₁||σ|| adjusts based on sliding surface magnitude ### 2.4 Lyapunov Stability Analysis **Lyapunov Function**:
</pre></div>
</div>
<p>V = ½σ²
<code class="docutils literal notranslate"><span class="pre">**Proof</span> <span class="pre">of</span> <span class="pre">Stability**:</span> <span class="pre">1.</span> <span class="pre">**Positive</span> <span class="pre">Definiteness**:</span> <span class="pre">V</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">for</span> <span class="pre">σ</span> <span class="pre">≠</span> <span class="pre">0,</span> <span class="pre">V(0)</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">✓</span> <span class="pre">2.</span> <span class="pre">**Time</span> <span class="pre">Derivative**:</span></code> V̇ = σσ̇ = σ[λ₁θ̇₁ + λ₂θ̇₂ + k₁θ̈₁ + k₂θ̈₂] <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Substitute</span> <span class="pre">Dynamics**:</span> <span class="pre">M(q)q̈</span> <span class="pre">=</span> <span class="pre">Bu</span> <span class="pre">-</span> <span class="pre">C(q,q̇)q̇</span> <span class="pre">-</span> <span class="pre">G(q)</span> <span class="pre">+</span> <span class="pre">d</span> <span class="pre">Solving</span> <span class="pre">for</span> <span class="pre">q̈</span> <span class="pre">and</span> <span class="pre">substituting:</span></code> V̇ = σ · L · M⁻¹ · (B(u_eq - K·sign(σ) - k_d·σ + d) - C(q,q̇)q̇ - G(q)) <code class="docutils literal notranslate"><span class="pre">4.</span> <span class="pre">**Simplification</span> <span class="pre">using</span> <span class="pre">σ̇</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">for</span> <span class="pre">u_eq**:</span> <span class="pre">The</span> <span class="pre">equivalent</span> <span class="pre">control</span> <span class="pre">u_eq</span> <span class="pre">is</span> <span class="pre">designed</span> <span class="pre">such</span> <span class="pre">that</span> <span class="pre">σ̇</span> <span class="pre">=</span> <span class="pre">0</span> <span class="pre">when</span> <span class="pre">d</span> <span class="pre">=</span> <span class="pre">0.</span> <span class="pre">Therefore:</span></code> V̇ = σ · L · M⁻¹ · B · (-K·sign(σ) + d - k_d·σ) <code class="docutils literal notranslate"><span class="pre">Let</span> <span class="pre">η_c</span> <span class="pre">=</span> <span class="pre">L·M⁻¹·B</span> <span class="pre">(controllability</span> <span class="pre">measure).</span> <span class="pre">Then:</span></code> V̇ = η_c · σ · (-K·sign(σ) + d - k_d·σ) = η_c · (-K|σ| + σd - k_d·σ²) ≤ η_c · (-K|σ| + |d|·|σ| - k_d·σ²) = η_c · (-(K - ||d||∞)|σ| - k_d·σ²) <code class="docutils literal notranslate"><span class="pre">5.</span> <span class="pre">**Negative</span> <span class="pre">Definiteness**:</span> <span class="pre">If</span> <span class="pre">K</span> <span class="pre">&gt;</span> <span class="pre">||d||∞,</span> <span class="pre">then:</span></code> V̇ ≤ -η_c·η|σ| where η = K - ||d||∞ &gt; 0 <code class="docutils literal notranslate"><span class="pre">Since</span> <span class="pre">η_c</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">(controllability</span> <span class="pre">condition)</span> <span class="pre">and</span> <span class="pre">η</span> <span class="pre">&gt;</span> <span class="pre">0,</span> <span class="pre">we</span> <span class="pre">have</span> <span class="pre">V̇</span> <span class="pre">&lt;</span> <span class="pre">0</span> <span class="pre">for</span> <span class="pre">all</span> <span class="pre">σ</span> <span class="pre">≠</span> <span class="pre">0.</span> <span class="pre">6.</span> <span class="pre">**Conclusion**:</span> <span class="pre">By</span> <span class="pre">Lyapunov's</span> <span class="pre">theorem,</span> <span class="pre">σ</span> <span class="pre">→</span> <span class="pre">0</span> <span class="pre">asymptotically.</span> <span class="pre">###</span> <span class="pre">2.5</span> <span class="pre">Convergence</span> <span class="pre">Rate</span> <span class="pre">Analysis</span> <span class="pre">**Exponential</span> <span class="pre">Convergence**:</span> <span class="pre">From</span> <span class="pre">V̇</span> <span class="pre">≤</span> <span class="pre">-η_c·η|σ|,</span> <span class="pre">we</span> <span class="pre">can</span> <span class="pre">derive:</span></code></p>
<p>|σ(t)| ≤ |σ(0)|e^(-ηt)
<code class="docutils literal notranslate"><span class="pre">**Time</span> <span class="pre">Constants**:</span> <span class="pre">On</span> <span class="pre">the</span> <span class="pre">sliding</span> <span class="pre">surface</span> <span class="pre">(σ</span> <span class="pre">=</span> <span class="pre">0),</span> <span class="pre">the</span> <span class="pre">reduced-order</span> <span class="pre">dynamics</span> <span class="pre">are:</span></code>
λ₁θ₁ + λ₂θ₂ + k₁θ̇₁ + k₂θ̇₂ = 0
<code class="docutils literal notranslate"><span class="pre">For</span> <span class="pre">the</span> <span class="pre">critically</span> <span class="pre">damped</span> <span class="pre">case</span> <span class="pre">(k²ᵢ</span> <span class="pre">=</span> <span class="pre">4λᵢ):</span></code></p>
<p>τᵢ = 2/kᵢ (time constant for pendulum i)</p>
<div class="highlight-**Practical notranslate"><div class="highlight"><pre><span></span>- Classical SMC achieves **exponential convergence** (not finite-time)
- Convergence rate determined by gains k₁, k₂
- Larger kᵢ → Faster convergence but potentially more oscillation

---

## 3. Super-Twisting SMC Theory ### 3.1 Second-Order Sliding Mode Concept The **super-twisting algorithm** (STA) is a second-order sliding mode technique that suppresses chattering by applying the discontinuity on the **derivative** of the control signal rather than on the control itself. **Key Innovation**: Move discontinuity to u̇ instead of u:
- **Classical SMC**: u contains sign(σ) → discontinuous control
- **STA SMC**: u̇ contains sign(σ) → continuous control, discontinuous derivative **Result**:
- u is continuous
- Both σ and σ̇ converge to zero in **finite time** **Sliding Variable** (for STA):
</pre></div>
</div>
<p>σ = k₁(θ̇₁ + λ₁θ₁) + k₂(θ̇₂ + λ₂θ₂)
<code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">3.2</span> <span class="pre">Super-Twisting</span> <span class="pre">Algorithm</span> <span class="pre">The</span> <span class="pre">STA</span> <span class="pre">control</span> <span class="pre">law</span> <span class="pre">consists</span> <span class="pre">of</span> <span class="pre">two</span> <span class="pre">components:</span></code>
u = u_c + u_i + u_eq</p>
<div class="highlight-**1. notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<p>u_c = -K₁√|σ|·sign(σ)</p>
<div class="highlight-- notranslate"><div class="highlight"><pre><span></span>
- Continuous but non-smooth at σ = 0
- Acts as nonlinear damping proportional to √|σ| **2. Integral Term**:
</pre></div>
</div>
<p>u̇_i = -K₂·sign(σ)</p>
<div class="highlight-- notranslate"><div class="highlight"><pre><span></span>
- Integrated to produce continuous u_i **Discrete Implementation**:
</pre></div>
</div>
<p>u_i(t+dt) = u_i(t) - K₂·sign(σ)·dt
<code class="docutils literal notranslate"><span class="pre">**3.</span> <span class="pre">Equivalent</span> <span class="pre">Control**:</span> <span class="pre">Model-based</span> <span class="pre">feedforward</span> <span class="pre">(same</span> <span class="pre">as</span> <span class="pre">classical</span> <span class="pre">SMC)</span> <span class="pre">###</span> <span class="pre">3.3</span> <span class="pre">Lyapunov</span> <span class="pre">Function</span> <span class="pre">for</span> <span class="pre">STA</span> <span class="pre">**Candidate</span> <span class="pre">Lyapunov</span> <span class="pre">Function**</span> <span class="pre">(Moreno</span> <span class="pre">&amp;</span> <span class="pre">Osorio,</span> <span class="pre">2012):</span></code></p>
<p>V = k₁|σ|^(3/2) + ½z²
<code class="docutils literal notranslate"><span class="pre">where</span> <span class="pre">z</span> <span class="pre">is</span> <span class="pre">an</span> <span class="pre">auxiliary</span> <span class="pre">variable</span> <span class="pre">related</span> <span class="pre">to</span> <span class="pre">σ̇.</span> <span class="pre">**Finite-Time</span> <span class="pre">Convergence</span> <span class="pre">Proof</span> <span class="pre">(Sketch)**:</span> <span class="pre">1.</span> <span class="pre">**Positive</span> <span class="pre">Definiteness**:</span> <span class="pre">V</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">for</span> <span class="pre">(σ,</span> <span class="pre">z)</span> <span class="pre">≠</span> <span class="pre">(0,</span> <span class="pre">0)</span> <span class="pre">✓</span> <span class="pre">2.</span> <span class="pre">**Time</span> <span class="pre">Derivative**</span> <span class="pre">(using</span> <span class="pre">homogeneity</span> <span class="pre">argument):</span></code> V̇ = (3k₁/2)|σ|^(1/2)·σ̇·sign(σ) + z·ż <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Substitute</span> <span class="pre">STA</span> <span class="pre">Dynamics**:</span> <span class="pre">-</span> <span class="pre">σ̇</span> <span class="pre">is</span> <span class="pre">related</span> <span class="pre">to</span> <span class="pre">z</span> <span class="pre">through</span> <span class="pre">system</span> <span class="pre">dynamics</span> <span class="pre">-</span> <span class="pre">ż</span> <span class="pre">=</span> <span class="pre">-K₂·sign(σ)</span> <span class="pre">from</span> <span class="pre">control</span> <span class="pre">law</span> <span class="pre">4.</span> <span class="pre">**Gain</span> <span class="pre">Conditions**:</span> <span class="pre">-</span> <span class="pre">K₁</span> <span class="pre">&gt;</span> <span class="pre">L</span> <span class="pre">(L</span> <span class="pre">=</span> <span class="pre">Lipschitz</span> <span class="pre">constant</span> <span class="pre">of</span> <span class="pre">disturbance</span> <span class="pre">derivative)</span> <span class="pre">-</span> <span class="pre">K₂</span> <span class="pre">&gt;</span> <span class="pre">K₁·C</span> <span class="pre">(C</span> <span class="pre">depends</span> <span class="pre">on</span> <span class="pre">system</span> <span class="pre">parameters)</span> <span class="pre">5.</span> <span class="pre">**Result**:</span> <span class="pre">Under</span> <span class="pre">these</span> <span class="pre">conditions:</span></code> V̇ ≤ -β·V^(1/2) for some β &gt; 0 <code class="docutils literal notranslate"><span class="pre">6.</span> <span class="pre">**Finite-Time</span> <span class="pre">Convergence**:</span> <span class="pre">Integrating</span> <span class="pre">V̇</span> <span class="pre">≤</span> <span class="pre">-β·V^(1/2)</span> <span class="pre">gives:</span></code> V(t) = 0 for all t ≥ T_reach <code class="docutils literal notranslate"><span class="pre">where:</span></code> T_reach ≤ 2V(0)^(1/2)/β ≤ 2|σ(0)|^(1/2)/(K₁^(1/2)) ``` <strong>Key Takeaway</strong>: Both σ and σ̇ reach zero in finite time, unlike classical SMC which only achieves exponential convergence. ### 3.4 Gain Selection Guidelines <strong>K₁ Selection</strong>:</p>
<ul class="simple">
<li><p>Must exceed max disturbance derivative: K₁ &gt; L</p></li>
<li><p>Larger K₁ → Faster convergence, higher control effort</p></li>
<li><p>Typical range: K₁ ∈ [1, 50] <strong>K₂ Selection</strong>:</p></li>
<li><p>Sufficient condition: K₂ ≥ K₁·C (C depends on system)</p></li>
<li><p>Practical guideline: K₂ ≈ K₁ balances proportional/integral action</p></li>
<li><p>Too large K₂ → Oscillations, potential instability <strong>Tuning Strategy</strong>:</p></li>
</ul>
<ol class="arabic simple">
<li><p>Start with K₁ = 5, K₂ = 5</p></li>
<li><p>Increase K₁ if convergence is too slow</p></li>
<li><p>Adjust K₂ to balance integral action (typically K₂ ≈ K₁)</p></li>
<li><p>Use PSO optimization for fine-tuning <strong>Advantages</strong>:</p></li>
</ol>
<ul class="simple">
<li><p>Finite-time convergence</p></li>
<li><p>Continuous control (reduced chattering)</p></li>
<li><p>Robustness against matched uncertainties <strong>Disadvantages</strong>:</p></li>
<li><p>More complex tuning (2 gains vs 1 for classical)</p></li>
<li><p>Higher computational cost (square root, integration)</p></li>
</ul>
</section>
<hr class="docutils" />
<section id="adaptive-smc-theory-4-1-motivation-and-problem-statement-challenge-classical-smc-requires-prior-knowledge-of-disturbance-bounds-k-d-in-practice">
<h2>4. Adaptive SMC Theory ### 4.1 Motivation and Problem Statement <strong>Challenge</strong>: Classical SMC requires prior knowledge of disturbance bounds (K &gt; ||d||∞). In practice:<a class="headerlink" href="#adaptive-smc-theory-4-1-motivation-and-problem-statement-challenge-classical-smc-requires-prior-knowledge-of-disturbance-bounds-k-d-in-practice" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>Disturbance bounds may be unknown</p></li>
<li><p>Conservative estimates lead to excessive control effort</p></li>
<li><p>Time-varying disturbances require adaptive response <strong>Solution</strong>: Adaptive SMC adjusts the switching gain K(t) online based on observed sliding surface magnitude. <strong>Advantages</strong>:</p></li>
<li><p>No need for disturbance bound knowledge a priori</p></li>
<li><p>Avoids overly conservative gains</p></li>
<li><p>Maintains robustness to unknown disturbances ### 4.2 Adaptation Law <strong>Piecewise Adaptation with Dead Zone</strong>: ```
K̇(t) = { γ|σ|, if |σ| &gt; δ (outside dead zone - adaptation active) -αK, if |σ| ≤ δ (inside dead zone - leak prevents windup)
}</p></li>
</ul>
<div class="highlight-**Parameters**: notranslate"><div class="highlight"><pre><span></span>
- **γ &gt; 0**: Adaptation rate (how fast K grows)
- **δ &gt; 0**: Dead zone width (noise tolerance threshold)
- **α ≥ 0**: Leak rate (prevents unbounded growth) **Bounded Adaptation**:
</pre></div>
</div>
<p>K_min ≤ K(t) ≤ K_max</p>
<div class="highlight-**Rate notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<p>|K̇| ≤ Γ_max</p>
<div class="highlight-**Rationale**: notranslate"><div class="highlight"><pre><span></span>
- **Outside dead zone** (|σ| &gt; δ): System is far from sliding surface → increase gain to dominate disturbances
- **Inside dead zone** (|σ| ≤ δ): Near sliding surface → hold or decay gain to prevent noise-induced windup
- **Leak term** (-αK): Prevents indefinite growth, allows gain to decrease when disturbances subside
- **Bounds**: Safety constraints prevent numerical issues and actuator saturation ### 4.3 Lyapunov Stability with Adaptation **Extended Lyapunov Function**: ```
V = ½σ² + 1/(2γ)(K - K*)²
``` where K* is the ideal (unknown) switching gain that would perfectly dominate disturbances. **Proof of Bounded Adaptation and Convergence**: 1. **Positive Definiteness**: V ≥ 0 for all (σ, K) ✓ 2. **Time Derivative**: ``` V̇ = σσ̇ + 1/γ·(K - K*)·K̇ ``` 3. **Substitute Control Law**: u = u_eq - K·sat(σ/ε) ``` σσ̇ = σ(L·M⁻¹·B·(-K·sat(σ/ε) + d)) ``` Assuming |σ| &gt; ε (outside boundary layer): ``` σσ̇ = σ(-K·sign(σ) + d) = -K|σ| + σd ``` 4. **Substitute Adaptation Law**: K̇ = γ|σ| when |σ| &gt; δ ``` V̇ = (-K|σ| + σd) + (K - K*)|σ| = -K|σ| + σd + K|σ| - K*|σ| = σd - K*|σ| ``` 5. **Bound Using Disturbance Magnitude**: ``` V̇ ≤ ||d||∞|σ| - K*|σ| = (||d||∞ - K*)|σ| ``` 6. **Negative Definiteness**: Since K* &gt; ||d||∞ by definition: ``` V̇ ≤ -η|σ| where η = K* - ||d||∞ &gt; 0 ``` 7. **Conclusion**: - V̇ &lt; 0 whenever |σ| &gt; δ → σ converges to dead zone - (K - K*)² remains bounded → K remains bounded - Inside dead zone: leak term prevents unbounded growth **Key Result**: Both σ → 0 and K remains bounded, ensuring stable adaptation without prior knowledge of ||d||∞. ### 4.4 Dead Zone Trade-offs **Benefits**:
- Prevents chattering from sensor noise
- Avoids gain windup in steady state
- Reduces control effort when near equilibrium
- Allows adaptation to focus on significant errors **Drawbacks**:
- Introduces small steady-state error (|σ| ≤ δ)
- Slows convergence near sliding surface
- Requires tuning of δ **Optimal Sizing**: δ ≈ 2-3× sensor noise magnitude **Leak Rate Selection**:
- **Small α** (α ≈ 10⁻³): Slow decay, maintains gain for persistent disturbances
- **Large α** (α ≈ 10⁻¹): Fast decay, quickly forgets past disturbances **Practical Guidelines**:
- Start with δ = 0.01, α = 0.001
- Increase δ if chattering persists despite adaptation
- Increase α if gain grows excessively during transients

---

## 5. Hybrid Adaptive STA-SMC Theory ### 5.1 Unified Sliding Surface The hybrid controller combines the adaptive law with the super-twisting algorithm using a **single sliding surface** that captures both pendulum dynamics and cart recentering. **Absolute Formulation** (default): ```
σ = c₁(θ̇₁ + λ₁θ₁) + c₂(θ̇₂ + λ₂θ₂) + k_c(ẋ + λ_c x)
``` **Relative Formulation** (optional, `use_relative_surface=True`): ```

σ = c₁(θ̇₁ + λ₁θ₁) + c₂((θ̇₂-θ̇₁) + λ₂(θ₂-θ₁)) + k_c(ẋ + λ_c x)
``` **Design Principles**:
- **Positive Coefficients**: cᵢ, λᵢ, k_c, λ_c &gt; 0 (Hurwitz stability requirement)
- **Cart Recentering**: k_c, λ_c terms encourage cart to return to center
- **Relative Formulation**: Improves decoupling between pendulums but complicates analysis **Stability Condition**: All coefficients must be positive to ensure the sliding manifold is attractive and defines a stable reduced-order error surface. ### 5.2 Combined Super-Twisting with Adaptive Gains **Control Law**: ```
u = -k₁(t)√|σ|·sat(σ) + u_int - k_d·σ + u_eq
``` where:

- **k₁(t), k₂(t)**: Adaptive gains (time-varying)
- **u_int**: Integral term satisfying u̇_int = -k₂(t)·sat(σ)
- **k_d**: Damping gain (fixed)
- **u_eq**: Equivalent control (model-based feedforward) **Adaptive Law for Both Gains**: ```
k̇ᵢ(t) = { γᵢ|σ|·τ(σ), if |σ| &gt; δ -leak, otherwise
}
``` **Self-Tapering Function**: ```
τ(σ) = |σ|/(|σ| + ε_taper)
``` **Properties**:

- τ(σ) → 1 as |σ| → ∞ (full adaptation when far from surface)
- τ(σ) → 0 as |σ| → 0 (adaptation slows near surface)
- Prevents overshoot and oscillation as σ → 0 **Bounded Adaptation**:
</pre></div>
</div>
<p>0 ≤ k₁(t) ≤ k₁_max
0 ≤ k₂(t) ≤ k₂_max
|u_int| ≤ u_int_max
<code class="docutils literal notranslate"><span class="pre">Separating</span> <span class="pre">integral</span> <span class="pre">windup</span> <span class="pre">limit</span> <span class="pre">from</span> <span class="pre">actuator</span> <span class="pre">saturation</span> <span class="pre">ensures</span> <span class="pre">adaptation</span> <span class="pre">can</span> <span class="pre">proceed</span> <span class="pre">even</span> <span class="pre">when</span> <span class="pre">actuator</span> <span class="pre">saturates.</span> <span class="pre">###</span> <span class="pre">5.3</span> <span class="pre">Lyapunov</span> <span class="pre">Analysis</span> <span class="pre">**Composite</span> <span class="pre">Lyapunov</span> <span class="pre">Function**:</span></code></p>
<p>V = k₁|σ|^(3/2) + ½z² + 1/(2γ₁)(k₁ - k₁*)² + 1/(2γ₂)(k₂ - k₂*)²
<code class="docutils literal notranslate"><span class="pre">**Proof</span> <span class="pre">Sketch**:</span> <span class="pre">1.</span> <span class="pre">**Combines</span> <span class="pre">STA</span> <span class="pre">and</span> <span class="pre">Adaptive</span> <span class="pre">Terms**:</span> <span class="pre">-</span> <span class="pre">First</span> <span class="pre">two</span> <span class="pre">terms:</span> <span class="pre">STA</span> <span class="pre">Lyapunov</span> <span class="pre">function</span> <span class="pre">(finite-time</span> <span class="pre">convergence)</span> <span class="pre">-</span> <span class="pre">Last</span> <span class="pre">two</span> <span class="pre">terms:</span> <span class="pre">Adaptive</span> <span class="pre">parameter</span> <span class="pre">error</span> <span class="pre">(bounded</span> <span class="pre">adaptation)</span> <span class="pre">2.</span> <span class="pre">**Time</span> <span class="pre">Derivative</span> <span class="pre">Analysis**:</span></code> V̇ = (∂V/∂σ)σ̇ + (∂V/∂z)ż + (∂V/∂k₁)k̇₁ + (∂V/∂k₂)k̇₂ <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Substitute</span> <span class="pre">Dynamics**:</span> <span class="pre">-</span> <span class="pre">σ̇</span> <span class="pre">from</span> <span class="pre">STA</span> <span class="pre">control</span> <span class="pre">law</span> <span class="pre">with</span> <span class="pre">adaptive</span> <span class="pre">gains</span> <span class="pre">-</span> <span class="pre">ż</span> <span class="pre">=</span> <span class="pre">-k₂(t)·sign(σ)</span> <span class="pre">-</span> <span class="pre">k̇₁,</span> <span class="pre">k̇₂</span> <span class="pre">from</span> <span class="pre">adaptation</span> <span class="pre">law</span> <span class="pre">with</span> <span class="pre">self-tapering</span> <span class="pre">4.</span> <span class="pre">**Negative</span> <span class="pre">Definiteness**:</span> <span class="pre">Under</span> <span class="pre">appropriate</span> <span class="pre">gain</span> <span class="pre">conditions</span> <span class="pre">(k₁</span> <span class="pre">&gt;</span> <span class="pre">L,</span> <span class="pre">k₂</span> <span class="pre">&gt;</span> <span class="pre">k₁·C):</span></code> V̇ ≤ -β·V^(1/2) for some β &gt; 0 ``` 5. <strong>Key Results</strong>: - <strong>Finite-time convergence</strong>: σ → 0 in finite time T ≤ 2V(0)^(1/2)/β - <strong>Bounded gains</strong>: k₁(t), k₂(t) remain in [0, k_max] - <strong>Unknown disturbances</strong>: No prior knowledge of ||d||∞ required ### 5.4 Advantages and Complexity <strong>Advantages</strong>:</p>
<ul class="simple">
<li><p><strong>Finite-time convergence</strong> (from STA)</p></li>
<li><p><strong>Continuous control</strong> (low chattering from STA)</p></li>
<li><p><strong>Adaptive to unknown disturbances</strong> (from adaptation)</p></li>
<li><p><strong>Single sliding surface</strong> (simpler than dual-surface designs)</p></li>
<li><p><strong>Cart recentering</strong> (unified treatment of cart and pendulum dynamics) <strong>Complexity</strong>:</p></li>
<li><p><strong>More parameters to tune</strong>: c₁, λ₁, c₂, λ₂, k_c, λ_c, γ₁, γ₂, δ, ε_taper, k_d, …</p></li>
<li><p><strong>Higher computational cost</strong>: Square root, integral update, adaptation law</p></li>
<li><p><strong>Careful tuning required</strong>: PSO optimization recommended <strong>Recommended Use Cases</strong>:</p></li>
<li><p>Complex, highly coupled systems (✓ double-inverted pendulum)</p></li>
<li><p>High uncertainty environments</p></li>
<li><p>Research applications requiring maximum performance</p></li>
<li><p>Systems needing finite-time convergence with minimal chattering</p></li>
</ul>
</section>
<hr class="docutils" />
<section id="convergence-analysis-comparison-6-1-convergence-rate-summary-controller-convergence-type-rate-time-to-surface-steady-state-error">
<h2>6. Convergence Analysis Comparison ### 6.1 Convergence Rate Summary | Controller | Convergence Type | Rate | Time to Surface | Steady-State Error |<a class="headerlink" href="#convergence-analysis-comparison-6-1-convergence-rate-summary-controller-convergence-type-rate-time-to-surface-steady-state-error" title="Link to this heading">¶</a></h2>
<p>|———–|——————|——|—————–|——————-|
| <strong>Classical SMC</strong> | Asymptotic | Exponential: O(e^(-ηt)) | Infinite (theoretically) | Bounded by ε (boundary layer) |
| <strong>Adaptive SMC</strong> | Asymptotic | Exponential: O(e^(-ηt)) | Infinite (theoretically) | Zero (if no dead zone) or bounded by δ |
| <strong>STA SMC</strong> | Finite-time | O(t^(1/2)) | T ≤ 2|σ₀|^(1/2)/K₁^(1/2) | Zero (exact convergence) |
| <strong>Hybrid SMC</strong> | Finite-time | O(t^(1/2)) | T ≤ 2|σ₀|^(1/2)/k₁(0)^(1/2) | Zero (exact convergence) | ### 6.2 Mathematical Definitions <strong>Exponential Convergence</strong>: ```
|σ(t)| ≤ Ce^(-ηt)|σ(0)|</p>
<div class="highlight-- notranslate"><div class="highlight"><pre><span></span>
- **Practical convergence**: Reaches ε-neighborhood quickly
- **Advantage**: Simple analysis, well-understood
- **Disadvantage**: Technically never achieves perfect tracking **Finite-Time Convergence**: ```
∃ T &lt; ∞ : σ(t) = 0 for all t ≥ T
``` - **Exact convergence** in finite time T
- **Requires higher-order sliding modes** (e.g., STA)
- **Advantage**: Exact tracking after convergence time
- **Disadvantage**: More complex control law, higher computational cost ### 6.3 Convergence Time Bounds **Classical SMC** (95% settling time): ```
t_95% ≈ 3/η where η = K - ||d||∞
``` **STA SMC**: ```

T_reach ≤ 2|σ(0)|^(1/2)/(K₁^(1/2))
``` For typical initial condition |σ(0)| = 1.0 and K₁ = 25:
</pre></div>
</div>
<p>T_reach ≤ 2·1.0^(1/2)/25^(1/2) = 2/5 = 0.4 seconds</p>
<div class="highlight-**Practical notranslate"><div class="highlight"><pre><span></span>- **STA converges faster** for large initial errors
- **Classical SMC** can be competitive with well-tuned gains
- **Adaptive SMC** convergence time depends on adaptation rate ### 6.4 Phase Portrait Analysis **Classical SMC**:
- Spiral approach to σ = 0 line in (σ, σ̇) plane
- Exponential decay of both σ and σ̇
- Never reaches origin exactly **STA SMC**:
- Direct finite-time reach to origin in (σ, σ̇) plane
- Both σ and σ̇ reach zero simultaneously
- Twisting motion around origin during convergence **Adaptive SMC**:
- Spiral approach with varying damping (due to adaptive gain)
- Convergence rate changes as K(t) evolves
- Dead zone creates limit cycle around origin **Hybrid SMC**:
- Direct finite-time reach with adaptive rate
- Combines advantages of STA (finite-time) and adaptive (robustness)
- Self-tapering prevents overshoot near origin

---

## 7. Numerical Considerations ### 7.1 Matrix Regularization **Problem**: The inertia matrix M(q) can become ill-conditioned near singular configurations, leading to large rounding errors in inversion. **Tikhonov Regularization**: ```
M_reg = M(q) + αI, α &gt; 0
``` **Benefits**:

- Prevents singularity when det(M) ≈ 0
- Shifts eigenvalues: λᵢ → λᵢ + α (all eigenvalues become ≥ α)
- Converts nearly-singular matrix to well-conditioned **Trade-off**: Introduces small approximation error in equivalent control **Typical Value**: α = 10⁻⁸ to 10⁻⁶ **Mathematical Justification**: Adding a positive constant to the diagonal of a symmetric matrix shifts all eigenvalues upward, converting an indefinite or singular matrix into a positive-definite one. ### 7.2 Condition Number Monitoring **Definition**: ```
κ(M) = ||M|| · ||M⁻¹||
``` **Thresholds**:
- **κ &lt; 10³**: Well-conditioned (safe for direct inversion)
- **10³ &lt; κ &lt; 10⁶**: Moderate conditioning (use with caution)
- **κ &gt; 10⁶**: Ill-conditioned → **use pseudo-inverse** **Pseudo-Inverse**: ```
M⁺ = (MᵀM + αI)⁻¹Mᵀ (Moore-Penrose pseudo-inverse)
``` - Provides least-squares solution

- Minimizes effect of noise
- More robust than direct inversion for ill-conditioned systems **Implementation**:
```python
if np.linalg.cond(M) &gt; 1e6: M_inv = np.linalg.pinv(M) # Use pseudo-inverse
else: M_inv = np.linalg.inv(M) # Direct inversion safe
``` ### 7.3 Discrete-Time Implementation **Euler Integration** (for adaptive gains and STA integral): ```

u_int(k+1) = u_int(k) - K₂·sign(σ(k))·dt
K(k+1) = K(k) + γ|σ(k)|·dt
``` **Sampling Effects**:
- **dt too large** → Discrete chattering (control jumps between bounds)
- **dt too small** → Computational cost increases, numerical precision issues
- **Recommended**: dt ≤ 0.01s for DIP system **Discrete Chattering**: When dt is large relative to system dynamics, the control oscillates between saturation limits even though σ ≈ 0. Solution: Reduce dt or increase boundary layer ε. ### 7.4 Numerical Stability Checks **Implementation Safeguards**: 1. **Finite Value Checking**: ```python if not np.isfinite(u): u = 0.0 # Emergency fallback log_error(&quot;Non-finite control value detected&quot;) ``` 2. **Controllability Check**: ```python controllability = abs(L @ M_inv @ B) if controllability &lt; ε_threshold: # System near uncontrollable configuration u_eq = 0.0 # Disable equivalent control ``` Typical threshold: ε_threshold = 10⁻⁴ 3. **Actuator Saturation**: ```python u_sat = np.clip(u, -max_force, max_force) ``` 4. **Emergency Reset**: ```python if state_norm &gt; 10.0 or velocity_norm &gt; 50.0: # System diverging - reset controller state u_int = 0.0 K = K_init ``` **Robustness Best Practices**:
- Always validate outputs before applying control
- Monitor condition numbers of matrix operations
- Implement fallback strategies for edge cases
- Log warnings for numerical issues without crashing

---

## 8. References ### Primary SMC References [1] **Utkin, V.I.** (1992). &quot;Sliding Modes in Control and Optimization&quot;. Springer-Verlag, Berlin. doi: 10.1007/978-3-642-84379-2
*Foundational text on SMC theory, sliding mode equations, and exponential stability.* [2] **Edwards, C. and Spurgeon, S.K.** (1998). &quot;Sliding Mode Control: Theory and Applications&quot;. CRC Press, Boca Raton, FL. ISBN: 978-0748406012
*Chapter 3: Sliding Surface Design - pole placement via surface parameters.* [3] **Slotine, J.-J.E. and Li, W.** (1991). &quot;Applied Nonlinear Control&quot;. Prentice Hall, Englewood Cliffs, NJ. ISBN: 0-13-040890-5
*Practical implementation of SMC for nonlinear systems.* ### Higher-Order SMC References [4] **Levant, A.** (2003). &quot;Higher-order sliding modes, differentiation and output-feedback control&quot;. International Journal of Control, 76(9-10):924-941. doi: 10.1080/0020717031000099029
*Foundations of higher-order sliding modes and super-twisting algorithms.* [5] **Levant, A.** (2007). &quot;Principles of 2-sliding mode design&quot;. Automatica, 43(4):576-586. doi: 10.1016/j.automatica.2006.10.008
*Systematic design methodology for second-order sliding modes.* [6] **Moreno, J.A. and Osorio, M.** (2012). &quot;Strict Lyapunov Functions for the Super-Twisting Algorithm&quot;. IEEE Transactions on Automatic Control, 57(4):1035-1040.
*Rigorous Lyapunov analysis proving finite-time convergence of STA.* ### Adaptive SMC References [7] **Yang, Y., Meng, M.Q.-H., and Tan, K.K.** (2007). &quot;Adaptive sliding mode control for uncertain systems&quot;. Automatica, 43(2):201-207.
*Online gain adaptation for unknown disturbance bounds.* [8] **Huang, J., Yao, B., and Tao, G.** (2008). &quot;Adaptive second-order sliding-mode control of nonlinear systems&quot;. IEEE Transactions on Automatic Control, 53(11):2689-2694.
*Combines adaptation with second-order sliding modes.* ### Chattering Reduction References [9] **Burton, J.A. and Zinober, A.S.I.** (1986). &quot;Continuous approximation of variable structure control&quot;. International Journal of Systems Science, 17(6):875-885. doi: 10.1080/00207728608926853
*Boundary layer theory for chattering reduction.* [10] **Utkin, V.I., Guldner, J., and Shi, J.** (2009). &quot;Sliding Mode Control in Electro-Mechanical Systems&quot; (2nd ed.). CRC Press, Boca Raton, FL. doi: 10.1201/9781420065619
*Practical techniques for chattering mitigation.* ### Control Theory Fundamentals [11] **Utkin, V.I.** (1977). &quot;Variable structure systems with sliding modes&quot;. IEEE Transactions on Automatic Control, 22(2):212-222.
*Seminal paper establishing sliding mode control theory.* [12] **Slotine, J.-J. and Sastry, S.** (1983). &quot;Tracking control of nonlinear systems using sliding surfaces&quot;. International Journal of Control, 38(2):465-492.
*Application of SMC to tracking problems.* [13] **Young, K.D., Utkin, V.I., and Özgüner, Ü.** (1999). &quot;A control engineer&#39;s guide to sliding mode control&quot;. IEEE Transactions on Control Systems Technology, 7(3):328-342. doi: 10.1109/87.761053
*Practical guide for implementing SMC in engineering applications.* ### Recent Advances [14] **Shtessel, Y., Edwards, C., Fridman, L., and Levant, A.** (2014). &quot;Sliding Mode Control and Observation&quot;. Birkhäuser, New York, NY. doi: 10.1007/978-0-8176-4893-0
*modern treatment of SMC and observation techniques.* [15] **Levant, A.** (1993). &quot;Sliding order and sliding accuracy in sliding mode control&quot;. International Journal of Control, 58(6):1247-1263. doi: 10.1080/00207179308923053
*Analysis of sliding accuracy and convergence properties.* ### Optimization and Tuning [16] **Messina, A., Lanzafame, R., and Tomarchio, S.** (2013). &quot;Multi-objective optimal tuning of sliding mode controllers by evolutionary algorithms&quot;. IEEE/ASME Transactions on Mechatronics, 18(5):1446-1454.
*PSO and evolutionary algorithms for SMC gain tuning.* ### Underactuated Systems [17] **Utkin, V.I.** (1993). &quot;Sliding mode control design principles and applications to electric drives&quot;. IEEE Transactions on Industrial Electronics, 40(1):23-36. doi: 10.1109/41.184818
*Application of SMC to underactuated mechanical systems.* [18] **Gong, Z., Ba, Y., Zhang, M., and Guo, Y.** (2022). &quot;Robust sliding mode control of the permanent magnet synchronous motor with an improved power reaching law&quot;. Energies, 15(5):1935.
*Modern applications of adaptive reaching laws.*

---

**Document Classification**: Research-Grade Mathematical Theory
**Maintenance**: Update when new SMC variants are added
**Next Review**: 2025-11-04
**Version History**: v1.0 (2025-10-04) - Initial theory document
</pre></div>
</div>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Research Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on Oct 10, 2025</div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Complete Sliding Mode Control Mathematical Theory</a><ul>
<li><a class="reference internal" href="#table-of-contents-1-introduction-and-fundamentals">Table of Contents 1. <span class="xref myst">Introduction and Fundamentals</span></a></li>
<li><a class="reference internal" href="#introduction-and-fundamentals-1-1-overview-the-double-inverted-pendulum-dip-is-a-canonical-benchmark-for-nonlinear-underactuated-control-systems-with-two-pendula-attached-in-series-to-a-horizontally-moving-cart-the-system-has-fewer-actuators-than-degrees-of-freedom-making-it-both-underactuated-and-strongly-nonlinear-conventional-linear-controllers-struggle-with-large-deflections-parameter-variations-and-model-uncertainty-sliding-mode-control-smc-addresses-these-challenges-by-forcing-the-system-state-onto-a-pre-defined-sliding-manifold-when-the-state-reaches-this-manifold-the-resulting-closed-loop-dynamics-become-insensitive-to-matched-disturbances-and-uncertainties-the-control-law-compensates-modeling-errors-through-the-control-input-channel-causing-the-plant-to-behave-according-to-the-reduced-order-dynamics-on-the-manifold-this-robustness-and-finite-time-convergence-for-higher-order-smc-make-smc-attractive-for-underactuated-systems-however-the-discontinuous-switching-law-of-classical-smc-induces-chattering-a-high-frequency-oscillation-caused-by-rapid-control-switching-when-the-state-crosses-the-sliding-surface-chattering-increases-control-effort-excites-unmodeled-high-frequency-modes-and-can-cause-wear-in-actuators-introducing-a-boundary-layer-around-the-sliding-surface-alleviates-chattering-but-enlarges-the-tracking-error-this-document-presents-the-unified-mathematical-theory-for-four-smc-variants-implemented-in-this-project">1. Introduction and Fundamentals ### 1.1 Overview The double-inverted pendulum (DIP) is a canonical benchmark for nonlinear, underactuated control systems. With two pendula attached in series to a horizontally moving cart, the system has fewer actuators than degrees of freedom, making it both <strong>underactuated</strong> and <strong>strongly nonlinear</strong>. Conventional linear controllers struggle with large deflections, parameter variations, and model uncertainty. Sliding Mode Control (SMC) addresses these challenges by forcing the system state onto a pre-defined <strong>sliding manifold</strong>. When the state reaches this manifold, the resulting closed-loop dynamics become insensitive to matched disturbances and uncertainties. The control law compensates modeling errors through the control input channel, causing the plant to behave according to the reduced-order dynamics on the manifold. This robustness and finite-time convergence (for higher-order SMC) make SMC attractive for underactuated systems. However, the discontinuous switching law of classical SMC induces <strong>chattering</strong>, a high-frequency oscillation caused by rapid control switching when the state crosses the sliding surface. Chattering increases control effort, excites unmodeled high-frequency modes, and can cause wear in actuators. Introducing a boundary layer around the sliding surface alleviates chattering but enlarges the tracking error. This document presents the unified mathematical theory for four SMC variants implemented in this project:</a></li>
<li><a class="reference internal" href="#adaptive-smc-theory-4-1-motivation-and-problem-statement-challenge-classical-smc-requires-prior-knowledge-of-disturbance-bounds-k-d-in-practice">4. Adaptive SMC Theory ### 4.1 Motivation and Problem Statement <strong>Challenge</strong>: Classical SMC requires prior knowledge of disturbance bounds (K &gt; ||d||∞). In practice:</a></li>
<li><a class="reference internal" href="#convergence-analysis-comparison-6-1-convergence-rate-summary-controller-convergence-type-rate-time-to-surface-steady-state-error">6. Convergence Analysis Comparison ### 6.1 Convergence Rate Summary | Controller | Convergence Type | Rate | Time to Surface | Steady-State Error |</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=4ebf8126"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=46bd48cc"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=08e7b316"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../_static/back-to-top.js?v=840797bb"></script>
    <script src="../_static/lazy-load.js?v=dc25293c"></script>
    <script src="../_static/dark-mode.js?v=bf328970"></script>
    </body>
</html>