<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
.chartjs-container {
    margin: 1.5em auto;
    padding: 1em;
    background: #f8f9fa;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.chart-note {
    text-align: center;
    color: #6c757d;
    font-size: 0.9em;
    margin-top: 0.5em;
}
</style>
<link rel="index" title="Index" href="../genindex.html"><link rel="search" title="Search" href="../search.html">

    <!-- Generated with Sphinx 8.2.3 and Furo 2025.09.25 -->
        <title>Mathematical Test Validation Methodology This document describes the methodology for validating mathematical properties and algorithm correctness in the SMC controller implementations. ## 1. Overview The test validation methodology ensures that all mathematical algorithms and fixes in the SMC system are rigorously validated through: - Property-based testing: Verification of mathematical properties - DIP_SMC_PSO Documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5349f25f" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=580074bf" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=8dab3a3b" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=8a7e329d" />
    
    


<style>
  body {
    --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">DIP_SMC_PSO Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  <span class="sidebar-brand-text">DIP_SMC_PSO Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">ğŸ“š Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Optimal Sliding Mode Control for a Double-Inverted Pendulum via PSO  ## How to validate a ResearchPlan JSON Run the validator locally: ```bash</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory_overview.html">Theory Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../architecture.html">3. System Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plant_model.html">1.x Plant Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hil_quickstart.html">Hardware-in-the-Loop (HIL) Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../streamlit_dashboard_guide.html">Streamlit Dashboard User Guide</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/blob/main/docs/mathematical_foundations/test_validation_methodology.md?plain=true" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div><div class="edit-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/edit/main/docs/mathematical_foundations/test_validation_methodology.md" rel="edit" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section class="tex2jax_ignore mathjax_ignore" id="mathematical-test-validation-methodology-this-document-describes-the-methodology-for-validating-mathematical-properties-and-algorithm-correctness-in-the-smc-controller-implementations-1-overview-the-test-validation-methodology-ensures-that-all-mathematical-algorithms-and-fixes-in-the-smc-system-are-rigorously-validated-through-property-based-testing-verification-of-mathematical-properties">
<h1>Mathematical Test Validation Methodology This document describes the methodology for validating mathematical properties and algorithm correctness in the SMC controller implementations. ## 1. Overview The test validation methodology ensures that all mathematical algorithms and fixes in the SMC system are rigorously validated through: - <strong>Property-based testing</strong>: Verification of mathematical properties<a class="headerlink" href="#mathematical-test-validation-methodology-this-document-describes-the-methodology-for-validating-mathematical-properties-and-algorithm-correctness-in-the-smc-controller-implementations-1-overview-the-test-validation-methodology-ensures-that-all-mathematical-algorithms-and-fixes-in-the-smc-system-are-rigorously-validated-through-property-based-testing-verification-of-mathematical-properties" title="Link to this heading">Â¶</a></h1>
<ul class="simple">
<li><p><strong>Numerical validation</strong>: Accuracy and stability testing</p></li>
<li><p><strong>Algorithm verification</strong>: Correctness of mathematical computations</p></li>
<li><p><strong>Edge case testing</strong>: Robustness under extreme conditions</p></li>
<li><p><strong>Integration testing</strong>: System-level mathematical consistency ## 2. Test Categories and Structure ### 2.1 Mathematical Property Tests These tests verify that implementations satisfy fundamental mathematical requirements. #### 2.1.1 Sliding Surface Properties <strong>Test Suite:</strong> <code class="docutils literal notranslate"><span class="pre">tests/test_controllers/smc/core/test_sliding_surface.py</span></code> <strong>Mathematical Properties Validated:</strong> 1. <strong>Linearity Property</strong>: ```python</p></li>
</ul>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="example-metadata">
<h1>example-metadata:<a class="headerlink" href="#example-metadata" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-def-test-sliding-surface-linearity-test-that-sliding-surface-is-linear-in-state-surface-linearslidingsurface-gains-5-3-4-2-state1-np-array-0-1-0-1-0-1-0-05-0-05-0-05-state2-np-array-0-2-0-2-0-2-0-1-0-1-0-1-s1-surface-compute-state1-s2-surface-compute-state2-s-combined-surface-compute-state1-state2-linearity-s-x1-x2-s-x1-s-x2-assert-abs-s-combined-s1-s2-1e-10-2-homogeneity-property-python-def-test-sliding-surface-homogeneity-test-that-sliding-surface-is-homogeneous-of-degree-1-surface-linearslidingsurface-gains-5-3-4-2-state-np-array-0-1-0-1-0-1-0-05-0-05-0-05-alpha-2-5-s-original-surface-compute-state-s-scaled-surface-compute-alpha-state-homogeneity-s-x-s-x-assert-abs-s-scaled-alpha-s-original-1e-10-3-gain-sensitivity-python">
<h1>runnable: false def test_sliding_surface_linearity(): â€œâ€â€Test that sliding surface is linear in state.â€â€â€ surface = LinearSlidingSurface(gains=[5, 3, 4, 2]) state1 = np.array([0.1, 0.1, 0.1, 0.05, 0.05, 0.05]) state2 = np.array([0.2, 0.2, 0.2, 0.1, 0.1, 0.1]) s1 = surface.compute(state1) s2 = surface.compute(state2) s_combined = surface.compute(state1 + state2) # Linearity: s(x1 + x2) = s(x1) + s(x2) assert abs(s_combined - (s1 + s2)) &lt; 1e-10 <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Homogeneity</span> <span class="pre">Property**:</span></code>python def test_sliding_surface_homogeneity(): â€œâ€â€Test that sliding surface is homogeneous of degree 1.â€â€â€ surface = LinearSlidingSurface(gains=[5, 3, 4, 2]) state = np.array([0.1, 0.1, 0.1, 0.05, 0.05, 0.05]) alpha = 2.5 s_original = surface.compute(state) s_scaled = surface.compute(alpha * state) # Homogeneity: s(Î±Â·x) = Î±Â·s(x) assert abs(s_scaled - alpha * s_original) &lt; 1e-10 <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Gain</span> <span class="pre">Sensitivity**:</span></code>python<a class="headerlink" href="#runnable-false-def-test-sliding-surface-linearity-test-that-sliding-surface-is-linear-in-state-surface-linearslidingsurface-gains-5-3-4-2-state1-np-array-0-1-0-1-0-1-0-05-0-05-0-05-state2-np-array-0-2-0-2-0-2-0-1-0-1-0-1-s1-surface-compute-state1-s2-surface-compute-state2-s-combined-surface-compute-state1-state2-linearity-s-x1-x2-s-x1-s-x2-assert-abs-s-combined-s1-s2-1e-10-2-homogeneity-property-python-def-test-sliding-surface-homogeneity-test-that-sliding-surface-is-homogeneous-of-degree-1-surface-linearslidingsurface-gains-5-3-4-2-state-np-array-0-1-0-1-0-1-0-05-0-05-0-05-alpha-2-5-s-original-surface-compute-state-s-scaled-surface-compute-alpha-state-homogeneity-s-x-s-x-assert-abs-s-scaled-alpha-s-original-1e-10-3-gain-sensitivity-python" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1>example-metadata:<a class="headerlink" href="#id1" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-def-test-sliding-surface-gain-sensitivity-test-that-surface-responds-correctly-to-gain-changes-gains1-5-3-4-2-gains2-10-6-8-4-doubled-gains-surface1-linearslidingsurface-gains1-surface2-linearslidingsurface-gains2-state-np-array-0-1-0-1-0-1-0-05-0-05-0-05-s1-surface1-compute-state-s2-surface2-compute-state-surface-value-should-double-with-doubled-gains-assert-abs-s2-2-s1-1e-10-2-1-2-boundary-layer-properties-test-suite-tests-test-controllers-smc-algorithms-classical-test-boundary-layer-py-mathematical-properties-validated-1-continuity-python">
<h1>runnable: false def test_sliding_surface_gain_sensitivity(): â€œâ€â€Test that surface responds correctly to gain changes.â€â€â€ gains1 = [5, 3, 4, 2] gains2 = [10, 6, 8, 4] # Doubled gains surface1 = LinearSlidingSurface(gains1) surface2 = LinearSlidingSurface(gains2) state = np.array([0.1, 0.1, 0.1, 0.05, 0.05, 0.05]) s1 = surface1.compute(state) s2 = surface2.compute(state) # Surface value should double with doubled gains assert abs(s2 - 2 * s1) &lt; 1e-10 <code class="docutils literal notranslate"><span class="pre">####</span> <span class="pre">2.1.2</span> <span class="pre">Boundary</span> <span class="pre">Layer</span> <span class="pre">Properties</span> <span class="pre">**Test</span> <span class="pre">Suite:**</span> <span class="pre">`tests/test_controllers/smc/algorithms/classical/test_boundary_layer.py`</span> <span class="pre">**Mathematical</span> <span class="pre">Properties</span> <span class="pre">Validated:**</span> <span class="pre">1.</span> <span class="pre">**Continuity**:</span></code>python<a class="headerlink" href="#runnable-false-def-test-sliding-surface-gain-sensitivity-test-that-surface-responds-correctly-to-gain-changes-gains1-5-3-4-2-gains2-10-6-8-4-doubled-gains-surface1-linearslidingsurface-gains1-surface2-linearslidingsurface-gains2-state-np-array-0-1-0-1-0-1-0-05-0-05-0-05-s1-surface1-compute-state-s2-surface2-compute-state-surface-value-should-double-with-doubled-gains-assert-abs-s2-2-s1-1e-10-2-1-2-boundary-layer-properties-test-suite-tests-test-controllers-smc-algorithms-classical-test-boundary-layer-py-mathematical-properties-validated-1-continuity-python" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id2">
<h1>example-metadata:<a class="headerlink" href="#id2" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-def-test-boundary-layer-continuity-test-that-boundary-layer-provides-continuous-switching-boundary-layer-boundarylayer-thickness-0-1-switch-method-tanh-test-continuity-at-surface-s-0-epsilon-1e-8-switch-left-boundary-layer-compute-switching-function-epsilon-switch-right-boundary-layer-compute-switching-function-epsilon-switch-center-boundary-layer-compute-switching-function-0-0-values-should-be-very-close-at-the-boundary-assert-abs-switch-left-switch-center-1e-6-assert-abs-switch-right-switch-center-1e-6-2-monotonicity-python-def-test-boundary-layer-monotonicity-test-that-switching-function-is-monotonic-boundary-layer-boundarylayer-thickness-0-1-switch-method-tanh-s-values-np-linspace-1-1-100-switch-values-boundary-layer-compute-switching-function-s-for-s-in-s-values-switching-function-should-be-strictly-increasing-for-i-in-range-len-switch-values-1-assert-switch-values-i-1-switch-values-i-3-asymptotic-behavior-python-def-test-boundary-layer-asymptotic-behavior-test-asymptotic-limits-of-switching-function-boundary-layer-boundarylayer-thickness-0-1-switch-method-tanh-large-positive-surface-value-switch-pos-boundary-layer-compute-switching-function-10-0-assert-abs-switch-pos-1-0-1e-3-large-negative-surface-value-switch-neg-boundary-layer-compute-switching-function-10-0-assert-abs-switch-neg-1-0-1e-3-2-2-configuration-validation-tests-test-suite-tests-test-controllers-smc-algorithms-classical-test-config-validation-py-2-2-1-parameter-validationpython">
<h1>runnable: false def test_boundary_layer_continuity(): â€œâ€â€Test that boundary layer provides continuous switching.â€â€â€ boundary_layer = BoundaryLayer(thickness=0.1, switch_method=â€tanhâ€) # Test continuity at surface (s=0) epsilon = 1e-8 switch_left = boundary_layer.compute_switching_function(-epsilon) switch_right = boundary_layer.compute_switching_function(epsilon) switch_center = boundary_layer.compute_switching_function(0.0) # Values should be very close at the boundary assert abs(switch_left - switch_center) &lt; 1e-6 assert abs(switch_right - switch_center) &lt; 1e-6 <code class="docutils literal notranslate"><span class="pre">2.</span> <span class="pre">**Monotonicity**:</span></code>python def test_boundary_layer_monotonicity(): â€œâ€â€Test that switching function is monotonic.â€â€â€ boundary_layer = BoundaryLayer(thickness=0.1, switch_method=â€tanhâ€) s_values = np.linspace(-1, 1, 100) switch_values = [boundary_layer.compute_switching_function(s) for s in s_values] # Switching function should be strictly increasing for i in range(len(switch_values) - 1): assert switch_values[i+1] &gt;= switch_values[i] <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">**Asymptotic</span> <span class="pre">Behavior**:</span></code>python def test_boundary_layer_asymptotic_behavior(): â€œâ€â€Test asymptotic limits of switching function.â€â€â€ boundary_layer = BoundaryLayer(thickness=0.1, switch_method=â€tanhâ€) # Large positive surface value switch_pos = boundary_layer.compute_switching_function(10.0) assert abs(switch_pos - 1.0) &lt; 1e-3 # Large negative surface value switch_neg = boundary_layer.compute_switching_function(-10.0) assert abs(switch_neg - (-1.0)) &lt; 1e-3 <code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">2.2</span> <span class="pre">Configuration</span> <span class="pre">Validation</span> <span class="pre">Tests</span> <span class="pre">**Test</span> <span class="pre">Suite:**</span> <span class="pre">`tests/test_controllers/smc/algorithms/classical/test_config_validation.py`</span> <span class="pre">####</span> <span class="pre">2.2.1</span> <span class="pre">Parameter</span> <span class="pre">Validation</span></code>python<a class="headerlink" href="#runnable-false-def-test-boundary-layer-continuity-test-that-boundary-layer-provides-continuous-switching-boundary-layer-boundarylayer-thickness-0-1-switch-method-tanh-test-continuity-at-surface-s-0-epsilon-1e-8-switch-left-boundary-layer-compute-switching-function-epsilon-switch-right-boundary-layer-compute-switching-function-epsilon-switch-center-boundary-layer-compute-switching-function-0-0-values-should-be-very-close-at-the-boundary-assert-abs-switch-left-switch-center-1e-6-assert-abs-switch-right-switch-center-1e-6-2-monotonicity-python-def-test-boundary-layer-monotonicity-test-that-switching-function-is-monotonic-boundary-layer-boundarylayer-thickness-0-1-switch-method-tanh-s-values-np-linspace-1-1-100-switch-values-boundary-layer-compute-switching-function-s-for-s-in-s-values-switching-function-should-be-strictly-increasing-for-i-in-range-len-switch-values-1-assert-switch-values-i-1-switch-values-i-3-asymptotic-behavior-python-def-test-boundary-layer-asymptotic-behavior-test-asymptotic-limits-of-switching-function-boundary-layer-boundarylayer-thickness-0-1-switch-method-tanh-large-positive-surface-value-switch-pos-boundary-layer-compute-switching-function-10-0-assert-abs-switch-pos-1-0-1e-3-large-negative-surface-value-switch-neg-boundary-layer-compute-switching-function-10-0-assert-abs-switch-neg-1-0-1e-3-2-2-configuration-validation-tests-test-suite-tests-test-controllers-smc-algorithms-classical-test-config-validation-py-2-2-1-parameter-validationpython" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id3">
<h1>example-metadata:<a class="headerlink" href="#id3" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-class-testclassicalsmcconfigvalidation-test-configuration-parameter-validation-def-test-positive-gain-requirement-self-test-that-all-surface-gains-must-be-positive-valid-configuration-valid-gains-5-0-3-0-4-0-2-0-10-0-1-0-config-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-01-invalid-zero-gain-with-pytest-raises-valueerror-match-must-be-positive-invalid-gains-0-0-3-0-4-0-2-0-10-0-1-0-classicalsmcconfig-gains-invalid-gains-max-force-100-dt-0-01-boundary-layer-0-01-invalid-negative-gain-with-pytest-raises-valueerror-match-must-be-positive-invalid-gains-5-0-3-0-4-0-2-0-10-0-1-0-classicalsmcconfig-gains-invalid-gains-max-force-100-dt-0-01-boundary-layer-0-01-def-test-switching-gain-validation-self-test-switching-gain-must-be-positive-with-pytest-raises-valueerror-match-switching-gain-k-must-be-positive-invalid-gains-5-0-3-0-4-0-2-0-10-0-1-0-k-0-classicalsmcconfig-gains-invalid-gains-max-force-100-dt-0-01-boundary-layer-0-01-def-test-boundary-layer-validation-self-test-boundary-layer-thickness-validation-valid-boundary-layer-valid-gains-5-0-3-0-4-0-2-0-10-0-1-0-config-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-05-invalid-zero-boundary-layer-with-pytest-raises-valueerror-match-boundary-layer-must-be-positive-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-0-invalid-negative-boundary-layer-with-pytest-raises-valueerror-match-boundary-layer-must-be-positive-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-01">
<h1>runnable: false class TestClassicalSMCConfigValidation: â€œâ€â€Test configuration parameter validation.â€â€â€ def test_positive_gain_requirement(self): â€œâ€â€Test that all surface gains must be positive.â€â€â€ # Valid configuration valid_gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] config = ClassicalSMCConfig(gains=valid_gains, max_force=100, dt=0.01, boundary_layer=0.01) # Invalid: zero gain with pytest.raises(ValueError, match=â€must be positiveâ€): invalid_gains = [0.0, 3.0, 4.0, 2.0, 10.0, 1.0] ClassicalSMCConfig(gains=invalid_gains, max_force=100, dt=0.01, boundary_layer=0.01) # Invalid: negative gain with pytest.raises(ValueError, match=â€must be positiveâ€): invalid_gains = [5.0, -3.0, 4.0, 2.0, 10.0, 1.0] ClassicalSMCConfig(gains=invalid_gains, max_force=100, dt=0.01, boundary_layer=0.01) def test_switching_gain_validation(self): â€œâ€â€Test switching gain must be positive.â€â€â€ with pytest.raises(ValueError, match=â€Switching gain K must be positiveâ€): invalid_gains = [5.0, 3.0, 4.0, 2.0, -10.0, 1.0] # K &lt; 0 ClassicalSMCConfig(gains=invalid_gains, max_force=100, dt=0.01, boundary_layer=0.01) def test_boundary_layer_validation(self): â€œâ€â€Test boundary layer thickness validation.â€â€â€ # Valid boundary layer valid_gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] config = ClassicalSMCConfig(gains=valid_gains, max_force=100, dt=0.01, boundary_layer=0.05) # Invalid: zero boundary layer with pytest.raises(ValueError, match=â€boundary_layer must be positiveâ€): ClassicalSMCConfig(gains=valid_gains, max_force=100, dt=0.01, boundary_layer=0.0) # Invalid: negative boundary layer with pytest.raises(ValueError, match=â€boundary_layer must be positiveâ€): ClassicalSMCConfig(gains=valid_gains, max_force=100, dt=0.01, boundary_layer=-0.01)<a class="headerlink" href="#runnable-false-class-testclassicalsmcconfigvalidation-test-configuration-parameter-validation-def-test-positive-gain-requirement-self-test-that-all-surface-gains-must-be-positive-valid-configuration-valid-gains-5-0-3-0-4-0-2-0-10-0-1-0-config-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-01-invalid-zero-gain-with-pytest-raises-valueerror-match-must-be-positive-invalid-gains-0-0-3-0-4-0-2-0-10-0-1-0-classicalsmcconfig-gains-invalid-gains-max-force-100-dt-0-01-boundary-layer-0-01-invalid-negative-gain-with-pytest-raises-valueerror-match-must-be-positive-invalid-gains-5-0-3-0-4-0-2-0-10-0-1-0-classicalsmcconfig-gains-invalid-gains-max-force-100-dt-0-01-boundary-layer-0-01-def-test-switching-gain-validation-self-test-switching-gain-must-be-positive-with-pytest-raises-valueerror-match-switching-gain-k-must-be-positive-invalid-gains-5-0-3-0-4-0-2-0-10-0-1-0-k-0-classicalsmcconfig-gains-invalid-gains-max-force-100-dt-0-01-boundary-layer-0-01-def-test-boundary-layer-validation-self-test-boundary-layer-thickness-validation-valid-boundary-layer-valid-gains-5-0-3-0-4-0-2-0-10-0-1-0-config-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-05-invalid-zero-boundary-layer-with-pytest-raises-valueerror-match-boundary-layer-must-be-positive-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-0-invalid-negative-boundary-layer-with-pytest-raises-valueerror-match-boundary-layer-must-be-positive-classicalsmcconfig-gains-valid-gains-max-force-100-dt-0-01-boundary-layer-0-01" title="Link to this heading">Â¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">####</span> <span class="pre">2.2.2</span> <span class="pre">Stability</span> <span class="pre">Analysis</span> <span class="pre">Tests</span></code>python</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id4">
<h1>example-metadata:<a class="headerlink" href="#id4" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-def-test-hurwitz-stability-check-test-that-gain-combinations-satisfy-hurwitz-stability-def-check-stability-k1-k2-lam1-lam2-check-if-gains-produce-stable-sliding-dynamics-for-each-2x2-subsystem-s2-is-ci-0-stability-requires-i-0-and-ci-0-return-k1-0-and-k2-0-and-lam1-0-and-lam2-0-stable-configuration-stable-gains-5-0-3-0-4-0-2-0-10-0-1-0-config-classicalsmcconfig-gains-stable-gains-max-force-100-dt-0-01-boundary-layer-0-01-assert-check-stability-config-k1-config-k2-config-lam1-config-lam2-check-damping-ratios-zeta1-config-lam1-2-np-sqrt-config-k1-zeta2-config-lam2-2-np-sqrt-config-k2-both-subsystems-should-have-positive-damping-assert-zeta1-0-assert-zeta2-0">
<h1>runnable: false def test_hurwitz_stability_check(): â€œâ€â€Test that gain combinations satisfy Hurwitz stability.â€â€â€ def check_stability(k1, k2, lam1, lam2): â€œâ€â€Check if gains produce stable sliding dynamics.â€â€â€ # For each 2x2 subsystem: sÂ² + Î»áµ¢s + cáµ¢ = 0 # Stability requires Î»áµ¢ &gt; 0 and cáµ¢ &gt; 0 return k1 &gt; 0 and k2 &gt; 0 and lam1 &gt; 0 and lam2 &gt; 0 # Stable configuration stable_gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] config = ClassicalSMCConfig(gains=stable_gains, max_force=100, dt=0.01, boundary_layer=0.01) assert check_stability(config.k1, config.k2, config.lam1, config.lam2) # Check damping ratios zeta1 = config.lam1 / (2 * np.sqrt(config.k1)) zeta2 = config.lam2 / (2 * np.sqrt(config.k2)) # Both subsystems should have positive damping assert zeta1 &gt; 0 assert zeta2 &gt; 0<a class="headerlink" href="#runnable-false-def-test-hurwitz-stability-check-test-that-gain-combinations-satisfy-hurwitz-stability-def-check-stability-k1-k2-lam1-lam2-check-if-gains-produce-stable-sliding-dynamics-for-each-2x2-subsystem-s2-is-ci-0-stability-requires-i-0-and-ci-0-return-k1-0-and-k2-0-and-lam1-0-and-lam2-0-stable-configuration-stable-gains-5-0-3-0-4-0-2-0-10-0-1-0-config-classicalsmcconfig-gains-stable-gains-max-force-100-dt-0-01-boundary-layer-0-01-assert-check-stability-config-k1-config-k2-config-lam1-config-lam2-check-damping-ratios-zeta1-config-lam1-2-np-sqrt-config-k1-zeta2-config-lam2-2-np-sqrt-config-k2-both-subsystems-should-have-positive-damping-assert-zeta1-0-assert-zeta2-0" title="Link to this heading">Â¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">2.3</span> <span class="pre">Numerical</span> <span class="pre">Accuracy</span> <span class="pre">Tests</span> <span class="pre">####</span> <span class="pre">2.3.1</span> <span class="pre">Floating</span> <span class="pre">Point</span> <span class="pre">Precision</span></code>python</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id5">
<h1>example-metadata:<a class="headerlink" href="#id5" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-class-testnumericalaccuracy-test-numerical-accuracy-and-precision-def-test-floating-point-consistency-self-test-that-computations-are-consistent-across-repeated-calls-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-compute-control-multiple-times-results-for-in-range-100-result-controller-compute-control-state-control-result-get-control-output-result-get-control-result-get-u-if-control-is-not-none-results-append-control-if-results-results-np-array-results-all-results-should-be-identical-deterministic-computation-std-dev-np-std-results-axis-0-assert-np-all-std-dev-1e-15-machine-precision-def-test-numerical-stability-small-values-self-test-numerical-stability-with-very-small-state-values-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-very-small-state-values-near-machine-precision-small-state-np-array-1e-15-1e-15-1e-15-1e-15-1e-15-1e-15-result-controller-compute-control-small-state-control-result-get-control-output-result-get-control-result-get-u-if-control-is-not-none-control-should-be-finite-and-small-assert-np-all-np-isfinite-control-assert-np-all-np-abs-control-1-0-def-test-numerical-stability-large-values-self-test-numerical-stability-with-large-state-values-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-large-state-values-but-within-reasonable-bounds-large-state-np-array-10-0-5-0-3-0-2-0-2-0-1-0-result-controller-compute-control-large-state-control-result-get-control-output-result-get-control-result-get-u-if-control-is-not-none-control-should-be-finite-and-saturated-assert-np-all-np-isfinite-control-assert-np-all-np-abs-control-config-max-force-1-01-within-saturation">
<h1>runnable: false class TestNumericalAccuracy: â€œâ€â€Test numerical accuracy and precision.â€â€â€ def test_floating_point_consistency(self): â€œâ€â€Test that computations are consistent across repeated calls.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) # Compute control multiple times results = [] for _ in range(100): result = controller.compute_control(state, {}, {}) control = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, result.get(â€˜uâ€™))) if control is not None: results.append(control) if results: results = np.array(results) # All results should be identical (deterministic computation) std_dev = np.std(results, axis=0) assert np.all(std_dev &lt; 1e-15) # Machine precision def test_numerical_stability_small_values(self): â€œâ€â€Test numerical stability with very small state values.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) # Very small state values (near machine precision) small_state = np.array([1e-15, 1e-15, 1e-15, 1e-15, 1e-15, 1e-15]) result = controller.compute_control(small_state, {}, {}) control = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, result.get(â€˜uâ€™))) if control is not None: # Control should be finite and small assert np.all(np.isfinite(control)) assert np.all(np.abs(control) &lt; 1.0) def test_numerical_stability_large_values(self): â€œâ€â€Test numerical stability with large state values.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) # Large state values (but within reasonable bounds) large_state = np.array([10.0, 5.0, 3.0, 2.0, 2.0, 1.0]) result = controller.compute_control(large_state, {}, {}) control = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, result.get(â€˜uâ€™))) if control is not None: # Control should be finite and saturated assert np.all(np.isfinite(control)) assert np.all(np.abs(control) &lt;= config.max_force * 1.01) # Within saturation<a class="headerlink" href="#runnable-false-class-testnumericalaccuracy-test-numerical-accuracy-and-precision-def-test-floating-point-consistency-self-test-that-computations-are-consistent-across-repeated-calls-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-compute-control-multiple-times-results-for-in-range-100-result-controller-compute-control-state-control-result-get-control-output-result-get-control-result-get-u-if-control-is-not-none-results-append-control-if-results-results-np-array-results-all-results-should-be-identical-deterministic-computation-std-dev-np-std-results-axis-0-assert-np-all-std-dev-1e-15-machine-precision-def-test-numerical-stability-small-values-self-test-numerical-stability-with-very-small-state-values-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-very-small-state-values-near-machine-precision-small-state-np-array-1e-15-1e-15-1e-15-1e-15-1e-15-1e-15-result-controller-compute-control-small-state-control-result-get-control-output-result-get-control-result-get-u-if-control-is-not-none-control-should-be-finite-and-small-assert-np-all-np-isfinite-control-assert-np-all-np-abs-control-1-0-def-test-numerical-stability-large-values-self-test-numerical-stability-with-large-state-values-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-large-state-values-but-within-reasonable-bounds-large-state-np-array-10-0-5-0-3-0-2-0-2-0-1-0-result-controller-compute-control-large-state-control-result-get-control-output-result-get-control-result-get-u-if-control-is-not-none-control-should-be-finite-and-saturated-assert-np-all-np-isfinite-control-assert-np-all-np-abs-control-config-max-force-1-01-within-saturation" title="Link to this heading">Â¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">2.4</span> <span class="pre">Property-Based</span> <span class="pre">Testing</span> <span class="pre">Using</span> <span class="pre">Hypothesis</span> <span class="pre">for</span> <span class="pre">property</span> <span class="pre">testing:</span></code>python
from hypothesis import given, strategies as st class TestPropertyBasedSMC: â€œâ€â€Property-based tests using Hypothesis.â€â€â€ &#64;given( k1=st.floats(min_value=0.1, max_value=50.0), k2=st.floats(min_value=0.1, max_value=50.0), lam1=st.floats(min_value=0.1, max_value=50.0), lam2=st.floats(min_value=0.1, max_value=50.0), K=st.floats(min_value=1.0, max_value=200.0), kd=st.floats(min_value=0.0, max_value=20.0) ) def test_configuration_property_all_positive_gains(self, k1, k2, lam1, lam2, K, kd): â€œâ€â€Test that any positive gain combination creates valid configuration.â€â€â€ gains = [k1, k2, lam1, lam2, K, kd] # Should not raise any exceptions config = ClassicalSMCConfig( gains=gains, max_force=100.0, dt=0.01, boundary_layer=0.01 ) # All properties should be accessible assert config.k1 == k1 assert config.k2 == k2 assert config.lam1 == lam1 assert config.lam2 == lam2 assert config.K == K assert config.kd == kd &#64;given( state=st.lists( st.floats(min_value=-10.0, max_value=10.0), min_size=6, max_size=6 ) ) def test_sliding_surface_finite_output(self, state): â€œâ€â€Test that sliding surface always produces finite output for finite input.â€â€â€ gains = [5.0, 3.0, 4.0, 2.0, 10.0, 1.0] surface = LinearSlidingSurface(gains[:4]) state_array = np.array(state) # Sliding surface should always be finite for finite state if np.all(np.isfinite(state_array)): surface_value = surface.compute(state_array) assert np.isfinite(surface_value) &#64;given( boundary_thickness=st.floats(min_value=1e-6, max_value=1.0), surface_value=st.floats(min_value=-100.0, max_value=100.0) ) def test_boundary_layer_bounded_output(self, boundary_thickness, surface_value): â€œâ€â€Test that boundary layer output is always bounded.â€â€â€ boundary_layer = BoundaryLayer(thickness=boundary_thickness, switch_method=â€tanhâ€) if np.isfinite(surface_value): switch_value = boundary_layer.compute_switching_function(surface_value) # Switching function should be bounded between -1 and 1 assert -1.0 &lt;= switch_value &lt;= 1.0 assert np.isfinite(switch_value)
<code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">2.5</span> <span class="pre">Integration</span> <span class="pre">and</span> <span class="pre">System-Level</span> <span class="pre">Tests</span></code>python</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id6">
<h1>example-metadata:<a class="headerlink" href="#id6" title="Link to this heading">Â¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-class-testsystemlevelmathematics-test-mathematical-consistency-across-system-components-def-test-control-law-decomposition-self-test-that-control-law-components-sum-correctly-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-get-overall-control-output-result-controller-compute-control-state-total-control-result-get-control-output-result-get-control-result-get-u-get-individual-components-if-available-in-debug-output-components-result-get-debug-if-u-equivalent-in-components-and-u-switching-in-components-and-u-derivative-in-components-u-eq-components-u-equivalent-u-sw-components-u-switching-u-d-components-u-derivative-before-saturation-should-sum-correctly-u-unsaturated-u-eq-u-sw-u-d-after-saturation-u-saturated-np-clip-u-unsaturated-config-max-force-config-max-force-should-match-total-control-before-any-additional-processing-if-total-control-is-not-none-assert-np-allclose-u-saturated-total-control-rtol-1e-10-def-test-lyapunov-function-properties-self-test-lyapunov-function-properties-for-stability-analysis-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-surface-linearslidingsurface-config-get-surface-gains-multiple-test-states-states-np-array-0-1-0-05-0-08-0-02-0-03-0-01-np-array-0-2-0-1-0-15-0-05-0-08-0-03-np-array-0-1-0-05-0-08-0-02-0-03-0-01-for-state-in-states-s-surface-compute-state-lyapunov-function-candidate-v-0-5-s2-v-0-5-s-2-v-should-be-non-negative-assert-v-0-v-0-if-and-only-if-s-0-if-abs-s-1e-10-assert-v-1e-15-else-assert-v-0-def-test-reaching-law-satisfaction-self-test-that-reaching-law-is-satisfied-ss-s-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-surface-linearslidingsurface-config-get-surface-gains-test-state-away-from-surface-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-s-surface-compute-state-simplified-reaching-law-check-without-full-dynamics-for-switching-control-u-sw-k-sign-s-the-reaching-condition-ss-s-should-be-satisfied-when-k-is-chosen-large-enough-this-is-a-simplified-test-full-test-would-require-dynamics-model-if-abs-s-config-boundary-layer-outside-boundary-layer-should-have-strong-reaching-behavior-expected-reaching-rate-config-k-abs-s-max-abs-s-config-boundary-layer-assert-expected-reaching-rate-0-should-be-moving-toward-surface">
<h1>runnable: false class TestSystemLevelMathematics: â€œâ€â€Test mathematical consistency across system components.â€â€â€ def test_control_law_decomposition(self): â€œâ€â€Test that control law components sum correctly.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) # Get overall control output result = controller.compute_control(state, {}, {}) total_control = result.get(â€˜control_outputâ€™, result.get(â€˜controlâ€™, result.get(â€˜uâ€™))) # Get individual components (if available in debug output) components = result.get(â€˜debugâ€™, {}) if â€˜u_equivalentâ€™ in components and â€˜u_switchingâ€™ in components and â€˜u_derivativeâ€™ in components: u_eq = components[â€˜u_equivalentâ€™] u_sw = components[â€˜u_switchingâ€™] u_d = components[â€˜u_derivativeâ€™] # Before saturation, should sum correctly u_unsaturated = u_eq + u_sw + u_d # After saturation u_saturated = np.clip(u_unsaturated, -config.max_force, config.max_force) # Should match total control (before any additional processing) if total_control is not None: assert np.allclose(u_saturated, total_control, rtol=1e-10) def test_lyapunov_function_properties(self): â€œâ€â€Test Lyapunov function properties for stability analysis.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) controller = ModularClassicalSMC(config=config) surface = LinearSlidingSurface(config.get_surface_gains()) # Multiple test states states = [ np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]), np.array([0.2, 0.1, 0.15, 0.05, 0.08, 0.03]), np.array([-0.1, -0.05, -0.08, -0.02, -0.03, -0.01]) ] for state in states: s = surface.compute(state) # Lyapunov function candidate: V = 0.5 * sÂ² V = 0.5 * s**2 # V should be non-negative assert V &gt;= 0 # V = 0 if and only if s = 0 if abs(s) &lt; 1e-10: assert V &lt; 1e-15 else: assert V &gt; 0 def test_reaching_law_satisfaction(self): â€œâ€â€Test that reaching law is satisfied: s<em>á¹¡ â‰¤ -Î·|s|.â€â€â€ config = ClassicalSMCConfig( gains=[5.0, 3.0, 4.0, 2.0, 10.0, 1.0], max_force=100.0, dt=0.01, boundary_layer=0.01 ) surface = LinearSlidingSurface(config.get_surface_gains()) # Test state away from surface state = np.array([0.1, 0.05, 0.08, 0.02, 0.03, 0.01]) s = surface.compute(state) # Simplified reaching law check (without full dynamics) # For switching control: u_sw = -K * sign(s) # The reaching condition s</em>á¹¡ â‰¤ -Î·|s| should be satisfied # when K is chosen large enough # This is a simplified test - full test would require dynamics model if abs(s) &gt; config.boundary_layer: # Outside boundary layer, should have strong reaching behavior expected_reaching_rate = -config.K * abs(s) / max(abs(s), config.boundary_layer) assert expected_reaching_rate &lt; 0 # Should be moving toward surface<a class="headerlink" href="#runnable-false-class-testsystemlevelmathematics-test-mathematical-consistency-across-system-components-def-test-control-law-decomposition-self-test-that-control-law-components-sum-correctly-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-get-overall-control-output-result-controller-compute-control-state-total-control-result-get-control-output-result-get-control-result-get-u-get-individual-components-if-available-in-debug-output-components-result-get-debug-if-u-equivalent-in-components-and-u-switching-in-components-and-u-derivative-in-components-u-eq-components-u-equivalent-u-sw-components-u-switching-u-d-components-u-derivative-before-saturation-should-sum-correctly-u-unsaturated-u-eq-u-sw-u-d-after-saturation-u-saturated-np-clip-u-unsaturated-config-max-force-config-max-force-should-match-total-control-before-any-additional-processing-if-total-control-is-not-none-assert-np-allclose-u-saturated-total-control-rtol-1e-10-def-test-lyapunov-function-properties-self-test-lyapunov-function-properties-for-stability-analysis-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-controller-modularclassicalsmc-config-config-surface-linearslidingsurface-config-get-surface-gains-multiple-test-states-states-np-array-0-1-0-05-0-08-0-02-0-03-0-01-np-array-0-2-0-1-0-15-0-05-0-08-0-03-np-array-0-1-0-05-0-08-0-02-0-03-0-01-for-state-in-states-s-surface-compute-state-lyapunov-function-candidate-v-0-5-s2-v-0-5-s-2-v-should-be-non-negative-assert-v-0-v-0-if-and-only-if-s-0-if-abs-s-1e-10-assert-v-1e-15-else-assert-v-0-def-test-reaching-law-satisfaction-self-test-that-reaching-law-is-satisfied-ss-s-config-classicalsmcconfig-gains-5-0-3-0-4-0-2-0-10-0-1-0-max-force-100-0-dt-0-01-boundary-layer-0-01-surface-linearslidingsurface-config-get-surface-gains-test-state-away-from-surface-state-np-array-0-1-0-05-0-08-0-02-0-03-0-01-s-surface-compute-state-simplified-reaching-law-check-without-full-dynamics-for-switching-control-u-sw-k-sign-s-the-reaching-condition-ss-s-should-be-satisfied-when-k-is-chosen-large-enough-this-is-a-simplified-test-full-test-would-require-dynamics-model-if-abs-s-config-boundary-layer-outside-boundary-layer-should-have-strong-reaching-behavior-expected-reaching-rate-config-k-abs-s-max-abs-s-config-boundary-layer-assert-expected-reaching-rate-0-should-be-moving-toward-surface" title="Link to this heading">Â¶</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">##</span> <span class="pre">3.</span> <span class="pre">Test</span> <span class="pre">Organization</span> <span class="pre">and</span> <span class="pre">Execution</span> <span class="pre">###</span> <span class="pre">3.1</span> <span class="pre">Test</span> <span class="pre">Hierarchy</span></code>
tests/test_controllers/smc/
â”œâ”€â”€ algorithms/
â”‚ â”œâ”€â”€ classical/
â”‚ â”‚ â”œâ”€â”€ test_boundary_layer.py # Boundary layer mathematics
â”‚ â”‚ â”œâ”€â”€ test_sliding_surface.py # Surface computation tests
â”‚ â”‚ â”œâ”€â”€ test_config_validation.py # Parameter validation
â”‚ â”‚ â””â”€â”€ test_modular_controller.py # Integration tests
â”‚ â”œâ”€â”€ adaptive/
â”‚ â”‚ â””â”€â”€ test_modular_adaptive_smc.py # Adaptive algorithm tests
â”‚ â””â”€â”€ super_twisting/
â”‚ â””â”€â”€ test_super_twisting_smc.py # Higher-order SMC tests
â”œâ”€â”€ core/
â”‚ â”œâ”€â”€ test_sliding_surface.py # Core surface mathematics
â”‚ â”œâ”€â”€ test_equivalent_control.py # Model-based control
â”‚ â””â”€â”€ test_switching_functions.py # Switching function tests
â””â”€â”€ test_property_based_smc.py # Property-based tests
<code class="docutils literal notranslate"><span class="pre">###</span> <span class="pre">3.2</span> <span class="pre">Test</span> <span class="pre">Execution</span> <span class="pre">Strategy</span> <span class="pre">####</span> <span class="pre">3.2.1</span> <span class="pre">Continuous</span> <span class="pre">Integration</span></code>bash</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="fast-unit-tests-mathematical-properties">
<h1>Fast unit tests (mathematical properties)<a class="headerlink" href="#fast-unit-tests-mathematical-properties" title="Link to this heading">Â¶</a></h1>
<p>pytest tests/test_controllers/smc/core/ -v # Algorithm-specific tests
pytest tests/test_controllers/smc/algorithms/classical/ -v # Property-based tests (may take longer)
pytest tests/test_controllers/smc/test_property_based_smc.py -v â€“hypothesis-profile=ci # Full mathematical validation suite
pytest tests/test_controllers/smc/ -v -m â€œnot slowâ€
<code class="docutils literal notranslate"><span class="pre">####</span> <span class="pre">3.2.2</span> <span class="pre">Validation</span></code>bash</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="extended-property-based-testing">
<h1>Extended property-based testing<a class="headerlink" href="#extended-property-based-testing" title="Link to this heading">Â¶</a></h1>
<p>pytest tests/test_controllers/smc/ -v â€“hypothesis-profile=thorough # Performance and numerical stability
pytest tests/test_controllers/smc/ -v -m â€œnumerical_stabilityâ€ # Integration tests with actual dynamics
pytest tests/test_integration/ -k â€œsmcâ€ -v</p>
<div class="highlight-### notranslate"><div class="highlight"><pre><span></span>
- **Boundary Conditions**: 100% coverage of edge cases
- **Configuration Validation**: 100% coverage of all validation rules
- **Numerical Stability**: 95% coverage of numerical corner cases
- **Integration**: 90% coverage of system-level interactions ## 4. Automated Test Generation ### 4.1 Mathematical Property Templates ```python
# example-metadata:

# runnable: false def generate_linearity_test(component_class, property_name): &quot;&quot;&quot;Generate linearity test for any mathematical component.&quot;&quot;&quot; def test_linearity(self): component = component_class(default_params) x1 = generate_random_input() x2 = generate_random_input() result1 = getattr(component, property_name)(x1) result2 = getattr(component, property_name)(x2) result_combined = getattr(component, property_name)(x1 + x2) assert np.allclose(result_combined, result1 + result2, rtol=1e-10) return test_linearity def generate_monotonicity_test(function, domain): &quot;&quot;&quot;Generate monotonicity test for mathematical functions.&quot;&quot;&quot; def test_monotonicity(self): x_values = np.linspace(domain[0], domain[1], 100) y_values = [function(x) for x in x_values] # Check monotonicity for i in range(len(y_values) - 1): assert y_values[i+1] &gt;= y_values[i] return test_monotonicity

``` ### 4.2 Configuration Test Generation ```python
# example-metadata:
# runnable: false def generate_validation_tests(config_class, parameter_specs): &quot;&quot;&quot;Generate validation tests for configuration classes.&quot;&quot;&quot; tests = [] for param_name, spec in parameter_specs.items(): if spec.get(&#39;positive_required&#39;, False): def test_positive_validation(): invalid_config = create_invalid_config(param_name, -1.0) with pytest.raises(ValueError): config_class(**invalid_config) tests.append(test_positive_validation) if spec.get(&#39;nonzero_required&#39;, False): def test_nonzero_validation(): invalid_config = create_invalid_config(param_name, 0.0) with pytest.raises(ValueError): config_class(**invalid_config) tests.append(test_nonzero_validation) return tests
``` ## 5. Error Detection and Reporting ### 5.1 Mathematical Error Classification 1. **Stability Violations**: Configurations that violate stability requirements

2. **Numerical Instabilities**: Computations that produce NaN or infinite values
3. **Mathematical Inconsistencies**: Violations of mathematical properties
4. **Convergence Failures**: Algorithms that don&#39;t converge as expected
5. **Precision Losses**: Excessive numerical errors accumulation ### 5.2 Automated Error Reporting ```python
# example-metadata:

# runnable: false class MathematicalValidationReporter: &quot;&quot;&quot;Automated reporting for mathematical validation results.&quot;&quot;&quot; def __init__(self): self.violations = [] self.warnings = [] self.performance_metrics = {} def report_stability_violation(self, test_name, gains, eigenvalues): &quot;&quot;&quot;Report stability requirement violations.&quot;&quot;&quot; self.violations.append({ &#39;type&#39;: &#39;stability&#39;, &#39;test&#39;: test_name, &#39;gains&#39;: gains, &#39;eigenvalues&#39;: eigenvalues, &#39;severity&#39;: &#39;critical&#39; }) def report_numerical_instability(self, test_name, input_values, output_values): &quot;&quot;&quot;Report numerical computation issues.&quot;&quot;&quot; self.violations.append({ &#39;type&#39;: &#39;numerical&#39;, &#39;test&#39;: test_name, &#39;inputs&#39;: input_values, &#39;outputs&#39;: output_values, &#39;severity&#39;: &#39;high&#39; }) def generate_report(self): &quot;&quot;&quot;Generate validation report.&quot;&quot;&quot; report = { &#39;summary&#39;: { &#39;total_violations&#39;: len(self.violations), &#39;critical_issues&#39;: len([v for v in self.violations if v[&#39;severity&#39;] == &#39;critical&#39;]), &#39;warnings&#39;: len(self.warnings) }, &#39;violations&#39;: self.violations, &#39;warnings&#39;: self.warnings, &#39;performance&#39;: self.performance_metrics } return report

``` ## 6. Continuous Validation ### 6.1 Pre-commit Hooks ```bash
#!/bin/bash
# .git/hooks/pre-commit # Run mathematical property tests before each commit
pytest tests/test_controllers/smc/core/ -q
if [ $? -ne 0 ]; then echo &quot;Mathematical property tests failed. Commit rejected.&quot; exit 1
fi # Run configuration validation tests
pytest tests/test_controllers/smc/algorithms/classical/test_config_validation.py -q
if [ $? -ne 0 ]; then echo &quot;Configuration validation tests failed. Commit rejected.&quot; exit 1
fi echo &quot;Mathematical validation passed.&quot;
``` ### 6.2 Regression Detection ```python
# example-metadata:

# runnable: false class MathematicalRegressionDetector: &quot;&quot;&quot;Detect regressions in mathematical computations.&quot;&quot;&quot; def __init__(self, baseline_file): self.baseline = self.load_baseline(baseline_file) def check_computation_regression(self, component, test_inputs, tolerance=1e-12): &quot;&quot;&quot;Check if computation results match baseline within tolerance.&quot;&quot;&quot; current_results = [] for input_data in test_inputs: result = component.compute(input_data) current_results.append(result) baseline_key = f&quot;{component.__class__.__name__}_compute&quot; if baseline_key in self.baseline: baseline_results = self.baseline[baseline_key] for current, baseline in zip(current_results, baseline_results): if abs(current - baseline) &gt; tolerance: return False, f&quot;Regression detected: {current} vs {baseline}&quot; return True, &quot;No regression detected&quot; def update_baseline(self, component, test_inputs): &quot;&quot;&quot;Update baseline with current computation results.&quot;&quot;&quot; # Implementation for updating baseline values pass

``` This test validation methodology ensures that all mathematical algorithms and fixes in the SMC system maintain mathematical rigor, numerical stability, and correctness across all operating conditions. ## References 1. Utkin, V. I. (1992). *Sliding Modes in Control and Optimization*. Springer-Verlag. 2. Khalil, H. K. (2002). *Nonlinear Systems*. Prentice Hall. 3. Higham, N. J. (2002). *Accuracy and Stability of Numerical Algorithms*. SIAM. 4. MacKenzie, D. (2004). *Mechanizing Proof: Computing, Risk, and Trust*. MIT Press. 5. Beck, K. (2003). *Test-Driven Development: By Example*. Addison-Wesley.
</pre></div>
</div>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Research Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on Oct 10, 2025</div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=4ebf8126"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=46bd48cc"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=08e7b316"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../_static/back-to-top.js?v=840797bb"></script>
    <script src="../_static/lazy-load.js?v=dc25293c"></script>
    <script src="../_static/dark-mode.js?v=bf328970"></script>
    </body>
</html>