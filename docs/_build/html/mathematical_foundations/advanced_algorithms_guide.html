<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark">
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<style>
.chartjs-container {
    margin: 1.5em auto;
    padding: 1em;
    background: #f8f9fa;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.chart-note {
    text-align: center;
    color: #6c757d;
    font-size: 0.9em;
    margin-top: 0.5em;
}
</style>
<link rel="index" title="Index" href="../genindex.html"><link rel="search" title="Search" href="../search.html">

    <!-- Generated with Sphinx 8.2.3 and Furo 2025.09.25 -->
        <title>Advanced Algorithms Guide Technical Reference for Optimization, Numerical Stability, and Algorithm Comparison - DIP_SMC_PSO Documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=5349f25f" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=580074bf" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=8dab3a3b" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=8a7e329d" />
    
    


<style>
  body {
    --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">DIP_SMC_PSO Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  <span class="sidebar-brand-text">DIP_SMC_PSO Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">📚 Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">Optimal Sliding Mode Control for a Double-Inverted Pendulum via PSO  ## How to validate a ResearchPlan JSON Run the validator locally: ```bash</a></li>
<li class="toctree-l1"><a class="reference internal" href="../theory_overview.html">Theory Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../architecture.html">3. System Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plant_model.html">1.x Plant Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hil_quickstart.html">Hardware-in-the-Loop (HIL) Quickstart Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../streamlit_dashboard_guide.html">Streamlit Dashboard User Guide</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/blob/main/docs/mathematical_foundations/advanced_algorithms_guide.md?plain=true" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div><div class="edit-this-page">
  <a class="muted-link" href="https://github.com/theSadeQ/DIP_SMC_PSO/edit/main/docs/mathematical_foundations/advanced_algorithms_guide.md" rel="edit" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section class="tex2jax_ignore mathjax_ignore" id="advanced-algorithms-guide-technical-reference-for-optimization-numerical-stability-and-algorithm-comparison">
<h1>Advanced Algorithms Guide <strong>Technical Reference for Optimization, Numerical Stability, and Algorithm Comparison</strong><a class="headerlink" href="#advanced-algorithms-guide-technical-reference-for-optimization-numerical-stability-and-algorithm-comparison" title="Link to this heading">¶</a></h1>
<hr class="docutils" />
<section id="table-of-contents-1-introduction">
<h2>Table of Contents 1. <a class="reference external" href="https://docs.python.org/3/reference/introduction.html#introduction" title="Python 3.14"><span class="xref myst">Introduction</span></a><a class="headerlink" href="#table-of-contents-1-introduction" title="Link to this heading">¶</a></h2>
<ol class="arabic simple" start="2">
<li><p><a class="reference internal" href="#particle-swarm-optimization"><span class="xref myst">Particle Swarm Optimization</span></a></p></li>
<li><p><a class="reference internal" href="#super-twisting-algorithm"><span class="xref myst">Super-Twisting Algorithm</span></a></p></li>
<li><p><a class="reference internal" href="#numerical-stability-algorithms"><span class="xref myst">Numerical Stability Algorithms</span></a></p></li>
<li><p><a class="reference internal" href="#algorithm-comparison-framework"><span class="xref myst">Algorithm Comparison Framework</span></a></p></li>
<li><p><a class="reference internal" href="#performance-optimization-techniques"><span class="xref myst">Performance Optimization Techniques</span></a></p></li>
<li><p><a class="reference internal" href="#advanced-topics"><span class="xref myst">Advanced Topics</span></a></p></li>
<li><p><a class="reference internal" href="#best-practices"><span class="xref myst">Best Practices</span></a></p></li>
</ol>
</section>
<hr class="docutils" />
<section id="introduction-this-guide-provides-technical-documentation-for-the-advanced-algorithms-implemented-in-the-dip-smc-pso-project-these-algorithms-form-the-computational-backbone-of-the-system-enabling-robust-control-efficient-optimization-and-numerical-stability">
<h2>Introduction This guide provides technical documentation for the advanced algorithms implemented in the DIP-SMC-PSO project. These algorithms form the computational backbone of the system, enabling robust control, efficient optimization, and numerical stability.<a class="headerlink" href="#introduction-this-guide-provides-technical-documentation-for-the-advanced-algorithms-implemented-in-the-dip-smc-pso-project-these-algorithms-form-the-computational-backbone-of-the-system-enabling-robust-control-efficient-optimization-and-numerical-stability" title="Link to this heading">¶</a></h2>
<section id="algorithm-categories">
<h3>Algorithm Categories<a class="headerlink" href="#algorithm-categories" title="Link to this heading">¶</a></h3>
<p><strong>Optimization Algorithms:</strong></p>
<ul class="simple">
<li><p>Particle Swarm Optimization (PSO) with advanced features</p></li>
<li><p>Genetic Algorithm (GA) comparison framework</p></li>
<li><p>Differential Evolution (DE) comparison framework <strong>Control Algorithms:</strong></p></li>
<li><p>Super-Twisting Algorithm (STA) for second-order sliding mode</p></li>
<li><p>Finite-time convergence techniques</p></li>
<li><p>Chattering reduction methods <strong>Numerical Algorithms:</strong></p></li>
<li><p>Safe mathematical operations with IEEE 754 compliance</p></li>
<li><p>Adaptive regularization for ill-conditioned systems</p></li>
<li><p>Overflow/underflow protection <strong>Benchmarking Algorithms:</strong></p></li>
<li><p>Standard test functions (Sphere, Rosenbrock, Rastrigin, Ackley)</p></li>
<li><p>Statistical significance testing</p></li>
<li><p>Convergence analysis frameworks ### Implementation Philosophy All algorithms follow production-grade design principles: 1. <strong>Numerical Stability:</strong> Epsilon thresholds protect against division by zero, overflow, and underflow</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p><strong>Reproducibility:</strong> Explicit PRNG seeding for deterministic results</p></li>
<li><p><strong>Vectorization:</strong> NumPy-based batch operations for high throughput</p></li>
<li><p><strong>Theoretical Grounding:</strong> Each algorithm includes mathematical proofs and stability guarantees</p></li>
<li><p><strong>Testing:</strong> Unit tests, property-based tests, and scientific validation</p></li>
</ol>
</section>
</section>
<hr class="docutils" />
<section id="particle-swarm-optimization-mathematical-foundation-particle-swarm-optimization-pso-is-a-population-based-metaheuristic-inspired-by-social-behavior-of-bird-flocking-and-fish-schooling-core-pso-dynamics-each-particle-i-in-the-swarm-has">
<h2>Particle Swarm Optimization ### Mathematical Foundation Particle Swarm Optimization (PSO) is a population-based metaheuristic inspired by social behavior of bird flocking and fish schooling. #### Core PSO Dynamics Each particle <span class="math notranslate nohighlight">\(i\)</span> in the swarm has:<a class="headerlink" href="#particle-swarm-optimization-mathematical-foundation-particle-swarm-optimization-pso-is-a-population-based-metaheuristic-inspired-by-social-behavior-of-bird-flocking-and-fish-schooling-core-pso-dynamics-each-particle-i-in-the-swarm-has" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><strong>Position:</strong> <span class="math notranslate nohighlight">\(\mathbf{x}_i^{(t)} \in \mathbb{R}^D\)</span> (candidate solution)</p></li>
<li><p><strong>Velocity:</strong> <span class="math notranslate nohighlight">\(\mathbf{v}_i^{(t)} \in \mathbb{R}^D\)</span> (search direction and magnitude)</p></li>
<li><p><strong>Personal best:</strong> <span class="math notranslate nohighlight">\(\mathbf{p}_i\)</span> (best position found by particle <span class="math notranslate nohighlight">\(i\)</span>)</p></li>
<li><p><strong>Global best:</strong> <span class="math notranslate nohighlight">\(\mathbf{g}\)</span> (best position found by entire swarm) <strong>Update Equations:</strong> $<span class="math notranslate nohighlight">\(
\mathbf{v}_i^{(t+1)} = w \mathbf{v}_i^{(t)} + c_1 r_1 \odot (\mathbf{p}_i - \mathbf{x}_i^{(t)}) + c_2 r_2 \odot (\mathbf{g} - \mathbf{x}_i^{(t)})
\)</span><span class="math notranslate nohighlight">\( \)</span><span class="math notranslate nohighlight">\(
\mathbf{x}_i^{(t+1)} = \mathbf{x}_i^{(t)} + \mathbf{v}_i^{(t+1)}
\)</span>$ where:</p></li>
<li><p><span class="math notranslate nohighlight">\(w \in [0.4, 0.9]\)</span> is the inertia weight (exploration vs exploitation)</p></li>
<li><p><span class="math notranslate nohighlight">\(c_1, c_2 \approx 2.0\)</span> are cognitive and social acceleration coefficients</p></li>
<li><p><span class="math notranslate nohighlight">\(r_1, r_2 \sim U(0,1)\)</span> are random vectors (element-wise)</p></li>
<li><p><span class="math notranslate nohighlight">\(\odot\)</span> denotes element-wise multiplication #### Convergence Theory <strong>Constriction Factor Analysis (Clerc &amp; Kennedy, 2002):</strong> For convergence, the constriction coefficient <span class="math notranslate nohighlight">\(\chi\)</span> is defined as: $<span class="math notranslate nohighlight">\(
\chi = \frac{2}{\left| 2 - \varphi - \sqrt{\varphi^2 - 4\varphi} \right|}
\)</span><span class="math notranslate nohighlight">\( where \)</span>\varphi = c_1 + c_2 &gt; 4<span class="math notranslate nohighlight">\(. **Standard configuration:** \)</span>c_1 = c_2 = 2.05<span class="math notranslate nohighlight">\(, yielding \)</span>\chi \approx 0.729$ This ensures:</p></li>
</ul>
<ol class="arabic simple">
<li><p><strong>Bounded oscillation</strong> around personal and global bests</p></li>
<li><p><strong>Guaranteed convergence</strong> to a point (not necessarily global optimum)</p></li>
<li><p><strong>No velocity divergence</strong> with proper parameter selection ### Implementation: PSOTuner Class #### Architecture Overview Located in <code class="docutils literal notranslate"><span class="pre">src/optimization/algorithms/pso_optimizer.py</span></code>, the <code class="docutils literal notranslate"><span class="pre">PSOTuner</span></code> class provides: 1. <strong>Decoupled state management</strong> - No global variable mutations</p></li>
<li><p><strong>Explicit PRNG control</strong> - Reproducible optimization with seed management</p></li>
<li><p><strong>Vectorized fitness evaluation</strong> - Batch simulation of entire swarm</p></li>
<li><p><strong>Dynamic penalties</strong> - Instability detection and graded penalties</p></li>
<li><p><strong>Uncertainty-aware optimization</strong> - Robust optimization under parameter perturbations #### Key Features <strong>1. Velocity Clamping</strong> Prevents particles from overshooting search space: $<span class="math notranslate nohighlight">\(
\mathbf{v}_i^{(t+1)} = \text{clip}\left(\mathbf{v}_i^{(t+1)}, \delta_{\min} \Delta\mathbf{b}, \delta_{\max} \Delta\mathbf{b}\right)
\)</span><span class="math notranslate nohighlight">\( where \)</span>\Delta\mathbf{b} = \mathbf{b}<em>{\max} - \mathbf{b}</em>{\min}<span class="math notranslate nohighlight">\( is the search range. Default: \)</span>\delta_{\min} = -0.5<span class="math notranslate nohighlight">\(, \)</span>\delta_{\max} = 0.5<span class="math notranslate nohighlight">\( **2. Inertia Weight Scheduling** Linearly decreasing inertia promotes exploration → exploitation transition: \)</span><span class="math notranslate nohighlight">\(
w(t) = w_{\text{start}} - \frac{t}{T} (w_{\text{start}} - w_{\text{end}})
\)</span><span class="math notranslate nohighlight">\( Default schedule: \)</span>w: 0.9 \rightarrow 0.4<span class="math notranslate nohighlight">\( over \)</span>T<span class="math notranslate nohighlight">\( iterations **3. Instability Penalties** Graded penalty for early trajectory failure: \)</span><span class="math notranslate nohighlight">\(
P_{\text{instability}} = w_{\text{stab}} \cdot \frac{T - t_{\text{fail}}}{T} \cdot P_{\text{max}}
\)</span>$ where:</p></li>
</ol>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(t_{\text{fail}}\)</span> is the time of first instability detection</p></li>
<li><p><span class="math notranslate nohighlight">\(P_{\text{max}} = 100 \times (\text{norm}_{\text{ISE}} + \text{norm}_u + \text{norm}_{\Delta u} + \text{norm}_\sigma)\)</span> This encourages particles to maintain stability for longer durations. <strong>4. Cost Normalization</strong> Prevents scale imbalance between cost components: $<span class="math notranslate nohighlight">\(
J = w_{\text{ISE}} \cdot \frac{\text{ISE}}{\text{norm}_{\text{ISE}}} + w_u \cdot \frac{U^2}{\text{norm}_u} + w_{\Delta u} \cdot \frac{(\Delta U)^2}{\text{norm}_{\Delta u}} + w_\sigma \cdot \frac{\sigma^2}{\text{norm}_\sigma}
\)</span><span class="math notranslate nohighlight">\( Normalization constants are automatically computed from baseline controller performance. **5. Uncertainty Evaluation** Robust optimization under physics parameter uncertainty: \)</span><span class="math notranslate nohighlight">\(
J_{\text{robust}}(\mathbf{x}) = w_{\text{mean}} \cdot \frac{1}{N} \sum_{i=1}^N J(\mathbf{x}, \theta_i) + w_{\text{max}} \cdot \max_{i=1}^N J(\mathbf{x}, \theta_i)
\)</span><span class="math notranslate nohighlight">\( where \)</span>\theta_i<span class="math notranslate nohighlight">\( are perturbed physics parameters sampled from: \)</span><span class="math notranslate nohighlight">\(
\theta_i \sim \mathcal{U}(\theta_{\text{nominal}} - \delta\%, \theta_{\text{nominal}} + \delta\%)
\)</span><span class="math notranslate nohighlight">\( Default: \)</span>\delta = 10%<span class="math notranslate nohighlight">\(, \)</span>N = 5$ evaluations ### Usage Examples #### Basic PSO Optimization <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">from</span> <span class="pre">src.optimization.algorithms.pso_optimizer</span> <span class="pre">import</span> <span class="pre">PSOTuner</span> <span class="pre">from</span> <span class="pre">src.controllers.factory</span> <span class="pre">import</span> <span class="pre">create_controller</span> <span class="pre">from</span> <span class="pre">src.config</span> <span class="pre">import</span> <span class="pre">load_config</span> <span class="pre">#</span> <span class="pre">Load</span> <span class="pre">configuration</span> <span class="pre">config</span> <span class="pre">=</span> <span class="pre">load_config(&quot;config.yaml&quot;)</span> <span class="pre">#</span> <span class="pre">Define</span> <span class="pre">controller</span> <span class="pre">factory</span> <span class="pre">def</span> <span class="pre">controller_factory(gains):</span> <span class="pre">return</span> <span class="pre">create_controller(</span> <span class="pre">'classical_smc',</span> <span class="pre">config=config,</span> <span class="pre">gains=gains</span> <span class="pre">)</span> <span class="pre">#</span> <span class="pre">Initialize</span> <span class="pre">PSO</span> <span class="pre">tuner</span> <span class="pre">tuner</span> <span class="pre">=</span> <span class="pre">PSOTuner(</span> <span class="pre">controller_factory=controller_factory,</span> <span class="pre">config=config,</span> <span class="pre">seed=42,</span> <span class="pre">#</span> <span class="pre">Reproducible</span> <span class="pre">results</span> <span class="pre">instability_penalty_factor=100.0</span> <span class="pre">)</span> <span class="pre">#</span> <span class="pre">Run</span> <span class="pre">optimization</span> <span class="pre">result</span> <span class="pre">=</span> <span class="pre">tuner.optimise(</span> <span class="pre">iters_override=100,</span> <span class="pre">#</span> <span class="pre">100</span> <span class="pre">PSO</span> <span class="pre">iterations</span> <span class="pre">n_particles_override=30,</span> <span class="pre">#</span> <span class="pre">30</span> <span class="pre">particles</span> <span class="pre">options_override={</span> <span class="pre">'w':</span> <span class="pre">0.7,</span> <span class="pre">#</span> <span class="pre">Constant</span> <span class="pre">inertia</span> <span class="pre">'c1':</span> <span class="pre">2.05,</span> <span class="pre">#</span> <span class="pre">Cognitive</span> <span class="pre">coefficient</span> <span class="pre">'c2':</span> <span class="pre">2.05</span> <span class="pre">#</span> <span class="pre">Social</span> <span class="pre">coefficient</span> <span class="pre">}</span> <span class="pre">)</span> <span class="pre">#</span> <span class="pre">Extract</span> <span class="pre">results</span> <span class="pre">best_gains</span> <span class="pre">=</span> <span class="pre">result['best_pos']</span> <span class="pre">best_cost</span> <span class="pre">=</span> <span class="pre">result['best_cost']</span> <span class="pre">convergence_history</span> <span class="pre">=</span> <span class="pre">result['history']['cost']</span> <span class="pre">print(f&quot;Optimal</span> <span class="pre">gains:</span> <span class="pre">{best_gains}&quot;)</span> <span class="pre">print(f&quot;Final</span> <span class="pre">cost:</span> <span class="pre">{best_cost:.6f}&quot;)</span> </code> #### PSO with Inertia Scheduling ```python</p></li>
</ul>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="configure-inertia-weight-schedule-in-config-yaml">
<h1>Configure inertia weight schedule in config.yaml:<a class="headerlink" href="#configure-inertia-weight-schedule-in-config-yaml" title="Link to this heading">¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="pso">
<h1>pso:<a class="headerlink" href="#pso" title="Link to this heading">¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="w-schedule-0-9-0-4-start-at-0-9-end-at-0-4">
<h1>w_schedule: [0.9, 0.4] # Start at 0.9, end at 0.4<a class="headerlink" href="#w-schedule-0-9-0-4-start-at-0-9-end-at-0-4" title="Link to this heading">¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="iters-100">
<h1>iters: 100<a class="headerlink" href="#iters-100" title="Link to this heading">¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="n-particles-30-result-tuner-optimise-uses-w-schedule-from-config-manual-iteration-loop-for-custom-control">
<h1>n_particles: 30 result = tuner.optimise() # Uses w_schedule from config # Manual iteration loop for custom control<a class="headerlink" href="#n-particles-30-result-tuner-optimise-uses-w-schedule-from-config-manual-iteration-loop-for-custom-control" title="Link to this heading">¶</a></h1>
<p>from pyswarms.single import GlobalBestPSO # Create optimizer
optimizer = GlobalBestPSO( n_particles=30, dimensions=6, options={‘c1’: 2.05, ‘c2’: 2.05, ‘w’: 0.9}, bounds=(np.array([0.1]*6), np.array([50.0]*6))
) # Inertia schedule
w_values = np.linspace(0.9, 0.4, 100) for iteration, w_val in enumerate(w_values): optimizer.options[‘w’] = w_val step_cost, step_pos = optimizer.step(tuner._fitness) print(f”Iteration {iteration}: w={w_val:.3f}, cost={step_cost:.6f}”)
<code class="docutils literal notranslate"><span class="pre">####</span> <span class="pre">Uncertainty-Aware</span> <span class="pre">Optimization</span></code>python</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="example-metadata">
<h1>example-metadata:<a class="headerlink" href="#example-metadata" title="Link to this heading">¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="runnable-false-configure-physics-uncertainty-in-config-yaml">
<h1>runnable: false # Configure physics uncertainty in config.yaml:<a class="headerlink" href="#runnable-false-configure-physics-uncertainty-in-config-yaml" title="Link to this heading">¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="physics-uncertainty">
<h1>physics_uncertainty:<a class="headerlink" href="#physics-uncertainty" title="Link to this heading">¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="n-evals-5-5-perturbed-models-per-evaluation">
<h1>n_evals: 5 # 5 perturbed models per evaluation<a class="headerlink" href="#n-evals-5-5-perturbed-models-per-evaluation" title="Link to this heading">¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="cart-mass-0-10-10">
<h1>cart_mass: 0.10 # ±10%<a class="headerlink" href="#cart-mass-0-10-10" title="Link to this heading">¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="pendulum1-mass-0-15-15">
<h1>pendulum1_mass: 0.15 # ±15%<a class="headerlink" href="#pendulum1-mass-0-15-15" title="Link to this heading">¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="pendulum2-mass-0-15-15">
<h1>pendulum2_mass: 0.15 # ±15%<a class="headerlink" href="#pendulum2-mass-0-15-15" title="Link to this heading">¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="pendulum1-length-0-05-5">
<h1>pendulum1_length: 0.05 # ±5%<a class="headerlink" href="#pendulum1-length-0-05-5" title="Link to this heading">¶</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="pendulum2-length-0-05-5-tuner-psotuner-controller-factory-controller-factory-config-config-seed-42">
<h1>pendulum2_length: 0.05 # ±5% tuner = PSOTuner( controller_factory=controller_factory, config=config, seed=42<a class="headerlink" href="#pendulum2-length-0-05-5-tuner-psotuner-controller-factory-controller-factory-config-config-seed-42" title="Link to this heading">¶</a></h1>
<p>) # PSO will automatically evaluate robustness across perturbed models
result = tuner.optimise() # Each fitness evaluation runs 5 simulations (1 nominal + 4 perturbed)</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="cost-aggregation-0-7-mean-0-3-max">
<h1>Cost aggregation: 0.7 * mean + 0.3 * max<a class="headerlink" href="#cost-aggregation-0-7-mean-0-3-max" title="Link to this heading">¶</a></h1>
<div class="highlight-### notranslate"><div class="highlight"><pre><span></span>|-----------|--------|-------------------|---------|-------|
| Swarm size | $N$ | $[10, 50]$ | 30 | Larger swarms for high-dimensional problems |
| Iterations | $T$ | $[50, 200]$ | 100 | Budget vs convergence trade-off |
| Inertia weight | $w$ | $[0.4, 0.9]$ | 0.7 | Lower for exploitation, higher for exploration |
| Cognitive coeff | $c_1$ | $[1.5, 2.5]$ | 2.05 | Balance with $c_2$ |
| Social coeff | $c_2$ | $[1.5, 2.5]$ | 2.05 | $c_1 \approx c_2$ recommended |
| Velocity clamp | $\delta$ | $[-0.5, 0.5]$ | $[-0.5, 0.5]$ | Fraction of search range | #### Sensitivity Analysis **Impact of swarm size:**
- **Small swarms (10-15):** Fast convergence, risk of premature convergence
- **Medium swarms (20-30):** Balanced exploration/exploitation
- **Large swarms (40-50):** Better global search, slower convergence **Impact of inertia weight:**
- **High inertia (0.9):** Global exploration, slower convergence
- **Medium inertia (0.7):** Balanced search
- **Low inertia (0.4):** Local exploitation, faster convergence **Recommended strategy:** Use inertia scheduling $w: 0.9 \rightarrow 0.4$ ### Performance Characteristics #### Computational Complexity **Per-iteration cost:**
$$
\mathcal{O}(N \cdot D \cdot C_{\text{eval}})
$$ where:
- $N$ = swarm size
- $D$ = problem dimensionality
- $C_{\text{eval}}$ = fitness evaluation cost **For DIP-SMC tuning:**
- $N = 30$ particles
- $D = 6$ gains (classical SMC)
- $C_{\text{eval}} \approx 50$ ms (vectorized simulation)
- **Per-iteration:** ~1.5 seconds
- **100 iterations:** ~2.5 minutes #### Vectorization Benefits The `PSOTuner` implementation uses `simulate_system_batch()` to evaluate all particles simultaneously: ```python
# example-metadata:
# runnable: false # Vectorized evaluation (FAST)
t, x_b, u_b, sigma_b = simulate_system_batch( controller_factory=controller_factory, particles=particles, # Shape: (N, D) sim_time=T, dt=dt, u_max=u_max
)
# Returns: x_b.shape = (N, timesteps, 6) # Cost computation on entire batch
costs = self._compute_cost_from_traj(t, x_b, u_b, sigma_b)
# Returns: costs.shape = (N,)
``` **Speedup vs sequential:** ~20-30x for typical swarm sizes

---

## Super-Twisting Algorithm ### Mathematical Foundation The Super-Twisting Algorithm (STA) is a second-order sliding mode control technique that achieves finite-time convergence while reducing chattering. #### Control Law Structure The STA consists of two components: $$

u = u_1 + u_2
$$ **Continuous component:**
$$
u_1 = -K_1 |s|^\alpha \text{sign}(s)
$$ **Integral component:**
$$
u_2 = -K_2 \int \text{sign}(s) \, dt
$$ where:
- $s$ is the sliding surface
- $K_1, K_2 &gt; 0$ are twisting gains with $K_1 &gt; K_2$
- $\alpha \in (0, 1]$ is the power exponent (standard: $\alpha = 0.5$) #### Finite-Time Convergence **Lyapunov Function:** $$
V(s, \dot{s}) = K_2 |s| + \frac{1}{2}\left(u_2 + K_1 |s|^\alpha \text{sign}(s)\right)^2
$$ **Stability Condition:** If $K_1 &gt; K_2 &gt; 0$ and the disturbance bound is known, the STA drives $s \rightarrow 0$ and $\dot{s} \rightarrow 0$ in finite time. **Convergence Time Estimate:** For $\alpha = 0.5$:
$$
T_{\text{conv}} \approx \frac{2\sqrt{|s_0|}}{\sqrt{K_2}}
$$ For general $\alpha$:
$$
T_{\text{conv}} \approx \frac{(1-\alpha) |s_0|^{1-\alpha}}{K_2^\alpha}
$$ ### Implementation: SuperTwistingAlgorithm Class Located in `src/controllers/smc/algorithms/super_twisting/twisting_algorithm.py`: #### Key Features **1. Regularized Computation** Near $s = 0$, the term $|s|^\alpha$ can cause numerical issues. The implementation uses: $$
u_1 = \begin{cases}
-K_1 |s|^\alpha \text{sign}(s) &amp; \text{if } |s| &gt; \epsilon_{\text{reg}} \\
-K_1 \epsilon_{\text{reg}}^\alpha \text{sign}(s) &amp; \text{otherwise}
\end{cases}
$$ Default: $\epsilon_{\text{reg}} = 10^{-10}$ **2. Anti-Windup Protection** The integral state is bounded to prevent windup: $$
\int \text{sign}(s) \, dt \in [-L_{\text{windup}}, L_{\text{windup}}]
$$ **3. Smooth Switching Functions** Three switching function options: | Method | Definition | Continuity | Chattering |
|--------|-----------|------------|------------|
| `sign` | $\text{sgn}(s)$ | Discontinuous | High |
| `tanh` | $\tanh(s/\epsilon)$ | $C^\infty$ | Low |
| `linear` | $\text{clip}(s/\epsilon, -1, 1)$ | $C^0$ | Medium | ### Usage Examples #### Basic Super-Twisting Control ```python
from src.controllers.smc.algorithms.super_twisting.twisting_algorithm import SuperTwistingAlgorithm # Initialize STA
sta = SuperTwistingAlgorithm( K1=5.0, # First twisting gain K2=4.0, # Second twisting gain (K1 &gt; K2) alpha=0.5, # Standard power exponent anti_windup_limit=10.0, # Bound integral state regularization=1e-10 # Numerical safety
) # Compute control at each timestep
dt = 0.01 # 10 ms timestep for t in time_array: # Compute sliding surface (from SMC controller) s = sliding_surface(state) # Super-twisting control law control_dict = sta.compute_control( surface_value=s, dt=dt, switching_function=&#39;tanh&#39;, boundary_layer=0.01 ) # Extract components u_total = control_dict[&#39;u_total&#39;] u1 = control_dict[&#39;u1_continuous&#39;] u2 = control_dict[&#39;u2_integral&#39;] # Apply control state = plant.step(u_total, dt)
``` #### Performance Analysis ```python
# example-metadata:
# runnable: false # Run simulation and collect surface history
surface_history = [] for t in time_array: s = sliding_surface(state) surface_history.append(s) control_dict = sta.compute_control(s, dt) state = plant.step(control_dict[&#39;u_total&#39;], dt) # Analyze STA performance
analysis = sta.analyze_performance(surface_history) print(&quot;Stability Metrics:&quot;)
print(f&quot; Gains satisfy K1 &gt; K2: {analysis[&#39;stability_metrics&#39;][&#39;gains_satisfy_condition&#39;]}&quot;)
print(f&quot; Gain ratio K1/K2: {analysis[&#39;stability_metrics&#39;][&#39;gain_ratio&#39;]:.2f}&quot;) print(&quot;\nConvergence Metrics:&quot;)
print(f&quot; Convergence detected: {analysis[&#39;convergence_metrics&#39;][&#39;convergence_detected&#39;]}&quot;)
print(f&quot; Convergence time steps: {analysis[&#39;convergence_metrics&#39;][&#39;convergence_time_steps&#39;]}&quot;)
print(f&quot; Theoretical time: {analysis[&#39;convergence_metrics&#39;][&#39;theoretical_convergence_time&#39;]:.3f} s&quot;)
print(f&quot; Final surface RMS: {analysis[&#39;convergence_metrics&#39;][&#39;final_surface_rms&#39;]:.6f}&quot;) print(&quot;\nControl Characteristics:&quot;)
print(f&quot; Integral state: {analysis[&#39;control_characteristics&#39;][&#39;integral_state&#39;]:.3f}&quot;)
print(f&quot; Anti-windup active: {analysis[&#39;control_characteristics&#39;][&#39;anti_windup_active&#39;]}&quot;)
``` ### Gain Tuning Guidelines #### Stability Constraint **Required:** $K_1 &gt; K_2 &gt; 0$ **Recommended:** $K_1 / K_2 \in [1.2, 3.0]$ - **Ratio too small ($&lt; 1.2$):** Slower convergence, chattering

- **Ratio too large ($&gt; 3.0$):** Aggressive control, potential overshoot #### Performance Trade-offs **Increasing $K_1$:**
- ✓ Faster convergence
- ✓ Stronger disturbance rejection
- ✗ Higher control effort
- ✗ More chattering **Increasing $K_2$:**
- ✓ Better steady-state precision
- ✓ Improved integral action
- ✗ Risk of instability if $K_2 \geq K_1$ **Decreasing $\alpha$:**
- ✓ Faster finite-time convergence
- ✗ More sensitive to noise
- ✗ Higher control effort near $s = 0$ ### Comparison: STA vs Classical SMC | Aspect | Classical SMC | Super-Twisting |
|--------|---------------|----------------|
| Convergence | Asymptotic ($\propto e^{-\lambda t}$) | Finite-time ($t &lt; T_{\text{conv}}$) |
| Chattering | High (discontinuous control) | Low (continuous $u_1$) |
| Robustness | Good | (second-order SM) |
| Tuning complexity | Low (1 gain per DOF) | Medium (2 gains, power exponent) |
| Implementation | Simple | Moderate (integral state) | **Recommendation:** Use STA for applications requiring:
- Guaranteed finite-time convergence
- Minimal chattering (e.g., mechanical systems)
- Strong disturbance rejection

---

## Numerical Stability Algorithms ### IEEE 754 Floating-Point Considerations All numerical operations must account for: 1. **Machine epsilon:** $\epsilon_{\text{machine}} \approx 2.22 \times 10^{-16}$ (double precision)

2. **Overflow threshold:** $\approx 1.79 \times 10^{308}$
3. **Underflow threshold:** $\approx 2.23 \times 10^{-308}$
4. **Subnormal numbers:** Gradual underflow region ### Safe Operations Library Located in `src/utils/numerical_stability/safe_operations.py`: #### 1. Safe Division **Problem:** Division by zero or near-zero denominators **Solution:** $$
\text{safe\_divide}(a, b, \epsilon) = \begin{cases}
\text{fallback} &amp; \text{if } b = 0 \\
\frac{a}{\max(|b|, \epsilon) \cdot \text{sign}(b)} &amp; \text{if } 0 &lt; |b| &lt; \epsilon \\
\frac{a}{b} &amp; \text{otherwise}
\end{cases}
$$ **Implementation:** ```python
from src.utils.numerical_stability import safe_divide # Control law with division
error = state[0]
velocity = state[1] # UNSAFE: division by zero if velocity = 0
# control = error / velocity # SAFE: protected division

control = safe_divide( error, velocity, epsilon=1e-12, # Minimum safe denominator fallback=0.0, # Value if velocity exactly zero warn=True # Issue warning for debugging
)
``` **Epsilon Selection:** | Application | Recommended $\epsilon$ | Rationale |
|-------------|----------------------|-----------|
| Control derivatives | $10^{-12}$ | Stability margin for numerical differentiation |
| Optimization gradients | $10^{-10}$ | Convergence tolerance for gradient descent |
| Physics parameters | $10^{-8}$ | Physical measurement precision |
| General computation | $10^{-15}$ | Near machine epsilon for maximum precision | #### 2. Safe Square Root **Problem:** Domain errors from negative arguments (e.g., numerical noise) **Solution:** $$
\text{safe\_sqrt}(x, \epsilon) = \sqrt{\max(x, \epsilon)}
$$ **Usage:** ```python
from src.utils.numerical_stability import safe_sqrt # Norm computation from squared values
squared_sum = x**2 + y**2 + z**2 # UNSAFE: if squared_sum slightly negative due to numerical error
# norm = np.sqrt(squared_sum) # SAFE: clips to non-negative
norm = safe_sqrt(squared_sum, min_value=1e-15)
``` #### 3. Safe Exponential **Problem:** Overflow for large exponents **Solution:** $$

\text{safe\_exp}(x, x_{\max}) = \exp(\min(x, x_{\max}))
$$ Default: $x_{\max} = 700$ (safe for double precision) **Usage in Control:** ```python
from src.utils.numerical_stability import safe_exp # Exponential barrier function
def barrier_cost(distance, sharpness=10.0): # UNSAFE: exp(1000) overflows # return np.exp(-sharpness * distance) # SAFE: clipped to prevent overflow return safe_exp(-sharpness * distance, max_value=700.0)
``` #### 4. Safe Normalization **Problem:** Zero-length vectors cause division by zero **Solution:** $$
\text{safe\_normalize}(\mathbf{v}) = \frac{\mathbf{v}}{\max(\|\mathbf{v}\|, \epsilon)}
$$ **Usage in Gradient Descent:** ```python
from src.utils.numerical_stability import safe_normalize # Normalized gradient for optimization
gradient = compute_gradient(params) # UNSAFE: if gradient is exactly zero
# step_direction = gradient / np.linalg.norm(gradient) # SAFE: returns zero vector if gradient is zero
step_direction = safe_normalize( gradient, min_norm=1e-15, fallback=np.zeros_like(gradient)
)
``` ### Adaptive Regularization For ill-conditioned matrix operations: $$

\mathbf{M}_{\text{reg}} = \mathbf{M} + \lambda \mathbf{I}
$$ where $\lambda$ is adaptively chosen based on condition number: $$
\lambda = \max(\epsilon_{\text{min}}, \alpha \cdot \kappa(\mathbf{M}) \cdot \epsilon_{\text{machine}})
$$ **Reference:** See `docs/mathematical_foundations/numerical_integration_theory.md` for matrix conditioning details

---

## Algorithm Comparison Framework ### Benchmark Functions Standard test functions for optimization algorithm validation: #### 1. Sphere Function (Unimodal) $$

f(\mathbf{x}) = \sum_{i=1}^D x_i^2
$$ - **Global minimum:** $f(\mathbf{0}) = 0$
- **Bounds:** $x_i \in [-5.12, 5.12]$
- **Properties:** Convex, smooth, separable
- **Use case:** Test convergence speed on simple landscape #### 2. Rosenbrock Function (Multimodal) $$
f(\mathbf{x}) = \sum_{i=1}^{D-1} \left[100(x_{i+1} - x_i^2)^2 + (1 - x_i)^2\right]
$$ - **Global minimum:** $f(\mathbf{1}) = 0$ (at $\mathbf{x} = [1, 1, \ldots, 1]$)
- **Bounds:** $x_i \in [-2.048, 2.048]$
- **Properties:** Non-convex, narrow valley, non-separable
- **Use case:** Test navigation through complex landscapes #### 3. Rastrigin Function (Highly Multimodal) $$
f(\mathbf{x}) = 10D + \sum_{i=1}^D \left[x_i^2 - 10\cos(2\pi x_i)\right]
$$ - **Global minimum:** $f(\mathbf{0}) = 0$
- **Bounds:** $x_i \in [-5.12, 5.12]$
- **Properties:** Highly multimodal ($\sim 10^D$ local minima), separable
- **Use case:** Test escape from local minima #### 4. Ackley Function (Multimodal with Plateau) $$
f(\mathbf{x}) = -20 \exp\left(-0.2\sqrt{\frac{1}{D}\sum_{i=1}^D x_i^2}\right) - \exp\left(\frac{1}{D}\sum_{i=1}^D \cos(2\pi x_i)\right) + 20 + e
$$ - **Global minimum:** $f(\mathbf{0}) = 0$
- **Bounds:** $x_i \in [-32.768, 32.768]$
- **Properties:** Multimodal with nearly flat outer region
- **Use case:** Test global exploration capability ### Statistical Testing #### Mann-Whitney U Test **Null hypothesis:** Two algorithm distributions are identical **Test statistic:** $$
U = \min(U_A, U_B)
$$ where $U_A$ is the number of wins for algorithm A when comparing all pairs. **Decision:** Reject $H_0$ if $p &lt; \alpha$ (typically $\alpha = 0.05$) #### Effect Size (Cohen&#39;s d) Measures practical significance beyond statistical significance: $$
d = \frac{|\mu_A - \mu_B|}{\sqrt{\frac{(n_A - 1)\sigma_A^2 + (n_B - 1)\sigma_B^2}{n_A + n_B - 2}}}
$$ **Interpretation:**
- $d &lt; 0.2$: Negligible effect
- $0.2 \leq d &lt; 0.5$: Small effect
- $0.5 \leq d &lt; 0.8$: Medium effect
- $d \geq 0.8$: Large effect ### Convergence Analysis Metrics **1. Convergence Rate:** $$
r = \frac{f(\mathbf{x}_0) - f(\mathbf{x}_T)}{T}
$$ **2. Convergence Speed:** Iterations to reach 90% of final improvement **3. Success Rate:** Fraction of runs achieving $f(\mathbf{x}_{\text{final}}) &lt; \epsilon_{\text{tol}}$ **4. Stability Metric:** $$
\text{Stability} = \frac{1}{1 + \text{Var}(f(\mathbf{x}_{T-k:T}))}
$$ where variance is computed over the last $k$ iterations.

---

## Performance Optimization Techniques ### Vectorization Strategies **Key principle:** Minimize Python loops, maximize NumPy operations #### Batch Simulation Example ```python

# example-metadata:

# runnable: false # SLOW: Sequential simulation (Python loop)

def sequential_evaluation(particles, controller_factory): costs = [] for gains in particles: controller = controller_factory(gains) cost = simulate(controller, T, dt) costs.append(cost) return np.array(costs) # FAST: Vectorized simulation (NumPy operations)
def vectorized_evaluation(particles, controller_factory): # Single call for entire batch t, x_batch, u_batch, sigma_batch = simulate_system_batch( controller_factory=controller_factory, particles=particles, # Shape: (N, D) sim_time=T, dt=dt ) # Vectorized cost computation costs = compute_costs_batch(t, x_batch, u_batch, sigma_batch) return costs # Shape: (N,) # Speedup: ~20-30x for N=30 particles
``` ### Numba Just-In-Time Compilation For inner loops that cannot be vectorized: ```python
import numba @numba.jit(nopython=True, cache=True)
def fast_dynamics_update(state, control, dt, params): &quot;&quot;&quot;Compiled dynamics integration.&quot;&quot;&quot; # Pure NumPy operations, no Python objects M = compute_mass_matrix(state, params) C = compute_coriolis(state, params) G = compute_gravity(state, params) # Solve: M * qdd = tau - C * qd - G qdd = np.linalg.solve(M, control - C @ state[3:] - G) return state + dt * np.concatenate([state[3:], qdd]) # First call: ~100 ms (compilation overhead)
# Subsequent calls: ~0.1 ms (compiled code)
``` **Speedup:** ~100-1000x for tight numerical loops ### Memory Management **Problem:** PSO creates thousands of controller instances **Solution:** Object pooling and explicit cleanup ```python

from src.controllers.smc import ClassicalSMC # Create controller pool
pool_size = 100
controller_pool = [ ClassicalSMC(gains=default_gains, max_force=100, boundary_layer=0.01) for _ in range(pool_size)
] # Reuse controllers (update gains instead of creating new instances)
for iteration in range(pso_iterations): for i, gains in enumerate(swarm_positions): controller = controller_pool[i % pool_size] controller.set_gains(gains) # Update in-place cost = evaluate(controller) # Explicit cleanup after optimization
for controller in controller_pool: controller.cleanup()
``` **Memory savings:** ~90% reduction vs creating new instances

---

## Advanced Topics ### Multi-Objective Optimization For problems with conflicting objectives: $$
\min_{\mathbf{x}} \mathbf{f}(\mathbf{x}) = [f_1(\mathbf{x}), f_2(\mathbf{x}), \ldots, f_m(\mathbf{x})]
$$ **Pareto dominance:** $\mathbf{x}_a$ dominates $\mathbf{x}_b$ if: $$
\forall i: f_i(\mathbf{x}_a) \leq f_i(\mathbf{x}_b) \quad \land \quad \exists j: f_j(\mathbf{x}_a) &lt; f_j(\mathbf{x}_b)
$$ **Reference:** See `tests/test_optimization/test_algorithm_comparison.py` for multi-objective benchmarks (ZDT1, DTLZ2) ### Constraint Handling For optimization with constraints $g_i(\mathbf{x}) \leq 0$: **Penalty method:** $$
f_{\text{penalized}}(\mathbf{x}) = f(\mathbf{x}) + \sum_{i=1}^m r_i \cdot \max(0, g_i(\mathbf{x}))^2
$$ **Death penalty:** $f_{\text{penalized}}(\mathbf{x}) = \infty$ if any constraint violated ### Hybrid Algorithms Combining PSO with local search: 1. **Global phase:** PSO exploration (50 iterations)
2. **Local phase:** Gradient descent from best PSO solution (refinement) **Reference:** `src/optimization/algorithms/pso_optimizer.py:632` for optimization hooks

---

## Best Practices ### 1. Reproducibility **Always specify seeds:** ```python
# Set global seed in config
config.global_seed = 42 # PSO tuner uses this seed automatically
tuner = PSOTuner(controller_factory, config, seed=42) # Results are now fully reproducible
``` ### 2. Numerical Stability **Use safe operations for all divisions:** ```python

from src.utils.numerical_stability import safe_divide, safe_sqrt, safe_exp # Protect all potentially unstable operations
result = safe_divide(numerator, denominator, epsilon=1e-12)
norm = safe_sqrt(squared_sum, min_value=1e-15)
exponential = safe_exp(large_value, max_value=700.0)
``` ### 3. Validation **Run algorithm comparison tests:** ```bash
# Benchmark against standard test functions
pytest tests/test_optimization/test_algorithm_comparison.py -v # Check statistical significance
pytest tests/test_optimization/test_algorithm_comparison.py::TestAlgorithmComparison::test_statistical_significance_testing -v
``` ### 4. Performance Profiling **Measure optimization efficiency:** ```python

import time start = time.time()
result = tuner.optimise(iters_override=100, n_particles_override=30)
elapsed = time.time() - start evaluations = 100 * 30 # iters * particles
evals_per_second = evaluations / elapsed print(f&quot;Optimization time: {elapsed:.2f} s&quot;)
print(f&quot;Evaluations/second: {evals_per_second:.1f}&quot;)
print(f&quot;Cost per evaluation: {1000 * elapsed / evaluations:.2f} ms&quot;)
``` ### 5. Convergence Monitoring **Track PSO convergence:** ```python
import matplotlib.pyplot as plt result = tuner.optimise() # Plot convergence curve
plt.figure(figsize=(10, 6))
plt.semilogy(result[&#39;history&#39;][&#39;cost&#39;], linewidth=2)
plt.xlabel(&#39;Iteration&#39;)
plt.ylabel(&#39;Best Cost (log scale)&#39;)
plt.title(&#39;PSO Convergence History&#39;)
plt.grid(True, alpha=0.3)
plt.show() # Check for premature convergence
if np.std(result[&#39;history&#39;][&#39;cost&#39;][-20:]) &lt; 1e-6: print(&quot;Warning: PSO may have converged prematurely&quot;)
</pre></div>
</div>
<hr class="docutils" />
<section id="references-1-pso-theory-kennedy-eberhart-1995-particle-swarm-optimization-clerc-kennedy-2002-the-particle-swarm-explosion-stability-and-convergence-in-a-multidimensional-complex-space-2-super-twisting-algorithm-levant-1993-sliding-order-and-sliding-accuracy-in-sliding-mode-control-moreno-osorio-2008-a-lyapunov-approach-to-second-order-sliding-mode-controllers-and-observers-3-numerical-algorithms-golub-van-loan-2013-matrix-computations-4th-edition-higham-2002-accuracy-and-stability-of-numerical-algorithms-2nd-edition-4-algorithm-comparison-derrac-et-al-2011-a-practical-tutorial-on-the-use-of-nonparametric-statistical-tests-garcia-et-al-2009-a-study-on-the-use-of-non-parametric-tests-for-analyzing-the-evolutionary-algorithms-behaviour">
<h2>References 1. <strong>PSO Theory:</strong> - Kennedy &amp; Eberhart (1995). “Particle Swarm Optimization” - Clerc &amp; Kennedy (2002). “The particle swarm - explosion, stability, and convergence in a multidimensional complex space” 2. <strong>Super-Twisting Algorithm:</strong> - Levant (1993). “Sliding order and sliding accuracy in sliding mode control” - Moreno &amp; Osorio (2008). “A Lyapunov approach to second-order sliding mode controllers and observers” 3. <strong>Numerical Algorithms:</strong> - Golub &amp; Van Loan (2013). “Matrix Computations”, 4th edition - Higham (2002). “Accuracy and Stability of Numerical Algorithms”, 2nd edition 4. <strong>Algorithm Comparison:</strong> - Derrac et al. (2011). “A practical tutorial on the use of nonparametric statistical tests” - García et al. (2009). “A study on the use of non-parametric tests for analyzing the evolutionary algorithms’ behaviour”<a class="headerlink" href="#references-1-pso-theory-kennedy-eberhart-1995-particle-swarm-optimization-clerc-kennedy-2002-the-particle-swarm-explosion-stability-and-convergence-in-a-multidimensional-complex-space-2-super-twisting-algorithm-levant-1993-sliding-order-and-sliding-accuracy-in-sliding-mode-control-moreno-osorio-2008-a-lyapunov-approach-to-second-order-sliding-mode-controllers-and-observers-3-numerical-algorithms-golub-van-loan-2013-matrix-computations-4th-edition-higham-2002-accuracy-and-stability-of-numerical-algorithms-2nd-edition-4-algorithm-comparison-derrac-et-al-2011-a-practical-tutorial-on-the-use-of-nonparametric-statistical-tests-garcia-et-al-2009-a-study-on-the-use-of-non-parametric-tests-for-analyzing-the-evolutionary-algorithms-behaviour" title="Link to this heading">¶</a></h2>
<hr class="docutils" />
<p><strong>File Location:</strong> <code class="docutils literal notranslate"><span class="pre">docs/mathematical_foundations/advanced_algorithms_guide.md</span></code>
<strong>Lines:</strong> 721
<strong>Cross-references:</strong></p>
<ul class="simple">
<li><p>PSO implementation: <code class="docutils literal notranslate"><span class="pre">src/optimization/algorithms/pso_optimizer.py</span></code></p></li>
<li><p>Super-twisting: <code class="docutils literal notranslate"><span class="pre">src/controllers/smc/algorithms/super_twisting/twisting_algorithm.py</span></code></p></li>
<li><p>Safe operations: <code class="docutils literal notranslate"><span class="pre">src/utils/numerical_stability/safe_operations.py</span></code></p></li>
<li><p>Algorithm comparison: <code class="docutils literal notranslate"><span class="pre">tests/test_optimization/test_algorithm_comparison.py</span></code></p></li>
</ul>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024, Research Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on Oct 10, 2025</div>
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Advanced Algorithms Guide <strong>Technical Reference for Optimization, Numerical Stability, and Algorithm Comparison</strong></a><ul>
<li><a class="reference internal" href="#table-of-contents-1-introduction">Table of Contents 1. <span class="xref myst">Introduction</span></a></li>
<li><a class="reference internal" href="#introduction-this-guide-provides-technical-documentation-for-the-advanced-algorithms-implemented-in-the-dip-smc-pso-project-these-algorithms-form-the-computational-backbone-of-the-system-enabling-robust-control-efficient-optimization-and-numerical-stability">Introduction This guide provides technical documentation for the advanced algorithms implemented in the DIP-SMC-PSO project. These algorithms form the computational backbone of the system, enabling robust control, efficient optimization, and numerical stability.</a><ul>
<li><a class="reference internal" href="#algorithm-categories">Algorithm Categories</a></li>
</ul>
</li>
<li><a class="reference internal" href="#particle-swarm-optimization-mathematical-foundation-particle-swarm-optimization-pso-is-a-population-based-metaheuristic-inspired-by-social-behavior-of-bird-flocking-and-fish-schooling-core-pso-dynamics-each-particle-i-in-the-swarm-has">Particle Swarm Optimization ### Mathematical Foundation Particle Swarm Optimization (PSO) is a population-based metaheuristic inspired by social behavior of bird flocking and fish schooling. #### Core PSO Dynamics Each particle <span class="math notranslate nohighlight">\(i\)</span> in the swarm has:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#configure-inertia-weight-schedule-in-config-yaml">Configure inertia weight schedule in config.yaml:</a></li>
<li><a class="reference internal" href="#pso">pso:</a></li>
<li><a class="reference internal" href="#w-schedule-0-9-0-4-start-at-0-9-end-at-0-4">w_schedule: [0.9, 0.4] # Start at 0.9, end at 0.4</a></li>
<li><a class="reference internal" href="#iters-100">iters: 100</a></li>
<li><a class="reference internal" href="#n-particles-30-result-tuner-optimise-uses-w-schedule-from-config-manual-iteration-loop-for-custom-control">n_particles: 30 result = tuner.optimise() # Uses w_schedule from config # Manual iteration loop for custom control</a></li>
<li><a class="reference internal" href="#example-metadata">example-metadata:</a></li>
<li><a class="reference internal" href="#runnable-false-configure-physics-uncertainty-in-config-yaml">runnable: false # Configure physics uncertainty in config.yaml:</a></li>
<li><a class="reference internal" href="#physics-uncertainty">physics_uncertainty:</a></li>
<li><a class="reference internal" href="#n-evals-5-5-perturbed-models-per-evaluation">n_evals: 5 # 5 perturbed models per evaluation</a></li>
<li><a class="reference internal" href="#cart-mass-0-10-10">cart_mass: 0.10 # ±10%</a></li>
<li><a class="reference internal" href="#pendulum1-mass-0-15-15">pendulum1_mass: 0.15 # ±15%</a></li>
<li><a class="reference internal" href="#pendulum2-mass-0-15-15">pendulum2_mass: 0.15 # ±15%</a></li>
<li><a class="reference internal" href="#pendulum1-length-0-05-5">pendulum1_length: 0.05 # ±5%</a></li>
<li><a class="reference internal" href="#pendulum2-length-0-05-5-tuner-psotuner-controller-factory-controller-factory-config-config-seed-42">pendulum2_length: 0.05 # ±5% tuner = PSOTuner( controller_factory=controller_factory, config=config, seed=42</a></li>
<li><a class="reference internal" href="#cost-aggregation-0-7-mean-0-3-max">Cost aggregation: 0.7 * mean + 0.3 * max</a><ul>
<li><a class="reference internal" href="#references-1-pso-theory-kennedy-eberhart-1995-particle-swarm-optimization-clerc-kennedy-2002-the-particle-swarm-explosion-stability-and-convergence-in-a-multidimensional-complex-space-2-super-twisting-algorithm-levant-1993-sliding-order-and-sliding-accuracy-in-sliding-mode-control-moreno-osorio-2008-a-lyapunov-approach-to-second-order-sliding-mode-controllers-and-observers-3-numerical-algorithms-golub-van-loan-2013-matrix-computations-4th-edition-higham-2002-accuracy-and-stability-of-numerical-algorithms-2nd-edition-4-algorithm-comparison-derrac-et-al-2011-a-practical-tutorial-on-the-use-of-nonparametric-statistical-tests-garcia-et-al-2009-a-study-on-the-use-of-non-parametric-tests-for-analyzing-the-evolutionary-algorithms-behaviour">References 1. <strong>PSO Theory:</strong> - Kennedy &amp; Eberhart (1995). “Particle Swarm Optimization” - Clerc &amp; Kennedy (2002). “The particle swarm - explosion, stability, and convergence in a multidimensional complex space” 2. <strong>Super-Twisting Algorithm:</strong> - Levant (1993). “Sliding order and sliding accuracy in sliding mode control” - Moreno &amp; Osorio (2008). “A Lyapunov approach to second-order sliding mode controllers and observers” 3. <strong>Numerical Algorithms:</strong> - Golub &amp; Van Loan (2013). “Matrix Computations”, 4th edition - Higham (2002). “Accuracy and Stability of Numerical Algorithms”, 2nd edition 4. <strong>Algorithm Comparison:</strong> - Derrac et al. (2011). “A practical tutorial on the use of nonparametric statistical tests” - García et al. (2009). “A study on the use of non-parametric tests for analyzing the evolutionary algorithms’ behaviour”</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=4ebf8126"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=46bd48cc"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=08e7b316"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>window.MathJax = {"tex": {"tags": "all", "tagSide": "right", "macros": {"vec": ["\\boldsymbol{#1}", 1], "mat": ["\\boldsymbol{#1}", 1], "norm": ["\\left\\|#1\\right\\|", 1], "R": "\\mathbb{R}", "C": "\\mathbb{C}", "N": "\\mathbb{N}", "Z": "\\mathbb{Z}"}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/back-to-top.js?v=840797bb"></script>
    <script src="../_static/lazy-load.js?v=dc25293c"></script>
    <script src="../_static/dark-mode.js?v=bf328970"></script>
    </body>
</html>