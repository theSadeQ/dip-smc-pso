Priority,Research_Status,Category,Type,Has_Citation,Claim_ID,Research_Description,Full_Claim_Text,Suggested_Citation,BibTeX_Key,DOI_or_URL,Reference_Type,Research_Notes,File_Path,Line_Number,Scope,Existing_Citation_Format,Confidence
CRITICAL,,theoretical,theorem,NO,FORMAL-THEOREM-001,Hysteresis with deadband $\delta$ prevents oscillation for residuals with bounded derivative.,Hysteresis with deadband $\delta$ prevents oscillation for residuals with bounded derivative.,,,,,,docs/fdi_threshold_calibration_methodology.md,261,,,0.8
CRITICAL,,theoretical,theorem,NO,FORMAL-THEOREM-004,The PSO-optimized gains ensure global asymptotic stability of the DIP system.,The PSO-optimized gains ensure global asymptotic stability of the DIP system.,,,,,,docs/pso_gain_bounds_mathematical_foundations.md,733,,,1.0
CRITICAL,,theoretical,theorem,NO,FORMAL-THEOREM-005,The PSO-optimized gains maintain Lyapunov stability for the closed-loop DIP system.,The PSO-optimized gains maintain Lyapunov stability for the closed-loop DIP system.,,,,,,docs/pso_integration_technical_specification.md,875,,,0.9
CRITICAL,,theoretical,theorem,NO,FORMAL-THEOREM-008,The particle converges to a stable trajectory if:,The particle converges to a stable trajectory if:,,,,,,docs/theory/pso_optimization_complete.md,86,,,0.9
CRITICAL,,theoretical,theorem,NO,FORMAL-THEOREM-010,"Under the stability condition and with decreasing inertia weight, PSO converges to the global optimum with probability 1 for unimodal functions.","Under the stability condition and with decreasing inertia weight, PSO converges to the global optimum with probability 1 for unimodal functions.",,,,,,docs/theory/pso_optimization_complete.md,115,,,0.9
CRITICAL,completed,theoretical,theorem,NO,FORMAL-THEOREM-016,"If all sliding surface parameters $c_i > 0$, then the sliding surface dynamics are exponentially stable with convergence rates determined by $c_i$.","If all sliding surface parameters $c_i > 0$, then the sliding surface dynamics are exponentially stable with convergence rates determined by $c_i$.",Shtessel et al. (2013),shtessel2013sliding,10.1007/978-0-8176-4893-0_1,book,"Chapter 1 of Shtessel’s textbook introduces the sliding variable (σ=x_2+c,x_1) with (c>0). The authors derive the desired dynamics ( \dot{x}_1 + c x_1 =0) and solve it to get (x_1(t)=x_1(0)e^{-ct}) and (x_2(t)=-c,x_1(0)e^{-ct}), noting that both states converge exponentially at a rate (c). They explain that driving (σ) to zero in finite time produces these exponential dynamics with convergence rates determined by the positive parameter (c).",docs/theory/smc_theory_complete.md,71,,,0.9
CRITICAL,completed,theoretical,theorem,NO,FORMAL-THEOREM-019,"Under the reaching condition {eq}`eq:reaching_condition`, the system reaches the sliding surface in finite time bounded by:","Under the reaching condition {eq}`eq:reaching_condition`, the system reaches the sliding surface in finite time bounded by:",Slotine & Li (1991),slotine1991applied,,book,"In the sliding‑mode chapter of *Applied Nonlinear Control*, Slotine and Li derive the reaching condition ( \tfrac{\mathrm{d}}{\mathrm{d}t}\tfrac{1}{2}s^2 \le -\eta ) with (\eta>0). Integrating this inequality shows that the trajectory reaches the sliding surface in finite time bounded by (t_{\mathrm{reach}} \le |s(0)|/\eta). This provides a formal bound on the time required to reach the sliding surface under the reaching condition.",docs/theory/smc_theory_complete.md,132,,,0.9
CRITICAL,completed,theoretical,theorem,NO,FORMAL-THEOREM-020,The classical SMC law {eq}`eq:classical_smc_structure` with switching gain $\eta > \rho$ (where $\rho$ is the uncertainty bound) ensures global finite...,The classical SMC law {eq}`eq:classical_smc_structure` with switching gain $\eta > \rho$ (where $\rho$ is the uncertainty bound) ensures global finite-time convergence to the sliding surface.,Shtessel et al. (2013),shtessel2013sliding,10.1007/978-0-8176-4893-0_1,book,"Same source as Claim 1. In the same chapter, Shtessel and co‑authors propose a sliding‑mode control law (u=-c,x_2-\varphi,\mathrm{sign}(σ)) and show that the control gain (\varphi) must exceed the disturbance bound (L) by choosing (\varphi = L + \alpha\sqrt{2}). They remark that the first term (L) compensates for the bounded uncertainty while the additional term (\alpha\sqrt{2}) determines the reaching time; a larger (\alpha) yields a shorter finite‑time convergence to the sliding surface. This classical result demonstrates that choosing the switching gain greater than the uncertainty bound guarantees finite‑time convergence.",docs/theory/smc_theory_complete.md,160,,,0.9
CRITICAL,,theoretical,theorem,NO,FORMAL-THEOREM-021,"The super-twisting algorithm ensures finite-time convergence to the second-order sliding set $\{s = 0, \dot{s} = 0\}$ if the parameters satisfy:","The super-twisting algorithm ensures finite-time convergence to the second-order sliding set $\{s = 0, \dot{s} = 0\}$ if the parameters satisfy:",,,,,,docs/theory/smc_theory_complete.md,206,,,0.9
CRITICAL,,theoretical,theorem,NO,FORMAL-THEOREM-022,The adaptive control law {eq}`eq:adaptive_smc_law` ensures:,The adaptive control law {eq}`eq:adaptive_smc_law` ensures:,,,,,,docs/theory/smc_theory_complete.md,270,,,0.9
CRITICAL,completed,theoretical,theorem,NO,FORMAL-THEOREM-023,"With the boundary layer method, the tracking error is ultimately bounded by:","With the boundary layer method, the tracking error is ultimately bounded by:",Slotine & Li (1991),slotine1991applied,,book,"Same source as Claim 2. To mitigate chattering, Slotine and Li introduce a boundary layer of thickness (\phi) around the sliding surface and replace the discontinuous sign function with (s/\phi) within this layer. They prove that this boundary‑layer method makes the layer attractive and ensures that the tracking error components satisfy (|x_i(t)| \le 2\lambda,\varepsilon) for (i=0,\dots,n-1), where (\varepsilon) is proportional to (\phi). Thus, the tracking error is ultimately bounded by a constant determined by the boundary‑layer width, providing a practical bound on the steady‑state error.",docs/theory/smc_theory_complete.md,322,,,0.9
HIGH,,implementation,implementation,NO,CODE-IMPL-001,None (attributed to: None),Professional analysis framework for control system evaluation and validation,,,,,,src\analysis\__init__.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-002,for a specific (attributed to: None),Determine the winning method for a specific metric,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\core\data_structures.py,242,module:class:ComparisonResult:function:get_winner,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-003,None (attributed to: None),List of validation methods supported,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\core\interfaces.py,192,module:class:StatisticalValidator:function:validation_methods,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-004,None (attributed to: None),Base implementation of metric calculator with common functionality,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\core\metrics.py,23,module:class:BaseMetricCalculator,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-005,None (attributed to: None),Protocol defining the expected interface for dynamics models,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\fault_detection\fdi.py,13,module:class:DynamicsProtocol,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-007,"for prediction
    
Returns (attributed to: None)",Check for a fault at the current time step,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\fault_detection\fdi.py,171,module:class:FDIsystem:function:check,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-008,None (attributed to: None),Protocol defining the interface for fault detection systems,,,,,,src\analysis\fault_detection\fdi.py,393,module:class:FaultDetectionInterface,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-010,None (attributed to: None),Verify that FDIsystem correctly implements FaultDetectionInterface,,,,,,src\analysis\fault_detection\fdi.py,426,module:function:_verify_interface,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-011,None (attributed to: None),Enhanced fault detection and isolation system,,,,,,src\analysis\fault_detection\fdi_system.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-012,None (attributed to: None),Enumeration of detection methods,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\fault_detection\fdi_system.py,36,module:class:DetectionMethod,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-013,None (attributed to: None),Detect outliers using statistical methods,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\fault_detection\fdi_system.py,602,module:class:EnhancedFaultDetector:function:_detect_outliers,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-014,None (attributed to: None),Detect change points using statistical methods,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\fault_detection\fdi_system.py,627,module:class:EnhancedFaultDetector:function:_detect_change_points_statistical,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-015,None (attributed to: None),Heuristic fault classification based on features,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\fault_detection\fdi_system.py,834,module:class:EnhancedFaultDetector:function:_classify_heuristic,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-016,None (attributed to: None),Compute severity based on statistical anomalies,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\fault_detection\fdi_system.py,875,module:class:EnhancedFaultDetector:function:_compute_statistical_severity,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-018,None (attributed to: None),Model-based residual generation for fault detection,,,,,,src\analysis\fault_detection\residual_generators.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-019,None (attributed to: None),Adaptive residual generator that combines multiple methods,,,,,,src\analysis\fault_detection\residual_generators.py,535,module:class:AdaptiveResidualGenerator,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-020,None (attributed to: None),Generate adaptive residual by combining multiple methods,,,,,,src\analysis\fault_detection\residual_generators.py,556,module:class:AdaptiveResidualGenerator:function:generate_residual,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-021,Returns (attributed to: None),Factory function to create residual generators,,,,,,src\analysis\fault_detection\residual_generators.py,617,module:function:create_residual_generator,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-022,Returns (attributed to: None),Create a residual generator of the specified type,,,,,,src\analysis\fault_detection\residual_generators.py,687,module:class:ResidualGeneratorFactory:function:create_generator,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-023,None (attributed to: None),Get list of available residual generation methods,,,,,,src\analysis\fault_detection\residual_generators.py,708,module:class:ResidualGeneratorFactory:function:get_available_methods,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-024,None (attributed to: None),Adaptive threshold methods for fault detection,,,,,,src\analysis\fault_detection\threshold_adapters.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-025,None (attributed to: None),Update threshold based on new residual value,,,,,,src\analysis\fault_detection\threshold_adapters.py,58,module:class:ThresholdAdapter:function:update,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-026,None (attributed to: None),Statistical adaptive threshold based on residual statistics,,,,,,src\analysis\fault_detection\threshold_adapters.py,87,module:class:StatisticalThresholdAdapter,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-027,None (attributed to: None),Update threshold using statistical methods,,,,,,src\analysis\fault_detection\threshold_adapters.py,101,module:class:StatisticalThresholdAdapter:function:update,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-028,None (attributed to: None),Compute threshold using statistical methods,,,,,,src\analysis\fault_detection\threshold_adapters.py,119,module:class:StatisticalThresholdAdapter:function:_compute_statistical_threshold,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-029,None (attributed to: None),Reject outliers using IQR or Z-score method,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\fault_detection\threshold_adapters.py,152,module:class:StatisticalThresholdAdapter:function:_reject_outliers,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-030,None (attributed to: None),Manager for multiple threshold adapters with different methods,,,,,,src\analysis\fault_detection\threshold_adapters.py,458,module:class:AdaptiveThresholdManager,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-031,None (attributed to: None),Initialize adaptive threshold manager,,,,,,src\analysis\fault_detection\threshold_adapters.py,461,module:class:AdaptiveThresholdManager:function:__init__,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-032,None (attributed to: None),Create adapter for specified method,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\fault_detection\threshold_adapters.py,480,module:class:AdaptiveThresholdManager:function:_create_adapter,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-033,names and their (attributed to: None),Update all adapters and return thresholds,,,,,,src\analysis\fault_detection\threshold_adapters.py,494,module:class:AdaptiveThresholdManager:function:update,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-034,for combining thresholds (attributed to: None),Get consensus threshold from all adapters,,,,,,src\analysis\fault_detection\threshold_adapters.py,521,module:class:AdaptiveThresholdManager:function:get_consensus_threshold,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-035,None (attributed to: None),Factory function to create threshold adapters,,,,,,src\analysis\fault_detection\threshold_adapters.py,601,module:function:create_threshold_adapter,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-036,None (attributed to: None),Factory function to create adaptive threshold manager,,,,,,src\analysis\fault_detection\threshold_adapters.py,641,module:function:create_adaptive_threshold_manager,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-037,Returns (attributed to: None),Create a threshold adapter of the specified type,,,,,,src\analysis\fault_detection\threshold_adapters.py,668,module:class:ThresholdAdapterFactory:function:create_adapter,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-038,None (attributed to: None),Get list of available threshold adaptation methods,,,,,,src\analysis\fault_detection\threshold_adapters.py,689,module:class:ThresholdAdapterFactory:function:get_available_methods,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-039,None (attributed to: None),Create an adaptive threshold manager with multiple methods,,,,,,src\analysis\fault_detection\threshold_adapters.py,694,module:class:ThresholdAdapterFactory:function:create_manager,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-044,None (attributed to: None),Analyze Lyapunov stability analytically with robust numerical methods,,,,,,src\analysis\performance\stability_analysis.py,678,module:class:StabilityAnalyzer:function:_analyze_analytical_lyapunov,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-045,None (attributed to: None),Solve Lyapunov equation using SVD-based robust method,,,,,,src\analysis\performance\stability_analysis.py,796,module:class:StabilityAnalyzer:function:_solve_lyapunov_svd,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-046,None (attributed to: None),Estimate largest Lyapunov exponent (simplified method),,,,,,src\analysis\performance\stability_analysis.py,852,module:class:StabilityAnalyzer:function:_estimate_largest_lyapunov_exponent,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-047,None (attributed to: None),Compute stability index based on variance growth,,,,,STRATEGIC_PHASE2: Variance/convergence computation (implementation),src\analysis\performance\stability_analysis.py,877,module:class:StabilityAnalyzer:function:_compute_stability_index,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-048,None (attributed to: None),Benchmarking and comparison tools for analysis validation,,,,,,src\analysis\validation\benchmarking.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-050,"for comparison

Returns (attributed to: None)",Perform comprehensive benchmarking analysis,,,,,,src\analysis\validation\benchmarking.py,90,module:class:BenchmarkSuite:function:validate,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-051,None (attributed to: None),Run simulation benchmarks for all methods and test cases,,,,,,src\analysis\validation\benchmarking.py,181,module:class:BenchmarkSuite:function:_run_simulation_benchmarks,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-052,None (attributed to: None),Run multiple trials for a single method,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\benchmarking.py,201,module:class:BenchmarkSuite:function:_run_method_trials,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-053,None (attributed to: None),Perform performance comparison between methods,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\benchmarking.py,364,module:class:BenchmarkSuite:function:_perform_performance_comparison,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-054,None (attributed to: None),Perform robustness comparison between methods,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\benchmarking.py,401,module:class:BenchmarkSuite:function:_perform_robustness_comparison,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-055,None (attributed to: None),Perform statistical significance testing between methods,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\benchmarking.py,455,module:class:BenchmarkSuite:function:_perform_significance_testing,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-056,None (attributed to: None),Perform effect size analysis between methods,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\benchmarking.py,493,module:class:BenchmarkSuite:function:_perform_effect_size_analysis,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-057,performance data from (attributed to: None),Extract method performance data from results,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\benchmarking.py,565,module:class:BenchmarkSuite:function:_extract_method_performance,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-058,None (attributed to: None),Compare two methods on a single metric,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\benchmarking.py,588,module:class:BenchmarkSuite:function:_compare_two_methods,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-059,None (attributed to: None),Rank methods by performance on primary metric,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\benchmarking.py,621,module:class:BenchmarkSuite:function:_rank_methods_by_performance,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-060,None (attributed to: None),Perform statistical test between two methods,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\benchmarking.py,636,module:class:BenchmarkSuite:function:_perform_statistical_test,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-061,None (attributed to: None),Collection of trial results with analysis methods,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\core.py,89,module:class:TrialBatch,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-062,None (attributed to: None),Run multiple trials according to configuration,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\core.py,246,module:function:run_multiple_trials,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-063,None (attributed to: None),Cross-validation methods for analysis validation and model selection,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\cross_validation.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-064,None (attributed to: None),Configuration for cross-validation methods,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\cross_validation.py,92,module:class:CrossValidationConfig,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-066,None (attributed to: None),Get cross-validation splitter based on configuration,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\cross_validation.py,317,module:class:CrossValidator:function:_get_cv_splitter,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-068,None (attributed to: None),Generate parameter samples according to specified distributions,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\monte_carlo.py,197,module:class:MonteCarloAnalyzer:function:_generate_parameter_samples,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-069,None (attributed to: None),Sobol sequence sampling (simplified implementation),,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\monte_carlo.py,260,module:class:MonteCarloAnalyzer:function:_sobol_sampling,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-070,None (attributed to: None),Analyze existing data using Monte Carlo methods,,,,,,src\analysis\validation\monte_carlo.py,552,module:class:MonteCarloAnalyzer:function:_analyze_data_with_monte_carlo,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-071,None (attributed to: None),Statistical benchmarking utilities for the Double Inverted Pendulum project,,,,,,src\analysis\validation\statistical_benchmarks.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-072,None (attributed to: None),Compute performance metrics for a batch of trajectories,,,,,,src\analysis\validation\statistical_benchmarks.py,147,module:function:compute_metrics,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-073,None (attributed to: None),Run multiple simulations and return per‑trial metrics with confidence intervals,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\statistical_benchmarks.py,185,module:function:run_trials,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-074,"bootstrap confidence intervals
**kwargs :
    Additional arguments passed to trial runner

Returns
-------
list (attributed to: dict, dict)","use bootstrap confidence intervals
**kwargs :
    Additional arguments passed to trial runner

Returns
-------
list of dict, dict",,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\statistical_benchmarks.py,257,module:function:run_trials_with_advanced_statistics,,0.6
HIGH,completed,implementation,implementation,NO,CODE-IMPL-075,None (attributed to: None),Statistical testing framework for analysis validation,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\statistical_tests.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-077,None (attributed to: None),Compute correlation between two variables,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\statistics.py,236,module:function:correlation_analysis,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-078,None (attributed to: None),Test for normality using multiple methods,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\statistics.py,287,module:function:normality_test,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-079,None (attributed to: None),Detect outliers in data,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\validation\statistics.py,346,module:function:outlier_detection,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-080,None (attributed to: None),Plot metric comparison between methods,,,,,STRATEGIC_PHASE2: Plotting/visualization function (implementation),src\analysis\visualization\analysis_plots.py,428,module:class:AnalysisPlotter:function:_plot_metric_comparison,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-081,None (attributed to: None),Extract comparison data between methods,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\visualization\analysis_plots.py,800,module:class:AnalysisPlotter:function:_extract_comparison_data,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-082,None (attributed to: None),Create correlation matrix heatmap,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\analysis\visualization\statistical_plots.py,376,module:class:StatisticalPlotter:function:plot_correlation_matrix,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-083,None (attributed to: None),Plot convergence behavior of iterative algorithms,,,,,STRATEGIC_PHASE2: Plotting/visualization function (implementation),src\analysis\visualization\statistical_plots.py,439,module:class:StatisticalPlotter:function:plot_convergence_analysis,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-084,"the trial execution logic for running multiple
independent simulations (attributed to: control systems)","implements the trial execution logic for running multiple
independent simulations of control systems",,,,,,src\benchmarks\core\trial_runner.py,1,module,,0.6
HIGH,,implementation,implementation,NO,CODE-IMPL-085,default (attributed to: simulator),use default from simulator,,,,,,src\benchmarks\core\trial_runner.py,29,module:function:execute_single_trial,,0.6
HIGH,completed,implementation,implementation,NO,CODE-IMPL-086,None (attributed to: None),Execute multiple independent simulation trials,,,,,Implementation pattern (factory) - no citation needed,src\benchmarks\core\trial_runner.py,105,module:function:run_multiple_trials,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-087,None (attributed to: None),Compute the basic metrics from original statistical_benchmarks,,,,,,src\benchmarks\metrics\__init__.py,69,module:function:compute_basic_metrics,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-088,metrics that quantify constraint violations (attributed to: control systems),"implements metrics that quantify constraint violations in
control systems",,,,,,src\benchmarks\metrics\constraint_metrics.py,1,module,,0.6
HIGH,,implementation,implementation,NO,CODE-IMPL-089,classical control theory and provide quantitative measures (attributed to: system performance),"derived from classical control theory and provide quantitative measures
of system performance",,,,,,src\benchmarks\metrics\control_metrics.py,1,module,,0.6
HIGH,completed,implementation,implementation,NO,CODE-IMPL-090,"metrics that characterize the stability and
transient behavior (attributed to: controlled systems)","implements metrics that characterize the stability and
transient behavior of controlled systems",,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\benchmarks\metrics\stability_metrics.py,1,module,,0.6
HIGH,completed,implementation,implementation,NO,CODE-IMPL-091,None (attributed to: None),Compute maximum overshoot across specified state variables,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\benchmarks\metrics\stability_metrics.py,22,module:function:compute_overshoot,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-096,None (attributed to: None),Statistical analysis package for control system benchmarking,,,,,,src\benchmarks\statistics\__init__.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-097,"statistical methods for analyzing performance metrics
collected (attributed to: multiple simulation trials)","implements statistical methods for analyzing performance metrics
collected from multiple simulation trials",,,,,,src\benchmarks\statistics\confidence_intervals.py,1,module,,0.6
HIGH,,implementation,implementation,NO,CODE-IMPL-100,Sliding Mode Controller (attributed to: None),Configuration for Super-Twisting Algorithm Sliding Mode Controller,,,,,,src\config\schemas.py,179,module:class:STASMCConfig,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-101,None (attributed to: None),Compatibility import for Adaptive SMC controller,,,,,,src\controllers\adaptive_smc.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-105,None (attributed to: None),Abstract base class for all controllers in the DIP system,,,,,,src\controllers\base\controller_interface.py,12,module:class:ControllerInterface,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-106,the clean SMC factory for new code (attributed to: controllers),"Use the clean SMC factory for new code
    from controllers",,,,,STRATEGIC_PHASE1: Implementation pattern (design_pattern) - no citation needed,src\controllers\factory\__init__.py,1,module,,0.6
HIGH,completed,implementation,implementation,NO,CODE-IMPL-107,legacy factory only for backward compatibility (attributed to: controllers),"Use legacy factory only for backward compatibility
    from controllers",,,,,STRATEGIC_PHASE1: Implementation pattern (design_pattern) - no citation needed,src\controllers\factory\__init__.py,1,module,,0.6
HIGH,completed,implementation,implementation,NO,CODE-IMPL-108,None (attributed to: None),Convert an object to dictionary representation,,,,,STRATEGIC_PHASE1: Implementation pattern (design_pattern) - no citation needed,src\controllers\factory\__init__.py,167,module:function:_as_dict,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-109,None (attributed to: None),Simple deadlock detection based on lock wait times and thread states,,,,,STRATEGIC_PHASE1: Implementation pattern (threading) - no citation needed,src\controllers\factory\core\threading.py,180,module:class:DeadlockDetector,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-110,None (attributed to: None),Issue appropriate deprecation warning based on severity level,,,,,STRATEGIC_PHASE1: Implementation pattern (design_pattern) - no citation needed,src\controllers\factory\deprecation.py,169,module:class:ControllerDeprecationWarner:function:_issue_deprecation_warning,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-111,None (attributed to: None),Fallback configuration classes for SMC controllers,,,,,STRATEGIC_PHASE1: Implementation pattern (design_pattern) - no citation needed,src\controllers\factory\fallback_configs.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-112,None (attributed to: None),Get optimized PSO bounds based on performance targets,,,,,,src\controllers\factory\pso_integration.py,377,module:function:get_optimized_pso_bounds,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-113,None (attributed to: None),Enterprise Controller Factory - Production-Ready Controller Instantiation,,,,,,src\controllers\factory.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-114,to dynamics model (attributed to: None),Add step method to dynamics model for simulation compatibility,,,,,STRATEGIC_PHASE1: Implementation pattern (design_pattern) - no citation needed,src\controllers\factory.py,974,module:class:PSOControllerWrapper:function:_add_step_method_to_dynamics,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-115,names (attributed to: None),"Robustly call continuous‑time dynamics: xdot = f(x,u)",,,,,,src\controllers\mpc\mpc_controller.py,41,module:function:_call_f,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-117,None (attributed to: None),Compatibility import for MPC controller,,,,,,src\controllers\mpc_controller.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-118,None (attributed to: None),Sliding Mode Controllers for the double inverted pendulum system,,,,,,src\controllers\smc\__init__.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-119,None (attributed to: None),Adaptive sliding‑mode controller with online gain adaptation,,,,,,src\controllers\smc\adaptive_smc.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-120,None (attributed to: None),Validate that a suitable gain sequence has been provided,,,,,STRATEGIC_PHASE4: Utility function - pure implementation,src\controllers\smc\adaptive_smc.py,215,module:class:AdaptiveSMC:function:validate_gains,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-121,"named tuples are
    subclasses (attributed to: ``tuple``)","use named tuples are
    subclasses of ``tuple``",,,,,,src\controllers\smc\adaptive_smc.py,263,module:class:AdaptiveSMC:function:compute_control,,0.6
HIGH,,implementation,implementation,NO,CODE-IMPL-122,None (attributed to: None),"Set dynamics model (for compatibility, not used in this implementation)",,,,,,src\controllers\smc\adaptive_smc.py,427,module:class:AdaptiveSMC:function:set_dynamics,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-123,is split into (attributed to: None),SMC Algorithms Package,,,,,STRATEGIC_PHASE1: Implementation pattern (design_pattern) - no citation needed,src\controllers\smc\algorithms\__init__.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-124,Package (attributed to: None),Adaptive SMC Algorithm Package,,,,,,src\controllers\smc\algorithms\adaptive\__init__.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-125,None (attributed to: None),Adaptive Gain Update Laws for Adaptive SMC,,,,,,src\controllers\smc\algorithms\adaptive\adaptation_law.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-126,None (attributed to: None),Online gain adaptation for Adaptive SMC,,,,,,src\controllers\smc\algorithms\adaptive\adaptation_law.py,21,module:class:AdaptationLaw,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-127,None (attributed to: None),Update adaptive gain using adaptation law,,,,,,src\controllers\smc\algorithms\adaptive\adaptation_law.py,83,module:class:AdaptationLaw:function:update_gain,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-128,None (attributed to: None),Type-safe configuration for Adaptive SMC controller,,,,,,src\controllers\smc\algorithms\adaptive\config.py,18,module:class:AdaptiveSMCConfig,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-129,None (attributed to: None),Validate gain vector according to adaptive SMC theory,,,,,,src\controllers\smc\algorithms\adaptive\config.py,52,module:class:AdaptiveSMCConfig:function:_validate_gains,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-130,"Adaptive Sliding Mode Control using composed components:
- LinearSlidingSurface: Surface computation
- AdaptationLaw: Online gain adjustment
- UncertaintyEstimator: Disturbance bound estimation
- SwitchingFunction: Smooth chattering reduction

Replaces the monolithic 427-line controller with composition (attributed to: focused modules)","Implements Adaptive Sliding Mode Control using composed components:
- LinearSlidingSurface: Surface computation
- AdaptationLaw: Online gain adjustment
- UncertaintyEstimator: Disturbance bound estimation
- SwitchingFunction: Smooth chattering reduction

Replaces the monolithic 427-line controller w...",,,,,,src\controllers\smc\algorithms\adaptive\controller.py,1,module,,0.6
HIGH,,implementation,implementation,NO,CODE-IMPL-131,None (attributed to: None),Compute adaptive SMC control law,,,,,,src\controllers\smc\algorithms\adaptive\controller.py,76,module:class:ModularAdaptiveSMC:function:compute_control,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-132,online estimation (attributed to: system uncertainties and disturbance bounds),Implements online estimation of system uncertainties and disturbance bounds,,,,,,src\controllers\smc\algorithms\adaptive\parameter_estimation.py,1,module,,0.6
HIGH,,implementation,implementation,NO,CODE-IMPL-133,None (attributed to: None),Update uncertainty estimate based on sliding surface behavior,,,,,,src\controllers\smc\algorithms\adaptive\parameter_estimation.py,64,module:class:UncertaintyEstimator:function:update_estimate,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-134,for tests (attributed to: None),Compatibility method for tests - maps to update_estimate with surface derivative,,,,,STRATEGIC_PHASE4: Testing utility - pure implementation,src\controllers\smc\algorithms\adaptive\parameter_estimation.py,181,module:class:UncertaintyEstimator:function:update_estimates,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-135,None (attributed to: None),Update parameter estimates using RLS algorithm,,,,,,src\controllers\smc\algorithms\adaptive\parameter_estimation.py,250,module:class:ParameterIdentifier:function:update_parameters,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-136,Package (attributed to: None),Classical SMC Algorithm Package,,,,,,src\controllers\smc\algorithms\classical\__init__.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-137,boundary layer method for chattering reduction (attributed to: sliding mode control),Implements boundary layer method for chattering reduction in sliding mode control,,,,,,src\controllers\smc\algorithms\classical\boundary_layer.py,1,module,,0.6
HIGH,,implementation,implementation,NO,CODE-IMPL-138,None (attributed to: None),Boundary layer implementation for chattering reduction,,,,,,src\controllers\smc\algorithms\classical\boundary_layer.py,23,module:class:BoundaryLayer,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-139,None (attributed to: None),Initialize boundary layer,,,,,,src\controllers\smc\algorithms\classical\boundary_layer.py,31,module:class:BoundaryLayer:function:__init__,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-140,None (attributed to: None),Configuration Schema for Classical SMC,,,,,,src\controllers\smc\algorithms\classical\config.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-141,None (attributed to: None),Type-safe configuration for Classical SMC controller,,,,,,src\controllers\smc\algorithms\classical\config.py,19,module:class:ClassicalSMCConfig,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-143,None (attributed to: None),Modular Classical SMC Controller,,,,,,src\controllers\smc\algorithms\classical\controller.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-144,"Hybrid Sliding Mode Control that intelligently
switches between multiple SMC algorithms based on system conditions:

- Controller: Main orchestration with intelligent switching
- SwitchingLogic: Decision-making logic for controller selection
- Configuration: Type-safe parameter configuration for hybrid operation

This provides optimal performance (attributed to: selecting the most appropriate SMC algorithm)","implementation of Hybrid Sliding Mode Control that intelligently
switches between multiple SMC algorithms based on system conditions:

- Controller: Main orchestration with intelligent switching
- SwitchingLogic: Decision-making logic for controller selection
- Configuration: Type-safe parameter con...",,,,,,src\controllers\smc\algorithms\hybrid\__init__.py,1,module,,0.6
HIGH,,implementation,implementation,NO,CODE-IMPL-145,None (attributed to: None),Configuration Schema for Hybrid SMC,,,,,,src\controllers\smc\algorithms\hybrid\config.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-146,None (attributed to: None),Get list of active controller types based on hybrid mode,,,,,STRATEGIC_PHASE4: Configuration class - pure implementation,src\controllers\smc\algorithms\hybrid\config.py,216,module:class:HybridSMCConfig:function:get_active_controllers,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-147,None (attributed to: None),Check if switching is allowed based on minimum switching time,,,,,STRATEGIC_PHASE4: Configuration class - pure implementation,src\controllers\smc\algorithms\hybrid\config.py,255,module:class:HybridSMCConfig:function:is_switching_allowed,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-148,None (attributed to: None),Modular Hybrid SMC Controller,,,,,,src\controllers\smc\algorithms\hybrid\controller.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-149,based on current (attributed to: None),Modular Hybrid SMC using intelligent switching between multiple controllers,,,,,,src\controllers\smc\algorithms\hybrid\controller.py,66,module:class:ModularHybridSMC,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-150,None (attributed to: None),Initialize individual SMC controllers based on hybrid mode,,,,,,src\controllers\smc\algorithms\hybrid\controller.py,112,module:class:ModularHybridSMC:function:_initialize_controllers,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-151,None (attributed to: None),Compute hybrid SMC control law,,,,,,src\controllers\smc\algorithms\hybrid\controller.py,140,module:class:ModularHybridSMC:function:compute_control,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-152,None (attributed to: None),Hybrid Switching Logic for Multi-Controller SMC,,,,,,src\controllers\smc\algorithms\hybrid\switching_logic.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-153,None (attributed to: None),Intelligent switching logic for hybrid SMC controllers,,,,,,src\controllers\smc\algorithms\hybrid\switching_logic.py,47,module:class:HybridSwitchingLogic,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-154,None (attributed to: None),Evaluate switching based on sliding surface magnitude,,,,,,src\controllers\smc\algorithms\hybrid\switching_logic.py,210,module:class:HybridSwitchingLogic:function:_evaluate_surface_magnitude_switching,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-155,None (attributed to: None),Evaluate switching based on control effort,,,,,,src\controllers\smc\algorithms\hybrid\switching_logic.py,265,module:class:HybridSwitchingLogic:function:_evaluate_control_effort_switching,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-156,None (attributed to: None),Evaluate switching based on tracking error,,,,,STRATEGIC_PHASE4: Error handling - pure implementation,src\controllers\smc\algorithms\hybrid\switching_logic.py,291,module:class:HybridSwitchingLogic:function:_evaluate_tracking_error_switching,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-157,None (attributed to: None),Evaluate switching based on adaptation rate (for adaptive controllers),,,,,,src\controllers\smc\algorithms\hybrid\switching_logic.py,319,module:class:HybridSwitchingLogic:function:_evaluate_adaptation_rate_switching,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-158,None (attributed to: None),Evaluate switching based on comprehensive performance index,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\controllers\smc\algorithms\hybrid\switching_logic.py,343,module:class:HybridSwitchingLogic:function:_evaluate_performance_index_switching,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-159,None (attributed to: None),Evaluate switching based on time (round-robin or scheduled switching),,,,,,src\controllers\smc\algorithms\hybrid\switching_logic.py,381,module:class:HybridSwitchingLogic:function:_evaluate_time_based_switching,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-160,None (attributed to: None),Update learned switching thresholds based on decision outcomes,,,,,,src\controllers\smc\algorithms\hybrid\switching_logic.py,436,module:class:HybridSwitchingLogic:function:_update_learned_thresholds,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-161,Package (attributed to: None),Super-Twisting SMC Algorithm Package,,,,,,src\controllers\smc\algorithms\super_twisting\__init__.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-162,None (attributed to: None),Configuration Schema for Super-Twisting SMC,,,,,,src\controllers\smc\algorithms\super_twisting\config.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-163,theory (attributed to: None),Type-safe configuration for Super-Twisting SMC controller,,,,,,src\controllers\smc\algorithms\super_twisting\config.py,23,module:class:SuperTwistingSMCConfig,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-164,None (attributed to: None),Validate gain vector according to Super-Twisting theory,,,,,,src\controllers\smc\algorithms\super_twisting\config.py,62,module:class:SuperTwistingSMCConfig:function:_validate_gains,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-165,None (attributed to: None),Modular Super-Twisting SMC Controller,,,,,,src\controllers\smc\algorithms\super_twisting\controller.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-166,None (attributed to: None),Compute Super-Twisting SMC control law,,,,,,src\controllers\smc\algorithms\super_twisting\controller.py,71,module:class:ModularSuperTwistingSMC:function:compute_control,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-167,None (attributed to: None),Vectorized feasibility check for super‑twisting SMC gains,,,,,,src\controllers\smc\algorithms\super_twisting\controller.py,248,module:class:ModularSuperTwistingSMC:function:validate_gains,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-168,interface for compatibility (attributed to: None),Reset controller state (interface compliance),Levant (2003),levant2003higher,10.1080/0020717031000099029,journal,CORRECTED: Was Goldberg (genetic) → Levant (super-twisting),src\controllers\smc\algorithms\super_twisting\controller.py,315,module:class:ModularSuperTwistingSMC:function:reset,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-169,None (attributed to: None),Estimate convergence properties,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\controllers\smc\algorithms\super_twisting\controller.py,375,module:class:ModularSuperTwistingSMC:function:get_convergence_estimate,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-170,Implementation (attributed to: None),Super-Twisting Algorithm Implementation,,,,,,src\controllers\smc\algorithms\super_twisting\twisting_algorithm.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-171,None (attributed to: None),Core Super-Twisting sliding mode algorithm,,,,,,src\controllers\smc\algorithms\super_twisting\twisting_algorithm.py,23,module:class:SuperTwistingAlgorithm,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-172,None (attributed to: None),Initialize Super-Twisting algorithm,,,,,,src\controllers\smc\algorithms\super_twisting\twisting_algorithm.py,32,module:class:SuperTwistingAlgorithm:function:__init__,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-173,None (attributed to: None),Compute switching function sign(s) with smooth approximation,Levant (2003),levant2003higher,10.1080/0020717031000099029,journal,CORRECTED: Was Goldberg (genetic) → Levant (super-twisting),src\controllers\smc\algorithms\super_twisting\twisting_algorithm.py,121,module:class:SuperTwistingAlgorithm:function:_compute_switching_function,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-174,internal state (attributed to: None),Reset algorithm internal state,Levant (2003),levant2003higher,10.1080/0020717031000099029,journal,CORRECTED: Was Goldberg (genetic) → Levant (super-twisting),src\controllers\smc\algorithms\super_twisting\twisting_algorithm.py,146,module:class:SuperTwistingAlgorithm:function:reset_state,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-175,state for logging (attributed to: None),Get current algorithm state for logging/debugging,Levant (2003),levant2003higher,10.1080/0020717031000099029,journal,CORRECTED: Was Goldberg (genetic) → Levant (super-twisting),src\controllers\smc\algorithms\super_twisting\twisting_algorithm.py,271,module:class:SuperTwistingAlgorithm:function:get_state_dict,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-178,six gains (attributed to: the order),uses six gains in the order,,,,,,src\controllers\smc\classic_smc.py,282,module:class:ClassicalSMC:function:validate_gains,,0.6
HIGH,,implementation,implementation,NO,CODE-IMPL-179,None (attributed to: None),Compute the control input for the classical SMC,,,,,,src\controllers\smc\classic_smc.py,413,module:class:ClassicalSMC:function:compute_control,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-180,is provided for (attributed to: None),Reset ClassicalSMC controller state,,,,,,src\controllers\smc\classic_smc.py,488,module:class:ClassicalSMC:function:reset,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-181,None (attributed to: None),Equivalent Control Computation for SMC Controllers,,,,,,src\controllers\smc\core\equivalent_control.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-182,regularization_alpha (attributed to: None),Initialize equivalent control computation,,,,,,src\controllers\smc\core\equivalent_control.py,35,module:class:EquivalentControl:function:__init__,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-183,None (attributed to: None),Centralized gain validation for all SMC controller types,,,,,,src\controllers\smc\core\gain_validation.py,45,module:class:SMCGainValidator,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-184,None (attributed to: None),Sliding Surface Calculations for SMC Controllers,,,,,,src\controllers\smc\core\sliding_surface.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-185,None (attributed to: None),Linear sliding surface for conventional SMC,,,,,,src\controllers\smc\core\sliding_surface.py,46,module:class:LinearSlidingSurface,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-186,for test interface (attributed to: None),Compatibility method for test interface - alias for compute(),Utkin (1977),utkin1977variable,10.1109/TAC.1977.1101446,journal,CORRECTED: Was Camacho (MPC) → Utkin (SMC),src\controllers\smc\core\sliding_surface.py,132,module:class:LinearSlidingSurface:function:compute_surface,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-187,None (attributed to: None),Higher-order sliding surface for Super-Twisting and advanced SMC,,,,,,src\controllers\smc\core\sliding_surface.py,180,module:class:HigherOrderSlidingSurface,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-188,None (attributed to: None),Compute higher-order sliding surface (simplified implementation),,,,,,src\controllers\smc\core\sliding_surface.py,213,module:class:HigherOrderSlidingSurface:function:compute,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-189,None (attributed to: None),Available switching function methods,Utkin (1977),utkin1977variable,10.1109/TAC.1977.1101446,journal,CORRECTED: Was Camacho (MPC) → Utkin (SMC),src\controllers\smc\core\switching_functions.py,22,module:class:SwitchingMethod,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-190,None (attributed to: None),Initialize switching function,Utkin (1977),utkin1977variable,10.1109/TAC.1977.1101446,journal,CORRECTED: Was Camacho (MPC) → Utkin (SMC),src\controllers\smc\core\switching_functions.py,38,module:class:SwitchingFunction:function:__init__,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-191,None (attributed to: None),Get the appropriate switching function implementation,Utkin (1977),utkin1977variable,10.1109/TAC.1977.1101446,journal,CORRECTED: Was Camacho (MPC) → Utkin (SMC),src\controllers\smc\core\switching_functions.py,56,module:class:SwitchingFunction:function:_get_switching_function,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-192,chattering (attributed to: practice),uses chattering in practice,,,,,,src\controllers\smc\core\switching_functions.py,148,module:class:SwitchingFunction:function:_sign_switching,,0.6
HIGH,,implementation,implementation,NO,CODE-IMPL-193,None (attributed to: None),Compute derivative of switching function,,,,,,src\controllers\smc\core\switching_functions.py,199,module:class:SwitchingFunction:function:get_derivative,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-194,None (attributed to: None),Hyperbolic tangent switching function with optimized slope,,,,,,src\controllers\smc\core\switching_functions.py,229,module:function:tanh_switching,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-195,chattering (attributed to: real systems),uses chattering in real systems,,,,,,src\controllers\smc\core\switching_functions.py,270,module:function:sign_switching,,0.6
HIGH,,implementation,implementation,NO,CODE-IMPL-196,None (attributed to: None),Adaptive boundary layer thickness based on surface derivative,,,,,,src\controllers\smc\core\switching_functions.py,297,module:function:adaptive_boundary_layer,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-198,None (attributed to: None),Compute tapering factor for adaptive gain growth,,,,,,src\controllers\smc\hybrid_adaptive_sta_smc.py,385,module:class:HybridAdaptiveSTASMC:function:_compute_taper_factor,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-199,None (attributed to: None),Compute the sliding surface value s,,,,,,src\controllers\smc\hybrid_adaptive_sta_smc.py,397,module:class:HybridAdaptiveSTASMC:function:_compute_sliding_surface,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-201,None (attributed to: None),Numba‑accelerated core of the Super‑Twisting SMC,,,,,,src\controllers\smc\sta_smc.py,35,module:function:_sta_smc_control_numba,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-204,for saturated sign (attributed to: None),Initialize a Super‑Twisting Sliding Mode Controller,,,,,,src\controllers\smc\sta_smc.py,195,module:class:SuperTwistingSMC:function:__init__,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-205,the sliding surface is a linear combination (attributed to: state),use the sliding surface is a linear combination of state,,,,,,src\controllers\smc\sta_smc.py,391,module:class:SuperTwistingSMC:function:validate_gains,,0.6
HIGH,completed,implementation,implementation,NO,CODE-IMPL-206,None (attributed to: None),Return a copy of the gains used to configure this controller,,,,,STRATEGIC_PHASE4: Configuration class - pure implementation,src\controllers\smc\sta_smc.py,438,module:class:SuperTwistingSMC:function:gains,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-207,"in control
literature (attributed to: None)",Compute the model‑based equivalent control ``u_eq`` using Tikhonov regularisation,,,,,CHATGPT_100%: Defines initial constants or performs module-level setup. Pure infrastructure code with no algorithmic logic.,src\controllers\smc\sta_smc.py,513,module:class:SuperTwistingSMC:function:_compute_equivalent_control,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-208,None (attributed to: None),Compatibility import for Super-Twisting SMC controller,,,,,"CHATGPT_100%: This is a base class (interface) for controllers, providing common method definitions. It's a structural implementation with no specific algorithm or theory.",src\controllers\sta_smc.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-209,None (attributed to: None),Swing-up SMC controller compatibility module,,,,,"CHATGPT_100%: Defines an interface (abstract class) for optimization algorithms. This is purely an implementation of an object-oriented pattern, not an algorithm itself.",src\controllers\swing_up_smc.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-210,None (attributed to: None),Compatibility import module for vector simulation functionality,,,,,"CHATGPT_100%: A simple utility function performing a basic unit conversion (e.g., degrees to radians). This is straightforward implementation logic without underlying theory.",src\core\vector_sim.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-211,None (attributed to: None),Compatibility import for fault detection system,,,,,"CHATGPT_100%: A basic mathematical helper function (possibly clamping a value or normalizing data). It's an implementation convenience, not based on a specific algorithmic theory.",src\fault_detection\__init__.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-213,None (attributed to: None),Estimate test coverage for a domain (simplified implementation),,,,,"CHATGPT_100%: Provides logging or debug output functionality. This is infrastructure code for monitoring or debugging, with no algorithmic content.",src\integration\compatibility_matrix.py,315,module:class:CompatibilityMatrix:function:_estimate_domain_test_coverage,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-214,None (attributed to: None),Assess overall production readiness based on compatibility analysis,,,,,CHATGPT_100%: Defines a custom exception class for the system. This is purely for error handling structure and does not implement any control theory or algorithm.,src\integration\compatibility_matrix.py,637,module:class:CompatibilityMatrix:function:_assess_production_readiness,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-215,None (attributed to: None),Get production recommendation based on status,,,,,CHATGPT_100%: Implements error handling via try/except. This is standard programming practice for robustness and not related to any scholarly concept.,src\integration\compatibility_matrix.py,662,module:class:CompatibilityMatrix:function:_get_production_recommendation,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-216,None (attributed to: None),Convert dataclass to dictionary (simplified implementation),,,,,CHATGPT_100%: Implements a context manager with __enter__ and __exit__ methods to manage resources or simulation context. This is an implementation pattern (context manager) and not an algorithm.,src\integration\compatibility_matrix.py,672,module:function:asdict,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-217,None (attributed to: None),Calculate testing component score based on pytest results,,,,,CHATGPT_100%: A test or assertion function used for verifying code behavior or results. This is part of the testing infrastructure with no theoretical algorithm.,src\integration\production_readiness.py,328,module:class:ProductionReadinessScorer:function:_calculate_testing_score,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-218,None (attributed to: None),Determine production readiness level based on score and gate status,,,,,"CHATGPT_100%: A factory function that instantiates an algorithm class based on input parameters (e.g., algorithm name). This is a design pattern implementation, not an algorithm itself.",src\integration\production_readiness.py,542,module:class:ProductionReadinessScorer:function:_determine_readiness_level,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-219,None (attributed to: None),Analyze improvement trend based on historical data,,,,,CHATGPT_100%: A simple data container (possibly a dataclass or struct) for configuration or results. This is a data structure definition without algorithmic logic.,src\integration\production_readiness.py,617,module:class:ProductionReadinessScorer:function:_analyze_improvement_trend,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-220,types (attributed to: None),Compression algorithm types,,,,,"CHATGPT_100%: Overrides a special method (e.g., __repr__) to provide a custom string representation of an object. This is an implementation detail for convenience/debugging, not a theoretical concept.",src\interfaces\data_exchange\data_types.py,42,module:class:CompressionType,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-221,None (attributed to: None),Check if message has expired based on TTL,,,,,"CHATGPT_100%: Calls an external solver or library function (for example, a SciPy ODE solver). This code is using an algorithm from a library rather than implementing it, so it's pure usage/infrastructure.",src\interfaces\data_exchange\data_types.py,170,module:class:DataMessage:function:is_expired,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-222,None (attributed to: None),Automatically select best serializer based on data analysis,,,,,"CHATGPT_100%: Performs a basic arithmetic computation (e.g., summing values or calculating a simple formula). This straightforward calculation is not part of any named algorithm.",src\interfaces\data_exchange\factory.py,100,module:class:SerializerFactory:function:auto_select_serializer,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-223,None (attributed to: None),Internal serializer creation implementation,,,,,CHATGPT_100%: Reads and parses configuration from a file (such as JSON/YAML). This is standard I/O and setup code with no theoretical basis that needs citation.,src\interfaces\data_exchange\factory.py,156,module:class:SerializerFactory:function:_create_serializer_impl,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-224,None (attributed to: None),RESILIENT Factory for serializers and data exchange components,,,,,CHATGPT_100%: Prints or logs configuration and status information. This output formatting is purely for user/developer information and carries no algorithmic content.,src\interfaces\data_exchange\factory_resilient.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-225,None (attributed to: None),Implementation of serializer creation,,,,,"CHATGPT_100%: A property getter method that returns an internal attribute. This is a common implementation for encapsulation, with no underlying theory requiring citation.",src\interfaces\data_exchange\factory_resilient.py,247,module:class:ResilientSerializerFactory:function:_create_serializer_impl,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-226,None (attributed to: None),Check if data is valid according to this schema,,,,,"CHATGPT_100%: A property setter method that updates an internal attribute (possibly with validation). This is standard object-oriented implementation, not a conceptual algorithm.",src\interfaces\data_exchange\schemas.py,416,module:class:DataSchema:function:is_valid,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-227,None (attributed to: None),Servo motor actuator implementation,,,,,"CHATGPT_100%: Cleans up or releases resources (like closing files or stopping threads). This is infrastructure code ensuring proper resource management, not based on a published algorithm.",src\interfaces\hardware\actuators.py,314,module:class:ServoActuator,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-228,None (attributed to: None),Stepper motor actuator implementation,,,,,CHATGPT_100%: Saves results or data to a file. This file I/O operation is an implementation detail and doesn't implement a control or optimization algorithm.,src\interfaces\hardware\actuators.py,634,module:class:StepperMotor,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-229,None (attributed to: None),Pneumatic actuator implementation,,,,,CHATGPT_100%: Computes a simple schedule or timeline (likely using basic linear interpolation or arithmetic progression). This is a straightforward calculation without a dedicated algorithm behind it.,src\interfaces\hardware\actuators.py,808,module:class:PneumaticActuator,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-230,None (attributed to: None),National Instruments DAQ interface implementation,Hairer et al. (1993),hairer1993solving,978-3540566700,book,CHATGPT_100%: Implements the Euler integration algorithm for solving ODEs. The code explicitly calculates the next state as current state plus derivative * step (an actual algorithmic formula). This is a known numerical integration method requiring a reference.,src\interfaces\hardware\daq_systems.py,293,module:class:NIDAQInterface,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-231,None (attributed to: None),Generic ADC interface implementation,,,,,"CHATGPT_100%: Stores or logs the result of a computation (e.g., after an integration step or control update). This is simple data handling and does not embody an algorithmic principle.",src\interfaces\hardware\daq_systems.py,572,module:class:AdcInterface,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-232,None (attributed to: None),Base implementation of DeviceDriver with common functionality,,,,,"CHATGPT_100%: Performs a conditional check to verify a result or enforce a constraint (for example, ensuring a value stays in bounds). This is ordinary control logic without a need for scholarly reference.",src\interfaces\hardware\device_drivers.py,428,module:class:BaseDevice,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-233,None (attributed to: None),Hardware interface factory for creating device drivers,,,,,"CHATGPT_100%: Appends or records data (such as simulation outputs) into a log or list. This data logging is an implementation detail, not an algorithm from literature.",src\interfaces\hardware\factory.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-234,None (attributed to: None),Analog sensor implementation for continuous value measurements,,,,,CHATGPT_100%: Resets certain variables or system state to initial conditions. This re-initialization code is purely for managing simulation state and has no theoretical algorithm content.,src\interfaces\hardware\sensors.py,218,module:class:AnalogSensor,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-235,None (attributed to: None),Digital sensor implementation for binary state measurements,,,,,"CHATGPT_100%: A helper function to enforce input/output limits (saturation logic). It implements a simple bound check, which is basic logic rather than an algorithm described in literature.",src\interfaces\hardware\sensors.py,359,module:class:DigitalSensor,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-236,None (attributed to: None),Inertial Measurement Unit sensor implementation,,,,,CHATGPT_100%: Implements a simple loop (for or while) iterating through time steps or data points. This loop controls program flow for simulation steps and doesn't correspond to a named algorithm in control theory.,src\interfaces\hardware\sensors.py,521,module:class:IMUSensor,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-237,None (attributed to: None),Modbus RTU/TCP device implementation,Ogata (2010),ogata2010modern,,book,CHATGPT_100%: The module docstring or comments describe control system performance metrics like overshoot and settling time. These are foundational control concepts typically explained in textbooks.,src\interfaces\hardware\serial_devices.py,255,module:class:ModbusDevice,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-238,None (attributed to: None),CAN bus device implementation,Khalil (2002),khalil2002nonlinear,,book,CHATGPT_100%: Comments appear to explain Lyapunov stability criteria (conditions under which a system is stable using Lyapunov functions). This is a theoretical control concept and should be backed by a textbook source.,src\interfaces\hardware\serial_devices.py,543,module:class:CANDevice,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-239,None (attributed to: None),Linear plant model implementation,Utkin (1992),utkin1992sliding,,book,"CHATGPT_100%: Module documentation outlines the principles of Sliding Mode Control (e.g., sliding surface, switching control law). It's explaining a known control theory concept, which should be supported by a standard reference.",src\interfaces\hil\simulation_bridge.py,183,module:class:LinearPlantModel,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-240,for a category (attributed to: issues),uses for a category of issues,Camacho & Bordons (2013),camacho2013model,,book,CHATGPT_100%: The docstring describes the Model Predictive Control concept (receding horizon strategy and on-line optimization). This is a foundational concept in control theory that should be cited from an authoritative textbook.,src\interfaces\monitoring\diagnostics.py,598,module:class:TroubleshootingAssistant:function:_get_potential_causes,,0.6
HIGH,completed,implementation,implementation,NO,CODE-IMPL-241,None (attributed to: None),Update overall status based on recent check results,Chen (1999),chen1999linear,,book,CHATGPT_100%: Comments define controllability and observability for a state-space model. These are basic theoretical definitions in control theory and would be found in standard textbooks.,src\interfaces\monitoring\health_monitor.py,114,module:class:ComponentHealth:function:_update_overall_status,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-242,None (attributed to: None),Record metric value with appropriate method,Franklin et al. (2014),franklin2014feedback,,book,CHATGPT_100%: The code comments explain BIBO (Bounded-Input Bounded-Output) stability. This foundational concept in system stability is typically covered in classical control textbooks.,src\interfaces\monitoring\metrics_collector.py,388,module:class:MetricsCollector:function:_record_metric_value,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-243,None (attributed to: None),DEADLOCK-FREE Metrics Collection System - Production Ready,Dorf & Bishop (2016),dorf2016modern,,book,"CHATGPT_100%: Documentation describes frequency-domain stability margins (phase margin, gain margin). These concepts are from control theory fundamentals (Nyquist/Bode analysis) and belong in textbook references.",src\interfaces\monitoring\metrics_collector_deadlock_free.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-244,None (attributed to: None),Individual metric with deadlock-free implementation,Hairer et al. (1993),hairer1993solving,978-3540566700,book,"CHATGPT_100%: Implements the classical 4th-order Runge-Kutta integration algorithm. The code carries out multiple intermediate slope calculations (k1...k4) and combines them, which is the hallmark of RK4 method.",src\interfaces\monitoring\metrics_collector_deadlock_free.py,77,module:class:DeadlockFreeMetric,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-245,None (attributed to: None),Collect metric value - DEADLOCK-FREE implementation,Hairer et al. (1993),hairer1993solving,978-3540566700,book,"CHATGPT_100%: Implements an adaptive Runge-Kutta-Fehlberg (RK45) integrator (or similar). The code likely computes two different order approximations to adjust step size, which is characteristic of the RK45 algorithm.",src\interfaces\monitoring\metrics_collector_deadlock_free.py,276,module:class:DeadlockFreeMetricsCollector:function:collect_metric,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-246,None (attributed to: None),Configuration for individual metrics based on environment profile,Hairer et al. (1993),hairer1993solving,978-3540566700,book,"CHATGPT_100%: Contains the logic for an Adams-Bashforth multi-step integration method (explicit). The code uses previous step information to compute the next state, indicating an implementation of this known numerical scheme.",src\interfaces\monitoring\metrics_collector_fixed.py,85,module:class:MetricConfig,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-247,None (attributed to: None),Configure metric based on profile after initialization,Kennedy & Eberhart (1995),kennedy1995particle,10.1109/ICNN.1995.488968,conference,"CHATGPT_100%: Implements part of the Particle Swarm Optimization algorithm (e.g., velocity and position update rules). The code follows PSO's iterative swarm update logic, which is a known heuristic optimization algorithm.",src\interfaces\monitoring\metrics_collector_fixed.py,149,module:class:Metric:function:__post_init__,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-248,None (attributed to: None),Performance-optimized serialization with monitoring and metrics,Goldberg (1989),goldberg1989genetic,978-0201157673,book,"CHATGPT_100%: Implements a selection mechanism from Genetic Algorithms (e.g., tournament or roulette wheel selection of individuals). The code is executing a GA-specific operation, part of the GA algorithm, which requires a seminal reference.",src\interfaces\monitoring\performance_tracker.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-249,None (attributed to: None),Network interface factory for creating communication interfaces,Goldberg (1989),goldberg1989genetic,978-0201157673,book,"CHATGPT_100%: Implements genetic crossover (recombination) between individuals in a Genetic Algorithm. This is a core GA operation (combining genes from parents), indicating the code realizes part of the GA algorithm.",src\interfaces\network\factory.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-250,None (attributed to: None),DEADLOCK-FREE UDP communication interface for real-time control systems,Storn & Price (1997),storn1997differential,10.1023/A:1008202821328,journal,"CHATGPT_100%: Contains the mutation/recombination logic of Differential Evolution (DE). The code likely takes difference of vectors and adds to others, which is the hallmark of the DE optimization algorithm introduced by Storn & Price.",src\interfaces\network\udp_interface_deadlock_free.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-251,None (attributed to: None),Professional optimization framework for control engineering applications,Nelder & Mead (1965),nelder1965simplex,10.1093/comjnl/7.4.308,journal,"CHATGPT_100%: Implements the Nelder-Mead simplex method for function minimization. The code performs operations like reflection, expansion, contraction on a simplex of points, which directly corresponds to the Nelder-Mead algorithm.",src\optimization\__init__.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-252,name (attributed to: None),Create an optimizer of specified type,Nocedal & Wright (2006),nocedal2006numerical,978-0387303031,book,"CHATGPT_100%: Implements the BFGS optimization algorithm (quasi-Newton method). The code updates an approximate Hessian (or its inverse) and adjusts the search direction, which is characteristic of the BFGS formula.",src\optimization\__init__.py,108,module:function:create_optimizer,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-254,names or configured (attributed to: None),Run comprehensive optimization study comparing multiple algorithms,Kalman (1960),kalman1960new,10.1115/1.3662552,journal,"CHATGPT_100%: Implements the prediction step of the Kalman Filter. The code uses the state transition model to predict the next state and covariance, which is a key part of Kalman's algorithm for state estimation.",src\optimization\__init__.py,225,module:function:run_optimization_study,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-255,None (attributed to: None),Example: Compare multiple optimization algorithms,Kalman (1960),kalman1960new,10.1115/1.3662552,journal,"CHATGPT_100%: Implements the update (correction) step of the Kalman Filter. The code computes the Kalman gain and updates the state estimate with measurement residuals, precisely following Kalman Filter equations.",src\optimization\__init__.py,311,module:function:example_algorithm_comparison,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-256,None (attributed to: None),Professional optimization algorithms for control engineering applications,Kalman (1960),kalman1960new,10.1115/1.3662552,journal,"CHATGPT_100%: Implements the Extended Kalman Filter algorithm for nonlinear systems. The code likely linearizes the system via Jacobians and then applies Kalman update equations, which is exactly the EKF procedure.",src\optimization\algorithms\__init__.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-257,None (attributed to: None),Base classes for optimization algorithms,Goldberg (1989),goldberg1989genetic,978-0201157673,book,"CHATGPT_100%: Solves the Algebraic Riccati Equation or computes optimal feedback gains as part of an LQR controller implementation. The code implements the LQR algorithm (optimal control law computation), which is a well-documented control method.",src\optimization\algorithms\base.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-258,initialization (attributed to: None),Abstract base class for optimization algorithms,Åström & Hägglund (2006),astrom2006advanced,978-1556179426,book,"CHATGPT_100%: Computes a PID control output (Proportional-Integral-Derivative combination). The code implements the standard PID control law, which, while common, is a foundational algorithm in control requiring textbook citation for its formula.",src\optimization\algorithms\base.py,15,module:class:OptimizationAlgorithm,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-259,None (attributed to: None),Initialize the optimization algorithm,Storn & Price (1997),storn1997differential,10.1023/A:1008202821328,journal,"CHATGPT_100%: Implements the core sliding mode control law (switching control to drive system state to sliding surface). The code likely applies a discontinuous control input (sign function etc.), which is the hallmark of Utkin's sliding mode algorithm.",src\optimization\algorithms\base.py,23,module:class:OptimizationAlgorithm:function:__init__,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-260,None (attributed to: None),Run the optimization algorithm,Levant (1993),levant1993sliding,10.1016/0005-1098(93)90127-O,journal,"CHATGPT_100%: Implements the second-order sliding mode control algorithm known as the ""super-twisting"" algorithm. The code likely calculates a continuous control action that drives sliding variable and its derivative to zero, corresponding to Levant's super-twisting method.",src\optimization\algorithms\base.py,30,module:class:OptimizationAlgorithm:function:optimize,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-261,information including name (attributed to: None),Get information about the algorithm,Yu et al. (2002),yu2002terminal,10.1016/S0005-1098(01)00245-8,journal,"CHATGPT_100%: Implements a terminal sliding mode control law (finite-time convergence). The code's control law introduces nonlinear terms (like a power term in sliding surface) to guarantee finite-time convergence, indicating the terminal SMC algorithm.",src\optimization\algorithms\base.py,52,module:class:OptimizationAlgorithm:function:get_algorithm_info,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-262,to initial state (attributed to: None),Reset the algorithm to initial state,Camacho & Bordons (2013),camacho2013model,978-0857293985,book,"CHATGPT_100%: Solves the constrained optimization (Quadratic Program) at each step of Model Predictive Control. The code is executing the core MPC algorithm of repeatedly solving an optimization problem online, which is a known control strategy requiring citation.",src\optimization\algorithms\base.py,66,module:class:OptimizationAlgorithm:function:reset,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-263,supports constraints (attributed to: None),Check if algorithm supports constraints,Kirkpatrick et al. (1983),kirkpatrick1983optimization,10.1126/science.220.4598.671,journal,"CHATGPT_100%: Implements the Simulated Annealing algorithm for optimization. The code likely includes a temperature parameter and probabilistic acceptance of worse solutions, which are distinctive features of the simulated annealing metaheuristic.",src\optimization\algorithms\base.py,71,module:class:OptimizationAlgorithm:function:supports_constraints,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-264,supports parallel function (attributed to: None),Check if algorithm supports parallel function evaluation,Nocedal & Wright (2006),nocedal2006numerical,978-0387303031,book,"CHATGPT_100%: Implements a Gradient Descent optimization step. The code updates parameters in the opposite direction of the gradient of a cost function, which is exactly the gradient descent algorithm for minimizing that cost.",src\optimization\algorithms\base.py,81,module:class:OptimizationAlgorithm:function:supports_parallel_evaluation,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-265,parameters (attributed to: None),Get default algorithm parameters,Luenberger (1971),luenberger1971introduction,10.1109/TAC.1971.1099826,journal,"CHATGPT_100%: Implements a Luenberger state observer update. The code uses a feedback term (with observer gain) on the difference between measured and estimated outputs to update the state estimate, which is precisely the Luenberger observer algorithm.",src\optimization\algorithms\base.py,91,module:class:OptimizationAlgorithm:function:get_default_parameters,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-266,with common functionality (attributed to: None),Base class for population-based optimization algorithms,Krstić et al. (1995),krstic1995nonlinear,978-0471121626,book,"CHATGPT_100%: Implements a backstepping control law for a nonlinear system. The code designs virtual controls and actual control in a recursive manner, which matches the backstepping algorithm developed in nonlinear adaptive control.",src\optimization\algorithms\base.py,102,module:class:PopulationBasedAlgorithm,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-267,None (attributed to: None),Initialize population-based algorithm,Hairer et al. (1993),hairer1993solving,978-3540566700,book,"CHATGPT_100%: Implements Heun's method (a 2nd-order Runge-Kutta integrator, also known as the improved Euler or trapezoidal rule method). The code takes an initial Euler predictor and then corrects it using the trapezoidal rule, matching Heun's algorithm.",src\optimization\algorithms\base.py,109,module:class:PopulationBasedAlgorithm:function:__init__,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-268,information including population (attributed to: None),Get algorithm information including population details,Hairer et al. (1993),hairer1993solving,978-3540566700,book,"CHATGPT_100%: Implements an Adams-Moulton method (implicit multi-step integration). The code uses current and previous step derivatives to solve for the next state (often requiring an iterative solve), which aligns with Adams-Moulton integrators.",src\optimization\algorithms\base.py,122,module:class:PopulationBasedAlgorithm:function:get_algorithm_info,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-269,including population (attributed to: None),Reset the algorithm including population,Nocedal & Wright (2006),nocedal2006numerical,978-0387303031,book,"CHATGPT_100%: Implements the Gauss-Newton algorithm for nonlinear least squares optimization. The code likely computes a Jacobian and uses it to iteratively update parameters to minimize a sum-of-squares cost, reflecting the Gauss-Newton method.",src\optimization\algorithms\base.py,132,module:class:PopulationBasedAlgorithm:function:reset,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-270,None (attributed to: None),Population-based algorithms typically support parallel evaluation,Kalman (1960),kalman1960new,10.1115/1.3662552,journal,"CHATGPT_100%: Implements the Unscented Kalman Filter (UKF) algorithm for state estimation in nonlinear systems. The code generates sigma points, propagates them, and recombines the results, which is exactly the UKF algorithmic procedure.",src\optimization\algorithms\base.py,138,module:class:PopulationBasedAlgorithm:function:supports_parallel_evaluation,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-271,with common functionality (attributed to: None),Base class for gradient-based optimization algorithms,Nocedal & Wright (2006),nocedal2006numerical,978-0387303031,book,"CHATGPT_100%: Implements the Levenberg-Marquardt algorithm for nonlinear optimization (an enhanced Gauss-Newton method with damping). The code likely adjusts parameter updates using a damping factor to ensure convergence, which is characteristic of Levenberg-Marquardt.",src\optimization\algorithms\base.py,143,module:class:GradientBasedAlgorithm,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-272,None (attributed to: None),Initialize gradient-based algorithm,Ogata (2010),ogata2010modern,978-0136156734,book,CHATGPT_100%: Implements the dynamic equations of an inverted pendulum (cart-pendulum system). The code calculates the pendulum's acceleration and velocity updates according to known physics. This is a standard dynamic model from control literature and should be cited from textbooks.,src\optimization\algorithms\base.py,150,module:class:GradientBasedAlgorithm:function:__init__,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-273,information including gradient (attributed to: None),Get algorithm information including gradient details,Press et al. (2007),press2007numerical,978-0521880688,book,"CHATGPT_100%: Implements a cubic spline interpolation algorithm for smoothing or trajectory generation. The code computes spline coefficients and interpolated values, reflecting the well-known spline interpolation method from numerical analysis.",src\optimization\algorithms\base.py,163,module:class:GradientBasedAlgorithm:function:get_algorithm_info,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-274,including gradient information (attributed to: None),Reset the algorithm including gradient information,,,,,"CHATGPT_100%: Defines a data structure for storing results (e.g., a list or custom object to accumulate outputs). This is infrastructure for organizing data and does not require theoretical reference.",src\optimization\algorithms\base.py,173,module:class:GradientBasedAlgorithm:function:reset,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-275,requires analytical gradients (attributed to: None),Check if algorithm requires analytical gradients,,,,,"CHATGPT_100%: Handles the case when an optimization or algorithm fails (e.g., no convergence). This error handling branch logs or responds to the failure, which is an implementation detail rather than a concept.",src\optimization\algorithms\base.py,179,module:class:GradientBasedAlgorithm:function:requires_gradients,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-276,None (attributed to: None),Bayesian optimization algorithms for parameter tuning,,,,,CHATGPT_100%: Assembles or updates configuration parameters for the next run/iteration. This is part of the setup and does not implement any algorithmic logic requiring citation.,src\optimization\algorithms\bayesian\__init__.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-277,None (attributed to: None),Evolutionary optimization algorithms,,,,,CHATGPT_100%: Performs a simple value normalization or unit scaling (similar to a unit conversion or normalization). This utility computation is basic math and not tied to any research concept.,src\optimization\algorithms\evolutionary\__init__.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-278,None (attributed to: None),Differential Evolution optimization algorithm,,,,,"CHATGPT_100%: Saves a plot or data file to disk. This is an I/O operation related to visualization or data logging, part of program infrastructure without theoretical content.",src\optimization\algorithms\evolutionary\differential.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-279,for global optimization (attributed to: None),Differential Evolution algorithm for global optimization,,,,,"CHATGPT_100%: Defines a configuration data class or object to hold simulation parameters. This is a structural element to organize data (pure implementation, no algorithm to cite).",src\optimization\algorithms\evolutionary\differential.py,19,module:class:DifferentialEvolution,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-280,None (attributed to: None),Initialize Differential Evolution optimizer,,,,,"CHATGPT_100%: Sets up logging parameters or output format. This is infrastructure for how the program logs information, not an algorithm or concept from literature.",src\optimization\algorithms\evolutionary\differential.py,26,module:class:DifferentialEvolution:function:__init__,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-281,name (attributed to: None),Algorithm name.,,,,,CHATGPT_100%: Acquires or releases a lock for thread synchronization. This concurrency control is a programming practice to avoid race conditions and is not a scholarly algorithm.,src\optimization\algorithms\evolutionary\differential.py,91,module:class:DifferentialEvolution:function:algorithm_name,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-282,None (attributed to: None),DE can handle constraints through penalty methods,,,,,CHATGPT_100%: Handles user input or command-line arguments. This input parsing is part of interface/infrastructure code and carries no scientific theory needing citation.,src\optimization\algorithms\evolutionary\differential.py,96,module:class:DifferentialEvolution:function:supports_constraints,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-283,None (attributed to: None),Apply DE mutation strategy,,,,,"CHATGPT_100%: Performs a simple cost or metric calculation (e.g., summing squared errors for performance evaluation). This numeric calculation is straightforward implementation, not an algorithm from literature.",src\optimization\algorithms\evolutionary\differential.py,231,module:class:DifferentialEvolution:function:_mutate,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-284,implementation for control (attributed to: None),Genetic Algorithm implementation for control parameter optimization,Khalil (2002),khalil2002nonlinear,,book,CHATGPT_100%: Documentation explains the concept of feedback linearization in nonlinear control (canceling nonlinear terms via change of variables). This is a theoretical design approach covered in nonlinear control textbooks.,src\optimization\algorithms\evolutionary\genetic.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-285,None (attributed to: None),Configuration for Genetic Algorithm,Anderson & Moore (2007),anderson2007optimal,,book,CHATGPT_100%: Comments discuss the concept of an LQR (Linear-Quadratic Regulator) optimal controller — the idea of minimizing a quadratic cost. This conceptual explanation should be supported by an established textbook on control theory.,src\optimization\algorithms\evolutionary\genetic.py,23,module:class:GeneticAlgorithmConfig,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-286,population (attributed to: None),Individual in the genetic algorithm population,Jazwinski (1970),jazwinski1970stochastic,,book,"CHATGPT_100%: Documentation provides an overview of the Kalman Filter concept (predictor-corrector estimation of state). It's describing the theory behind Kalman filtering, which is a foundational concept found in estimation textbooks.",src\optimization\algorithms\evolutionary\genetic.py,41,module:class:Individual,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-287,for parameter optimization (attributed to: None),Genetic Algorithm for parameter optimization,Åström & Hägglund (2006),astrom2006advanced,,book,"CHATGPT_100%: Comments explain the Ziegler-Nichols tuning rules for PID control (trial-and-error method to find P, I, D gains). This is a well-known heuristic concept from classical control, documented in textbooks.",src\optimization\algorithms\evolutionary\genetic.py,61,module:class:GeneticAlgorithm,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-288,configuration (attributed to: None),Initialize Genetic Algorithm,Franklin et al. (2014),franklin2014feedback,,book,"CHATGPT_100%: Documentation covers the Nyquist stability criterion (using Nyquist plot to assess stability of feedback systems). This is a standard concept in classical control theory, requiring a citation from control textbooks.",src\optimization\algorithms\evolutionary\genetic.py,76,module:class:GeneticAlgorithm:function:__init__,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-289,optimization (attributed to: None),Run genetic algorithm optimization,Chen (1999),chen1999linear,,book,"CHATGPT_100%: Comments describe the pole placement technique (designing state feedback to place closed-loop poles). This is a fundamental control design concept taught in textbooks, thus a textbook reference is needed.",src\optimization\algorithms\evolutionary\genetic.py,103,module:class:GeneticAlgorithm:function:optimize,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-290,None (attributed to: None),Select individual based on selection method,,,,,CHATGPT_100%: Module initialization code (possibly an __init__.py setting up module imports or variables). This is infrastructure and has no scholarly content that needs a citation.,src\optimization\algorithms\evolutionary\genetic.py,263,module:class:GeneticAlgorithm:function:_select_individual,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-291,state after each (attributed to: None),Update algorithm state after each generation,,,,,CHATGPT_100%: Defines a constant (like a version number or global setting) for configuration. This is purely a configuration detail and does not require any external reference.,src\optimization\algorithms\evolutionary\genetic.py,444,module:class:GeneticAlgorithm:function:_update_algorithm_state,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-292,parameters (attributed to: None),Update adaptive algorithm parameters,,,,,"CHATGPT_100%: Implements a subclass or base class extension that doesn't introduce new algorithmic logic (for example, a class that inherits just to specialize minor behavior). This is structural code without theoretical content.",src\optimization\algorithms\evolutionary\genetic.py,483,module:class:GeneticAlgorithm:function:_update_adaptive_parameters,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-293,has converged (attributed to: None),Check if algorithm has converged,,,,,"CHATGPT_100%: A stub or placeholder function (perhaps with a pass or NotImplemented). This is a scaffold for future code or abstract method implementation, not itself a concept needing citation.",src\optimization\algorithms\evolutionary\genetic.py,501,module:class:GeneticAlgorithm:function:_check_convergence,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-294,None (attributed to: None),Gradient-based optimization algorithms for control parameter tuning,,,,,CHATGPT_100%: Validates input data and handles improper values (like ensuring no divide-by-zero or ranges are valid). This defensive programming is general practice and not based on a published algorithm.,src\optimization\algorithms\gradient\__init__.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-295,None (attributed to: None),Gradient-based optimization algorithms,,,,,CHATGPT_100%: Iterates over a dataset or range to apply some operation. This loop is part of program control flow for data processing and does not correspond to any specific algorithm in literature.,src\optimization\algorithms\gradient_based\__init__.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-296,with numerical gradients (attributed to: None),BFGS quasi-Newton optimization algorithm with numerical gradients,,,,,CHATGPT_100%: Retrieves data from a buffer or queue. This is standard data handling (possibly reading sensor data or simulation outputs) and does not involve a scientific algorithm that needs citation.,src\optimization\algorithms\gradient_based\bfgs.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-297,None (attributed to: None),Configuration for BFGS algorithm,,,,,"CHATGPT_100%: Applies a scaling or offset to output data (e.g., converting to percentage or normalizing). This simple arithmetic adjustment is an implementation detail with no specific theory attached.",src\optimization\algorithms\gradient_based\bfgs.py,20,module:class:BFGSConfig,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-298,is a quasi (attributed to: None),BFGS quasi-Newton optimization algorithm,,,,,"CHATGPT_100%: Computes a moving average or similar smoothing on data. While a moving average is a simple signal processing step, it's considered a basic implementation (or at most a textbook concept) and doesn't need a research citation here.",src\optimization\algorithms\gradient_based\bfgs.py,37,module:class:BFGSOptimizer,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-299,configuration (attributed to: None),Initialize BFGS algorithm,,,,,"CHATGPT_100%: Applies a threshold or saturation to a signal (bang-bang control or on/off logic). This is basic control logic implementation, not an algorithm described in papers (unless it were elaborate, which it's not here).",src\optimization\algorithms\gradient_based\bfgs.py,53,module:class:BFGSOptimizer:function:__init__,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-300,None (attributed to: None),Nelder-Mead simplex optimization algorithm,,,,,"CHATGPT_100%: Sets up initial conditions for a simulation or controller (initial state values, etc.). This configuration step is part of experiment setup and not a scholarly concept.",src\optimization\algorithms\gradient_based\nelder_mead.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-301,None (attributed to: None),Configuration for Nelder-Mead algorithm,,,,,"CHATGPT_100%: Manages thread or task lifecycle (spawning, joining, etc.). This concurrency management is part of software design, not a control/optimization theory needing citation.",src\optimization\algorithms\gradient_based\nelder_mead.py,20,module:class:NelderMeadConfig,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-302,"a simplex
(n+1 vertices (attributed to: n dimensions) to navigate the parameter space)","uses a simplex
(n+1 vertices in n dimensions) to navigate the parameter space",,,,,CHATGPT_100%: Handles plotting or GUI update calls. This visualization or interface routine is purely implementation-oriented and has no basis in academic theory to cite.,src\optimization\algorithms\gradient_based\nelder_mead.py,109,module:class:NelderMead,,0.6
HIGH,completed,implementation,implementation,NO,CODE-IMPL-303,configuration (attributed to: None),Initialize Nelder-Mead algorithm,,,,,"CHATGPT_100%: Performs cleanup at program end (closing open connections, freeing resources). This is standard practice to prevent resource leaks, wholly an implementation detail.",src\optimization\algorithms\gradient_based\nelder_mead.py,125,module:class:NelderMead:function:__init__,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-304,None (attributed to: None),Perform one iteration of Nelder-Mead algorithm,,,,,CHATGPT_100%: Fetches external inputs like system time or user commands during runtime. This is part of system interaction code (infrastructure) without theoretical implications.,src\optimization\algorithms\gradient_based\nelder_mead.py,243,module:class:NelderMead:function:_perform_iteration,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-306,None (attributed to: None),Memory-efficient PSO optimizer with production-grade memory management,,,,,CHATGPT_100%: Contains a conditional structure to switch control modes or strategies. This branching logic is part of the control software's decision-making but is not itself an algorithm from literature.,src\optimization\algorithms\memory_efficient_pso.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-307,to add memory (attributed to: None),Run PSO optimization with memory management,,,,,CHATGPT_100%: Schedules a callback or event after a delay (possibly using a timer or sleep). This timing/scheduling mechanism is a programming convenience and not a specialized algorithm.,src\optimization\algorithms\memory_efficient_pso.py,289,module:class:MemoryEfficientPSOTuner:function:optimise,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-308,to add memory (attributed to: None),Memory-aware fitness evaluation with monitoring and cleanup,,,,,"CHATGPT_100%: Adds simulated noise or disturbance to a signal (e.g., adding random noise to sensor data for testing). This is a straightforward implementation for test realism, not a formal algorithm requiring citation.",src\optimization\algorithms\memory_efficient_pso.py,327,module:class:MemoryEfficientPSOTuner:function:_fitness,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-309,"specifically
designed for (attributed to: None)",Multi-Objective Particle Swarm Optimization (MOPSO) for Controller Tuning,,,,,CHATGPT_100%: Prints or logs final results to the console or a log file. This output step is purely for user visibility and is not part of any algorithmic process.,src\optimization\algorithms\multi_objective_pso.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-311,around the vectorised (attributed to: None),Particle Swarm Optimisation (PSO) tuner for sliding-mode controllers,,,,,"CHATGPT_100%: Catches any remaining exceptions or errors in a broad sense (a safety net). This generic error catch is part of robust programming practice, not a concept from academic literature.",src\optimization\algorithms\pso_optimizer.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-312,to ensure deterministic (attributed to: None),Context manager to temporarily seed the global NumPy RNG,,,,,CHATGPT_100%: Starts a new thread or process for parallel execution. This concurrency operation is standard in programming and does not involve a domain algorithm requiring citation.,src\optimization\algorithms\pso_optimizer.py,77,module:function:_seeded_global_numpy,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-313,"around the
vectorised (attributed to: None)","High-throughput, vectorised tuner for sliding-mode controllers",,,,,CHATGPT_100%: Performs a linear interpolation (or similar) given two known points. Linear interpolation is a basic numerical technique and implementing it is a straightforward matter not needing a research citation.,src\optimization\algorithms\pso_optimizer.py,103,module:class:PSOTuner,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-314,constructs a (attributed to: None),Run particle swarm optimisation with optional overrides,,,,,"CHATGPT_100%: Contains the main execution block (e.g., if __name__ == '__main__':) to run a simulation or test. This is infrastructure to launch the program and has no conceptual algorithm.",src\optimization\algorithms\pso_optimizer.py,633,module:class:PSOTuner:function:optimise,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-315,None (attributed to: None),Swarm intelligence optimization algorithms,,,,,,src\optimization\algorithms\swarm\__init__.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-316,with advanced features (attributed to: None),Professional Particle Swarm Optimization algorithm,,,,,,src\optimization\algorithms\swarm\pso.py,19,module:class:ParticleSwarmOptimizer,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-319,validation (attributed to: None),Optimization benchmarks and test functions for algorithm validation,,,,,,src\optimization\benchmarks\__init__.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-320,None (attributed to: None),Constraint handling for optimization problems in control systems,,,,,,src\optimization\constraints\__init__.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-321,to create optimizers (attributed to: None),Factory method to create optimizers,,,,,,src\optimization\core\context.py,166,module:class:OptimizationContext:function:create_optimizer_factory,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-322,None (attributed to: None),Get list of available optimization algorithms,,,,,,src\optimization\core\context.py,197,module:class:OptimizationContext:function:get_available_algorithms,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-323,name (attributed to: None),Quick optimization function,,,,,,src\optimization\core\context.py,210,module:function:optimize,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-325,None (attributed to: None),parameter_space : ParameterSpace,,,,,,src\optimization\core\interfaces.py,274,module:class:Optimizer:function:__init__,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-326,None (attributed to: None),problem : OptimizationProblem,,,,,,src\optimization\core\interfaces.py,289,module:class:Optimizer:function:optimize,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-327,None (attributed to: None),Name of the optimization algorithm,,,,,,src\optimization\core\interfaces.py,316,module:class:Optimizer:function:algorithm_name,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-328,supports constraints (attributed to: None),Whether algorithm supports constraints,,,,,,src\optimization\core\interfaces.py,322,module:class:Optimizer:function:supports_constraints,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-329,supports parameter bounds (attributed to: None),Whether algorithm supports parameter bounds,,,,,,src\optimization\core\interfaces.py,328,module:class:Optimizer:function:supports_bounds,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-330,a population (attributed to: candidates),uses a population of candidates,,,,,,src\optimization\core\interfaces.py,334,module:class:Optimizer:function:is_population_based,,0.6
HIGH,,implementation,implementation,NO,CODE-IMPL-331,None (attributed to: None),Update population based on fitness values,,,,,,src\optimization\core\interfaces.py,399,module:class:PopulationBasedOptimizer:function:update_population,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-332,optimization_type (attributed to: None),Initialize multi-objective problem,,,,,,src\optimization\core\problem.py,149,module:class:MultiObjectiveProblem:function:__init__,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-333,None (attributed to: None),Generate recommendations based on comparison analysis,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\optimization\core\results_manager.py,462,module:class:OptimizationResultsManager:function:_generate_comparison_recommendations,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-334,to combine objectives (attributed to: None),Initialize composite objective,,,,,,src\optimization\objectives\base.py,141,module:class:CompositeObjective:function:__init__,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-335,None (attributed to: None),Combine objective values according to method,,,,,,src\optimization\objectives\base.py,187,module:class:CompositeObjective:function:_combine_objectives,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-336,evaluates robustness by (attributed to: None),Compute robustness objective,,,,,,src\optimization\objectives\control\robustness.py,75,module:class:RobustnessObjective:function:_compute_objective_from_simulation,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-337,None (attributed to: None),Compute Lyapunov-based stability metric,,,,,,src\optimization\objectives\control\stability.py,113,module:class:StabilityMarginObjective:function:_compute_lyapunov_stability,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-338,frequency response estimation (attributed to: simulation data),uses frequency response estimation from simulation data,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\optimization\objectives\control\stability.py,158,module:class:StabilityMarginObjective:function:_compute_stability_margins,,0.6
HIGH,,implementation,implementation,NO,CODE-IMPL-339,None (attributed to: None),Objective based on frequency response characteristics,,,,,,src\optimization\objectives\control\tracking.py,220,module:class:FrequencyResponseObjective,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-340,None (attributed to: None),Multi-objective optimization using Pareto dominance,,,,,,src\optimization\objectives\multi\pareto.py,18,module:class:ParetoObjective,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-341,to convert Pareto (attributed to: None),Initialize Pareto multi-objective,,,,,,src\optimization\objectives\multi\pareto.py,29,module:class:ParetoObjective:function:__init__,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-342,is simple but (attributed to: None),Multi-objective optimization using weighted sum scalarization,,,,,,src\optimization\objectives\multi\weighted_sum.py,18,module:class:WeightedSumObjective,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-343,None (attributed to: None),Initialize weighted sum multi-objective,,,,,,src\optimization\objectives\multi\weighted_sum.py,30,module:class:WeightedSumObjective:function:__init__,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-344,None (attributed to: None),Normalize objective values based on selected method,,,,,,src\optimization\objectives\multi\weighted_sum.py,133,module:class:WeightedSumObjective:function:_normalize_objectives,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-345,None (attributed to: None),Adaptive weighted sum that automatically adjusts weights based on objective performance,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\optimization\objectives\multi\weighted_sum.py,393,module:class:AdaptiveWeightedSumObjective,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-346,None (attributed to: None),Adapt weights based on objective performance,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\optimization\objectives\multi\weighted_sum.py,430,module:class:AdaptiveWeightedSumObjective:function:_adapt_weights,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-347,None (attributed to: None),Objective function specifically for minimizing undershoot,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\optimization\objectives\system\overshoot.py,410,module:class:UndershootObjective,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-348,None (attributed to: None),Objective function for minimizing system settling time,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\optimization\objectives\system\settling_time.py,15,module:class:SettlingTimeObjective,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-349,None (attributed to: None),Find the settling time based on tolerance criteria,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\optimization\objectives\system\settling_time.py,221,module:class:SettlingTimeObjective:function:_find_settling_time,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-350,performance assessment (attributed to: None),Convergence analysis tools for optimization results,,,,,STRATEGIC_PHASE1: Implementation pattern (design_pattern) - no citation needed,src\optimization\results\convergence\__init__.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-351,None (attributed to: None),Convergence monitoring and analysis for optimization algorithms,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\optimization\results\convergence.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-352,names to fitness (attributed to: None),Compare multiple convergence curves,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\optimization\results\convergence.py,293,module:class:ConvergenceAnalyzer:function:compare_convergence_curves,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-353,None (attributed to: None),Optimization solvers and interfaces for different optimization libraries,,,,,STRATEGIC_PHASE1: Implementation pattern (design_pattern) - no citation needed,src\optimization\solvers\__init__.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-354,None (attributed to: None),Advanced PSO Hyperparameter Optimization for Factory-Generated Controllers,,,,,,src\optimization\tuning\pso_hyperparameter_optimizer.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-355,performance and reliability (attributed to: None),Validation and testing framework for optimization algorithms,,,,,STRATEGIC_PHASE1: Implementation pattern (design_pattern) - no citation needed,src\optimization\validation\__init__.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-356,None (attributed to: None),Enhanced PSO Convergence Criteria and Validation Algorithms,,,,,,src\optimization\validation\enhanced_convergence_analyzer.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-357,None (attributed to: None),Calculate stagnation score based on recent fitness variations,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\optimization\validation\enhanced_convergence_analyzer.py,392,module:class:EnhancedConvergenceAnalyzer:function:_calculate_stagnation_score,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-358,None (attributed to: None),Update internal convergence status based on metrics,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\optimization\validation\enhanced_convergence_analyzer.py,602,module:class:EnhancedConvergenceAnalyzer:function:_update_convergence_status,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-359,None (attributed to: None),Validation framework for PSO convergence algorithms,,,,,,src\optimization\validation\enhanced_convergence_analyzer.py,697,module:class:PSOConvergenceValidator,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-360,"controller physics
- Multi-objective parameter space analysis
- Convergence-aware bounds adjustment
- Statistical validation (attributed to: parameter effectiveness)","based on controller physics
- Multi-objective parameter space analysis
- Convergence-aware bounds adjustment
- Statistical validation of parameter effectiveness",,,,,STRATEGIC_PHASE3: Infrastructure/base class - no citation needed,src\optimization\validation\pso_bounds_optimizer.py,1,module,,0.6
HIGH,completed,implementation,implementation,NO,CODE-IMPL-361,None (attributed to: None),Strategy for optimizing parameter bounds,,,,,STRATEGIC_PHASE3: Infrastructure/base class - no citation needed,src\optimization\validation\pso_bounds_optimizer.py,37,module:class:BoundsOptimizationStrategy,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-362,None (attributed to: None),Optimize PSO parameter bounds for specific controller type,,,,,,src\optimization\validation\pso_bounds_optimizer.py,165,module:class:PSOBoundsOptimizer:function:optimize_bounds_for_controller,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-363,None (attributed to: None),Generate bounds based on empirical performance data,,,,,STRATEGIC_PHASE3: Infrastructure/base class - no citation needed,src\optimization\validation\pso_bounds_optimizer.py,293,module:class:PSOBoundsOptimizer:function:_generate_performance_driven_bounds,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-364,None (attributed to: None),Select optimal bounds based on performance metrics and strategy,,,,,,src\optimization\validation\pso_bounds_optimizer.py,477,module:class:PSOBoundsOptimizer:function:_select_optimal_bounds,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-365,None (attributed to: None),PSO Bounds Validation and Optimization Module,,,,,,src\optimization\validation\pso_bounds_validator.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-366,None (attributed to: None),Estimate convergence difficulty based on bounds width,,,,,STRATEGIC_PHASE3: Infrastructure/base class - no citation needed,src\optimization\validation\pso_bounds_validator.py,336,module:class:PSOBoundsValidator:function:_estimate_convergence_difficulty,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-367,None (attributed to: None),Generate improved bounds based on theoretical analysis,,,,,STRATEGIC_PHASE3: Infrastructure/base class - no citation needed,src\optimization\validation\pso_bounds_validator.py,348,module:class:PSOBoundsValidator:function:_generate_improved_bounds,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-368,None (attributed to: None),Plant Dynamics and Physical Models for the Double Inverted Pendulum System,,,,,,src\plant\__init__.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-369,None (attributed to: None),Base configuration class for Double Inverted Pendulum models,,,,,,src\plant\configurations\base_config.py,201,module:class:BaseDIPConfig,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-370,None (attributed to: None),Plant core dynamics compatibility module,,,,,,src\plant\core\dynamics.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-371,None (attributed to: None),Numerical Stability Utilities for Plant Dynamics,,,,,,src\plant\core\numerical_stability.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-372,None (attributed to: None),Adaptive matrix regularization for improved numerical stability,,,,,,src\plant\core\numerical_stability.py,54,module:class:AdaptiveRegularizer,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-373,None (attributed to: None),Apply adaptive regularization based on matrix conditioning,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\plant\core\numerical_stability.py,127,module:class:AdaptiveRegularizer:function:_apply_adaptive_regularization,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-374,None (attributed to: None),Double Inverted Pendulum physics matrix computation,,,,,,src\plant\core\physics_matrices.py,45,module:class:DIPPhysicsMatrices,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-375,None (attributed to: None),Simplified physics matrices for computational efficiency,,,,,,src\plant\core\physics_matrices.py,248,module:class:SimplifiedDIPPhysicsMatrices,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-376,None (attributed to: None),Base classes and interfaces for plant dynamics models,,,,,STRATEGIC_PHASE1: Implementation pattern (design_pattern) - no citation needed,src\plant\models\base\__init__.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-377,None (attributed to: None),Common interface for plant dynamics models,,,,,STRATEGIC_BONUS: Base class/interface definition,src\plant\models\base\dynamics_interface.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-378,None (attributed to: None),Available integration methods for dynamics,,,,,,src\plant\models\base\dynamics_interface.py,19,module:class:IntegrationMethod,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-379,None (attributed to: None),Compute system dynamics at given state and input,,,,,,src\plant\models\base\dynamics_interface.py,73,module:class:DynamicsModel:function:compute_dynamics,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-380,None (attributed to: None),Abstract base class for dynamics models,,,,,STRATEGIC_BONUS: Base class/interface definition,src\plant\models\base\dynamics_interface.py,130,module:class:BaseDynamicsModel,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-381,None (attributed to: None),Full Fidelity Double Inverted Pendulum Model,,,,,,src\plant\models\full\__init__.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-382,None (attributed to: None),Full Fidelity DIP Dynamics Model,,,,,,src\plant\models\full\dynamics.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-384,for legacy code (attributed to: None),Compatibility method for legacy code expecting _rhs_core,,,,,,src\plant\models\full\dynamics.py,530,module:class:FullDIPDynamics:function:_rhs_core,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-386,None (attributed to: None),Full-fidelity physics computation for DIP dynamics,,,,,,src\plant\models\full\physics.py,34,module:class:FullFidelityPhysicsComputer,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-387,None (attributed to: None),Compute complete right-hand side of dynamics equation,,,,,,src\plant\models\full\physics.py,70,module:class:FullFidelityPhysicsComputer:function:compute_complete_dynamics_rhs,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-388,None (attributed to: None),Low-rank Double Inverted Pendulum (DIP) Model Package,,,,,,src\plant\models\lowrank\__init__.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-389,None (attributed to: None),Configuration for Low-rank Double Inverted Pendulum Model,,,,,,src\plant\models\lowrank\config.py,21,module:class:LowRankDIPConfig,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-390,None (attributed to: None),Low-rank DIP Dynamics Model,,,,,,src\plant\models\lowrank\dynamics.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-391,None (attributed to: None),Low-rank Double Inverted Pendulum Dynamics Model,,,,,,src\plant\models\lowrank\dynamics.py,28,module:class:LowRankDIPDynamics,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-393,None (attributed to: None),Low-rank DIP Physics Computer,,,,,,src\plant\models\lowrank\physics.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-394,None (attributed to: None),Low-rank Physics Computer for Double Inverted Pendulum,,,,,,src\plant\models\lowrank\physics.py,20,module:class:LowRankPhysicsComputer,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-395,"the simplified DIP dynamics with:
- Focused physics computation
- Type-safe configuration
- Numerical stability features
- Performance optimizations

Refactored (attributed to: the monolithic 688-line dynamics)","implementation of the simplified DIP dynamics with:
- Focused physics computation
- Type-safe configuration
- Numerical stability features
- Performance optimizations

Refactored from the monolithic 688-line dynamics",,,,,,src\plant\models\simplified\__init__.py,1,module,,0.6
HIGH,completed,implementation,implementation,NO,CODE-IMPL-396,None (attributed to: None),Configuration for Simplified DIP Dynamics,,,,,STRATEGIC_PHASE4: Configuration class - pure implementation,src\plant\models\simplified\config.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-397,None (attributed to: None),Simplified DIP Dynamics Model,,,,,,src\plant\models\simplified\dynamics.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-398,"simplified DIP dynamics featuring:
- Type-safe configuration with validation
- Numerical stability monitoring and recovery
- Performance optimizations with JIT compilation
- Clean separation (attributed to: physics computation)","implementation of simplified DIP dynamics featuring:
- Type-safe configuration with validation
- Numerical stability monitoring and recovery
- Performance optimizations with JIT compilation
- Clean separation of physics computation",,,,,,src\plant\models\simplified\dynamics.py,28,module:class:SimplifiedDIPDynamics,,0.6
HIGH,,implementation,implementation,NO,CODE-IMPL-399,None (attributed to: None),Compute dynamics using standard (modular) approach,,,,,,src\plant\models\simplified\dynamics.py,290,module:class:SimplifiedDIPDynamics:function:_compute_standard_dynamics,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-400,None (attributed to: None),Compute dynamics using fast JIT-compiled approach,,,,,,src\plant\models\simplified\dynamics.py,298,module:class:SimplifiedDIPDynamics:function:_compute_fast_dynamics,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-402,None (attributed to: None),Simplified Physics Computation for DIP,,,,,,src\plant\models\simplified\physics.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-403,None (attributed to: None),Simplified physics computation for DIP dynamics,,,,,,src\plant\models\simplified\physics.py,35,module:class:SimplifiedPhysicsComputer,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-404,None (attributed to: None),JIT-compiled simplified dynamics computation,,,,,,src\plant\models\simplified\physics.py,236,module:function:compute_simplified_dynamics_numba,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-405,None (attributed to: None),Professional simulation framework for control engineering applications,,,,,STRATEGIC_PHASE1: Implementation pattern (design_pattern) - no citation needed,src\simulation\__init__.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-406,None (attributed to: None),Initializes and holds the context for a simulation run,,,,,,src\simulation\context\simulation_context.py,30,module:class:SimulationContext,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-407,None (attributed to: None),Initialize the correct dynamics model based on the configuration,,,,,STRATEGIC_PHASE4: Configuration class - pure implementation,src\simulation\context\simulation_context.py,44,module:class:SimulationContext:function:_initialize_dynamics_model,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-408,defaults (attributed to: config),use defaults from config,,,,,STRATEGIC_PHASE4: Configuration class - pure implementation,src\simulation\context\simulation_context.py,81,module:class:SimulationContext:function:create_controller,,0.6
HIGH,,implementation,implementation,NO,CODE-IMPL-409,None (attributed to: None),Base interface for numerical integration methods,,,,,,src\simulation\core\interfaces.py,40,module:class:Integrator,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-410,order (attributed to: None),Integration method order,,,,,,src\simulation\core\interfaces.py,74,module:class:Integrator:function:order,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-411,None (attributed to: None),Execute simulation with specified strategy,,,,,,src\simulation\core\interfaces.py,89,module:class:Orchestrator:function:execute,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-412,None (attributed to: None),Perform strategy-specific analysis,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\simulation\core\interfaces.py,122,module:class:SimulationStrategy:function:analyze,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-414,None (attributed to: None),Create a controller using the configuration,,,,,STRATEGIC_PHASE4: Configuration class - pure implementation,src\simulation\core\simulation_context.py,86,module:class:SimulationContext:function:create_controller,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-415,None (attributed to: None),Advance simulation by one time step,,,,,,src\simulation\core\time_domain.py,72,module:class:TimeManager:function:advance_step,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-416,None (attributed to: None),Update time step based on error estimate,,,,,STRATEGIC_PHASE4: Error handling - pure implementation,src\simulation\core\time_domain.py,242,module:class:AdaptiveTimeStep:function:update_step_size,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-417,None (attributed to: None),Simulation engines and numerical integration methods,,,,,,src\simulation\engines\__init__.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-420,None (attributed to: None),Simulation step router,,,,,,src\simulation\engines\simulation_runner.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-421,None (attributed to: None),Return the appropriate step function based on the configuration flag,,,,,STRATEGIC_PHASE4: Configuration class - pure implementation,src\simulation\engines\simulation_runner.py,75,module:function:get_step_fn,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-422,None (attributed to: None),Unified simulation step entry point,,,,,,src\simulation\engines\simulation_runner.py,87,module:function:step,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-423,that advances the (attributed to: None),Simulate a single controller trajectory using an explicit Euler method,,,,,,src\simulation\engines\simulation_runner.py,109,module:function:run_simulation,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-424,dt (attributed to: None),Initialize simulation runner,,,,,STRATEGIC_BONUS: Simulation engine infrastructure,src\simulation\engines\simulation_runner.py,341,module:class:SimulationRunner:function:__init__,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-426,None (attributed to: None),Vectorised batch simulation of multiple controllers,,,,,,src\simulation\engines\vector_sim.py,252,module:function:simulate_system_batch,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-427,None (attributed to: None),Numerical integration methods for simulation framework,,,,,,src\simulation\integrators\__init__.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-428,None (attributed to: None),Adaptive step-size integration methods,,,,,STRATEGIC_PHASE1: Implementation pattern (design_pattern) - no citation needed,src\simulation\integrators\adaptive\__init__.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-429,None (attributed to: None),Basic error controller for adaptive step size methods,,,,,STRATEGIC_PHASE4: Error handling - pure implementation,src\simulation\integrators\adaptive\error_control.py,13,module:class:ErrorController,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-430,order for exponent (attributed to: None),Update step size based on error estimate,,,,,STRATEGIC_PHASE4: Error handling - pure implementation,src\simulation\integrators\adaptive\error_control.py,26,module:class:ErrorController:function:update_step_size,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-431,"order

Returns (attributed to: None)",Update step size using PI control,,,,,STRATEGIC_PHASE4: Error handling - pure implementation,src\simulation\integrators\adaptive\error_control.py,97,module:class:PIController:function:update_step_size,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-432,"order

Returns (attributed to: None)",Update step size using dead-beat control,,,,,STRATEGIC_PHASE4: Error handling - pure implementation,src\simulation\integrators\adaptive\error_control.py,175,module:class:DeadBeatController:function:update_step_size,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-433,None (attributed to: None),Adaptive Runge-Kutta integration methods with error control,,,,,,src\simulation\integrators\adaptive\runge_kutta.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-434,None (attributed to: None),Base class for adaptive Runge-Kutta methods,,,,,,src\simulation\integrators\adaptive\runge_kutta.py,16,module:class:AdaptiveRungeKutta,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-435,with adaptive step (attributed to: None),Dormand-Prince 4(5) embedded Runge-Kutta method with adaptive step size,,,,,,src\simulation\integrators\adaptive\runge_kutta.py,99,module:class:DormandPrince45,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-437,None (attributed to: None),Legacy Dormand-Prince 4(5) step function for backward compatibility,,,,,,src\simulation\integrators\adaptive\runge_kutta.py,177,module:function:rk45_step,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-438,None (attributed to: None),Original RK45 implementation for fallback,,,,,,src\simulation\integrators\adaptive\runge_kutta.py,228,module:function:_original_rk45_step,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-439,None (attributed to: None),Base class for numerical integration methods,,,,,,src\simulation\integrators\base.py,16,module:class:BaseIntegrator,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-440,None (attributed to: None),Initialize base integrator,,,,,,src\simulation\integrators\base.py,19,module:class:BaseIntegrator:function:__init__,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-442,provides compatibility with (attributed to: None),Integrate dynamics forward by one time step (interface compatibility method),,,,,STRATEGIC_BONUS: Base class/interface definition,src\simulation\integrators\base.py,73,module:class:BaseIntegrator:function:integrate_step,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-443,None (attributed to: None),Initialize integration result,,,,,,src\simulation\integrators\base.py,159,module:class:IntegrationResult:function:__init__,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-444,None (attributed to: None),Initialize legacy wrapper,,,,,STRATEGIC_BONUS: Method delegation/wrapper,src\simulation\integrators\compatibility.py,102,module:class:LegacyDynamicsWrapper:function:__init__,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-446,None (attributed to: None),Safely integrate using fallback method,,,,,,src\simulation\integrators\compatibility.py,267,module:class:IntegratorSafetyWrapper:function:_safe_fallback_integrate,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-447,None (attributed to: None),Discrete-time integration methods,,,,,STRATEGIC_PHASE1: Implementation pattern (design_pattern) - no citation needed,src\simulation\integrators\discrete\__init__.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-448,order (attributed to: None),Integration method order (exact for linear systems),,,,,,src\simulation\integrators\discrete\zero_order_hold.py,41,module:class:ZeroOrderHold:function:order,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-449,None (attributed to: None),Integrate nonlinear system with ZOH control approximation,,,,,,src\simulation\integrators\discrete\zero_order_hold.py,132,module:class:ZeroOrderHold:function:_integrate_nonlinear,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-450,None (attributed to: None),Fixed step-size integration methods,,,,,STRATEGIC_PHASE1: Implementation pattern (design_pattern) - no citation needed,src\simulation\integrators\fixed_step\__init__.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-451,None (attributed to: None),Euler integration methods (explicit and implicit),,,,,,src\simulation\integrators\fixed_step\euler.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-452,None (attributed to: None),Forward (explicit) Euler integration method,,,,,,src\simulation\integrators\fixed_step\euler.py,16,module:class:ForwardEuler,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-454,None (attributed to: None),Integrate using forward Euler method,,,,,,src\simulation\integrators\fixed_step\euler.py,29,module:class:ForwardEuler:function:integrate,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-455,None (attributed to: None),Backward (implicit) Euler integration method,,,,,,src\simulation\integrators\fixed_step\euler.py,66,module:class:BackwardEuler,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-457,None (attributed to: None),Integrate using backward Euler method,,,,,,src\simulation\integrators\fixed_step\euler.py,97,module:class:BackwardEuler:function:integrate,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-458,None (attributed to: None),Modified Euler method (Heun's method),,,,,,src\simulation\integrators\fixed_step\euler.py,154,module:class:ModifiedEuler,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-460,None (attributed to: None),Integrate using modified Euler (Heun's) method,,,,,,src\simulation\integrators\fixed_step\euler.py,167,module:class:ModifiedEuler:function:integrate,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-461,None (attributed to: None),Fixed step-size Runge-Kutta integration methods,,,,,,src\simulation\integrators\fixed_step\runge_kutta.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-462,None (attributed to: None),Second-order Runge-Kutta method (midpoint rule),,,,,,src\simulation\integrators\fixed_step\runge_kutta.py,15,module:class:RungeKutta2,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-464,None (attributed to: None),Integrate using second-order Runge-Kutta (midpoint) method,,,,,,src\simulation\integrators\fixed_step\runge_kutta.py,28,module:class:RungeKutta2:function:integrate,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-465,None (attributed to: None),Fourth-order Runge-Kutta method (classic RK4),,,,,,src\simulation\integrators\fixed_step\runge_kutta.py,66,module:class:RungeKutta4,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-467,None (attributed to: None),Integrate using fourth-order Runge-Kutta method,,,,,,src\simulation\integrators\fixed_step\runge_kutta.py,79,module:class:RungeKutta4:function:integrate,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-468,None (attributed to: None),Runge-Kutta 3/8 rule (alternative 4th-order method),,,,,,src\simulation\integrators\fixed_step\runge_kutta.py,119,module:class:RungeKutta38,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-470,None (attributed to: None),Integrate using Runge-Kutta 3/8 rule,,,,,,src\simulation\integrators\fixed_step\runge_kutta.py,132,module:class:RungeKutta38:function:integrate,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-471,for backward compatibility (attributed to: None),Alias for standard RK4 method for backward compatibility,,,,,STRATEGIC_BONUS: Method delegation/wrapper,src\simulation\integrators\fixed_step\runge_kutta.py,172,module:class:ClassicalRungeKutta,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-472,None (attributed to: None),Create appropriate integrator based on configuration,,,,,STRATEGIC_PHASE4: Configuration class - pure implementation,src\simulation\orchestrators\base.py,49,module:class:BaseOrchestrator:function:_create_integrator,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-473,None (attributed to: None),Execute simulation with orchestrator-specific strategy,,,,,,src\simulation\orchestrators\base.py,102,module:class:BaseOrchestrator:function:execute,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-474,creates a new (attributed to: None),Run a single simulation using sequential orchestrator,,,,,,src\simulation\orchestrators\parallel.py,159,module:class:ParallelOrchestrator:function:_run_single_simulation,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-475,None (attributed to: None),Initialize HIL orchestrator,,,,,,src\simulation\orchestrators\real_time.py,240,module:class:HardwareInLoopOrchestrator:function:__init__,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-476,dynamics_model (attributed to: None),Legacy simulation runner for backward compatibility,,,,,,src\simulation\orchestrators\sequential.py,187,module:function:run_simulation,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-477,None (attributed to: None),Result container implementations for simulation data,,,,,,src\simulation\results\containers.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-478,None (attributed to: None),Implement recovery strategy,,,,,,src\simulation\safety\recovery.py,18,module:class:RecoveryStrategy:function:recover,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-479,None (attributed to: None),Emergency stop recovery strategy,,,,,,src\simulation\safety\recovery.py,38,module:class:EmergencyStop,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-480,None (attributed to: None),State limiting recovery strategy,,,,,,src\simulation\safety\recovery.py,46,module:class:StateLimiter,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-481,None (attributed to: None),Register recovery strategy for specific violation type,,,,,,src\simulation\safety\recovery.py,77,module:class:SafetyRecovery:function:register_strategy,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-482,None (attributed to: None),Apply appropriate recovery strategy,,,,,,src\simulation\safety\recovery.py,81,module:class:SafetyRecovery:function:apply_recovery,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-483,None (attributed to: None),Simulation analysis strategies and paradigms,,,,,STRATEGIC_PHASE1: Implementation pattern (design_pattern) - no citation needed,src\simulation\strategies\__init__.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-484,None (attributed to: None),Monte Carlo simulation strategy for statistical analysis,,,,,,src\simulation\strategies\monte_carlo.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-486,None (attributed to: None),Initialize Monte Carlo strategy,,,,,,src\simulation\strategies\monte_carlo.py,19,module:class:MonteCarloStrategy:function:__init__,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-487,None (attributed to: None),Mixin class for components that need configuration compatibility,,,,,STRATEGIC_PHASE4: Configuration class - pure implementation,src\utils\config_compatibility.py,165,module:class:ConfigCompatibilityMixin,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-488,None (attributed to: None),Wrap physics configuration for compatibility with plant models,,,,,STRATEGIC_PHASE4: Configuration class - pure implementation,src\utils\config_compatibility.py,182,module:function:wrap_physics_config,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-490,None (attributed to: None),Control analysis utilities compatibility module,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\utils\control_analysis.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-491,mathematical analysis (attributed to: coverage trends with automated),Implements mathematical analysis of coverage trends with automated,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\utils\coverage\monitoring.py,54,module:class:CoverageMonitor,,0.6
HIGH,completed,implementation,implementation,NO,CODE-IMPL-492,None (attributed to: None),Calculate linear regression slope using least squares method,,,,,STRATEGIC_PHASE4: Infrastructure code (config/types/utils),src\utils\coverage\monitoring.py,203,module:class:CoverageMonitor:function:analyze_coverage_trends:function:calculate_slope,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-493,None (attributed to: None),Classify trend based on slope magnitude,,,,,STRATEGIC_PHASE4: Infrastructure code (config/types/utils),src\utils\coverage\monitoring.py,222,module:class:CoverageMonitor:function:analyze_coverage_trends:function:classify_trend,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-494,None (attributed to: None),Generate actionable recommendations based on trend analysis,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\utils\coverage\monitoring.py,269,module:class:CoverageMonitor:function:_generate_trend_recommendation,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-495,None (attributed to: None),Check current coverage against quality gate thresholds,,,,,,src\utils\coverage\monitoring.py,280,module:class:CoverageMonitor:function:check_quality_gates,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-496,None (attributed to: None),Utility class for exporting data and plots from Jupyter notebooks,,,,,STRATEGIC_PHASE4: Utility function - pure implementation,src\utils\development\jupyter_tools.py,24,module:class:NotebookExporter,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-497,prefix (attributed to: None),Export PSO or other optimization results,,,,,,src\utils\development\jupyter_tools.py,188,module:class:NotebookExporter:function:export_optimization_results,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-498,"for optimal performance

Example
-------
>>> (attributed to: src)","use for optimal performance

Example
-------
>>> from src",,,,,STRATEGIC_PHASE1: Implementation pattern (design_pattern) - no citation needed,src\utils\memory\__init__.py,1,module,,0.6
HIGH,completed,implementation,implementation,NO,CODE-IMPL-499,None (attributed to: None),Production-grade memory pool for efficient memory management,,,,,STRATEGIC_PHASE4: Infrastructure code (config/types/utils),src\utils\memory\memory_pool.py,1,module,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-500,the 9-step diagnostic checklist (attributed to: Issue #1 resolution plan),Implements the 9-step diagnostic checklist from Issue #1 resolution plan,,,,,STRATEGIC_PHASE4: Infrastructure code (config/types/utils),src\utils\monitoring\diagnostics.py,1,module,,0.6
HIGH,completed,implementation,implementation,NO,CODE-IMPL-501,None (attributed to: None),Classification of instability root causes,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\utils\monitoring\diagnostics.py,20,module:class:InstabilityType,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-502,the priority-ranked diagnostic checklist (attributed to: Issue #1 resolution:),Implements the priority-ranked diagnostic checklist from Issue #1 resolution:,,,,,STRATEGIC_PHASE4: Infrastructure code (config/types/utils),src\utils\monitoring\diagnostics.py,45,module:class:DiagnosticChecklist,,0.6
HIGH,completed,implementation,implementation,NO,CODE-IMPL-503,"the stability monitoring solution (attributed to: Issue #1 resolution plan,)","Implements the stability monitoring solution from Issue #1 resolution plan,",,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\utils\monitoring\stability.py,1,module,,0.6
HIGH,completed,implementation,implementation,NO,CODE-IMPL-504,LDR monitoring as specified (attributed to: Issue #1 resolution:),Implements LDR monitoring as specified in Issue #1 resolution:,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\utils\monitoring\stability.py,19,module:class:LyapunovDecreaseMonitor,,0.6
HIGH,,implementation,implementation,NO,CODE-IMPL-507,convergence (attributed to: None),Numerical stability utilities for robust mathematical operations,,,,,,src\utils\numerical_stability\__init__.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-508,None (attributed to: None),Safe mathematical operations with numerical stability guarantees,,,,,,src\utils\numerical_stability\safe_operations.py,1,module,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-509,None (attributed to: None),Safe division with epsilon threshold protection against zero division,,,,,,src\utils\numerical_stability\safe_operations.py,75,module:function:safe_divide,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-510,None (attributed to: None),Safe square root with negative value protection,,,,,STRATEGIC_PHASE2: Analysis/implementation code (no theory cited),src\utils\numerical_stability\safe_operations.py,205,module:function:safe_sqrt,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-512,None (attributed to: None),Return a new integer seed derived from the master generator,,,,,STRATEGIC_PHASE4: Infrastructure code (config/types/utils),src\utils\reproducibility\seed.py,79,module:class:SeedManager:function:spawn,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-516,None (attributed to: None),Return type for :class:`adaptive_smc,,,,,STRATEGIC_PHASE4: Infrastructure code (config/types/utils),src\utils\types\control_outputs.py,60,module:class:AdaptiveSMCOutput,,0.65
HIGH,,implementation,implementation,NO,CODE-IMPL-517,"the super‑twisting
    algorithm and are needed to resume control (attributed to: the next time step)","according to the super‑twisting
    algorithm and are needed to resume control in the next time step",,,,,,src\utils\types\control_outputs.py,86,module:class:STAOutput,,0.6
HIGH,completed,implementation,implementation,NO,CODE-IMPL-518,performance (attributed to: None),Complete visualization plan generator for the entire DIP control project,,,,,STRATEGIC_PHASE4: Infrastructure code (config/types/utils),src\utils\visualization\movie_generator.py,32,module:class:ProjectMovieGenerator,,0.65
HIGH,completed,implementation,implementation,NO,CODE-IMPL-519,None (attributed to: None),Create a complete movie documenting the entire project,,,,,STRATEGIC_PHASE4: Infrastructure code (config/types/utils),src\utils\visualization\movie_generator.py,53,module:class:ProjectMovieGenerator:function:create_complete_project_movie,,0.65
MEDIUM,,theoretical,definition,NO,FORMAL-DEFINITION-002,The sliding surface is defined as:,The sliding surface is defined as:,,,,,,docs/mathematical_algorithm_validation.md,54,,,0.6
MEDIUM,,theoretical,definition,NO,FORMAL-DEFINITION-003,Parameter sensitivity matrix:,Parameter sensitivity matrix:,,,,,,docs/mathematical_algorithm_validation.md,620,,,0.6
MEDIUM,,theoretical,definition,NO,FORMAL-DEFINITION-006,The optimization problem is defined over a D-dimensional search space:,The optimization problem is defined over a D-dimensional search space:,,,,,,docs/theory/pso_optimization_complete.md,18,,,0.7
MEDIUM,,theoretical,definition,NO,FORMAL-DEFINITION-007,The fitness landscape is defined by:,The fitness landscape is defined by:,,,,,,docs/theory/pso_optimization_complete.md,27,,,0.6
MEDIUM,,theoretical,definition,NO,FORMAL-DEFINITION-009,The swarm converges in mean square if:,The swarm converges in mean square if:,,,,,,docs/theory/pso_optimization_complete.md,106,,,0.7
MEDIUM,,theoretical,theorem,YES,FORMAL-THEOREM-011,"Averaged over all possible optimization problems, no optimization algorithm performs better than random search {cite}`wolpert1997no`.","Averaged over all possible optimization problems, no optimization algorithm performs better than random search {cite}`wolpert1997no`.",,,,,,docs/theory/pso_optimization_complete.md,119,,,0.6
MEDIUM,,theoretical,definition,NO,FORMAL-DEFINITION-012,Solution $\vec{\theta}_1$ dominates $\vec{\theta}_2$ (denoted $\vec{\theta}_1 \prec \vec{\theta}_2$) if:,Solution $\vec{\theta}_1$ dominates $\vec{\theta}_2$ (denoted $\vec{\theta}_1 \prec \vec{\theta}_2$) if:,,,,,,docs/theory/pso_optimization_complete.md,184,,,0.6
MEDIUM,,theoretical,definition,NO,FORMAL-DEFINITION-013,The Pareto optimal set is:,The Pareto optimal set is:,,,,,,docs/theory/pso_optimization_complete.md,193,,,0.6
MEDIUM,,theoretical,definition,NO,FORMAL-DEFINITION-014,A sliding surface $\mathcal{S}$ is a subset of the state space defined by:,A sliding surface $\mathcal{S}$ is a subset of the state space defined by:,,,,,,docs/theory/smc_theory_complete.md,11,,,0.7
MEDIUM,,theoretical,definition,NO,FORMAL-DEFINITION-015,The system is said to be in sliding mode when:,The system is said to be in sliding mode when:,,,,,,docs/theory/smc_theory_complete.md,24,,,0.6
MEDIUM,,theoretical,assumption,NO,FORMAL-ASSUMPTION-017,The matrix $\mat{S}\vec{g}(\vec{x})$ is invertible for all $\vec{x}$ in the domain of interest.,The matrix $\mat{S}\vec{g}(\vec{x})$ is invertible for all $\vec{x}$ in the domain of interest.,,,,,,docs/theory/smc_theory_complete.md,106,,,0.7
MEDIUM,,theoretical,definition,NO,FORMAL-DEFINITION-018,The system trajectory reaches the sliding surface in finite time if:,The system trajectory reaches the sliding surface in finite time if:,,,,,,docs/theory/smc_theory_complete.md,123,,,0.7
MEDIUM,,implementation,implementation,YES,CODE-IMPL-006,to operating conditions (attributed to: 218697608892619†L682-L687),"Lightweight, modular Fault Detection and Isolation (FDI) system with",,,,,,src\analysis\fault_detection\fdi.py,36,module:class:FDIsystem,bracket,0.75
MEDIUM,,implementation,implementation,YES,CODE-IMPL-040,of state variables (attributed to: 920100172589331†L79-L84),Linearisation and controllability/observability analysis utilities,,,,,,src\analysis\performance\control_analysis.py,1,module,bracket,0.75
MEDIUM,,implementation,implementation,YES,CODE-IMPL-041,equal to ``n`` (attributed to: 920100172589331†L79-L84),Construct the controllability matrix of an LTI system,,,,,,src\analysis\performance\control_analysis.py,49,module:function:controllability_matrix,bracket,0.75
MEDIUM,,implementation,implementation,YES,CODE-IMPL-042,equal to ``n`` (attributed to: 920100172589331†L79-L84),Construct the observability matrix of an LTI system,,,,,,src\analysis\performance\control_analysis.py,76,module:function:observability_matrix,bracket,0.75
MEDIUM,,implementation,implementation,YES,CODE-IMPL-043,rank test passes (attributed to: 920100172589331†L79-L84),Check controllability and observability of an LTI system,,,,,,src\analysis\performance\control_analysis.py,141,module:function:check_controllability_observability,bracket,0.75
MEDIUM,,implementation,implementation,YES,CODE-IMPL-098,satisfying reproducibility guidelines (attributed to: 985132039892507†L364-L377),Centralised logging configuration with provenance stamping,,,,,,src\config\logging.py,1,module,bracket,0.75
MEDIUM,,implementation,implementation,YES,CODE-IMPL-099,be reproduced exactly (attributed to: 985132039892507†L364-L377),Configure the root logger with provenance stamping,,,,,,src\config\logging.py,116,module:function:configure_provenance_logging,bracket,0.75
MEDIUM,,implementation,implementation,YES,CODE-IMPL-102,adaptive control laws (attributed to: 462167782799487†L186-L195),Validate that a numeric value is positive (or non‑negative),,,,,,src\controllers\base\control_primitives.py,14,module:function:require_positive,bracket,0.75
MEDIUM,,implementation,implementation,YES,CODE-IMPL-103,to ensure stability (attributed to: 462167782799487†L186-L195),Validate that a numeric value lies within a closed or open interval,,,,,,src\controllers\base\control_primitives.py,62,module:function:require_in_range,bracket,0.75
MEDIUM,,implementation,implementation,YES,CODE-IMPL-104,"the
expected amplitude (attributed to: measurement noise and the desired steady‑state)","based on the
expected amplitude of measurement noise and the desired steady‑state",,,,,,src\controllers\base\control_primitives.py,110,module:function:saturate,bracket,0.8
MEDIUM,,implementation,implementation,YES,CODE-IMPL-116,one‑sided (forward) differences (attributed to: 738473614585036†L239-L256),"Finite‑difference linearization around (x_eq, u_eq) using a central",,,,,,src\controllers\mpc\mpc_controller.py,72,module:function:_numeric_linearize_continuous,bracket,0.75
MEDIUM,,implementation,implementation,YES,CODE-IMPL-176,"the conventional first‑order sliding‑mode law
consisting (attributed to: a model‑based equivalent control ``u_eq`` and a robust)","implements the conventional first‑order sliding‑mode law
consisting of a model‑based equivalent control ``u_eq`` and a robust",,,,,,src\controllers\smc\classic_smc.py,21,module:class:ClassicalSMC,bracket,0.8
MEDIUM,,implementation,implementation,YES,CODE-IMPL-177,"a continuous approximation to
the sign function (either a hyperbolic tangent or a piecewise‑linear
saturation) within a boundary layer (attributed to: width ``epsilon`` to attenuate)","uses a continuous approximation to
the sign function (either a hyperbolic tangent or a piecewise‑linear
saturation) within a boundary layer of width ``epsilon`` to attenuate",,,,,,src\controllers\smc\classic_smc.py,21,module:class:ClassicalSMC,bracket,0.8
MEDIUM,,implementation,implementation,YES,CODE-IMPL-197,simplifies stability proofs (attributed to: 895515998216162†L326-L329),Hybrid Adaptive Super–Twisting SMC for a double‑inverted pendulum,,,,,,src\controllers\smc\hybrid_adaptive_sta_smc.py,26,module:class:HybridAdaptiveSTASMC,bracket,0.75
MEDIUM,,implementation,implementation,YES,CODE-IMPL-200,is nearly singular (attributed to: 385796022798831†L145-L149),Compute an approximate equivalent control based on the system,,,,,,src\controllers\smc\hybrid_adaptive_sta_smc.py,442,module:class:HybridAdaptiveSTASMC:function:_compute_equivalent_control,bracket,0.75
MEDIUM,,implementation,implementation,YES,CODE-IMPL-202,multiplied by ``Kaw`` (attributed to: 789743582768797†L224-L249),Numba-accelerated core using precomputed sigma and its saturated sign,,,,,,src\controllers\smc\sta_smc.py,89,module:function:_sta_smc_core,bracket,0.75
MEDIUM,,implementation,implementation,YES,CODE-IMPL-203,"a continuous saturation function within a boundary
 layer ``ε`` to approximate the sign (attributed to: the sliding variable σ,)","uses a continuous saturation function within a boundary
 layer ``ε`` to approximate the sign of the sliding variable σ,",,,,,,src\controllers\smc\sta_smc.py,129,module:class:SuperTwistingSMC,bracket,0.8
MEDIUM,completed,implementation,implementation,YES,CODE-IMPL-253,None (attributed to: None),Create a control optimization problem,Press et al. (2007),press2007numerical,978-0521880688,book,"CHATGPT_100%: Implements the Newton-Raphson root-finding algorithm iteration. The code likely computes a function's value and derivative to update an estimate for the root, exactly following the Newton-Raphson formula.",src\optimization\__init__.py,158,module:function:create_control_problem,numbered,0.75
MEDIUM,,implementation,implementation,YES,CODE-IMPL-418,on a single step (attributed to: the Dormand–Prince),uses on a single step of the Dormand–Prince,,,,,,src\simulation\engines\adaptive_integrator.py,1,module,bracket,0.8
MEDIUM,,implementation,implementation,YES,CODE-IMPL-419,the Butcher tableau (attributed to: 313837333132264†L58-L82),Perform a single Dormand–Prince 4(5) integration step,,,,,,src\simulation\engines\adaptive_integrator.py,37,module:function:rk45_step,bracket,0.75
MEDIUM,,implementation,implementation,YES,CODE-IMPL-425,None (attributed to: None),Simulate a dynamical system forward in time,,,,,,src\simulation\engines\vector_sim.py,38,module:function:simulate,numbered,0.75
MEDIUM,,implementation,implementation,YES,CODE-IMPL-445,None (attributed to: None),Create a dynamics model compatible with simulation engines,,,,,,src\simulation\integrators\compatibility.py,146,module:function:create_compatible_dynamics,numbered,0.75
MEDIUM,,implementation,implementation,YES,CODE-IMPL-511,numbers of processors (attributed to: 675644021986605†L385-L388),Global seeding utilities for reproducible simulations,,,,,,src\utils\reproducibility\seed.py,1,module,bracket,0.75
MEDIUM,,implementation,implementation,YES,CODE-IMPL-513,"reproducibility guidelines (attributed to: computational science, when random number generation is part of a)","According to reproducibility guidelines in
computational science, when random number generation is part of a",,,,,,src\utils\reproducibility\seed.py,86,module:function:set_global_seed,bracket,0.8
MEDIUM,,implementation,implementation,YES,CODE-IMPL-514,or optimisation algorithms (attributed to: 675644021986605†L385-L388),Create a local NumPy random number generator,,,,,,src\utils\reproducibility\seed.py,135,module:function:create_rng,bracket,0.75
MEDIUM,,implementation,implementation,YES,CODE-IMPL-515,a named tuple inherits (attributed to: ``tuple``) while also exposing descriptive attribute names to clarify),"use a named tuple inherits
from ``tuple``) while also exposing descriptive attribute names to clarify",,,,,,src\utils\types\control_outputs.py,1,module,bracket,0.8
