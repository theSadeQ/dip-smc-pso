{
  "agent": "code-beautification-directory-specialist",
  "issue": "#16",
  "timestamp": "2025-10-01T16:00:28.604089",
  "scan_summary": {
    "files_scanned": 109,
    "total_copies": 364,
    "unnecessary_copies": 57,
    "necessary_copies": 307,
    "convertible_to_views": 0
  },
  "by_category": {
    "UNNECESSARY": [
      {
        "file": "src\\controllers\\factory\\core\\registry.py",
        "line": 191,
        "pattern": "return CONTROLLER_REGISTRY[controller_type].copy()",
        "category": "UNNECESSARY",
        "reason": "Return copy of local variable (can return directly)",
        "confidence": 0.7,
        "context": "            f\"Available: {available}. \"\n\n            f\"Use canonicalize_controller_type() for normalization.\"\n\n        )\n\n    return CONTROLLER_REGISTRY[controller_type].copy()\n\n\n\n\n\ndef canonicalize_controller_type(name: str) -> str:\n"
      },
      {
        "file": "src\\interfaces\\data_exchange\\factory_resilient.py",
        "line": 171,
        "pattern": "stats = self._stats.copy()",
        "category": "UNNECESSARY",
        "reason": "Stats dict copy for read-only access (no mutation needed)",
        "confidence": 0.8,
        "context": "    def get_statistics(self) -> Dict[str, Any]:\n\n        \"\"\"Get factory statistics.\"\"\"\n\n        with self._stats_lock:\n\n            stats = self._stats.copy()\n\n\n\n        with self._cache_lock:\n\n            stats['cached_serializers'] = len(self._serializer_cache)\n"
      },
      {
        "file": "src\\interfaces\\hardware\\daq_systems.py",
        "line": 265,
        "pattern": "return buffer.samples.copy()",
        "category": "UNNECESSARY",
        "reason": "Return copy of local variable (can return directly)",
        "confidence": 0.7,
        "context": "\n\n        buffer = self._buffers[channel_name]\n\n        if count is None:\n\n            return buffer.samples.copy()\n\n        return buffer.get_latest(count)\n\n\n\n    async def clear_buffers(self) -> None:\n"
      },
      {
        "file": "src\\interfaces\\hardware\\factory.py",
        "line": 556,
        "pattern": "return cls._default_configs.get(device_type, {}).copy()",
        "category": "UNNECESSARY",
        "reason": "Return copy of local variable (can return directly)",
        "confidence": 0.7,
        "context": "        Dict[str, Any]\n\n            Default configuration dictionary\n\n        \"\"\"\n\n        return cls._default_configs.get(device_type, {}).copy()\n\n\n\n    @classmethod\n\n    def _build_device_config(\n"
      },
      {
        "file": "src\\interfaces\\hardware\\sensors.py",
        "line": 122,
        "pattern": "return history.copy()",
        "category": "UNNECESSARY",
        "reason": "Return copy of local variable (can return directly)",
        "confidence": 0.7,
        "context": "        \"\"\"Get historical readings for channel.\"\"\"\n\n        history = self._readings_history.get(channel, [])\n\n        if count is None:\n\n            return history.copy()\n\n        return history[-count:] if count <= len(history) else history.copy()\n\n\n\n    async def calibrate_channel(self, channel: str, calibration: SensorCalibration) -> bool:\n"
      },
      {
        "file": "src\\interfaces\\hardware\\sensors.py",
        "line": 123,
        "pattern": "return history[-count:] if count <= len(history) else history.copy()",
        "category": "UNNECESSARY",
        "reason": "Return copy of local variable (can return directly)",
        "confidence": 0.7,
        "context": "        history = self._readings_history.get(channel, [])\n\n        if count is None:\n\n            return history.copy()\n\n        return history[-count:] if count <= len(history) else history.copy()\n\n\n\n    async def calibrate_channel(self, channel: str, calibration: SensorCalibration) -> bool:\n\n        \"\"\"Calibrate specific channel.\"\"\"\n"
      },
      {
        "file": "src\\interfaces\\hil\\fault_injection.py",
        "line": 153,
        "pattern": "stats = self._stats.copy()",
        "category": "UNNECESSARY",
        "reason": "Stats dict copy for read-only access (no mutation needed)",
        "confidence": 0.8,
        "context": "    @property\n\n    def statistics(self) -> Dict[str, Any]:\n\n        \"\"\"Get fault injection statistics.\"\"\"\n\n        stats = self._stats.copy()\n\n        stats['fault_types_used'] = list(stats['fault_types_used'])\n\n        return stats\n\n\n"
      },
      {
        "file": "src\\interfaces\\hil\\real_time_sync.py",
        "line": 119,
        "pattern": "stats = self._statistics.copy()",
        "category": "UNNECESSARY",
        "reason": "Stats dict copy for read-only access (no mutation needed)",
        "confidence": 0.8,
        "context": "\n\n    def get_statistics(self) -> Dict[str, Any]:\n\n        \"\"\"Get deadline miss statistics.\"\"\"\n\n        stats = self._statistics.copy()\n\n        if stats['total_deadlines'] > 0:\n\n            stats['miss_rate'] = stats['missed_deadlines'] / stats['total_deadlines']\n\n        else:\n"
      },
      {
        "file": "src\\interfaces\\hil\\real_time_sync.py",
        "line": 254,
        "pattern": "stats = self._performance_stats.copy()",
        "category": "UNNECESSARY",
        "reason": "Stats dict copy for read-only access (no mutation needed)",
        "confidence": 0.8,
        "context": "\n\n    def get_timing_statistics(self) -> Dict[str, Any]:\n\n        \"\"\"Get timing performance statistics.\"\"\"\n\n        stats = self._performance_stats.copy()\n\n\n\n        if stats['iterations'] > 0:\n\n            stats['avg_jitter'] = stats['total_jitter'] / stats['iterations']\n"
      },
      {
        "file": "src\\interfaces\\network\\factory.py",
        "line": 442,
        "pattern": "return cls._default_configs.get(interface_type, {}).copy()",
        "category": "UNNECESSARY",
        "reason": "Return copy of local variable (can return directly)",
        "confidence": 0.7,
        "context": "        Dict[str, Any]\n\n            Default configuration dictionary\n\n        \"\"\"\n\n        return cls._default_configs.get(interface_type, {}).copy()\n\n\n\n    @classmethod\n\n    def _build_interface_config(\n"
      },
      {
        "file": "src\\interfaces\\network\\http_interface.py",
        "line": 177,
        "pattern": "stats = self._stats.copy()",
        "category": "UNNECESSARY",
        "reason": "Stats dict copy for read-only access (no mutation needed)",
        "confidence": 0.8,
        "context": "\n\n    def get_statistics(self) -> Dict[str, Any]:\n\n        \"\"\"Get HTTP communication statistics.\"\"\"\n\n        stats = self._stats.copy()\n\n        stats['connection_state'] = self._connection_state.value\n\n        stats['is_server'] = self._app is not None\n\n        stats['registered_routes'] = len(self._routes)\n"
      },
      {
        "file": "src\\interfaces\\network\\message_queue.py",
        "line": 190,
        "pattern": "stats = self._stats.copy()",
        "category": "UNNECESSARY",
        "reason": "Stats dict copy for read-only access (no mutation needed)",
        "confidence": 0.8,
        "context": "\n\n    def get_statistics(self) -> Dict[str, Any]:\n\n        \"\"\"Get ZeroMQ communication statistics.\"\"\"\n\n        stats = self._stats.copy()\n\n        stats['connection_state'] = self._connection_state.value\n\n        stats['active_sockets'] = len(self._sockets)\n\n        stats['socket_names'] = list(self._sockets.keys())\n"
      },
      {
        "file": "src\\interfaces\\network\\message_queue.py",
        "line": 600,
        "pattern": "stats = self._stats.copy()",
        "category": "UNNECESSARY",
        "reason": "Stats dict copy for read-only access (no mutation needed)",
        "confidence": 0.8,
        "context": "\n\n    def get_statistics(self) -> Dict[str, Any]:\n\n        \"\"\"Get RabbitMQ communication statistics.\"\"\"\n\n        stats = self._stats.copy()\n\n        stats['connection_state'] = self._connection_state.value\n\n        stats['active_queues'] = len(self._queues)\n\n        stats['active_exchanges'] = len(self._exchanges)\n"
      },
      {
        "file": "src\\interfaces\\network\\tcp_interface.py",
        "line": 221,
        "pattern": "stats = self._stats.copy()",
        "category": "UNNECESSARY",
        "reason": "Stats dict copy for read-only access (no mutation needed)",
        "confidence": 0.8,
        "context": "\n\n    def get_statistics(self) -> Dict[str, Any]:\n\n        \"\"\"Get TCP communication statistics.\"\"\"\n\n        stats = self._stats.copy()\n\n        stats['connection_state'] = self._connection_state.value\n\n        stats['active_clients'] = len(self._clients)\n\n        stats['is_server'] = self._server is not None\n"
      },
      {
        "file": "src\\interfaces\\network\\udp_interface.py",
        "line": 189,
        "pattern": "stats = self._stats.copy()",
        "category": "UNNECESSARY",
        "reason": "Stats dict copy for read-only access (no mutation needed)",
        "confidence": 0.8,
        "context": "\n\n    def get_statistics(self) -> Dict[str, Any]:\n\n        \"\"\"Get UDP communication statistics.\"\"\"\n\n        stats = self._stats.copy()\n\n        stats['connection_state'] = self._connection_state.value\n\n        stats['sequence_number'] = self._sequence_number\n\n        stats['expected_sequence'] = self._expected_sequence\n"
      },
      {
        "file": "src\\interfaces\\network\\udp_interface_threadsafe.py",
        "line": 234,
        "pattern": "stats = self._stats.copy()",
        "category": "UNNECESSARY",
        "reason": "Stats dict copy for read-only access (no mutation needed)",
        "confidence": 0.8,
        "context": "    def get_statistics(self) -> Dict[str, Any]:\n\n        \"\"\"Get UDP communication statistics safely.\"\"\"\n\n        with self._stats_lock:\n\n            stats = self._stats.copy()\n\n\n\n        with self._state_lock:\n\n            stats['connection_state'] = self._connection_state.value\n"
      },
      {
        "file": "src\\interfaces\\network\\websocket_interface.py",
        "line": 225,
        "pattern": "stats = self._stats.copy()",
        "category": "UNNECESSARY",
        "reason": "Stats dict copy for read-only access (no mutation needed)",
        "confidence": 0.8,
        "context": "\n\n    def get_statistics(self) -> Dict[str, Any]:\n\n        \"\"\"Get WebSocket communication statistics.\"\"\"\n\n        stats = self._stats.copy()\n\n        stats['connection_state'] = self._connection_state.value\n\n        stats['connected_clients'] = len(self._clients)\n\n        stats['is_server'] = self._server is not None\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\genetic.py",
        "line": 280,
        "pattern": "return winner.copy()",
        "category": "UNNECESSARY",
        "reason": "Return copy of local variable (can return directly)",
        "confidence": 0.7,
        "context": "        tournament_size = min(self.config.tournament_size, len(self.population))\n\n        tournament = np.random.choice(self.population, tournament_size, replace=False)\n\n        winner = min(tournament, key=lambda x: x.fitness or float('inf'))\n\n        return winner.copy()\n\n\n\n    def _roulette_selection(self) -> Individual:\n\n        \"\"\"Roulette wheel selection.\"\"\"\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\genetic.py",
        "line": 348,
        "pattern": "return parent1.copy(), parent2.copy()",
        "category": "UNNECESSARY",
        "reason": "Return copy of local variable (can return directly)",
        "confidence": 0.7,
        "context": "    def _single_point_crossover(self, parent1: Individual, parent2: Individual) -> Tuple[Individual, Individual]:\n\n        \"\"\"Single-point crossover.\"\"\"\n\n        if self.dimension <= 1:\n\n            return parent1.copy(), parent2.copy()\n\n\n\n        crossover_point = np.random.randint(1, self.dimension)\n\n\n"
      },
      {
        "file": "src\\plant\\models\\base\\dynamics_interface.py",
        "line": 295,
        "pattern": "control_input=control_input.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "            return self._create_success_result(\n\n                state_derivative,\n\n                time=time,\n\n                control_input=control_input.copy(),\n\n                **kwargs\n\n            )\n\n\n"
      },
      {
        "file": "src\\plant\\models\\full\\dynamics.py",
        "line": 119,
        "pattern": "state=state.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "        if not self._validate_inputs(state, control_input):\n\n            return self._create_failure_result(\n\n                \"Invalid inputs\",\n\n                state=state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time\n\n            )\n"
      },
      {
        "file": "src\\plant\\models\\full\\dynamics.py",
        "line": 120,
        "pattern": "control_input=control_input.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "            return self._create_failure_result(\n\n                \"Invalid inputs\",\n\n                state=state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time\n\n            )\n\n\n"
      },
      {
        "file": "src\\plant\\models\\full\\dynamics.py",
        "line": 131,
        "pattern": "state=state.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "                if not self._check_physical_constraints(sanitized_state):\n\n                    return self._create_failure_result(\n\n                        \"Physical constraints violated\",\n\n                        state=state.copy(),\n\n                        control_input=control_input.copy(),\n\n                        time=time\n\n                    )\n"
      },
      {
        "file": "src\\plant\\models\\full\\dynamics.py",
        "line": 132,
        "pattern": "control_input=control_input.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "                    return self._create_failure_result(\n\n                        \"Physical constraints violated\",\n\n                        state=state.copy(),\n\n                        control_input=control_input.copy(),\n\n                        time=time\n\n                    )\n\n            else:\n"
      },
      {
        "file": "src\\plant\\models\\full\\dynamics.py",
        "line": 152,
        "pattern": "state=sanitized_state.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "            if not self._validate_state_derivative(state_derivative):\n\n                return self._create_failure_result(\n\n                    \"Invalid state derivative computed\",\n\n                    state=sanitized_state.copy(),\n\n                    control_input=control_input.copy(),\n\n                    time=time\n\n                )\n"
      },
      {
        "file": "src\\plant\\models\\full\\dynamics.py",
        "line": 153,
        "pattern": "control_input=control_input.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "                return self._create_failure_result(\n\n                    \"Invalid state derivative computed\",\n\n                    state=sanitized_state.copy(),\n\n                    control_input=control_input.copy(),\n\n                    time=time\n\n                )\n\n\n"
      },
      {
        "file": "src\\plant\\models\\full\\dynamics.py",
        "line": 166,
        "pattern": "state=sanitized_state.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "\n\n            return self._create_success_result(\n\n                state_derivative,\n\n                state=sanitized_state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time,\n\n                wind_velocity=wind_velocity.copy() if wind_velocity is not None else None,\n"
      },
      {
        "file": "src\\plant\\models\\full\\dynamics.py",
        "line": 167,
        "pattern": "control_input=control_input.copy(),",
        "category": "UNNECESSARY",
        "reason": "Diagnostic copy for result dict (read-only snapshot, no mutation risk)",
        "confidence": 0.8,
        "context": "            return self._create_success_result(\n\n                state_derivative,\n\n                state=sanitized_state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time,\n\n                wind_velocity=wind_velocity.copy() if wind_velocity is not None else None,\n\n                **diagnostics\n"
      },
      {
        "file": "src\\plant\\models\\full\\dynamics.py",
        "line": 179,
        "pattern": "state=state.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "\n\n            return self._create_failure_result(\n\n                f\"Numerical instability: {e}\",\n\n                state=state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time,\n\n                error_type=\"numerical_instability\"\n"
      },
      {
        "file": "src\\plant\\models\\full\\dynamics.py",
        "line": 180,
        "pattern": "control_input=control_input.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "            return self._create_failure_result(\n\n                f\"Numerical instability: {e}\",\n\n                state=state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time,\n\n                error_type=\"numerical_instability\"\n\n            )\n"
      },
      {
        "file": "src\\plant\\models\\full\\dynamics.py",
        "line": 191,
        "pattern": "state=state.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "\n\n            return self._create_failure_result(\n\n                f\"Dynamics computation failed: {e}\",\n\n                state=state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time,\n\n                error_type=\"computation_error\"\n"
      },
      {
        "file": "src\\plant\\models\\full\\dynamics.py",
        "line": 192,
        "pattern": "control_input=control_input.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "            return self._create_failure_result(\n\n                f\"Dynamics computation failed: {e}\",\n\n                state=state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time,\n\n                error_type=\"computation_error\"\n\n            )\n"
      },
      {
        "file": "src\\plant\\models\\full\\dynamics.py",
        "line": 292,
        "pattern": "stats = self.integration_stats.copy()",
        "category": "UNNECESSARY",
        "reason": "Stats dict copy for read-only access (no mutation needed)",
        "confidence": 0.8,
        "context": "\n\n    def get_integration_statistics(self) -> Dict[str, Any]:\n\n        \"\"\"Get integration performance statistics.\"\"\"\n\n        stats = self.integration_stats.copy()\n\n        if stats['total_steps'] > 0:\n\n            stats['success_rate'] = stats['successful_steps'] / stats['total_steps']\n\n            stats['rejection_rate'] = stats['rejected_steps'] / stats['total_steps']\n"
      },
      {
        "file": "src\\plant\\models\\full\\dynamics.py",
        "line": 391,
        "pattern": "self._last_state = state.copy()",
        "category": "UNNECESSARY",
        "reason": "Diagnostic copy for result dict (read-only snapshot, no mutation risk)",
        "confidence": 0.8,
        "context": "                diagnostics['derivative_consistency_error'] = derivative_error\n\n\n\n        # Store for next iteration\n\n        self._last_state = state.copy()\n\n        self._last_time = time\n\n\n\n        return diagnostics\n"
      },
      {
        "file": "src\\plant\\models\\lowrank\\dynamics.py",
        "line": 109,
        "pattern": "state=state.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "        if not self._validate_inputs(state, control_input):\n\n            return self._create_failure_result(\n\n                \"Invalid inputs\",\n\n                state=state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time\n\n            )\n"
      },
      {
        "file": "src\\plant\\models\\lowrank\\dynamics.py",
        "line": 110,
        "pattern": "control_input=control_input.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "            return self._create_failure_result(\n\n                \"Invalid inputs\",\n\n                state=state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time\n\n            )\n\n\n"
      },
      {
        "file": "src\\plant\\models\\lowrank\\dynamics.py",
        "line": 132,
        "pattern": "state=sanitized_state.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "            if not self.physics.validate_computation(sanitized_state, state_derivative):\n\n                return self._create_failure_result(\n\n                    \"Invalid state derivative computed\",\n\n                    state=sanitized_state.copy(),\n\n                    control_input=control_input.copy(),\n\n                    time=time\n\n                )\n"
      },
      {
        "file": "src\\plant\\models\\lowrank\\dynamics.py",
        "line": 133,
        "pattern": "control_input=control_input.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "                return self._create_failure_result(\n\n                    \"Invalid state derivative computed\",\n\n                    state=sanitized_state.copy(),\n\n                    control_input=control_input.copy(),\n\n                    time=time\n\n                )\n\n\n"
      },
      {
        "file": "src\\plant\\models\\lowrank\\dynamics.py",
        "line": 147,
        "pattern": "state=sanitized_state.copy(),",
        "category": "UNNECESSARY",
        "reason": "Diagnostic copy for result dict (read-only snapshot, no mutation risk)",
        "confidence": 0.8,
        "context": "\n\n            return self._create_success_result(\n\n                state_derivative,\n\n                state=sanitized_state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time,\n\n                **diagnostics\n"
      },
      {
        "file": "src\\plant\\models\\lowrank\\dynamics.py",
        "line": 148,
        "pattern": "control_input=control_input.copy(),",
        "category": "UNNECESSARY",
        "reason": "Diagnostic copy for result dict (read-only snapshot, no mutation risk)",
        "confidence": 0.8,
        "context": "            return self._create_success_result(\n\n                state_derivative,\n\n                state=sanitized_state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time,\n\n                **diagnostics\n\n            )\n"
      },
      {
        "file": "src\\plant\\models\\lowrank\\dynamics.py",
        "line": 157,
        "pattern": "state=state.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "            self._record_failed_computation()\n\n            return self._create_failure_result(\n\n                f\"Numerical instability: {e}\",\n\n                state=state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time,\n\n                error_type=\"numerical_instability\"\n"
      },
      {
        "file": "src\\plant\\models\\lowrank\\dynamics.py",
        "line": 158,
        "pattern": "control_input=control_input.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "            return self._create_failure_result(\n\n                f\"Numerical instability: {e}\",\n\n                state=state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time,\n\n                error_type=\"numerical_instability\"\n\n            )\n"
      },
      {
        "file": "src\\plant\\models\\lowrank\\dynamics.py",
        "line": 167,
        "pattern": "state=state.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "            self._record_failed_computation()\n\n            return self._create_failure_result(\n\n                f\"Dynamics computation failed: {e}\",\n\n                state=state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time,\n\n                error_type=\"computation_error\"\n"
      },
      {
        "file": "src\\plant\\models\\lowrank\\dynamics.py",
        "line": 168,
        "pattern": "control_input=control_input.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "            return self._create_failure_result(\n\n                f\"Dynamics computation failed: {e}\",\n\n                state=state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time,\n\n                error_type=\"computation_error\"\n\n            )\n"
      },
      {
        "file": "src\\plant\\models\\lowrank\\dynamics.py",
        "line": 272,
        "pattern": "stats = self.computation_stats.copy()",
        "category": "UNNECESSARY",
        "reason": "Stats dict copy for read-only access (no mutation needed)",
        "confidence": 0.8,
        "context": "\n\n    def get_computation_statistics(self) -> Dict[str, Any]:\n\n        \"\"\"Get computation performance statistics.\"\"\"\n\n        stats = self.computation_stats.copy()\n\n        if stats['total_computations'] > 0:\n\n            stats['success_rate'] = stats['successful_computations'] / stats['total_computations']\n\n            stats['failure_rate'] = stats['failed_computations'] / stats['total_computations']\n"
      },
      {
        "file": "src\\plant\\models\\simplified\\dynamics.py",
        "line": 164,
        "pattern": "state=state.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "        if not self.validate_state(state):\n\n            return self._create_failure_result(\n\n                \"Invalid state vector\",\n\n                state=state.copy(),\n\n                time=time\n\n            )\n\n\n"
      },
      {
        "file": "src\\plant\\models\\simplified\\dynamics.py",
        "line": 171,
        "pattern": "control_input=control_input.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "        if not self._validate_control_input(control_input):\n\n            return self._create_failure_result(\n\n                \"Invalid control input\",\n\n                control_input=control_input.copy(),\n\n                time=time\n\n            )\n\n\n"
      },
      {
        "file": "src\\plant\\models\\simplified\\dynamics.py",
        "line": 189,
        "pattern": "state=state.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "            if not self._validate_state_derivative(state_derivative):\n\n                return self._create_failure_result(\n\n                    \"Invalid state derivative computed\",\n\n                    state=state.copy(),\n\n                    control_input=control_input.copy(),\n\n                    time=time\n\n                )\n"
      },
      {
        "file": "src\\plant\\models\\simplified\\dynamics.py",
        "line": 190,
        "pattern": "control_input=control_input.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "                return self._create_failure_result(\n\n                    \"Invalid state derivative computed\",\n\n                    state=state.copy(),\n\n                    control_input=control_input.copy(),\n\n                    time=time\n\n                )\n\n\n"
      },
      {
        "file": "src\\plant\\models\\simplified\\dynamics.py",
        "line": 200,
        "pattern": "state=sanitized_state.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "\n\n            return self._create_success_result(\n\n                state_derivative,\n\n                state=sanitized_state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time,\n\n                total_energy=self.physics.compute_total_energy(sanitized_state),\n"
      },
      {
        "file": "src\\plant\\models\\simplified\\dynamics.py",
        "line": 201,
        "pattern": "control_input=control_input.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "            return self._create_success_result(\n\n                state_derivative,\n\n                state=sanitized_state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time,\n\n                total_energy=self.physics.compute_total_energy(sanitized_state),\n\n                kinetic_energy=self.physics.compute_kinetic_energy(sanitized_state),\n"
      },
      {
        "file": "src\\plant\\models\\simplified\\dynamics.py",
        "line": 215,
        "pattern": "state=state.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "\n\n            return self._create_failure_result(\n\n                f\"Numerical instability: {e}\",\n\n                state=state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time,\n\n                error_type=\"numerical_instability\"\n"
      },
      {
        "file": "src\\plant\\models\\simplified\\dynamics.py",
        "line": 216,
        "pattern": "control_input=control_input.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "            return self._create_failure_result(\n\n                f\"Numerical instability: {e}\",\n\n                state=state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time,\n\n                error_type=\"numerical_instability\"\n\n            )\n"
      },
      {
        "file": "src\\plant\\models\\simplified\\dynamics.py",
        "line": 228,
        "pattern": "state=state.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "\n\n            return self._create_failure_result(\n\n                f\"Dynamics computation failed: {e}\",\n\n                state=state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time,\n\n                error_type=\"computation_error\"\n"
      },
      {
        "file": "src\\plant\\models\\simplified\\dynamics.py",
        "line": 229,
        "pattern": "control_input=control_input.copy(),",
        "category": "UNNECESSARY",
        "reason": "Result dict construction (immutable after return, no mutation risk)",
        "confidence": 0.85,
        "context": "            return self._create_failure_result(\n\n                f\"Dynamics computation failed: {e}\",\n\n                state=state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time,\n\n                error_type=\"computation_error\"\n\n            )\n"
      },
      {
        "file": "src\\simulation\\integrators\\compatibility.py",
        "line": 287,
        "pattern": "return state.copy()",
        "category": "UNNECESSARY",
        "reason": "Return copy of local variable (can return directly)",
        "confidence": 0.7,
        "context": "\n\n        except Exception:\n\n            # Ultimate safety: return unchanged state\n\n            return state.copy()\n\n\n\n    def reset(self) -> None:\n\n        \"\"\"Reset the safety wrapper state.\"\"\"\n"
      },
      {
        "file": "src\\simulation\\safety\\recovery.py",
        "line": 43,
        "pattern": "return state.copy(), 0.0, True",
        "category": "UNNECESSARY",
        "reason": "Return copy of local variable (can return directly)",
        "confidence": 0.7,
        "context": "\n\n    def recover(self, state: np.ndarray, control: float, violation_info: dict) -> tuple:\n\n        \"\"\"Apply emergency stop - zero control and hold state.\"\"\"\n\n        return state.copy(), 0.0, True\n\n\n\n\n\nclass StateLimiter(RecoveryStrategy):\n"
      }
    ],
    "NECESSARY": [
      {
        "file": "src\\analysis\\core\\data_structures.py",
        "line": 79,
        "pattern": "metadata=self.metadata.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            controls=self.controls[start_idx:control_end_idx],\n\n            reference=self.reference[start_idx:end_idx] if self.reference is not None else None,\n\n            disturbances=self.disturbances[start_idx:end_idx] if self.disturbances is not None else None,\n\n            metadata=self.metadata.copy()\n\n        )\n\n\n\n    def downsample(self, factor: int) -> 'SimulationData':\n"
      },
      {
        "file": "src\\analysis\\core\\data_structures.py",
        "line": 96,
        "pattern": "metadata=self.metadata.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            controls=self.controls[control_indices],\n\n            reference=self.reference[indices] if self.reference is not None else None,\n\n            disturbances=self.disturbances[indices] if self.disturbances is not None else None,\n\n            metadata=self.metadata.copy()\n\n        )\n\n\n\n\n"
      },
      {
        "file": "src\\analysis\\fault_detection\\fdi.py",
        "line": 183,
        "pattern": "self._last_state = meas.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            return \"FAULT\", np.inf\n\n\n\n        if self._last_state is None:\n\n            self._last_state = meas.copy()\n\n            # Store history for first measurement\n\n            self.times.append(t)\n\n            self.residuals.append(0.0)\n"
      },
      {
        "file": "src\\analysis\\fault_detection\\fdi.py",
        "line": 308,
        "pattern": "self._last_state = meas.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        else:\n\n            self._counter = 0  # Reset on any good measurement\n\n            # Only update state when measurement appears good\n\n            self._last_state = meas.copy()\n\n\n\n        # Check for fault condition based on persistence count\n\n        if self._counter >= self.persistence_counter:\n"
      },
      {
        "file": "src\\analysis\\fault_detection\\fdi_system.py",
        "line": 1117,
        "pattern": "self._last_state = meas.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            return \"FAULT\", np.inf\n\n\n\n        if self._last_state is None:\n\n            self._last_state = meas.copy()\n\n            return \"OK\", 0.0\n\n\n\n        # One-step prediction using the dynamics model\n"
      },
      {
        "file": "src\\analysis\\fault_detection\\fdi_system.py",
        "line": 1206,
        "pattern": "self._last_state = meas.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            return \"FAULT\", residual_norm\n\n\n\n        # Update state for next prediction\n\n        self._last_state = meas.copy()\n\n        return \"OK\", residual_norm\n\n\n\n\n"
      },
      {
        "file": "src\\analysis\\fault_detection\\residual_generators.py",
        "line": 147,
        "pattern": "self._observer_state = states[0].copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n        # Initialize observer state\n\n        if self._observer_state is None:\n\n            self._observer_state = states[0].copy()\n\n\n\n        for i in range(1, len(states)):\n\n            dt = times[i] - times[i-1]\n"
      },
      {
        "file": "src\\analysis\\fault_detection\\residual_generators.py",
        "line": 176,
        "pattern": "observer_states.append(self._observer_state.copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n            # Store results\n\n            residuals.append(innovation)\n\n            observer_states.append(self._observer_state.copy())\n\n\n\n        residuals = np.array(residuals) if residuals else np.array([]).reshape(0, self.C.shape[0])\n\n\n"
      },
      {
        "file": "src\\analysis\\fault_detection\\residual_generators.py",
        "line": 244,
        "pattern": "self._x_hat = states[0].copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n        # Initialize if needed\n\n        if self._x_hat is None:\n\n            self._x_hat = states[0].copy()\n\n            self._P = self.P0.copy()\n\n\n\n        for i in range(1, len(states)):\n"
      },
      {
        "file": "src\\analysis\\fault_detection\\residual_generators.py",
        "line": 245,
        "pattern": "self._P = self.P0.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        # Initialize if needed\n\n        if self._x_hat is None:\n\n            self._x_hat = states[0].copy()\n\n            self._P = self.P0.copy()\n\n\n\n        for i in range(1, len(states)):\n\n            dt = times[i] - times[i-1]\n"
      },
      {
        "file": "src\\analysis\\fault_detection\\residual_generators.py",
        "line": 293,
        "pattern": "estimated_states.append(self._x_hat.copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            # Store results\n\n            residuals.append(innovation)\n\n            innovations_cov.append(S)\n\n            estimated_states.append(self._x_hat.copy())\n\n\n\n        residuals = np.array(residuals) if residuals else np.array([]).reshape(0, self.C.shape[0])\n\n\n"
      },
      {
        "file": "src\\analysis\\fault_detection\\residual_generators.py",
        "line": 512,
        "pattern": "return self.nominal_parameters.copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "        # In practice, would use more sophisticated methods like recursive least squares\n\n\n\n        if len(states) < 3:\n\n            return self.nominal_parameters.copy()\n\n\n\n        # Compute state derivatives using finite differences\n\n        dt = np.mean(np.diff(times))\n"
      },
      {
        "file": "src\\analysis\\performance\\robustness.py",
        "line": 231,
        "pattern": "ic_pos = initial_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            perturbation = self.config.sensitivity_perturbation * (abs(initial_state[i]) + 1.0)\n\n\n\n            # Create perturbed initial conditions\n\n            ic_pos = initial_state.copy()\n\n            ic_pos[i] += perturbation\n\n\n\n            ic_neg = initial_state.copy()\n"
      },
      {
        "file": "src\\analysis\\performance\\robustness.py",
        "line": 234,
        "pattern": "ic_neg = initial_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            ic_pos = initial_state.copy()\n\n            ic_pos[i] += perturbation\n\n\n\n            ic_neg = initial_state.copy()\n\n            ic_neg[i] -= perturbation\n\n\n\n            # Simulate with perturbed initial conditions\n"
      },
      {
        "file": "src\\analysis\\performance\\robustness.py",
        "line": 463,
        "pattern": "A_pert = A.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            # Perturb specific element of A matrix\n\n            try:\n\n                i, j = map(int, param_name.split('_')[1:])\n\n                A_pert = A.copy()\n\n                A_pert[i, j] += perturbation\n\n                return (A_pert, B, C, D)\n\n            except:\n"
      },
      {
        "file": "src\\analysis\\performance\\robustness.py",
        "line": 471,
        "pattern": "B_pert = B.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        elif param_name.startswith('B_'):\n\n            try:\n\n                i, j = map(int, param_name.split('_')[1:])\n\n                B_pert = B.copy()\n\n                B_pert[i, j] += perturbation\n\n                return (A, B_pert, C, D)\n\n            except:\n"
      },
      {
        "file": "src\\analysis\\performance\\stability_analysis.py",
        "line": 430,
        "pattern": "C_matrix = B.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        n = A.shape[0]\n\n\n\n        # Controllability matrix\n\n        C_matrix = B.copy()\n\n        for i in range(1, n):\n\n            C_matrix = np.hstack([C_matrix, np.linalg.matrix_power(A, i) @ B])\n\n\n"
      },
      {
        "file": "src\\analysis\\performance\\stability_analysis.py",
        "line": 450,
        "pattern": "O_matrix = C.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        n = A.shape[0]\n\n\n\n        # Observability matrix\n\n        O_matrix = C.copy()\n\n        for i in range(1, n):\n\n            O_matrix = np.vstack([O_matrix, C @ np.linalg.matrix_power(A, i)])\n\n\n"
      },
      {
        "file": "src\\analysis\\validation\\benchmarking.py",
        "line": 681,
        "pattern": "corrected_result = result.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        # Update test results with corrected p-values\n\n        corrected_results = {}\n\n        for i, (comparison_key, result) in enumerate(test_results.items()):\n\n            corrected_result = result.copy()\n\n            corrected_result['corrected_p_value'] = float(min(1.0, corrected_p_values[i]))\n\n            corrected_result['corrected_significant'] = bool(corrected_result['corrected_p_value'] < self.config.significance_level)\n\n            corrected_results[comparison_key] = corrected_result\n"
      },
      {
        "file": "src\\analysis\\validation\\monte_carlo.py",
        "line": 734,
        "pattern": "perturbed_params = baseline_params.copy()",
        "category": "NECESSARY",
        "reason": "Parameter perturbation (mutation follows)",
        "confidence": 0.95,
        "context": "            perturbation_factors = [-0.1, -0.05, 0.05, 0.1]  # \u00b110%, \u00b15%\n\n\n\n            for factor in perturbation_factors:\n\n                perturbed_params = baseline_params.copy()\n\n\n\n                if dist_info.get('type', 'normal') == 'normal':\n\n                    std = dist_info.get('std', 1.0)\n"
      },
      {
        "file": "src\\analysis\\visualization\\report_generator.py",
        "line": 386,
        "pattern": "'metadata': self.metadata.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n        # Prepare data for JSON serialization\n\n        report_data = {\n\n            'metadata': self.metadata.copy(),\n\n            'simulation_summary': {\n\n                'duration': float(simulation_data.time[-1] - simulation_data.time[0]),\n\n                'sample_rate': float(1/(simulation_data.time[1] - simulation_data.time[0])),\n"
      },
      {
        "file": "src\\controllers\\factory\\__init__.py",
        "line": 122,
        "pattern": "processed_params = params.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        params = {}\n\n\n\n    # Make a copy to avoid modifying the original\n\n    processed_params = params.copy()\n\n\n\n    # Define parameter deprecation mappings by controller type\n\n    deprecation_mappings = {\n"
      },
      {
        "file": "src\\controllers\\factory\\core\\registry.py",
        "line": 268,
        "pattern": "return controller_info['default_gains'].copy()",
        "category": "NECESSARY",
        "reason": "Error result construction (copy required for immutability)",
        "confidence": 0.9,
        "context": "        ValueError: If controller_type is not recognized\n\n    \"\"\"\n\n    controller_info = get_controller_info(controller_type)\n\n    return controller_info['default_gains'].copy()\n\n\n\n\n\ndef get_gain_bounds(controller_type: str) -> List[tuple]:\n"
      },
      {
        "file": "src\\controllers\\factory\\core\\registry.py",
        "line": 284,
        "pattern": "return controller_info.get('gain_bounds', []).copy()",
        "category": "NECESSARY",
        "reason": "Error result construction (copy required for immutability)",
        "confidence": 0.9,
        "context": "        ValueError: If controller_type is not recognized\n\n    \"\"\"\n\n    controller_info = get_controller_info(controller_type)\n\n    return controller_info.get('gain_bounds', []).copy()\n\n\n\n\n\ndef validate_controller_type(controller_type: str) -> bool:\n"
      },
      {
        "file": "src\\controllers\\factory\\deprecation.py",
        "line": 144,
        "pattern": "updated_params = config_params.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        if controller_type not in self._deprecation_mappings:\n\n            return config_params\n\n\n\n        updated_params = config_params.copy()\n\n        deprecation_map = self._deprecation_mappings[controller_type]\n\n\n\n        for param_name, param_value in config_params.items():\n"
      },
      {
        "file": "src\\controllers\\factory\\pso_integration.py",
        "line": 413,
        "pattern": "lower = base_bounds[smc_type]['lower'].copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    if smc_type not in base_bounds:\n\n        raise ValueError(f\"Unsupported controller type: {smc_type}\")\n\n\n\n    lower = base_bounds[smc_type]['lower'].copy()\n\n    upper = base_bounds[smc_type]['upper'].copy()\n\n\n\n    # Adjust bounds based on performance target\n"
      },
      {
        "file": "src\\controllers\\factory\\pso_integration.py",
        "line": 414,
        "pattern": "upper = base_bounds[smc_type]['upper'].copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        raise ValueError(f\"Unsupported controller type: {smc_type}\")\n\n\n\n    lower = base_bounds[smc_type]['lower'].copy()\n\n    upper = base_bounds[smc_type]['upper'].copy()\n\n\n\n    # Adjust bounds based on performance target\n\n    if performance_target == 'aggressive':\n"
      },
      {
        "file": "src\\controllers\\factory.py",
        "line": 282,
        "pattern": "controller_info = CONTROLLER_REGISTRY[controller_type].copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            f\"Available: {available}\"\n\n        )\n\n\n\n    controller_info = CONTROLLER_REGISTRY[controller_type].copy()\n\n\n\n    # For MPC controller, check if it's been dynamically made available (e.g., via monkeypatch)\n\n    if controller_type == 'mpc_controller' and controller_info['class'] is None:\n"
      },
      {
        "file": "src\\controllers\\factory.py",
        "line": 453,
        "pattern": "controller_params = controller_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            if hasattr(controller_config, 'model_dump'):\n\n                controller_params = controller_config.model_dump()\n\n            elif isinstance(controller_config, dict):\n\n                controller_params = controller_config.copy()\n\n            else:\n\n                # Extract attributes from config object\n\n                controller_params = {\n"
      },
      {
        "file": "src\\controllers\\factory.py",
        "line": 590,
        "pattern": "controller_params = controller_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                if hasattr(controller_config, 'model_dump'):\n\n                    controller_params = controller_config.model_dump()\n\n                elif isinstance(controller_config, dict):\n\n                    controller_params = controller_config.copy()\n\n                else:\n\n                    # Extract attributes from config object\n\n                    controller_params = {\n"
      },
      {
        "file": "src\\controllers\\factory.py",
        "line": 887,
        "pattern": "return CONTROLLER_REGISTRY[controller_type]['default_gains'].copy()",
        "category": "NECESSARY",
        "reason": "Error result construction (copy required for immutability)",
        "confidence": 0.9,
        "context": "        available = list(CONTROLLER_REGISTRY.keys())\n\n        raise ValueError(f\"Unknown controller type '{controller_type}'. Available: {available}\")\n\n\n\n    return CONTROLLER_REGISTRY[controller_type]['default_gains'].copy()\n\n\n\n\n\n# Backwards compatibility aliases\n"
      },
      {
        "file": "src\\controllers\\smc\\algorithms\\adaptive\\parameter_estimation.py",
        "line": 290,
        "pattern": "'parameters': self.theta_hat.copy(),",
        "category": "NECESSARY",
        "reason": "Storing in history/list (copy prevents aliasing)",
        "confidence": 0.95,
        "context": "        # Store history\n\n        self._parameter_history.append({\n\n            'step': len(self._parameter_history),\n\n            'parameters': self.theta_hat.copy(),\n\n            'prediction_error': float(error),\n\n            'gain_norm': float(np.linalg.norm(K)),\n\n            'covariance_trace': float(np.trace(self.P))\n"
      },
      {
        "file": "src\\controllers\\smc\\algorithms\\adaptive\\parameter_estimation.py",
        "line": 296,
        "pattern": "return self.theta_hat.copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "            'covariance_trace': float(np.trace(self.P))\n\n        })\n\n\n\n        return self.theta_hat.copy()\n\n\n\n    def get_parameter_estimates(self) -> np.ndarray:\n\n        \"\"\"Get current parameter estimates.\"\"\"\n"
      },
      {
        "file": "src\\controllers\\smc\\algorithms\\adaptive\\parameter_estimation.py",
        "line": 300,
        "pattern": "return self.theta_hat.copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "\n\n    def get_parameter_estimates(self) -> np.ndarray:\n\n        \"\"\"Get current parameter estimates.\"\"\"\n\n        return self.theta_hat.copy()\n\n\n\n    def get_parameter_covariance(self) -> np.ndarray:\n\n        \"\"\"Get parameter covariance matrix.\"\"\"\n"
      },
      {
        "file": "src\\controllers\\smc\\algorithms\\adaptive\\parameter_estimation.py",
        "line": 304,
        "pattern": "return self.P.copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "\n\n    def get_parameter_covariance(self) -> np.ndarray:\n\n        \"\"\"Get parameter covariance matrix.\"\"\"\n\n        return self.P.copy()\n\n\n\n    def get_parameter_confidence(self, confidence: float = 0.95) -> np.ndarray:\n\n        \"\"\"\n"
      },
      {
        "file": "src\\controllers\\smc\\algorithms\\classical\\config.py",
        "line": 201,
        "pattern": "config_dict = config_dict.copy()",
        "category": "NECESSARY",
        "reason": "Config dict mutation safety (prevents side effects on caller's dict)",
        "confidence": 0.95,
        "context": "    @classmethod\n\n    def from_dict(cls, config_dict: dict, dynamics_model=None) -> 'ClassicalSMCConfig':\n\n        \"\"\"Create configuration from dictionary.\"\"\"\n\n        config_dict = config_dict.copy()\n\n        config_dict['dynamics_model'] = dynamics_model\n\n        return cls(**config_dict)\n\n\n"
      },
      {
        "file": "src\\controllers\\smc\\algorithms\\hybrid\\config.py",
        "line": 316,
        "pattern": "config_dict = config_dict.copy()",
        "category": "NECESSARY",
        "reason": "Config dict mutation safety (prevents side effects on caller's dict)",
        "confidence": 0.95,
        "context": "    @classmethod\n\n    def from_dict(cls, config_dict: Dict[str, Any], dynamics_model=None) -> 'HybridSMCConfig':\n\n        \"\"\"Create configuration from dictionary.\"\"\"\n\n        config_dict = config_dict.copy()\n\n\n\n        # Convert enum strings back to enums\n\n        config_dict['hybrid_mode'] = HybridMode(config_dict['hybrid_mode'])\n"
      },
      {
        "file": "src\\controllers\\smc\\algorithms\\hybrid\\switching_logic.py",
        "line": 162,
        "pattern": "'metrics': decision.metrics.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            'to': decision.target_controller.value,\n\n            'reason': decision.reason,\n\n            'confidence': decision.confidence,\n\n            'metrics': decision.metrics.copy()\n\n        })\n\n\n\n        # Execute switch\n"
      },
      {
        "file": "src\\controllers\\smc\\algorithms\\hybrid\\switching_logic.py",
        "line": 412,
        "pattern": "'state': system_state.copy(),",
        "category": "NECESSARY",
        "reason": "Storing in history/list (copy prevents aliasing)",
        "confidence": 0.95,
        "context": "        # Store current state for prediction\n\n        if self.prediction_buffer is not None:\n\n            self.prediction_buffer.append({\n\n                'state': system_state.copy(),\n\n                'metrics': self.current_performance_metrics.copy(),\n\n                'decision': decision\n\n            })\n"
      },
      {
        "file": "src\\controllers\\smc\\algorithms\\hybrid\\switching_logic.py",
        "line": 413,
        "pattern": "'metrics': self.current_performance_metrics.copy(),",
        "category": "NECESSARY",
        "reason": "Storing in history/list (copy prevents aliasing)",
        "confidence": 0.95,
        "context": "        if self.prediction_buffer is not None:\n\n            self.prediction_buffer.append({\n\n                'state': system_state.copy(),\n\n                'metrics': self.current_performance_metrics.copy(),\n\n                'decision': decision\n\n            })\n\n\n"
      },
      {
        "file": "src\\controllers\\smc\\algorithms\\hybrid\\switching_logic.py",
        "line": 446,
        "pattern": "'thresholds': self.learned_thresholds.copy(),",
        "category": "NECESSARY",
        "reason": "Storing in history/list (copy prevents aliasing)",
        "confidence": 0.95,
        "context": "        # For now, just record the decision for future analysis\n\n        self.threshold_adaptation_history.append({\n\n            'decision': decision,\n\n            'thresholds': self.learned_thresholds.copy(),\n\n            'metrics': self.current_performance_metrics.copy()\n\n        })\n\n\n"
      },
      {
        "file": "src\\controllers\\smc\\algorithms\\hybrid\\switching_logic.py",
        "line": 447,
        "pattern": "'metrics': self.current_performance_metrics.copy()",
        "category": "NECESSARY",
        "reason": "Storing in history/list (copy prevents aliasing)",
        "confidence": 0.95,
        "context": "        self.threshold_adaptation_history.append({\n\n            'decision': decision,\n\n            'thresholds': self.learned_thresholds.copy(),\n\n            'metrics': self.current_performance_metrics.copy()\n\n        })\n\n\n\n    def get_switching_analysis(self) -> Dict[str, Any]:\n"
      },
      {
        "file": "src\\controllers\\smc\\algorithms\\super_twisting\\config.py",
        "line": 216,
        "pattern": "config_dict = config_dict.copy()",
        "category": "NECESSARY",
        "reason": "Config dict mutation safety (prevents side effects on caller's dict)",
        "confidence": 0.95,
        "context": "    @classmethod\n\n    def from_dict(cls, config_dict: dict, dynamics_model=None) -> 'SuperTwistingSMCConfig':\n\n        \"\"\"Create configuration from dictionary.\"\"\"\n\n        config_dict = config_dict.copy()\n\n        config_dict['dynamics_model'] = dynamics_model\n\n        return cls(**config_dict)\n\n\n"
      },
      {
        "file": "src\\interfaces\\hardware\\daq_systems.py",
        "line": 92,
        "pattern": "return self.samples[-count:] if count <= len(self.samples) else self.samples.copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "\n\n    def get_latest(self, count: int = 1) -> List[DAQSample]:\n\n        \"\"\"Get latest samples.\"\"\"\n\n        return self.samples[-count:] if count <= len(self.samples) else self.samples.copy()\n\n\n\n    def clear(self) -> None:\n\n        \"\"\"Clear buffer.\"\"\"\n"
      },
      {
        "file": "src\\interfaces\\hardware\\daq_systems.py",
        "line": 134,
        "pattern": "return self._channels.copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "    @property\n\n    def channels(self) -> Dict[str, ChannelConfig]:\n\n        \"\"\"Get channel configurations.\"\"\"\n\n        return self._channels.copy()\n\n\n\n    @abstractmethod\n\n    async def configure_channel(self, channel_config: ChannelConfig) -> bool:\n"
      },
      {
        "file": "src\\interfaces\\hardware\\device_drivers.py",
        "line": 143,
        "pattern": "return self._capabilities.copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "    @property\n\n    def capabilities(self) -> List[DeviceCapability]:\n\n        \"\"\"Get device capabilities.\"\"\"\n\n        return self._capabilities.copy()\n\n\n\n    @property\n\n    def config(self) -> DeviceConfig:\n"
      },
      {
        "file": "src\\interfaces\\hardware\\device_drivers.py",
        "line": 474,
        "pattern": "return self._data_cache.copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "        if (current_time - self._last_cache_update) < self._cache_timeout:\n\n            if channel:\n\n                return {channel: self._data_cache.get(channel)} if channel in self._data_cache else {}\n\n            return self._data_cache.copy()\n\n\n\n        # Update cache with fresh data\n\n        await self._update_data_cache()\n"
      },
      {
        "file": "src\\interfaces\\hardware\\device_drivers.py",
        "line": 482,
        "pattern": "return self._data_cache.copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "\n\n        if channel:\n\n            return {channel: self._data_cache.get(channel)} if channel in self._data_cache else {}\n\n        return self._data_cache.copy()\n\n\n\n    async def write_data(self, data: Dict[str, Any]) -> bool:\n\n        \"\"\"Write data to base device.\"\"\"\n"
      },
      {
        "file": "src\\interfaces\\hardware\\sensors.py",
        "line": 662,
        "pattern": "return self._orientation.copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "    async def get_orientation(self) -> Dict[str, float]:\n\n        \"\"\"Get current orientation (roll, pitch, yaw).\"\"\"\n\n        await self._update_sensor_fusion()\n\n        return self._orientation.copy()\n\n\n\n    async def _read_imu_data(self) -> Dict[str, float]:\n\n        \"\"\"Read all IMU sensor data.\"\"\"\n"
      },
      {
        "file": "src\\interfaces\\hil\\data_logging.py",
        "line": 195,
        "pattern": "data=data.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            # Create log entry\n\n            entry = LogEntry(\n\n                timestamp=timestamp or time.time(),\n\n                data=data.copy(),\n\n                sequence=self._sequence_counter,\n\n                source=\"hil_system\"\n\n            )\n"
      },
      {
        "file": "src\\interfaces\\hil\\data_logging.py",
        "line": 232,
        "pattern": "data=data.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            for i, data in enumerate(batch_data):\n\n                entry = LogEntry(\n\n                    timestamp=current_time + i * 0.001,  # 1ms spacing\n\n                    data=data.copy(),\n\n                    sequence=self._sequence_counter + i,\n\n                    source=\"hil_system\"\n\n                )\n"
      },
      {
        "file": "src\\interfaces\\hil\\data_logging.py",
        "line": 306,
        "pattern": "entries_to_flush = self._buffer.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                if not self._buffer:\n\n                    return\n\n\n\n                entries_to_flush = self._buffer.copy()\n\n                self._buffer.clear()\n\n\n\n            # Write entries to file\n"
      },
      {
        "file": "src\\interfaces\\hil\\enhanced_hil.py",
        "line": 332,
        "pattern": "'inputs': self._input_data.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                # Collect data\n\n                current_data = {\n\n                    'timestamp': time.time() - start_time,\n\n                    'inputs': self._input_data.copy(),\n\n                    'outputs': self._output_data.copy(),\n\n                    'simulation': self._simulation_data.copy()\n\n                }\n"
      },
      {
        "file": "src\\interfaces\\hil\\enhanced_hil.py",
        "line": 333,
        "pattern": "'outputs': self._output_data.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                current_data = {\n\n                    'timestamp': time.time() - start_time,\n\n                    'inputs': self._input_data.copy(),\n\n                    'outputs': self._output_data.copy(),\n\n                    'simulation': self._simulation_data.copy()\n\n                }\n\n                scenario_data.append(current_data)\n"
      },
      {
        "file": "src\\interfaces\\hil\\enhanced_hil.py",
        "line": 334,
        "pattern": "'simulation': self._simulation_data.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                    'timestamp': time.time() - start_time,\n\n                    'inputs': self._input_data.copy(),\n\n                    'outputs': self._output_data.copy(),\n\n                    'simulation': self._simulation_data.copy()\n\n                }\n\n                scenario_data.append(current_data)\n\n\n"
      },
      {
        "file": "src\\interfaces\\hil\\enhanced_hil.py",
        "line": 545,
        "pattern": "'inputs': self._input_data.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                    await self._data_logger.log_data({\n\n                        'iteration': iteration,\n\n                        'timestamp': time.time() - loop_start_time,\n\n                        'inputs': self._input_data.copy(),\n\n                        'outputs': self._output_data.copy(),\n\n                        'simulation': self._simulation_data.copy()\n\n                    })\n"
      },
      {
        "file": "src\\interfaces\\hil\\enhanced_hil.py",
        "line": 546,
        "pattern": "'outputs': self._output_data.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                        'iteration': iteration,\n\n                        'timestamp': time.time() - loop_start_time,\n\n                        'inputs': self._input_data.copy(),\n\n                        'outputs': self._output_data.copy(),\n\n                        'simulation': self._simulation_data.copy()\n\n                    })\n\n\n"
      },
      {
        "file": "src\\interfaces\\hil\\enhanced_hil.py",
        "line": 547,
        "pattern": "'simulation': self._simulation_data.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                        'timestamp': time.time() - loop_start_time,\n\n                        'inputs': self._input_data.copy(),\n\n                        'outputs': self._output_data.copy(),\n\n                        'simulation': self._simulation_data.copy()\n\n                    })\n\n\n\n                # Update performance metrics\n"
      },
      {
        "file": "src\\interfaces\\hil\\fault_injection.py",
        "line": 148,
        "pattern": "return self._active_faults.copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "    @property\n\n    def active_faults(self) -> Dict[str, FaultProfile]:\n\n        \"\"\"Get currently active faults.\"\"\"\n\n        return self._active_faults.copy()\n\n\n\n    @property\n\n    def statistics(self) -> Dict[str, Any]:\n"
      },
      {
        "file": "src\\interfaces\\hil\\plant_server.py",
        "line": 54,
        "pattern": "x = x.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            def __init__(self, dt: float):\n\n                self.dt = dt\n\n            def step(self, x, u):\n\n                x = x.copy()\n\n                x[0] += self.dt\n\n                x[1] += self.dt * x[3]\n\n                x[2] += self.dt * x[4]\n"
      },
      {
        "file": "src\\interfaces\\hil\\plant_server.py",
        "line": 191,
        "pattern": "meas = self.state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                    except Exception:\n\n                        pass\n\n                # Copy state and inject noise.\n\n                meas = self.state.copy()\n\n                if self.sensor_noise_std > 0.0:\n\n                    meas += self.rng.normal(0.0, self.sensor_noise_std, size=meas.shape)\n\n                # Optional latency.\n"
      },
      {
        "file": "src\\interfaces\\hil\\simulation_bridge.py",
        "line": 134,
        "pattern": "self._parameters = parameters.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    async def initialize(self, parameters: Dict[str, Any]) -> bool:\n\n        \"\"\"Initialize plant model.\"\"\"\n\n        try:\n\n            self._parameters = parameters.copy()\n\n\n\n            # Initialize state vector\n\n            state_size = parameters.get('state_size', 6)\n"
      },
      {
        "file": "src\\interfaces\\hil\\simulation_bridge.py",
        "line": 153,
        "pattern": "state_vector=self._state.copy() if self._state is not None else np.array([]),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        return ModelState(\n\n            model_id=self._model_id,\n\n            model_type=self.model_type,\n\n            state_vector=self._state.copy() if self._state is not None else np.array([]),\n\n            parameters=self._parameters.copy(),\n\n            timestamp=time.time(),\n\n            is_active=self._initialized\n"
      },
      {
        "file": "src\\interfaces\\hil\\simulation_bridge.py",
        "line": 154,
        "pattern": "parameters=self._parameters.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            model_id=self._model_id,\n\n            model_type=self.model_type,\n\n            state_vector=self._state.copy() if self._state is not None else np.array([]),\n\n            parameters=self._parameters.copy(),\n\n            timestamp=time.time(),\n\n            is_active=self._initialized\n\n        )\n"
      },
      {
        "file": "src\\interfaces\\hil\\simulation_bridge.py",
        "line": 163,
        "pattern": "self._state = state.state_vector.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        \"\"\"Set plant state.\"\"\"\n\n        try:\n\n            if state.model_id == self._model_id:\n\n                self._state = state.state_vector.copy()\n\n                return True\n\n            return False\n\n        except Exception:\n"
      },
      {
        "file": "src\\interfaces\\hil\\simulation_bridge.py",
        "line": 259,
        "pattern": "'state_vector': self._state.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n            return {\n\n                'plant_output': y,\n\n                'state_vector': self._state.copy(),\n\n                'timestamp': time.time()\n\n            }\n\n\n"
      },
      {
        "file": "src\\interfaces\\network\\factory.py",
        "line": 307,
        "pattern": "config_overrides = kwargs.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        ZeroMQInterface\n\n            Configured ZeroMQ interface\n\n        \"\"\"\n\n        config_overrides = kwargs.copy()\n\n        if socket_configs:\n\n            config_overrides['sockets'] = socket_configs\n\n\n"
      },
      {
        "file": "src\\interfaces\\network\\udp_interface.py",
        "line": 380,
        "pattern": "return self._clients.copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "\n\n    def get_connected_clients(self) -> Dict[Tuple[str, int], Dict[str, Any]]:\n\n        \"\"\"Get list of connected clients.\"\"\"\n\n        return self._clients.copy()\n\n\n\n\n\nclass UDPClient(UDPInterface):\n"
      },
      {
        "file": "src\\interfaces\\network\\websocket_interface.py",
        "line": 172,
        "pattern": "*[client.send(message_json) for client in self._clients.copy()],",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                # Server mode - broadcast to all clients\n\n                if self._clients:\n\n                    await asyncio.gather(\n\n                        *[client.send(message_json) for client in self._clients.copy()],\n\n                        return_exceptions=True\n\n                    )\n\n            else:\n"
      },
      {
        "file": "src\\interfaces\\network\\websocket_interface.py",
        "line": 464,
        "pattern": "return self._clients.copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "\n\n    def get_connected_clients(self) -> Set[websockets.WebSocketServerProtocol]:\n\n        \"\"\"Get set of connected clients.\"\"\"\n\n        return self._clients.copy()\n\n\n\n    async def broadcast(self, data: Any, metadata: Optional[MessageMetadata] = None) -> int:\n\n        \"\"\"Broadcast message to all connected clients.\"\"\"\n"
      },
      {
        "file": "src\\interfaces\\network\\websocket_interface.py",
        "line": 472,
        "pattern": "for client in self._clients.copy():",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            return 0\n\n\n\n        success_count = 0\n\n        for client in self._clients.copy():\n\n            if await self.send_to_client(client, data, metadata):\n\n                success_count += 1\n\n\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\differential.py",
        "line": 155,
        "pattern": "population=self.population.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            if self.convergence_monitor:\n\n                self.convergence_monitor.update(\n\n                    iteration, self.best_fitness, self.best_individual,\n\n                    population=self.population.copy(),\n\n                    fitness=self.fitness.copy()\n\n                )\n\n                converged, status, message = self.convergence_monitor.check_convergence()\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\differential.py",
        "line": 156,
        "pattern": "fitness=self.fitness.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                self.convergence_monitor.update(\n\n                    iteration, self.best_fitness, self.best_individual,\n\n                    population=self.population.copy(),\n\n                    fitness=self.fitness.copy()\n\n                )\n\n                converged, status, message = self.convergence_monitor.check_convergence()\n\n            else:\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\differential.py",
        "line": 174,
        "pattern": "population=self.population.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            if self._callback:\n\n                self._callback(\n\n                    iteration, self.best_fitness, self.best_individual,\n\n                    population=self.population.copy(),\n\n                    fitness=self.fitness.copy()\n\n                )\n\n\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\differential.py",
        "line": 175,
        "pattern": "fitness=self.fitness.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                self._callback(\n\n                    iteration, self.best_fitness, self.best_individual,\n\n                    population=self.population.copy(),\n\n                    fitness=self.fitness.copy()\n\n                )\n\n\n\n            # Verbose output\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\differential.py",
        "line": 192,
        "pattern": "x=self.best_individual.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n        # Create result\n\n        result = OptimizationResult(\n\n            x=self.best_individual.copy(),\n\n            fun=self.best_fitness,\n\n            success=converged or status == ConvergenceStatus.MAX_ITERATIONS,\n\n            status=status,\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\differential.py",
        "line": 199,
        "pattern": "fitness_history=self.fitness_history.copy(),",
        "category": "NECESSARY",
        "reason": "History list copy for result isolation",
        "confidence": 0.9,
        "context": "            message=message,\n\n            nit=self.iteration_count + 1,\n\n            nfev=(self.iteration_count + 1) * self.population_size,\n\n            fitness_history=self.fitness_history.copy(),\n\n            final_population=self.population.copy(),\n\n            final_fitness=self.fitness.copy()\n\n        )\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\differential.py",
        "line": 200,
        "pattern": "final_population=self.population.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            nit=self.iteration_count + 1,\n\n            nfev=(self.iteration_count + 1) * self.population_size,\n\n            fitness_history=self.fitness_history.copy(),\n\n            final_population=self.population.copy(),\n\n            final_fitness=self.fitness.copy()\n\n        )\n\n\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\differential.py",
        "line": 201,
        "pattern": "final_fitness=self.fitness.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            nfev=(self.iteration_count + 1) * self.population_size,\n\n            fitness_history=self.fitness_history.copy(),\n\n            final_population=self.population.copy(),\n\n            final_fitness=self.fitness.copy()\n\n        )\n\n\n\n        return result\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\differential.py",
        "line": 267,
        "pattern": "trial = target.copy()",
        "category": "NECESSARY",
        "reason": "Crossover operation (mutation follows)",
        "confidence": 1.0,
        "context": "\n\n    def _crossover(self, target: np.ndarray, mutant: np.ndarray, rng: np.random.Generator) -> np.ndarray:\n\n        \"\"\"Apply binomial crossover.\"\"\"\n\n        trial = target.copy()\n\n\n\n        # Ensure at least one parameter comes from mutant\n\n        j_rand = rng.integers(0, len(target))\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\differential.py",
        "line": 295,
        "pattern": "self.best_individual = self.population[self.best_index].copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        \"\"\"Update best individual and fitness.\"\"\"\n\n        self.best_index = np.argmin(self.fitness)\n\n        self.best_fitness = self.fitness[self.best_index]\n\n        self.best_individual = self.population[self.best_index].copy()\n\n\n\n    def _adapt_parameters(self, iteration: int, max_iterations: int) -> None:\n\n        \"\"\"Adapt F and CR parameters during evolution.\"\"\"\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\differential.py",
        "line": 313,
        "pattern": "penalized_fitness = fitness.copy()",
        "category": "NECESSARY",
        "reason": "Constraint penalty application (mutation follows)",
        "confidence": 0.95,
        "context": "                                  population: np.ndarray,\n\n                                  problem: OptimizationProblem) -> np.ndarray:\n\n        \"\"\"Apply constraint penalties to fitness values.\"\"\"\n\n        penalized_fitness = fitness.copy()\n\n\n\n        for i, individual in enumerate(population):\n\n            satisfied, violations = problem.check_constraints(individual)\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\differential.py",
        "line": 328,
        "pattern": "'best_individual': self.best_individual.copy() if self.best_individual is not None else None,",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        return {\n\n            'iteration': self.iteration_count,\n\n            'best_fitness': self.best_fitness,\n\n            'best_individual': self.best_individual.copy() if self.best_individual is not None else None,\n\n            'fitness_history': self.fitness_history.copy(),\n\n            'current_mutation_factor': self.mutation_factor,\n\n            'current_crossover_probability': self.crossover_probability,\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\differential.py",
        "line": 329,
        "pattern": "'fitness_history': self.fitness_history.copy(),",
        "category": "NECESSARY",
        "reason": "History list copy for result isolation",
        "confidence": 0.9,
        "context": "            'iteration': self.iteration_count,\n\n            'best_fitness': self.best_fitness,\n\n            'best_individual': self.best_individual.copy() if self.best_individual is not None else None,\n\n            'fitness_history': self.fitness_history.copy(),\n\n            'current_mutation_factor': self.mutation_factor,\n\n            'current_crossover_probability': self.crossover_probability,\n\n            'population_diversity': np.std(self.population, axis=0).mean() if self.population is not None else 0.0,\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\genetic.py",
        "line": 45,
        "pattern": "self.genes = genes.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    \"\"\"Individual in the genetic algorithm population.\"\"\"\n\n\n\n    def __init__(self, genes: np.ndarray, fitness: Optional[float] = None):\n\n        self.genes = genes.copy()\n\n        self.fitness = fitness\n\n        self.age = 0\n\n        self.id = np.random.randint(0, 1000000)\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\genetic.py",
        "line": 226,
        "pattern": "new_population.extend([ind.copy() for ind in elite_individuals])",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        # Elitism - preserve best individuals\n\n        elite_count = max(1, int(self.config.elite_ratio * self.config.population_size))\n\n        elite_individuals = self._select_elite(elite_count)\n\n        new_population.extend([ind.copy() for ind in elite_individuals])\n\n\n\n        # Generate offspring to fill remaining population\n\n        while len(new_population) < self.config.population_size:\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\genetic.py",
        "line": 238,
        "pattern": "child1, child2 = parent1.copy(), parent2.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            if np.random.random() < self.current_crossover_prob:\n\n                child1, child2 = self._crossover(parent1, parent2)\n\n            else:\n\n                child1, child2 = parent1.copy(), parent2.copy()\n\n\n\n            # Mutation\n\n            if np.random.random() < self.config.mutation_probability:\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\genetic.py",
        "line": 292,
        "pattern": "return np.random.choice(self.population).copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "            finite_mask = np.isfinite(fitnesses)\n\n            if not np.any(finite_mask):\n\n                # All infinite - random selection\n\n                return np.random.choice(self.population).copy()\n\n            fitnesses[~finite_mask] = np.max(fitnesses[finite_mask]) * 10\n\n\n\n        # Convert to probabilities (invert for minimization)\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\genetic.py",
        "line": 305,
        "pattern": "return self.population[selected_idx].copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "\n\n        probabilities = weights / np.sum(weights)\n\n        selected_idx = np.random.choice(len(self.population), p=probabilities)\n\n        return self.population[selected_idx].copy()\n\n\n\n    def _rank_selection(self) -> Individual:\n\n        \"\"\"Rank-based selection.\"\"\"\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\genetic.py",
        "line": 320,
        "pattern": "return self.population[selected_idx].copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "        # Selection probabilities based on ranks\n\n        probabilities = ranks / np.sum(ranks)\n\n        selected_idx = np.random.choice(len(self.population), p=probabilities)\n\n        return self.population[selected_idx].copy()\n\n\n\n    def _crossover(self, parent1: Individual, parent2: Individual) -> Tuple[Individual, Individual]:\n\n        \"\"\"Perform crossover between two parents.\"\"\"\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\genetic.py",
        "line": 385,
        "pattern": "mutated_genes = individual.genes.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n    def _gaussian_mutation(self, individual: Individual) -> Individual:\n\n        \"\"\"Gaussian mutation - add normally distributed noise.\"\"\"\n\n        mutated_genes = individual.genes.copy()\n\n\n\n        # Add Gaussian noise\n\n        noise = np.random.normal(0, self.current_mutation_strength, self.dimension)\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\genetic.py",
        "line": 400,
        "pattern": "mutated_genes = individual.genes.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n    def _uniform_mutation(self, individual: Individual) -> Individual:\n\n        \"\"\"Uniform mutation - replace with random value in range.\"\"\"\n\n        mutated_genes = individual.genes.copy()\n\n\n\n        # Randomly select genes to mutate\n\n        mutation_mask = np.random.random(self.dimension) < 0.1  # 10% of genes\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\genetic.py",
        "line": 415,
        "pattern": "mutated_genes = individual.genes.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def _polynomial_mutation(self, individual: Individual) -> Individual:\n\n        \"\"\"Polynomial mutation.\"\"\"\n\n        eta = 20.0  # Distribution index\n\n        mutated_genes = individual.genes.copy()\n\n\n\n        for i in range(self.dimension):\n\n            if np.random.random() < (1.0 / self.dimension):\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\genetic.py",
        "line": 464,
        "pattern": "self.best_individual = current_best.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n        if (self.best_individual is None or\n\n            (current_best.fitness or float('inf')) < (self.best_individual.fitness or float('inf'))):\n\n            self.best_individual = current_best.copy()\n\n            self.stagnation_counter = 0\n\n        else:\n\n            self.stagnation_counter += 1\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\genetic.py",
        "line": 521,
        "pattern": "best_parameters=self.best_individual.genes.copy() if self.best_individual else np.array([]),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def _create_result(self) -> OptimizationResult:\n\n        \"\"\"Create optimization result.\"\"\"\n\n        return OptimizationResult(\n\n            best_parameters=self.best_individual.genes.copy() if self.best_individual else np.array([]),\n\n            best_value=self.best_individual.fitness if self.best_individual else float('inf'),\n\n            n_evaluations=len(self.fitness_history) * self.config.population_size,\n\n            convergence_history=self.fitness_history.copy(),\n"
      },
      {
        "file": "src\\optimization\\algorithms\\evolutionary\\genetic.py",
        "line": 524,
        "pattern": "convergence_history=self.fitness_history.copy(),",
        "category": "NECESSARY",
        "reason": "History list copy for result isolation",
        "confidence": 0.9,
        "context": "            best_parameters=self.best_individual.genes.copy() if self.best_individual else np.array([]),\n\n            best_value=self.best_individual.fitness if self.best_individual else float('inf'),\n\n            n_evaluations=len(self.fitness_history) * self.config.population_size,\n\n            convergence_history=self.fitness_history.copy(),\n\n            success=self.best_individual is not None and np.isfinite(self.best_individual.fitness),\n\n            algorithm_info={\n\n                'algorithm': 'GeneticAlgorithm',\n"
      },
      {
        "file": "src\\optimization\\algorithms\\gradient_based\\bfgs.py",
        "line": 194,
        "pattern": "x_plus = x.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        if self.config.gradient_method == 'forward':\n\n            f_x = self._safe_evaluate(x)\n\n            for i in range(self.dimension):\n\n                x_plus = x.copy()\n\n                x_plus[i] = min(x_plus[i] + epsilon, self.parameter_space.upper_bounds[i])\n\n                f_plus = self._safe_evaluate(x_plus)\n\n                gradient[i] = (f_plus - f_x) / (x_plus[i] - x[i])\n"
      },
      {
        "file": "src\\optimization\\algorithms\\gradient_based\\bfgs.py",
        "line": 202,
        "pattern": "x_minus = x.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        elif self.config.gradient_method == 'backward':\n\n            f_x = self._safe_evaluate(x)\n\n            for i in range(self.dimension):\n\n                x_minus = x.copy()\n\n                x_minus[i] = max(x_minus[i] - epsilon, self.parameter_space.lower_bounds[i])\n\n                f_minus = self._safe_evaluate(x_minus)\n\n                gradient[i] = (f_x - f_minus) / (x[i] - x_minus[i])\n"
      },
      {
        "file": "src\\optimization\\algorithms\\gradient_based\\bfgs.py",
        "line": 209,
        "pattern": "x_plus = x.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n        else:  # central differences (default)\n\n            for i in range(self.dimension):\n\n                x_plus = x.copy()\n\n                x_minus = x.copy()\n\n\n\n                h_plus = min(epsilon, self.parameter_space.upper_bounds[i] - x[i])\n"
      },
      {
        "file": "src\\optimization\\algorithms\\gradient_based\\bfgs.py",
        "line": 210,
        "pattern": "x_minus = x.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        else:  # central differences (default)\n\n            for i in range(self.dimension):\n\n                x_plus = x.copy()\n\n                x_minus = x.copy()\n\n\n\n                h_plus = min(epsilon, self.parameter_space.upper_bounds[i] - x[i])\n\n                h_minus = min(epsilon, x[i] - self.parameter_space.lower_bounds[i])\n"
      },
      {
        "file": "src\\optimization\\algorithms\\gradient_based\\bfgs.py",
        "line": 368,
        "pattern": "best_parameters=self.current_x.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            )\n\n\n\n        return OptimizationResult(\n\n            best_parameters=self.current_x.copy(),\n\n            best_value=self.current_f,\n\n            n_evaluations=self.n_evaluations,\n\n            convergence_history=self.convergence_history.copy(),\n"
      },
      {
        "file": "src\\optimization\\algorithms\\gradient_based\\bfgs.py",
        "line": 371,
        "pattern": "convergence_history=self.convergence_history.copy(),",
        "category": "NECESSARY",
        "reason": "History list copy for result isolation",
        "confidence": 0.9,
        "context": "            best_parameters=self.current_x.copy(),\n\n            best_value=self.current_f,\n\n            n_evaluations=self.n_evaluations,\n\n            convergence_history=self.convergence_history.copy(),\n\n            success=(self.current_f is not None and\n\n                    np.isfinite(self.current_f) and\n\n                    np.linalg.norm(self.current_gradient) < self.config.gradient_tolerance),\n"
      },
      {
        "file": "src\\optimization\\algorithms\\gradient_based\\nelder_mead.py",
        "line": 209,
        "pattern": "vertices = [start_point.copy()]",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            )\n\n\n\n        # Create initial simplex vertices\n\n        vertices = [start_point.copy()]\n\n        step_size = self.config.initial_step_size\n\n\n\n        # Calculate appropriate step sizes for each dimension\n"
      },
      {
        "file": "src\\optimization\\algorithms\\gradient_based\\nelder_mead.py",
        "line": 218,
        "pattern": "new_vertex = start_point.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n        # Create n additional vertices by perturbing each dimension\n\n        for i in range(self.dimension):\n\n            new_vertex = start_point.copy()\n\n            perturbation = step_sizes[i]\n\n\n\n            # Try positive perturbation first\n"
      },
      {
        "file": "src\\optimization\\algorithms\\gradient_based\\nelder_mead.py",
        "line": 404,
        "pattern": "best_parameters=self.simplex.best_vertex.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            )\n\n\n\n        return OptimizationResult(\n\n            best_parameters=self.simplex.best_vertex.copy(),\n\n            best_value=self.simplex.best_value,\n\n            n_evaluations=self.n_evaluations,\n\n            convergence_history=self.convergence_history.copy(),\n"
      },
      {
        "file": "src\\optimization\\algorithms\\gradient_based\\nelder_mead.py",
        "line": 407,
        "pattern": "convergence_history=self.convergence_history.copy(),",
        "category": "NECESSARY",
        "reason": "History list copy for result isolation",
        "confidence": 0.9,
        "context": "            best_parameters=self.simplex.best_vertex.copy(),\n\n            best_value=self.simplex.best_value,\n\n            n_evaluations=self.n_evaluations,\n\n            convergence_history=self.convergence_history.copy(),\n\n            success=np.isfinite(self.simplex.best_value),\n\n            algorithm_info={\n\n                'algorithm': 'NelderMead',\n"
      },
      {
        "file": "src\\optimization\\algorithms\\gradient_based\\nelder_mead.py",
        "line": 467,
        "pattern": "best_vertex = self.simplex.best_vertex.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            return\n\n\n\n        # Keep best vertex, perturb others\n\n        best_vertex = self.simplex.best_vertex.copy()\n\n        ranges = self.parameter_space.upper_bounds - self.parameter_space.lower_bounds\n\n        perturbation = perturbation_factor * ranges\n\n\n"
      },
      {
        "file": "src\\optimization\\algorithms\\gradient_based\\nelder_mead.py",
        "line": 473,
        "pattern": "new_vertex = best_vertex.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n        new_vertices = [best_vertex]\n\n        for i in range(self.dimension):\n\n            new_vertex = best_vertex.copy()\n\n            new_vertex[i] += np.random.normal(0, perturbation[i])\n\n            new_vertex = self._apply_bounds(new_vertex)\n\n            new_vertices.append(new_vertex)\n"
      },
      {
        "file": "src\\optimization\\algorithms\\multi_objective_pso.py",
        "line": 69,
        "pattern": "'position': position.copy(),",
        "category": "NECESSARY",
        "reason": "Archive storage (prevents external mutation)",
        "confidence": 0.95,
        "context": "        \"\"\"Add a solution to the archive if it's non-dominated.\"\"\"\n\n        with self._lock:\n\n            new_solution = {\n\n                'position': position.copy(),\n\n                'objectives': objectives.copy(),\n\n                'metadata': metadata or {}\n\n            }\n"
      },
      {
        "file": "src\\optimization\\algorithms\\multi_objective_pso.py",
        "line": 70,
        "pattern": "'objectives': objectives.copy(),",
        "category": "NECESSARY",
        "reason": "Archive storage (prevents external mutation)",
        "confidence": 0.95,
        "context": "        with self._lock:\n\n            new_solution = {\n\n                'position': position.copy(),\n\n                'objectives': objectives.copy(),\n\n                'metadata': metadata or {}\n\n            }\n\n\n"
      },
      {
        "file": "src\\optimization\\algorithms\\multi_objective_pso.py",
        "line": 143,
        "pattern": "return [sol.copy() for sol in self.solutions]",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "    def get_pareto_front(self) -> List[Dict[str, Any]]:\n\n        \"\"\"Get the current Pareto front.\"\"\"\n\n        with self._lock:\n\n            return [sol.copy() for sol in self.solutions]\n\n\n\n\n\nclass MultiObjectivePSO:\n"
      },
      {
        "file": "src\\optimization\\algorithms\\multi_objective_pso.py",
        "line": 169,
        "pattern": "self.personal_best_positions = self.positions.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        self.velocities = np.zeros((self.n_particles, self.n_dimensions))\n\n\n\n        # Personal best tracking\n\n        self.personal_best_positions = self.positions.copy()\n\n        self.personal_best_objectives = None\n\n\n\n        # Archive for Pareto solutions\n"
      },
      {
        "file": "src\\optimization\\algorithms\\multi_objective_pso.py",
        "line": 212,
        "pattern": "self.personal_best_objectives = objectives.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n        # Evaluate initial population\n\n        objectives = self._evaluate_population(objective_functions, self.positions)\n\n        self.personal_best_objectives = objectives.copy()\n\n\n\n        # Initialize archive with initial population\n\n        for i in range(self.n_particles):\n"
      },
      {
        "file": "src\\optimization\\algorithms\\multi_objective_pso.py",
        "line": 368,
        "pattern": "self.personal_best_positions[i] = self.positions[i].copy()",
        "category": "NECESSARY",
        "reason": "PSO personal best tracking (independent from current position)",
        "confidence": 1.0,
        "context": "            # Check if new solution dominates personal best\n\n            if (self.personal_best_objectives is None or\n\n                self._dominates(new_objectives[i], self.personal_best_objectives[i])):\n\n                self.personal_best_positions[i] = self.positions[i].copy()\n\n                self.personal_best_objectives[i] = new_objectives[i].copy()\n\n\n\n            # Add to archive\n"
      },
      {
        "file": "src\\optimization\\algorithms\\multi_objective_pso.py",
        "line": 369,
        "pattern": "self.personal_best_objectives[i] = new_objectives[i].copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            if (self.personal_best_objectives is None or\n\n                self._dominates(new_objectives[i], self.personal_best_objectives[i])):\n\n                self.personal_best_positions[i] = self.positions[i].copy()\n\n                self.personal_best_objectives[i] = new_objectives[i].copy()\n\n\n\n            # Add to archive\n\n            self.archive.add_solution(self.positions[i], new_objectives[i])\n"
      },
      {
        "file": "src\\optimization\\algorithms\\pso_optimizer.py",
        "line": 364,
        "pattern": "perturbed_params = base_params.copy()",
        "category": "NECESSARY",
        "reason": "Parameter perturbation (mutation follows)",
        "confidence": 0.95,
        "context": "        base_params = self.physics_cfg.model_dump()\n\n        pu = self.uncertainty_cfg.model_dump()\n\n        for _ in range(self.uncertainty_cfg.n_evals - 1):\n\n            perturbed_params = base_params.copy()\n\n            for key, pct in pu.items():\n\n                if key == \"n_evals\" or pct is None or key not in perturbed_params:\n\n                    continue\n"
      },
      {
        "file": "src\\optimization\\algorithms\\pso_optimizer.py",
        "line": 380,
        "pattern": "dipparams_dict = perturbed_params.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                if perturbed_params[\"pendulum2_com\"] >= perturbed_params[\"pendulum2_length\"]:\n\n                    perturbed_params[\"pendulum2_com\"] = 0.99 * perturbed_params[\"pendulum2_length\"]\n\n            # Handle field mapping for DIPParams\n\n            dipparams_dict = perturbed_params.copy()\n\n            if 'regularization' in dipparams_dict:\n\n                reg = dipparams_dict.pop('regularization')\n\n                dipparams_dict.setdefault('min_regularization', reg)\n"
      },
      {
        "file": "src\\optimization\\algorithms\\pso_optimizer.py",
        "line": 866,
        "pattern": "pos_hist.append(np.asarray(step_pos, dtype=float).copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                # Execute a single PSO step; returns current best cost and position\n\n                step_cost, step_pos = optimizer.step(self._fitness)\n\n                cost_hist.append(float(step_cost))\n\n                pos_hist.append(np.asarray(step_pos, dtype=float).copy())\n\n            # Retrieve final global best values from the swarm\n\n            try:\n\n                final_cost = float(optimizer.swarm.best_cost)\n"
      },
      {
        "file": "src\\optimization\\algorithms\\pso_optimizer.py",
        "line": 870,
        "pattern": "final_pos = np.asarray(optimizer.swarm.best_pos, dtype=float).copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            # Retrieve final global best values from the swarm\n\n            try:\n\n                final_cost = float(optimizer.swarm.best_cost)\n\n                final_pos = np.asarray(optimizer.swarm.best_pos, dtype=float).copy()\n\n            except Exception:\n\n                # Fallback to the last recorded values\n\n                final_cost = float(cost_hist[-1])\n"
      },
      {
        "file": "src\\optimization\\algorithms\\swarm\\pso.py",
        "line": 173,
        "pattern": "diversity=diversity, positions=self.positions.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            if self.convergence_monitor:\n\n                self.convergence_monitor.update(\n\n                    iteration, self.global_best_fitness, self.global_best_position,\n\n                    diversity=diversity, positions=self.positions.copy()\n\n                )\n\n                converged, status, message = self.convergence_monitor.check_convergence()\n\n            else:\n"
      },
      {
        "file": "src\\optimization\\algorithms\\swarm\\pso.py",
        "line": 191,
        "pattern": "swarm_positions=self.positions.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            if self._callback:\n\n                self._callback(\n\n                    iteration, self.global_best_fitness, self.global_best_position,\n\n                    swarm_positions=self.positions.copy(),\n\n                    swarm_fitness=fitness.copy(),\n\n                    diversity=diversity\n\n                )\n"
      },
      {
        "file": "src\\optimization\\algorithms\\swarm\\pso.py",
        "line": 192,
        "pattern": "swarm_fitness=fitness.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                self._callback(\n\n                    iteration, self.global_best_fitness, self.global_best_position,\n\n                    swarm_positions=self.positions.copy(),\n\n                    swarm_fitness=fitness.copy(),\n\n                    diversity=diversity\n\n                )\n\n\n"
      },
      {
        "file": "src\\optimization\\algorithms\\swarm\\pso.py",
        "line": 211,
        "pattern": "x=self.global_best_position.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n        # Create result\n\n        result = OptimizationResult(\n\n            x=self.global_best_position.copy(),\n\n            fun=self.global_best_fitness,\n\n            success=converged or status == ConvergenceStatus.MAX_ITERATIONS,\n\n            status=status,\n"
      },
      {
        "file": "src\\optimization\\algorithms\\swarm\\pso.py",
        "line": 218,
        "pattern": "fitness_history=self.fitness_history.copy(),",
        "category": "NECESSARY",
        "reason": "History list copy for result isolation",
        "confidence": 0.9,
        "context": "            message=message,\n\n            nit=self.iteration_count + 1,\n\n            nfev=(self.iteration_count + 1) * self.population_size,\n\n            fitness_history=self.fitness_history.copy(),\n\n            diversity_history=self.diversity_history.copy(),\n\n            final_positions=self.positions.copy(),\n\n            final_fitness=fitness.copy()\n"
      },
      {
        "file": "src\\optimization\\algorithms\\swarm\\pso.py",
        "line": 219,
        "pattern": "diversity_history=self.diversity_history.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            nit=self.iteration_count + 1,\n\n            nfev=(self.iteration_count + 1) * self.population_size,\n\n            fitness_history=self.fitness_history.copy(),\n\n            diversity_history=self.diversity_history.copy(),\n\n            final_positions=self.positions.copy(),\n\n            final_fitness=fitness.copy()\n\n        )\n"
      },
      {
        "file": "src\\optimization\\algorithms\\swarm\\pso.py",
        "line": 220,
        "pattern": "final_positions=self.positions.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            nfev=(self.iteration_count + 1) * self.population_size,\n\n            fitness_history=self.fitness_history.copy(),\n\n            diversity_history=self.diversity_history.copy(),\n\n            final_positions=self.positions.copy(),\n\n            final_fitness=fitness.copy()\n\n        )\n\n\n"
      },
      {
        "file": "src\\optimization\\algorithms\\swarm\\pso.py",
        "line": 221,
        "pattern": "final_fitness=fitness.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            fitness_history=self.fitness_history.copy(),\n\n            diversity_history=self.diversity_history.copy(),\n\n            final_positions=self.positions.copy(),\n\n            final_fitness=fitness.copy()\n\n        )\n\n\n\n        return result\n"
      },
      {
        "file": "src\\optimization\\algorithms\\swarm\\pso.py",
        "line": 240,
        "pattern": "self.personal_best_positions = self.positions.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        )\n\n\n\n        # Initialize personal bests\n\n        self.personal_best_positions = self.positions.copy()\n\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n\n\n\n        # Initialize global best\n"
      },
      {
        "file": "src\\optimization\\algorithms\\swarm\\pso.py",
        "line": 303,
        "pattern": "self.global_best_position = self.personal_best_positions[best_idx].copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n        if best_fitness < self.global_best_fitness:\n\n            self.global_best_fitness = best_fitness\n\n            self.global_best_position = self.personal_best_positions[best_idx].copy()\n\n\n\n    def _update_adaptive_parameters(self, iteration: int, max_iterations: int) -> None:\n\n        \"\"\"Update PSO parameters adaptively.\"\"\"\n"
      },
      {
        "file": "src\\optimization\\algorithms\\swarm\\pso.py",
        "line": 337,
        "pattern": "penalized_fitness = fitness.copy()",
        "category": "NECESSARY",
        "reason": "Constraint penalty application (mutation follows)",
        "confidence": 0.95,
        "context": "                                  fitness: np.ndarray,\n\n                                  problem: OptimizationProblem) -> np.ndarray:\n\n        \"\"\"Apply constraint penalties to fitness values.\"\"\"\n\n        penalized_fitness = fitness.copy()\n\n\n\n        for i, position in enumerate(self.positions):\n\n            satisfied, violations = problem.check_constraints(position)\n"
      },
      {
        "file": "src\\optimization\\algorithms\\swarm\\pso.py",
        "line": 353,
        "pattern": "'global_best_position': self.global_best_position.copy() if self.global_best_position is not None else None,",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        return {\n\n            'iteration': self.iteration_count,\n\n            'global_best_fitness': self.global_best_fitness,\n\n            'global_best_position': self.global_best_position.copy() if self.global_best_position is not None else None,\n\n            'diversity': self.diversity_history[-1] if self.diversity_history else 0.0,\n\n            'fitness_history': self.fitness_history.copy(),\n\n            'diversity_history': self.diversity_history.copy(),\n"
      },
      {
        "file": "src\\optimization\\algorithms\\swarm\\pso.py",
        "line": 355,
        "pattern": "'fitness_history': self.fitness_history.copy(),",
        "category": "NECESSARY",
        "reason": "History list copy for result isolation",
        "confidence": 0.9,
        "context": "            'global_best_fitness': self.global_best_fitness,\n\n            'global_best_position': self.global_best_position.copy() if self.global_best_position is not None else None,\n\n            'diversity': self.diversity_history[-1] if self.diversity_history else 0.0,\n\n            'fitness_history': self.fitness_history.copy(),\n\n            'diversity_history': self.diversity_history.copy(),\n\n            'current_inertia': self.inertia_weight,\n\n            'current_cognitive': self.cognitive_weight,\n"
      },
      {
        "file": "src\\optimization\\algorithms\\swarm\\pso.py",
        "line": 356,
        "pattern": "'diversity_history': self.diversity_history.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            'global_best_position': self.global_best_position.copy() if self.global_best_position is not None else None,\n\n            'diversity': self.diversity_history[-1] if self.diversity_history else 0.0,\n\n            'fitness_history': self.fitness_history.copy(),\n\n            'diversity_history': self.diversity_history.copy(),\n\n            'current_inertia': self.inertia_weight,\n\n            'current_cognitive': self.cognitive_weight,\n\n            'current_social': self.social_weight,\n"
      },
      {
        "file": "src\\optimization\\core\\context.py",
        "line": 84,
        "pattern": "'parameters': parameters.copy(),",
        "category": "NECESSARY",
        "reason": "Storing in history/list (copy prevents aliasing)",
        "confidence": 0.95,
        "context": "            self.iteration_data.append({\n\n                'iteration': iteration,\n\n                'best_value': best_value,\n\n                'parameters': parameters.copy(),\n\n                **cb_kwargs\n\n            })\n\n\n"
      },
      {
        "file": "src\\optimization\\core\\parameters.py",
        "line": 303,
        "pattern": "clipped = parameters.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def clip(self, parameters: np.ndarray) -> np.ndarray:\n\n        \"\"\"Clip mixed parameters.\"\"\"\n\n        parameters = np.atleast_2d(parameters)\n\n        clipped = parameters.copy()\n\n\n\n        for i, param in enumerate(self.parameters):\n\n            clipped[:, i] = param.clip(parameters[:, i])\n"
      },
      {
        "file": "src\\optimization\\integration\\pso_factory_bridge.py",
        "line": 263,
        "pattern": "state = scenario['initial_state'].copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        steps = int(sim_time / dt)\n\n\n\n        # Initialize state\n\n        state = scenario['initial_state'].copy()\n\n\n\n        # Cost accumulators\n\n        position_error_cost = 0.0\n"
      },
      {
        "file": "src\\optimization\\integration\\pso_factory_bridge.py",
        "line": 370,
        "pattern": "'optimization_stats': self.validation_stats.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                'controller': final_controller,\n\n                'convergence_history': result.get('history', {}),\n\n                'controller_type': self.config.controller_type.value,\n\n                'optimization_stats': self.validation_stats.copy(),\n\n                'performance_analysis': self._analyze_optimization_performance(result),\n\n                'validation_results': self._validate_optimized_controller(final_controller, optimized_gains)\n\n            }\n"
      },
      {
        "file": "src\\optimization\\integration\\pso_factory_bridge.py",
        "line": 388,
        "pattern": "'optimization_stats': self.validation_stats.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                'success': False,\n\n                'error': str(e),\n\n                'controller_type': self.config.controller_type.value,\n\n                'optimization_stats': self.validation_stats.copy()\n\n            }\n\n\n\n    def _analyze_optimization_performance(self, pso_result: Dict[str, Any]) -> Dict[str, Any]:\n"
      },
      {
        "file": "src\\optimization\\objectives\\multi\\pareto.py",
        "line": 113,
        "pattern": "'parameters': current_parameters.copy() if len(current_parameters) > 0 else None,",
        "category": "NECESSARY",
        "reason": "Storing in history/list (copy prevents aliasing)",
        "confidence": 0.95,
        "context": "        # Store current solution\n\n        current_parameters = kwargs.get('controller_parameters', np.array([]))\n\n        self._evaluation_history.append({\n\n            'parameters': current_parameters.copy() if len(current_parameters) > 0 else None,\n\n            'objectives': objective_values.copy(),\n\n            'timestamp': len(self._evaluation_history)\n\n        })\n"
      },
      {
        "file": "src\\optimization\\objectives\\multi\\pareto.py",
        "line": 114,
        "pattern": "'objectives': objective_values.copy(),",
        "category": "NECESSARY",
        "reason": "Storing in history/list (copy prevents aliasing)",
        "confidence": 0.95,
        "context": "        current_parameters = kwargs.get('controller_parameters', np.array([]))\n\n        self._evaluation_history.append({\n\n            'parameters': current_parameters.copy() if len(current_parameters) > 0 else None,\n\n            'objectives': objective_values.copy(),\n\n            'timestamp': len(self._evaluation_history)\n\n        })\n\n\n"
      },
      {
        "file": "src\\optimization\\objectives\\multi\\pareto.py",
        "line": 155,
        "pattern": "self._pareto_solutions.append(parameters.copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                del self._pareto_objectives[idx]\n\n\n\n            # Add new solution\n\n            self._pareto_solutions.append(parameters.copy())\n\n            self._pareto_objectives.append(objectives.copy())\n\n\n\n    def _check_dominance(self, obj1: np.ndarray, obj2: np.ndarray) -> int:\n"
      },
      {
        "file": "src\\optimization\\objectives\\multi\\pareto.py",
        "line": 156,
        "pattern": "self._pareto_objectives.append(objectives.copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n            # Add new solution\n\n            self._pareto_solutions.append(parameters.copy())\n\n            self._pareto_objectives.append(objectives.copy())\n\n\n\n    def _check_dominance(self, obj1: np.ndarray, obj2: np.ndarray) -> int:\n\n        \"\"\"Check dominance relationship between two objective vectors.\n"
      },
      {
        "file": "src\\optimization\\objectives\\multi\\pareto.py",
        "line": 212,
        "pattern": "'mins': objective_values.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        elif self.normalization == 'min_max':\n\n            if self._normalization_bounds is None:\n\n                self._normalization_bounds = {\n\n                    'mins': objective_values.copy(),\n\n                    'maxs': objective_values.copy()\n\n                }\n\n            else:\n"
      },
      {
        "file": "src\\optimization\\objectives\\multi\\pareto.py",
        "line": 213,
        "pattern": "'maxs': objective_values.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            if self._normalization_bounds is None:\n\n                self._normalization_bounds = {\n\n                    'mins': objective_values.copy(),\n\n                    'maxs': objective_values.copy()\n\n                }\n\n            else:\n\n                self._normalization_bounds['mins'] = np.minimum(\n"
      },
      {
        "file": "src\\optimization\\objectives\\multi\\pareto.py",
        "line": 346,
        "pattern": "'solutions': [sol.copy() for sol in self._pareto_solutions],",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            Pareto frontier data including solutions and objectives\n\n        \"\"\"\n\n        return {\n\n            'solutions': [sol.copy() for sol in self._pareto_solutions],\n\n            'objectives': [obj.copy() for obj in self._pareto_objectives],\n\n            'n_solutions': len(self._pareto_solutions),\n\n            'frontier_metrics': self._compute_frontier_metrics()\n"
      },
      {
        "file": "src\\optimization\\objectives\\multi\\pareto.py",
        "line": 347,
        "pattern": "'objectives': [obj.copy() for obj in self._pareto_objectives],",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        \"\"\"\n\n        return {\n\n            'solutions': [sol.copy() for sol in self._pareto_solutions],\n\n            'objectives': [obj.copy() for obj in self._pareto_objectives],\n\n            'n_solutions': len(self._pareto_solutions),\n\n            'frontier_metrics': self._compute_frontier_metrics()\n\n        }\n"
      },
      {
        "file": "src\\optimization\\objectives\\multi\\weighted_sum.py",
        "line": 121,
        "pattern": "self._evaluation_history.append(objective_values.copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n        # Store for adaptive normalization\n\n        if self.normalization == 'adaptive':\n\n            self._evaluation_history.append(objective_values.copy())\n\n            if len(self._evaluation_history) > 1000:  # Limit history size\n\n                self._evaluation_history = self._evaluation_history[-1000:]\n\n\n"
      },
      {
        "file": "src\\optimization\\objectives\\multi\\weighted_sum.py",
        "line": 162,
        "pattern": "self._min_values = objective_values.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        elif self.normalization == 'min_max':\n\n            # Update min/max values\n\n            if self._min_values is None:\n\n                self._min_values = objective_values.copy()\n\n                self._max_values = objective_values.copy()\n\n            else:\n\n                self._min_values = np.minimum(self._min_values, objective_values)\n"
      },
      {
        "file": "src\\optimization\\objectives\\multi\\weighted_sum.py",
        "line": 163,
        "pattern": "self._max_values = objective_values.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            # Update min/max values\n\n            if self._min_values is None:\n\n                self._min_values = objective_values.copy()\n\n                self._max_values = objective_values.copy()\n\n            else:\n\n                self._min_values = np.minimum(self._min_values, objective_values)\n\n                self._max_values = np.maximum(self._max_values, objective_values)\n"
      },
      {
        "file": "src\\optimization\\objectives\\multi\\weighted_sum.py",
        "line": 339,
        "pattern": "original_weights = self.weights.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        dict\n\n            Sensitivity analysis results\n\n        \"\"\"\n\n        original_weights = self.weights.copy()\n\n        sensitivity_results = []\n\n\n\n        try:\n"
      },
      {
        "file": "src\\optimization\\objectives\\multi\\weighted_sum.py",
        "line": 412,
        "pattern": "self._weight_history = [self.weights.copy()]",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        \"\"\"\n\n        super().__init__(*args, **kwargs)\n\n        self.adaptation_rate = adaptation_rate\n\n        self._weight_history = [self.weights.copy()]\n\n        self._performance_history = []\n\n\n\n    def _compute_objective_from_simulation(self,\n"
      },
      {
        "file": "src\\optimization\\objectives\\multi\\weighted_sum.py",
        "line": 470,
        "pattern": "self._weight_history.append(self.weights.copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n        # Normalize\n\n        self.weights = new_weights / np.sum(new_weights)\n\n        self._weight_history.append(self.weights.copy())\n\n\n\n    def get_adaptation_info(self) -> Dict[str, Any]:\n\n        \"\"\"Get information about weight adaptation.\"\"\"\n"
      },
      {
        "file": "src\\optimization\\results\\convergence.py",
        "line": 73,
        "pattern": "self.history['parameters'].append(parameters.copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        # Store history\n\n        self.history['iteration'].append(iteration)\n\n        self.history['best_fitness'].append(best_value)\n\n        self.history['parameters'].append(parameters.copy())\n\n        self.history['improvement'].append(improvement)\n\n        self.history['stagnation_count'].append(self.stagnation_count)\n\n\n"
      },
      {
        "file": "src\\optimization\\results\\convergence.py",
        "line": 123,
        "pattern": "return self.history.copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "    @property\n\n    def convergence_history(self) -> Dict[str, List]:\n\n        \"\"\"Get convergence history data.\"\"\"\n\n        return self.history.copy()\n\n\n\n\n\nclass ConvergenceAnalyzer:\n"
      },
      {
        "file": "src\\optimization\\tuning\\pso_hyperparameter_optimizer.py",
        "line": 227,
        "pattern": "optimization_history=self.optimization_history.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            result = OptimizationResult(\n\n                optimized_parameters=optimized_params,\n\n                performance_metrics=validation_results['performance_metrics'],\n\n                optimization_history=self.optimization_history.copy(),\n\n                controller_type=controller_type,\n\n                optimization_time=optimization_time,\n\n                validation_results=validation_results,\n"
      },
      {
        "file": "src\\plant\\core\\state_validation.py",
        "line": 147,
        "pattern": "sanitized = state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        if not self._check_state_structure(state):\n\n            raise StateValidationError(\"Cannot sanitize: invalid state structure\")\n\n\n\n        sanitized = state.copy()\n\n        was_modified = False\n\n\n\n        # Handle numerical issues\n"
      },
      {
        "file": "src\\plant\\core\\state_validation.py",
        "line": 156,
        "pattern": "original_sanitized = sanitized.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            was_modified = True\n\n\n\n        # Apply physical bounds\n\n        original_sanitized = sanitized.copy()\n\n        sanitized = self._apply_physical_bounds(sanitized)\n\n        if not np.allclose(original_sanitized, sanitized):\n\n            was_modified = True\n"
      },
      {
        "file": "src\\plant\\core\\state_validation.py",
        "line": 163,
        "pattern": "original_angles = sanitized[[1, 2]].copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n        # Wrap angles if requested\n\n        if self.wrap_angles:\n\n            original_angles = sanitized[[1, 2]].copy()\n\n            sanitized[[1, 2]] = self._wrap_angles(sanitized[[1, 2]])\n\n            if not np.allclose(original_angles, sanitized[[1, 2]]):\n\n                was_modified = True\n"
      },
      {
        "file": "src\\plant\\core\\state_validation.py",
        "line": 274,
        "pattern": "fixed = state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n    def _fix_numerical_issues(self, state: np.ndarray) -> np.ndarray:\n\n        \"\"\"Fix numerical issues in state vector.\"\"\"\n\n        fixed = state.copy()\n\n\n\n        # Replace NaN with zeros\n\n        nan_mask = np.isnan(fixed)\n"
      },
      {
        "file": "src\\plant\\core\\state_validation.py",
        "line": 294,
        "pattern": "bounded = state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n    def _apply_physical_bounds(self, state: np.ndarray) -> np.ndarray:\n\n        \"\"\"Apply physical bounds to state vector.\"\"\"\n\n        bounded = state.copy()\n\n\n\n        x, theta1, theta2, x_dot, theta1_dot, theta2_dot = bounded\n\n\n"
      },
      {
        "file": "src\\plant\\core\\state_validation.py",
        "line": 363,
        "pattern": "sanitized = state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n        # Only fix numerical issues\n\n        if not np.all(np.isfinite(state)):\n\n            sanitized = state.copy()\n\n            sanitized[~np.isfinite(sanitized)] = 0.0\n\n            return sanitized\n\n\n"
      },
      {
        "file": "src\\plant\\models\\full\\config.py",
        "line": 345,
        "pattern": "mapped_config = config_dict.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def from_dict(cls, config_dict: dict) -> 'FullDIPConfig':\n\n        \"\"\"Create configuration from dictionary with parameter mapping.\"\"\"\n\n        # Create a copy to avoid modifying the original\n\n        mapped_config = config_dict.copy()\n\n\n\n        # Handle parameter name mappings\n\n        parameter_mappings = {\n"
      },
      {
        "file": "src\\plant\\models\\full\\dynamics.py",
        "line": 169,
        "pattern": "wind_velocity=wind_velocity.copy() if wind_velocity is not None else None,",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                state=sanitized_state.copy(),\n\n                control_input=control_input.copy(),\n\n                time=time,\n\n                wind_velocity=wind_velocity.copy() if wind_velocity is not None else None,\n\n                **diagnostics\n\n            )\n\n\n"
      },
      {
        "file": "src\\plant\\models\\simplified\\dynamics.py",
        "line": 360,
        "pattern": "state_plus = eq_state.copy()",
        "category": "NECESSARY",
        "reason": "Numerical differentiation (element mutation follows)",
        "confidence": 1.0,
        "context": "        n = len(eq_state)\n\n        A = np.zeros((n, n))\n\n        for i in range(n):\n\n            state_plus = eq_state.copy()\n\n            state_plus[i] += eps\n\n\n\n            dynamics_plus = self.compute_dynamics(state_plus, eq_input)\n"
      },
      {
        "file": "src\\plant\\models\\simplified\\dynamics.py",
        "line": 373,
        "pattern": "input_plus = eq_input.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        m = len(eq_input)\n\n        B = np.zeros((n, m))\n\n        for j in range(m):\n\n            input_plus = eq_input.copy()\n\n            input_plus[j] += eps\n\n\n\n            dynamics_plus = self.compute_dynamics(eq_state, input_plus)\n"
      },
      {
        "file": "src\\simulation\\core\\state_space.py",
        "line": 193,
        "pattern": "x_plus = x_eq.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        # Compute A matrix (\u2202f/\u2202x)\n\n        A = np.zeros((n_states, n_states))\n\n        for i in range(n_states):\n\n            x_plus = x_eq.copy()\n\n            x_minus = x_eq.copy()\n\n            x_plus[i] += epsilon\n\n            x_minus[i] -= epsilon\n"
      },
      {
        "file": "src\\simulation\\core\\state_space.py",
        "line": 194,
        "pattern": "x_minus = x_eq.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        A = np.zeros((n_states, n_states))\n\n        for i in range(n_states):\n\n            x_plus = x_eq.copy()\n\n            x_minus = x_eq.copy()\n\n            x_plus[i] += epsilon\n\n            x_minus[i] -= epsilon\n\n\n"
      },
      {
        "file": "src\\simulation\\core\\state_space.py",
        "line": 206,
        "pattern": "u_plus = u_eq.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        # Compute B matrix (\u2202f/\u2202u)\n\n        B = np.zeros((n_states, n_controls))\n\n        for i in range(n_controls):\n\n            u_plus = u_eq.copy()\n\n            u_minus = u_eq.copy()\n\n            u_plus[i] += epsilon\n\n            u_minus[i] -= epsilon\n"
      },
      {
        "file": "src\\simulation\\core\\state_space.py",
        "line": 207,
        "pattern": "u_minus = u_eq.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        B = np.zeros((n_states, n_controls))\n\n        for i in range(n_controls):\n\n            u_plus = u_eq.copy()\n\n            u_minus = u_eq.copy()\n\n            u_plus[i] += epsilon\n\n            u_minus[i] -= epsilon\n\n\n"
      },
      {
        "file": "src\\simulation\\engines\\vector_sim.py",
        "line": 366,
        "pattern": "init_b = _np.broadcast_to(init, (B, init.shape[0])).copy()",
        "category": "NECESSARY",
        "reason": "broadcast_to returns read-only view, copy makes it writable",
        "confidence": 1.0,
        "context": "        if init.ndim == 1:\n\n            # broadcast across batch\n\n            # MEMORY OPTIMIZATION: Must copy broadcast_to result (returns view that needs writeable buffer)\n\n            init_b = _np.broadcast_to(init, (B, init.shape[0])).copy()\n\n        else:\n\n            # MEMORY OPTIMIZATION: Copy only when necessary (will be written to)\n\n            init_b = init.copy()\n"
      },
      {
        "file": "src\\simulation\\engines\\vector_sim.py",
        "line": 369,
        "pattern": "init_b = init.copy()",
        "category": "NECESSARY",
        "reason": "broadcast_to returns read-only view, copy makes it writable",
        "confidence": 1.0,
        "context": "            init_b = _np.broadcast_to(init, (B, init.shape[0])).copy()\n\n        else:\n\n            # MEMORY OPTIMIZATION: Copy only when necessary (will be written to)\n\n            init_b = init.copy()\n\n    # Preallocate outputs\n\n    t_arr = _np.zeros(H + 1, dtype=float)\n\n    x_b = _np.zeros((B, H + 1, init_b.shape[1]), dtype=float)\n"
      },
      {
        "file": "src\\simulation\\integrators\\base.py",
        "line": 71,
        "pattern": "return self._stats.copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "\n\n    def get_statistics(self) -> Dict[str, Any]:\n\n        \"\"\"Get integration statistics.\"\"\"\n\n        return self._stats.copy()\n\n\n\n    def integrate_step(self, dynamics_fn: Callable, state: np.ndarray, time: float, dt: float) -> np.ndarray:\n\n        \"\"\"\n"
      },
      {
        "file": "src\\simulation\\orchestrators\\base.py",
        "line": 141,
        "pattern": "return self._execution_stats.copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "\n\n    def get_execution_statistics(self) -> Dict[str, Any]:\n\n        \"\"\"Get execution performance statistics.\"\"\"\n\n        return self._execution_stats.copy()\n\n\n\n    def reset_statistics(self) -> None:\n\n        \"\"\"Reset execution statistics.\"\"\"\n"
      },
      {
        "file": "src\\simulation\\orchestrators\\batch.py",
        "line": 83,
        "pattern": "current_states = initial_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n        # Track which simulations are still active\n\n        active_mask = np.ones(batch_size, dtype=bool)\n\n        current_states = initial_state.copy()\n\n\n\n        # Main simulation loop\n\n        for i in range(horizon):\n"
      },
      {
        "file": "src\\simulation\\orchestrators\\batch.py",
        "line": 115,
        "pattern": "next_states = current_states.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                            active_mask[b] = False\n\n\n\n            # Vectorized simulation step for active simulations\n\n            next_states = current_states.copy()\n\n\n\n            for b in range(batch_size):\n\n                if active_mask[b]:\n"
      },
      {
        "file": "src\\simulation\\orchestrators\\parallel.py",
        "line": 121,
        "pattern": "simulation_params.append((initial_state, controls, dt, horizon, kwargs.copy()))",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            else:\n\n                controls = control_inputs\n\n\n\n            simulation_params.append((initial_state, controls, dt, horizon, kwargs.copy()))\n\n\n\n        # Execute simulations in parallel\n\n        results = []\n"
      },
      {
        "file": "src\\simulation\\orchestrators\\real_time.py",
        "line": 95,
        "pattern": "current_state = initial_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        states[0] = initial_state\n\n\n\n        # Main real-time simulation loop\n\n        current_state = initial_state.copy()\n\n\n\n        for i in range(horizon):\n\n            # Start timing for this step\n"
      },
      {
        "file": "src\\simulation\\orchestrators\\sequential.py",
        "line": 77,
        "pattern": "current_state = initial_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            control_sequence = np.full(horizon, control_inputs.flat[0])\n\n\n\n        # Main simulation loop\n\n        current_state = initial_state.copy()\n\n        for i in range(horizon):\n\n            # Get control input\n\n            control = control_sequence[i]\n"
      },
      {
        "file": "src\\simulation\\orchestrators\\sequential.py",
        "line": 294,
        "pattern": "x_curr = x0.copy()",
        "category": "NECESSARY",
        "reason": "State variable may be mutated",
        "confidence": 0.7,
        "context": "    use_fallback = False\n\n\n\n    # Main simulation loop\n\n    x_curr = x0.copy()\n\n    for i in range(n_steps):\n\n        t_now = i * dt\n\n\n"
      },
      {
        "file": "src\\simulation\\results\\containers.py",
        "line": 27,
        "pattern": "self.states = states.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n    def add_trajectory(self, states: np.ndarray, times: np.ndarray, **metadata) -> None:\n\n        \"\"\"Add trajectory data to container.\"\"\"\n\n        self.states = states.copy()\n\n        self.times = times.copy()\n\n\n\n        # Store additional data in metadata\n"
      },
      {
        "file": "src\\simulation\\results\\containers.py",
        "line": 28,
        "pattern": "self.times = times.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def add_trajectory(self, states: np.ndarray, times: np.ndarray, **metadata) -> None:\n\n        \"\"\"Add trajectory data to container.\"\"\"\n\n        self.states = states.copy()\n\n        self.times = times.copy()\n\n\n\n        # Store additional data in metadata\n\n        for key, value in metadata.items():\n"
      },
      {
        "file": "src\\simulation\\results\\containers.py",
        "line": 72,
        "pattern": "'states': states.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        batch_index = metadata.get('batch_index', len(self.batch_data))\n\n\n\n        self.batch_data[batch_index] = {\n\n            'states': states.copy(),\n\n            'times': times.copy(),\n\n            'controls': metadata.get('controls', None),\n\n            'metadata': {k: v for k, v in metadata.items() if k not in ['batch_index', 'controls']}\n"
      },
      {
        "file": "src\\simulation\\results\\containers.py",
        "line": 73,
        "pattern": "'times': times.copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n        self.batch_data[batch_index] = {\n\n            'states': states.copy(),\n\n            'times': times.copy(),\n\n            'controls': metadata.get('controls', None),\n\n            'metadata': {k: v for k, v in metadata.items() if k not in ['batch_index', 'controls']}\n\n        }\n"
      },
      {
        "file": "src\\simulation\\safety\\monitors.py",
        "line": 122,
        "pattern": "self.state_history.append(state.copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def update(self, state: np.ndarray, control: float, metrics: Dict[str, float]) -> None:\n\n        \"\"\"Update system health with new data.\"\"\"\n\n        # Store state and control history\n\n        self.state_history.append(state.copy())\n\n        self.control_history.append(control)\n\n\n\n        # Maintain history length\n"
      },
      {
        "file": "src\\utils\\config_compatibility.py",
        "line": 84,
        "pattern": "return self._data.copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "\n\n    def to_dict(self) -> Dict[str, Any]:\n\n        \"\"\"Convert back to plain dictionary.\"\"\"\n\n        return self._data.copy()\n\n\n\n    def __repr__(self) -> str:\n\n        \"\"\"String representation.\"\"\"\n"
      },
      {
        "file": "src\\utils\\config_compatibility.py",
        "line": 201,
        "pattern": "enhanced_config = config_dict.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    config_dict = ensure_dict_access(physics_config)\n\n\n\n    # Handle parameter name mappings and add missing defaults\n\n    enhanced_config = config_dict.copy()\n\n\n\n    # Parameter name mappings\n\n    if 'regularization' in config_dict and 'regularization_alpha' not in config_dict:\n"
      },
      {
        "file": "src\\utils\\monitoring\\stability.py",
        "line": 80,
        "pattern": "self.sigma_history.append(sigma.copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        self.sample_count += 1\n\n\n\n        # Store sigma values\n\n        self.sigma_history.append(sigma.copy())\n\n\n\n        # Compute sigma_dot if we have previous sample\n\n        if len(self.sigma_history) >= 2:\n"
      },
      {
        "file": "src\\utils\\numerical_stability\\safe_operations.py",
        "line": 150,
        "pattern": "sign_den = np.atleast_1d(sign_den).copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    # Preserve sign: safe_divide(a, b) = a / (\u03b5 * sign(b)) if |b| < \u03b5\n\n    sign_den = np.sign(den_array)\n\n    # Handle sign(0) = 0 edge case (convert to array to support item assignment)\n\n    sign_den = np.atleast_1d(sign_den).copy()\n\n    sign_den[sign_den == 0] = 1.0\n\n\n\n    # Compute safe division (suppress numpy warnings since we handle them explicitly)\n"
      },
      {
        "file": "tests\\integration\\test_overshoot_comparison.py",
        "line": 92,
        "pattern": "state = initial_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            )\n\n\n\n            # Initialize simulation\n\n            state = initial_state.copy()\n\n            controller_state = controller.initialize_state()\n\n            history = controller.initialize_history()\n\n\n"
      },
      {
        "file": "tests\\integration\\test_pso_convergence_analysis.py",
        "line": 106,
        "pattern": "position_history=[pos.copy() for pos in position_history],",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                convergence_iterations=convergence_iterations,\n\n                optimization_time=optimization_time,\n\n                cost_history=list(cost_history),\n\n                position_history=[pos.copy() for pos in position_history],\n\n                final_gains=result['best_pos'].copy(),\n\n                convergence_rate=convergence_rate,\n\n                stability_achieved=stability_achieved\n"
      },
      {
        "file": "tests\\integration\\test_pso_convergence_analysis.py",
        "line": 107,
        "pattern": "final_gains=result['best_pos'].copy(),",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                optimization_time=optimization_time,\n\n                cost_history=list(cost_history),\n\n                position_history=[pos.copy() for pos in position_history],\n\n                final_gains=result['best_pos'].copy(),\n\n                convergence_rate=convergence_rate,\n\n                stability_achieved=stability_achieved\n\n            )\n"
      },
      {
        "file": "tests\\integration\\test_simulation_integration.py",
        "line": 87,
        "pattern": "states.append(state.copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    try:\n\n        while t < sim_time:\n\n            time_points.append(t)\n\n            states.append(state.copy())\n\n\n\n            # Compute control\n\n            try:\n"
      },
      {
        "file": "tests\\test_analysis\\infrastructure\\test_analysis_chain.py",
        "line": 269,
        "pattern": "next_state = state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        class SimpleDynamics:\n\n            def step(self, state: np.ndarray, u: float, dt: float) -> np.ndarray:\n\n                # Simplified dynamics for testing\n\n                next_state = state.copy()\n\n                next_state[0] += dt * state[1]\n\n                next_state[1] += dt * u\n\n                next_state[2] += dt * state[3]\n"
      },
      {
        "file": "tests\\test_analysis\\infrastructure\\test_analysis_chain.py",
        "line": 498,
        "pattern": "next_state = state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    class MockDynamics:\n\n        def step(self, state: np.ndarray, u: float, dt: float) -> np.ndarray:\n\n            # Simple integrator dynamics\n\n            next_state = state.copy()\n\n            next_state[0] += dt * state[1]\n\n            next_state[1] += dt * u\n\n            if len(state) > 2:\n"
      },
      {
        "file": "tests\\test_benchmarks\\core\\test_benchmark_interfaces.py",
        "line": 338,
        "pattern": "state = initial_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            dt = 0.01\n\n\n\n            # Run simulation loop\n\n            state = initial_state.copy()\n\n            controller_state = controller.initialize_state()\n\n            history = controller.initialize_history()\n\n\n"
      },
      {
        "file": "tests\\test_benchmarks\\core\\test_memory_usage.py",
        "line": 126,
        "pattern": "states = [base_state.copy() for _ in range(batch_size)]",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n    # Multiple calls with same state\n\n    for batch_size in [1, 10, 100]:\n\n        states = [base_state.copy() for _ in range(batch_size)]\n\n        results = []\n\n\n\n        for state in states:\n"
      },
      {
        "file": "tests\\test_benchmarks\\core\\test_memory_usage.py",
        "line": 159,
        "pattern": "initial_state_copy = state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    state = np.array([0.1, 0.2, 0.3, 0.05, 0.1, 0.15])\n\n\n\n    # Check that repeated calls don't accumulate objects\n\n    initial_state_copy = state.copy()\n\n\n\n    # Many calls with different states\n\n    for i in range(500):\n"
      },
      {
        "file": "tests\\test_benchmarks\\core\\test_memory_usage.py",
        "line": 193,
        "pattern": "initial_estimates = controller.uncertainty_estimator.current_estimates.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    # Adaptive controllers may grow parameters, but it should be bounded\n\n    initial_params = getattr(controller, 'parameters', None)\n\n    if hasattr(controller, 'uncertainty_estimator'):\n\n        initial_estimates = controller.uncertainty_estimator.current_estimates.copy()\n\n\n\n    # Run adaptation for many steps\n\n    for i in range(200):\n"
      },
      {
        "file": "tests\\test_benchmarks\\core\\test_memory_usage.py",
        "line": 232,
        "pattern": "history[f'step_{i}'] = {'state': state.copy(), 'time': i * 0.01}",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    # Build up history over many calls\n\n    for i in range(100):\n\n        # Add entries to history to test memory management\n\n        history[f'step_{i}'] = {'state': state.copy(), 'time': i * 0.01}\n\n\n\n        result = controller.compute_control(state, np.array([0.0]), history)\n\n        control = result.get('u', result.get('control'))\n"
      },
      {
        "file": "tests\\test_benchmarks\\integration\\test_benchmark_workflows.py",
        "line": 465,
        "pattern": "state = initial_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        dt = 0.01\n\n\n\n        # Run simulation\n\n        state = initial_state.copy()\n\n        controller_state = controller.initialize_state()\n\n        history = controller.initialize_history()\n\n\n"
      },
      {
        "file": "tests\\test_benchmarks\\performance\\test_performance_benchmarks_deep.py",
        "line": 290,
        "pattern": "states_history.append(state.copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            control = np.sin(i * 0.01)  # Time-varying control\n\n            state = benchmark_simulator.simulate_single_step(state, control)\n\n            if i % 100 == 0:  # Store every 100th state\n\n                states_history.append(state.copy())\n\n\n\n        # Check memory growth\n\n        peak_memory = process.memory_info().rss / 1024 / 1024\n"
      },
      {
        "file": "tests\\test_benchmarks\\performance\\test_regression_detection.py",
        "line": 510,
        "pattern": "state = initial_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        n_steps = int(sim_time / dt)\n\n\n\n        # Run simulation\n\n        state = initial_state.copy()\n\n        controller_state = controller.initialize_state()\n\n        history = controller.initialize_history()\n\n\n"
      },
      {
        "file": "tests\\test_benchmarks\\performance\\test_regression_detection.py",
        "line": 610,
        "pattern": "state = initial_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            dt = 0.01\n\n            n_steps = 200  # 2 seconds\n\n\n\n            state = initial_state.copy()\n\n            controller_state = controller.initialize_state()\n\n            history = controller.initialize_history()\n\n\n"
      },
      {
        "file": "tests\\test_benchmarks\\validation\\test_parameter_realism.py",
        "line": 662,
        "pattern": "bad_mass_params = valid_params.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        assert is_consistent, f\"Valid parameters should be consistent. Errors: {errors}\"\n\n\n\n        # Test inconsistent mass ratios\n\n        bad_mass_params = valid_params.copy()\n\n        bad_mass_params['pendulum1_mass'] = 5.0  # Much larger than cart\n\n\n\n        is_consistent, errors = parameter_validator.validate_physics_consistency(bad_mass_params)\n"
      },
      {
        "file": "tests\\test_benchmarks\\validation\\test_parameter_realism.py",
        "line": 670,
        "pattern": "bad_inertia_params = valid_params.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        assert any(\"mass ratio\" in error for error in errors), \"Should explain mass ratio problem\"\n\n\n\n        # Test inconsistent inertia\n\n        bad_inertia_params = valid_params.copy()\n\n        bad_inertia_params['pendulum1_inertia'] = 0.5  # Much too large for rod\n\n\n\n        is_consistent, errors = parameter_validator.validate_physics_consistency(bad_inertia_params)\n"
      },
      {
        "file": "tests\\test_config\\test_compatibility_validation.py",
        "line": 117,
        "pattern": "dict_config = original_config._data.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        if hasattr(original_config, 'to_dict'):\n\n            dict_config = original_config.to_dict()\n\n        elif hasattr(original_config, '_data'):\n\n            dict_config = original_config._data.copy()\n\n        else:\n\n            dict_config = dict(original_config)\n\n\n"
      },
      {
        "file": "tests\\test_controllers\\factory\\test_controller_factory.py",
        "line": 369,
        "pattern": "trajectory_states = [initial_state.copy()]",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n            # Test stability around equilibrium\n\n            initial_state = self.test_states['small_disturbance']\n\n            trajectory_states = [initial_state.copy()]\n\n            current_state = initial_state.copy()\n\n\n\n            dt = 0.01\n"
      },
      {
        "file": "tests\\test_controllers\\factory\\test_controller_factory.py",
        "line": 370,
        "pattern": "current_state = initial_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            # Test stability around equilibrium\n\n            initial_state = self.test_states['small_disturbance']\n\n            trajectory_states = [initial_state.copy()]\n\n            current_state = initial_state.copy()\n\n\n\n            dt = 0.01\n\n            for step in range(200):  # 2 seconds simulation\n"
      },
      {
        "file": "tests\\test_controllers\\factory\\test_controller_factory.py",
        "line": 383,
        "pattern": "trajectory_states.append(current_state.copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n                # Euler integration step\n\n                current_state = current_state + dt * result.state_derivative\n\n                trajectory_states.append(current_state.copy())\n\n\n\n                # Check for instability\n\n                if np.any(np.abs(current_state) > 10.0):\n"
      },
      {
        "file": "tests\\test_controllers\\factory\\test_controller_factory.py",
        "line": 414,
        "pattern": "current_state = initial_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n            # Run stabilization task\n\n            initial_state = self.test_states['large_angles']\n\n            current_state = initial_state.copy()\n\n\n\n            control_efforts = []\n\n            settling_times = []\n"
      },
      {
        "file": "tests\\test_controllers\\factory\\test_controller_factory.py",
        "line": 553,
        "pattern": "current_state = self.test_states['large_angles'].copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                dynamics = SimplifiedDIPDynamics(plant_config)\n\n\n\n                # Test stabilization from disturbed state\n\n                current_state = self.test_states['large_angles'].copy()\n\n\n\n                for _ in range(100):  # 1 second simulation\n\n                    control = controller.compute_control(current_state)\n"
      },
      {
        "file": "tests\\test_controllers\\factory\\test_controller_factory.py",
        "line": 626,
        "pattern": "state = self.test_states['high_velocity'].copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        )\n\n\n\n        # Start from a specific state and evolve forward\n\n        state = self.test_states['high_velocity'].copy()\n\n        previous_controls = []\n\n\n\n        for step in range(50):  # 0.5 second trajectory\n"
      },
      {
        "file": "tests\\test_controllers\\smc\\algorithms\\classical\\test_sliding_surface.py",
        "line": 103,
        "pattern": "perturbed_state = base_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n        # Test continuity in each state dimension\n\n        for i in range(len(base_state)):\n\n            perturbed_state = base_state.copy()\n\n            perturbed_state[i] += delta\n\n\n\n            surface_perturbed = controller._surface.compute(perturbed_state)\n"
      },
      {
        "file": "tests\\test_controllers\\smc\\test_hybrid_adaptive_sta_smc.py",
        "line": 231,
        "pattern": "state = state_large_error.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        \"\"\"Test adaptive gain mechanism.\"\"\"\n\n        # Run controller multiple times to trigger adaptation\n\n        controls = []\n\n        state = state_large_error.copy()\n\n\n\n        for i in range(10):\n\n            control_output = controller.compute_control(state, last_u=0.0)\n"
      },
      {
        "file": "tests\\test_controllers\\test_modular_smc.py",
        "line": 217,
        "pattern": "initial_estimates = controller._uncertainty_estimator.current_estimates.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        state = np.array([0.1, 0.2, 0.3, 0.1, 0.1, 0.1])\n\n\n\n        # Get initial estimates\n\n        initial_estimates = controller._uncertainty_estimator.current_estimates.copy()\n\n\n\n        # Run several control steps\n\n        for _ in range(10):\n"
      },
      {
        "file": "tests\\test_integration\\test_cross_mission_integration.py",
        "line": 396,
        "pattern": "state = initial_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                dt = 0.01\n\n                n_steps = 100  # Short simulation\n\n\n\n                state = initial_state.copy()\n\n                controller_state = controller.initialize_state()\n\n                history = controller.initialize_history()\n\n\n"
      },
      {
        "file": "tests\\test_integration\\test_end_to_end\\test_integration_end_to_end_deep.py",
        "line": 78,
        "pattern": "self.state_history.append(self.state.copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n            # Update history\n\n            self.control_history.append(control)\n\n            self.state_history.append(self.state.copy())\n\n            self.time_history.append(self.time)\n\n\n\n            # Update state and time\n"
      },
      {
        "file": "tests\\test_integration\\test_end_to_end\\test_integration_end_to_end_deep.py",
        "line": 487,
        "pattern": "varied_config = plant_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        ]\n\n\n\n        for variation in variations:\n\n            varied_config = plant_config.copy()\n\n            varied_config.update(variation)\n\n\n\n            varied_system = MockCompleteControlSystem(varied_config, smc_controller_config)\n"
      },
      {
        "file": "tests\\test_integration\\test_error_recovery\\test_error_recovery_deep.py",
        "line": 78,
        "pattern": "singular_matrix = matrix.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        \"\"\"Inject matrix-related errors.\"\"\"\n\n        if error_type == ErrorType.MATRIX_SINGULAR:\n\n            # Make matrix singular\n\n            singular_matrix = matrix.copy()\n\n            if len(singular_matrix.shape) == 2 and singular_matrix.shape[0] == singular_matrix.shape[1]:\n\n                singular_matrix[0, :] = singular_matrix[1, :]  # Make rows identical\n\n            return singular_matrix\n"
      },
      {
        "file": "tests\\test_integration\\test_error_recovery\\test_error_recovery_deep.py",
        "line": 90,
        "pattern": "corrupted = input_data.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        \"\"\"Inject input-related errors.\"\"\"\n\n        if error_type == ErrorType.INVALID_INPUT:\n\n            if isinstance(input_data, np.ndarray):\n\n                corrupted = input_data.copy()\n\n                corrupted[0] = np.nan\n\n                return corrupted\n\n            else:\n"
      },
      {
        "file": "tests\\test_integration\\test_error_recovery\\test_error_recovery_deep.py",
        "line": 139,
        "pattern": "self.last_valid_state = state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                raise ValueError(\"Invalid control output\")\n\n\n\n            # Success - update valid state\n\n            self.last_valid_state = state.copy()\n\n            self.last_valid_control = control\n\n            self.error_count = 0  # Reset error count on success\n\n\n"
      },
      {
        "file": "tests\\test_integration\\test_error_recovery\\test_error_recovery_deep.py",
        "line": 211,
        "pattern": "'state': state.copy() if isinstance(state, np.ndarray) else None,",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            'error_type': type(error).__name__,\n\n            'error_message': str(error),\n\n            'error_count': self.error_count,\n\n            'state': state.copy() if isinstance(state, np.ndarray) else None,\n\n            'traceback': traceback.format_exc()\n\n        }\n\n\n"
      },
      {
        "file": "tests\\test_integration\\test_numerical_stability\\test_numerical_stability_deep.py",
        "line": 483,
        "pattern": "return self.state.copy()",
        "category": "NECESSARY",
        "reason": "Public getter returning internal state (defensive copy required)",
        "confidence": 0.95,
        "context": "                self.state[0] += x_dot * dt\n\n                self.state[1] += x_ddot * dt\n\n\n\n                return self.state.copy()\n\n\n\n        # Test step response\n\n        system = MockSecondOrderSystem()\n"
      },
      {
        "file": "tests\\test_integration\\test_property_based\\test_property_based_deep.py",
        "line": 152,
        "pattern": "perturbed_state = state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n        # Test continuity in each dimension\n\n        for i in range(len(state)):\n\n            perturbed_state = state.copy()\n\n            perturbed_state[i] += epsilon\n\n            result_perturbed = surface.compute(perturbed_state)\n\n\n"
      },
      {
        "file": "tests\\test_integration\\test_statistical_analysis\\test_statistical_monte_carlo_deep.py",
        "line": 570,
        "pattern": "self.state_history = [state.copy()]",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            def simulate_markov_process(self, n_steps=50):\n\n                \"\"\"Simulate control process with Markov property.\"\"\"\n\n                state = np.random.normal(0, 0.1, 3)  # Simplified 3D state\n\n                self.state_history = [state.copy()]\n\n\n\n                transition_matrix = np.array([\n\n                    [0.9, 0.05, 0.05],\n"
      },
      {
        "file": "tests\\test_integration\\test_statistical_analysis\\test_statistical_monte_carlo_deep.py",
        "line": 581,
        "pattern": "self.state_history.append(state.copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                for step in range(n_steps):\n\n                    # Markov transition (current state only depends on previous state)\n\n                    state = transition_matrix @ state + np.random.normal(0, 0.01, 3)\n\n                    self.state_history.append(state.copy())\n\n\n\n                # Return final deviation from origin\n\n                return np.linalg.norm(state)\n"
      },
      {
        "file": "tests\\test_integration\\test_thread_safety\\test_concurrent_thread_safety_deep.py",
        "line": 73,
        "pattern": "self._state_history.append(state.copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            self._shared_data['timestamp'] = time.time()\n\n\n\n            # Store history\n\n            self._state_history.append(state.copy())\n\n            self._control_history.append(control)\n\n\n\n            return control\n"
      },
      {
        "file": "tests\\test_interfaces\\test_parameter_compatibility.py",
        "line": 371,
        "pattern": "current_state = state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            else:\n\n                raise ValueError(f\"Dynamics failed: {result.info}\")\n\n\n\n        current_state = state.copy()\n\n        current_time = 0.0\n\n\n\n        try:\n"
      },
      {
        "file": "tests\\test_optimization\\core\\test_cli_determinism.py",
        "line": 189,
        "pattern": "env = os.environ.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\ndef _run_cli(app: Path, config: Path) -> str:\n\n    # Set TEST_MODE to force fast mode\n\n    env = os.environ.copy()\n\n    env[\"TEST_MODE\"] = \"1\"\n\n    \n\n    cmd = [\n"
      },
      {
        "file": "tests\\test_optimization\\test_algorithm_comparison.py",
        "line": 216,
        "pattern": "best_solution = population[current_best_idx].copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n                    if current_best_fitness < best_fitness:\n\n                        best_fitness = current_best_fitness\n\n                        best_solution = population[current_best_idx].copy()\n\n\n\n                    self.convergence_history.append(best_fitness)\n\n\n"
      },
      {
        "file": "tests\\test_optimization\\test_algorithm_comparison.py",
        "line": 228,
        "pattern": "new_population.append(population[winner_idx].copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                        tournament_size = 3\n\n                        tournament_indices = np.random.choice(self.population_size, tournament_size)\n\n                        winner_idx = tournament_indices[np.argmin(fitness_values[tournament_indices])]\n\n                        new_population.append(population[winner_idx].copy())\n\n\n\n                    population = np.array(new_population)\n\n\n"
      },
      {
        "file": "tests\\test_optimization\\test_algorithm_comparison.py",
        "line": 237,
        "pattern": "temp = population[i, crossover_point:].copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                        if np.random.random() < self.crossover_rate:\n\n                            # Simple crossover\n\n                            crossover_point = np.random.randint(1, n_dimensions)\n\n                            temp = population[i, crossover_point:].copy()\n\n                            population[i, crossover_point:] = population[i+1, crossover_point:]\n\n                            population[i+1, crossover_point:] = temp\n\n\n"
      },
      {
        "file": "tests\\test_optimization\\test_algorithm_comparison.py",
        "line": 293,
        "pattern": "best_solution = population[best_idx].copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                fitness_values = np.array([fitness_function(ind) for ind in population])\n\n                best_idx = np.argmin(fitness_values)\n\n                best_fitness = fitness_values[best_idx]\n\n                best_solution = population[best_idx].copy()\n\n\n\n                for generation in range(self.generations):\n\n                    for i in range(self.population_size):\n"
      },
      {
        "file": "tests\\test_optimization\\test_algorithm_comparison.py",
        "line": 309,
        "pattern": "trial = population[i].copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                            mutant[j] = np.clip(mutant[j], self.bounds[j][0], self.bounds[j][1])\n\n\n\n                        # Crossover\n\n                        trial = population[i].copy()\n\n                        R = np.random.randint(n_dimensions)  # Ensure at least one parameter from mutant\n\n\n\n                        for j in range(n_dimensions):\n"
      },
      {
        "file": "tests\\test_optimization\\test_algorithm_comparison.py",
        "line": 324,
        "pattern": "best_solution = trial.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n                            if trial_fitness < best_fitness:\n\n                                best_fitness = trial_fitness\n\n                                best_solution = trial.copy()\n\n\n\n                    self.convergence_history.append(best_fitness)\n\n\n"
      },
      {
        "file": "tests\\test_optimization\\test_multi_objective_pso.py",
        "line": 643,
        "pattern": "penalized_objectives = objectives.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n        def apply_constraint_penalties(objectives, constraints_violated):\n\n            \"\"\"Apply penalties for constraint violations.\"\"\"\n\n            penalized_objectives = objectives.copy()\n\n\n\n            for i, violated in enumerate(constraints_violated):\n\n                if violated:\n"
      },
      {
        "file": "tests\\test_optimization\\test_multi_objective_pso.py",
        "line": 819,
        "pattern": "normalized_front = pareto_front.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                weights = np.ones(pareto_front.shape[1]) / pareto_front.shape[1]\n\n\n\n            # Normalize objectives (assuming minimization)\n\n            normalized_front = pareto_front.copy()\n\n            for i in range(pareto_front.shape[1]):\n\n                obj_range = pareto_front[:, i].max() - pareto_front[:, i].min()\n\n                if obj_range > 0:\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 94,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n    def test_missing_pso_section_fails(self, base_valid_config):\n\n        \"\"\"Test that missing PSO section fails validation.\"\"\"\n\n        config = base_valid_config.copy()\n\n        del config['pso']\n\n\n\n        result = validate_pso_configuration(config)\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 103,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n    def test_missing_physics_section_fails(self, base_valid_config):\n\n        \"\"\"Test that missing physics section fails validation.\"\"\"\n\n        config = base_valid_config.copy()\n\n        del config['physics']\n\n\n\n        result = validate_pso_configuration(config)\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 112,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n    def test_missing_simulation_section_fails(self, base_valid_config):\n\n        \"\"\"Test that missing simulation section fails validation.\"\"\"\n\n        config = base_valid_config.copy()\n\n        del config['simulation']\n\n\n\n        result = validate_pso_configuration(config)\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 124,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def test_invalid_particle_count_fails(self, base_valid_config):\n\n        \"\"\"Test invalid particle count validation.\"\"\"\n\n        # Zero particles\n\n        config = base_valid_config.copy()\n\n        config['pso']['n_particles'] = 0\n\n        result = validate_pso_configuration(config)\n\n        assert result['valid'] is False\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 142,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def test_invalid_iteration_count_fails(self, base_valid_config):\n\n        \"\"\"Test invalid iteration count validation.\"\"\"\n\n        # Zero iterations\n\n        config = base_valid_config.copy()\n\n        config['pso']['max_iter'] = 0\n\n        result = validate_pso_configuration(config)\n\n        assert result['valid'] is False\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 155,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def test_invalid_pso_coefficients_fail(self, base_valid_config):\n\n        \"\"\"Test invalid PSO coefficient validation.\"\"\"\n\n        # Negative c1\n\n        config = base_valid_config.copy()\n\n        config['pso']['c1'] = -0.5\n\n        result = validate_pso_configuration(config)\n\n        assert result['valid'] is False\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 161,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        assert result['valid'] is False\n\n\n\n        # Negative c2\n\n        config = base_valid_config.copy()\n\n        config['pso']['c2'] = -0.3\n\n        result = validate_pso_configuration(config)\n\n        assert result['valid'] is False\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 167,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        assert result['valid'] is False\n\n\n\n        # Negative inertia weight\n\n        config = base_valid_config.copy()\n\n        config['pso']['w'] = -0.1\n\n        result = validate_pso_configuration(config)\n\n        assert result['valid'] is False\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 173,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        assert result['valid'] is False\n\n\n\n        # c1 + c2 > 4 (should warn about potential instability)\n\n        config = base_valid_config.copy()\n\n        config['pso']['c1'] = 2.5\n\n        config['pso']['c2'] = 2.5\n\n        result = validate_pso_configuration(config)\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 182,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def test_velocity_clamp_validation(self, base_valid_config):\n\n        \"\"\"Test velocity clamp parameter validation.\"\"\"\n\n        # Valid velocity clamp\n\n        config = base_valid_config.copy()\n\n        config['pso']['velocity_clamp'] = (-1.0, 1.0)\n\n        result = validate_pso_configuration(config)\n\n        assert result['valid'] is True\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 200,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def test_inertia_weight_schedule_validation(self, base_valid_config):\n\n        \"\"\"Test inertia weight schedule validation.\"\"\"\n\n        # Valid schedule\n\n        config = base_valid_config.copy()\n\n        config['pso']['w_schedule'] = (0.9, 0.4)\n\n        result = validate_pso_configuration(config)\n\n        assert result['valid'] is True\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 221,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def test_physics_parameter_bounds(self, base_valid_config):\n\n        \"\"\"Test physics parameter boundary validation.\"\"\"\n\n        # Negative mass (should fail)\n\n        config = base_valid_config.copy()\n\n        config['physics']['cart_mass'] = -1.0\n\n        result = validate_pso_configuration(config)\n\n        assert result['valid'] is False\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 232,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        assert result['valid'] is False\n\n\n\n        # Negative length (should fail)\n\n        config = base_valid_config.copy()\n\n        config['physics']['pendulum1_length'] = -0.5\n\n        result = validate_pso_configuration(config)\n\n        assert result['valid'] is False\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 243,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        assert len(result['warnings']) > 0\n\n\n\n        # Negative gravity (should fail or warn about upside-down)\n\n        config = base_valid_config.copy()\n\n        config['physics']['gravity'] = -9.81\n\n        result = validate_pso_configuration(config)\n\n        # Could be valid for inverted systems but should warn\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 252,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def test_friction_parameter_validation(self, base_valid_config):\n\n        \"\"\"Test friction parameter validation.\"\"\"\n\n        # Negative friction (should fail)\n\n        config = base_valid_config.copy()\n\n        config['physics']['cart_friction'] = -0.1\n\n        result = validate_pso_configuration(config)\n\n        assert result['valid'] is False\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 267,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def test_simulation_parameter_validation(self, base_valid_config):\n\n        \"\"\"Test simulation parameter validation.\"\"\"\n\n        # Negative time step\n\n        config = base_valid_config.copy()\n\n        config['simulation']['dt'] = -0.01\n\n        result = validate_pso_configuration(config)\n\n        assert result['valid'] is False\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 283,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        assert len(result['warnings']) > 0\n\n\n\n        # Negative duration\n\n        config = base_valid_config.copy()\n\n        config['simulation']['duration'] = -5.0\n\n        result = validate_pso_configuration(config)\n\n        assert result['valid'] is False\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 296,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def test_initial_state_validation(self, base_valid_config):\n\n        \"\"\"Test initial state validation.\"\"\"\n\n        # Wrong number of states\n\n        config = base_valid_config.copy()\n\n        config['simulation']['initial_state'] = [0.0, 0.1, -0.05]  # Only 3 states instead of 6\n\n        result = validate_pso_configuration(config)\n\n        assert result['valid'] is False\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 316,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def test_cost_function_validation(self, base_valid_config):\n\n        \"\"\"Test cost function weight validation.\"\"\"\n\n        # Missing cost function section\n\n        config = base_valid_config.copy()\n\n        del config['cost_function']\n\n        result = validate_pso_configuration(config)\n\n        assert result['valid'] is False\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 322,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        assert result['valid'] is False\n\n\n\n        # Negative weights\n\n        config = base_valid_config.copy()\n\n        config['cost_function']['weights']['ise'] = -1.0\n\n        result = validate_pso_configuration(config)\n\n        assert result['valid'] is False\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 335,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        assert len(result['warnings']) > 0\n\n\n\n        # Very large weights (should warn about numerical issues)\n\n        config = base_valid_config.copy()\n\n        config['cost_function']['weights']['ise'] = 1e10\n\n        result = validate_pso_configuration(config)\n\n        assert len(result['warnings']) > 0\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 345,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def test_physics_uncertainty_validation(self, base_valid_config):\n\n        \"\"\"Test physics uncertainty configuration validation.\"\"\"\n\n        # Valid uncertainty configuration\n\n        config = base_valid_config.copy()\n\n        config['physics_uncertainty'] = {\n\n            'n_evals': 5,\n\n            'mass_std': 0.05,\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 361,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        assert result['valid'] is False\n\n\n\n        # Negative standard deviation\n\n        config = base_valid_config.copy()\n\n        config['physics_uncertainty'] = {\n\n            'n_evals': 5,\n\n            'mass_std': -0.05\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 436,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def test_complex_configuration_combinations(self, base_valid_config):\n\n        \"\"\"Test complex configuration combinations.\"\"\"\n\n        # High-performance configuration\n\n        config = base_valid_config.copy()\n\n        config.update({\n\n            'pso': {\n\n                'n_particles': 100,\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 471,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def test_edge_case_values(self, base_valid_config):\n\n        \"\"\"Test edge case parameter values.\"\"\"\n\n        # Very small positive values\n\n        config = base_valid_config.copy()\n\n        config['physics']['cart_mass'] = 1e-6\n\n        config['simulation']['dt'] = 1e-6\n\n        result = validate_pso_configuration(config)\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 479,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        assert len(result['warnings']) > 0\n\n\n\n        # Very large values\n\n        config = base_valid_config.copy()\n\n        config['physics']['cart_mass'] = 1e6\n\n        config['simulation']['duration'] = 1e6\n\n        result = validate_pso_configuration(config)\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 487,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        assert len(result['warnings']) > 0\n\n\n\n        # Boundary values for PSO parameters\n\n        config = base_valid_config.copy()\n\n        config['pso'].update({\n\n            'c1': 0.0,  # Minimum cognitive parameter\n\n            'c2': 4.0,  # High social parameter\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 502,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def test_comprehensive_error_reporting(self, base_valid_config):\n\n        \"\"\"Test comprehensive error reporting functionality.\"\"\"\n\n        # Multiple errors should all be reported\n\n        config = base_valid_config.copy()\n\n        config['pso']['n_particles'] = -5  # Error 1\n\n        config['pso']['max_iter'] = 0       # Error 2\n\n        config['physics']['cart_mass'] = -1.0  # Error 3\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 513,
        "pattern": "config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        assert len(result['errors']) >= 4  # Should report all errors\n\n\n\n        # Warnings should be accumulated\n\n        config = base_valid_config.copy()\n\n        config['pso']['n_particles'] = 1000    # Warning 1: many particles\n\n        config['pso']['c1'] = 3.0              # Warning 2: high coefficient\n\n        config['pso']['c2'] = 3.0              # Combined with c1 > 4\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_config_validation.py",
        "line": 548,
        "pattern": "large_config = base_valid_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        import time\n\n\n\n        # Large configuration\n\n        large_config = base_valid_config.copy()\n\n        large_config.update({\n\n            'physics': {**base_valid_config['physics'], **{f'param_{i}': 1.0 for i in range(100)}},\n\n            'pso': {**base_valid_config['pso'], **{f'option_{i}': 0.5 for i in range(50)}}\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_convergence_validation.py",
        "line": 304,
        "pattern": "self.pos_history.append(current_pos.copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                                   0.1 * np.random.normal(0, 1, 6)\n\n\n\n                    self.cost_history.append(current_cost)\n\n                    self.pos_history.append(current_pos.copy())\n\n\n\n                self.best_cost = current_cost\n\n                self.best_pos = current_pos.copy()\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_convergence_validation.py",
        "line": 307,
        "pattern": "self.best_pos = current_pos.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                    self.pos_history.append(current_pos.copy())\n\n\n\n                self.best_cost = current_cost\n\n                self.best_pos = current_pos.copy()\n\n\n\n                return self.best_cost, self.best_pos\n\n\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_convergence_validation.py",
        "line": 414,
        "pattern": "best_pos = current_pos.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n                    if current_cost < best_cost - self.tolerance:\n\n                        best_cost = current_cost\n\n                        best_pos = current_pos.copy()\n\n                        no_improvement_count = 0\n\n                    else:\n\n                        no_improvement_count += 1\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_convergence_validation.py",
        "line": 420,
        "pattern": "pos_history.append(best_pos.copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                        no_improvement_count += 1\n\n\n\n                    cost_history.append(best_cost)\n\n                    pos_history.append(best_pos.copy())\n\n\n\n                    # Early stopping check\n\n                    if no_improvement_count >= self.patience:\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_convergence_validation.py",
        "line": 650,
        "pattern": "current = initial_gains.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        initial_gains = np.array([15.0, 12.0, 8.0, 6.0, 30.0, 4.0])\n\n\n\n        gain_history = []\n\n        current = initial_gains.copy()\n\n\n\n        for i in range(20):\n\n            # Move towards optimal with decreasing step size\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_convergence_validation.py",
        "line": 657,
        "pattern": "gain_history.append(current.copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            step_size = 0.1 * np.exp(-i/10)\n\n            current = current + step_size * (optimal_gains - current) + \\\n\n                     0.05 * np.random.normal(0, 1, 6)\n\n            gain_history.append(current.copy())\n\n\n\n        analysis = analyze_gain_convergence(gain_history)\n\n\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_deterministic_coverage.py",
        "line": 136,
        "pattern": "config_with_deprecated = deterministic_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def test_pso_tuner_deprecated_parameters_validation(self, deterministic_config, mock_controller_factory):\n\n        \"\"\"Test validation of deprecated PSO parameters.\"\"\"\n\n        # Create config with deprecated parameters\n\n        config_with_deprecated = deterministic_config.copy()\n\n        config_with_deprecated['pso'].update({\n\n            'n_processes': 4,  # Should trigger error\n\n            'hyper_trials': 10,  # Should trigger error\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_deterministic_coverage.py",
        "line": 277,
        "pattern": "x_b_nan = x_b.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        assert all(np.isfinite(result))\n\n\n\n        # Test with NaN in simulation results\n\n        x_b_nan = x_b.copy()\n\n        x_b_nan[0, :, 0] = np.nan  # Introduce NaN in first particle\n\n        mock_simulate.return_value = (t, x_b_nan, u_b, sigma_b)\n\n\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_deterministic_coverage.py",
        "line": 320,
        "pattern": "config_no_pso = deterministic_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        assert result['valid'] is True\n\n\n\n        # Missing PSO section\n\n        config_no_pso = deterministic_config.copy()\n\n        del config_no_pso['pso']\n\n        result = validate_pso_configuration(config_no_pso)\n\n        assert result['valid'] is False\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_deterministic_coverage.py",
        "line": 326,
        "pattern": "config_invalid_particles = deterministic_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        assert result['valid'] is False\n\n\n\n        # Invalid particle count\n\n        config_invalid_particles = deterministic_config.copy()\n\n        config_invalid_particles['pso']['n_particles'] = -1\n\n        result = validate_pso_configuration(config_invalid_particles)\n\n        assert result['valid'] is False\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_deterministic_coverage.py",
        "line": 332,
        "pattern": "config_invalid_iter = deterministic_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        assert result['valid'] is False\n\n\n\n        # Invalid iteration count\n\n        config_invalid_iter = deterministic_config.copy()\n\n        config_invalid_iter['pso']['max_iter'] = 0\n\n        result = validate_pso_configuration(config_invalid_iter)\n\n        assert result['valid'] is False\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_deterministic_coverage.py",
        "line": 376,
        "pattern": "convergence_config = deterministic_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    def test_convergence_detection_comprehensive(self, mock_simulate, deterministic_config, mock_controller_factory):\n\n        \"\"\"Test convergence detection with various scenarios.\"\"\"\n\n        # Configure for early stopping\n\n        convergence_config = deterministic_config.copy()\n\n        convergence_config['pso'].update({\n\n            'max_iter': 50,\n\n            'convergence_threshold': 1e-6,\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_integration_e2e.py",
        "line": 353,
        "pattern": "config = test_config.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        ]\n\n\n\n        for i, pso_params in enumerate(pso_configs):\n\n            config = test_config.copy()\n\n            config['pso'].update(pso_params)\n\n\n\n            tuner = PSOTuner(mock_controller_factory, config, seed=42)\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_safety_critical.py",
        "line": 219,
        "pattern": "x_unstable = x_stable.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        cost_stable = tuner._compute_cost_from_traj(t, x_stable, u_stable, sigma_stable)\n\n\n\n        # Unstable trajectory (large pendulum angles)\n\n        x_unstable = x_stable.copy()\n\n        x_unstable[:, 50:, 1] = 2.0  # theta1 > pi/2\n\n        cost_unstable = tuner._compute_cost_from_traj(t, x_unstable, u_stable, sigma_stable)\n\n\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_safety_critical.py",
        "line": 224,
        "pattern": "x_explosive = x_stable.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        cost_unstable = tuner._compute_cost_from_traj(t, x_unstable, u_stable, sigma_stable)\n\n\n\n        # Explosive trajectory\n\n        x_explosive = x_stable.copy()\n\n        x_explosive[:, 70:, :] = 1e8  # Explosive growth\n\n        cost_explosive = tuner._compute_cost_from_traj(t, x_explosive, u_stable, sigma_stable)\n\n\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_safety_critical.py",
        "line": 255,
        "pattern": "u_inf = u_normal.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        assert np.all(cost_nan == tuner.instability_penalty)\n\n\n\n        # Infinity in controls\n\n        u_inf = u_normal.copy()\n\n        u_inf[:, 30] = np.inf\n\n        cost_inf = tuner._compute_cost_from_traj(t, x_nan, u_inf, sigma_normal)\n\n        assert np.all(cost_inf == tuner.instability_penalty)\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_safety_critical.py",
        "line": 261,
        "pattern": "sigma_nan = sigma_normal.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        assert np.all(cost_inf == tuner.instability_penalty)\n\n\n\n        # NaN in sliding variables\n\n        sigma_nan = sigma_normal.copy()\n\n        sigma_nan[:, 40] = np.nan\n\n        cost_sigma_nan = tuner._compute_cost_from_traj(t, x_nan, u_normal, sigma_nan)\n\n        assert np.all(cost_sigma_nan == tuner.instability_penalty)\n"
      },
      {
        "file": "tests\\test_optimization\\test_pso_safety_critical.py",
        "line": 714,
        "pattern": "x_unacceptable = x_acceptable.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        cost_marginal = tuner._compute_cost_from_traj(t, x_marginal, u_acceptable, sigma_acceptable)\n\n\n\n        # Unacceptable for production\n\n        x_unacceptable = x_acceptable.copy()\n\n        x_unacceptable[:, 800:, 1] = 2.0  # Fall over\n\n        cost_unacceptable = tuner._compute_cost_from_traj(t, x_unacceptable, u_acceptable, sigma_acceptable)\n\n\n"
      },
      {
        "file": "tests\\test_physics\\test_energy_conservation_bounds.py",
        "line": 97,
        "pattern": "state = initial_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "            print(f\"Initial energy: {initial_energy:.6f} J\")\n\n\n\n            # Run RK4 simulation\n\n            state = initial_state.copy()\n\n            control = 0.0  # No control for energy conservation test\n\n\n\n            num_steps = int(sim_time / dt)\n"
      },
      {
        "file": "tests\\test_physics\\test_energy_conservation_bounds.py",
        "line": 142,
        "pattern": "rk4_state = test_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        initial_energy = self.physics_computer.compute_total_energy(test_state)\n\n\n\n        # Test RK4\n\n        rk4_state = test_state.copy()\n\n        num_steps = int(sim_time / dt)\n\n        for _ in range(num_steps):\n\n            rk4_state = step_rk4_numba(rk4_state, control, dt, self.params)\n"
      },
      {
        "file": "tests\\test_physics\\test_energy_conservation_bounds.py",
        "line": 151,
        "pattern": "euler_state = test_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        rk4_drift_percent = abs(rk4_energy - initial_energy) / initial_energy * 100\n\n\n\n        # Test Euler\n\n        euler_state = test_state.copy()\n\n        for _ in range(num_steps):\n\n            euler_state = step_euler_numba(euler_state, control, dt, self.params)\n\n\n"
      },
      {
        "file": "tests\\test_physics\\test_energy_conservation_bounds.py",
        "line": 196,
        "pattern": "state = test_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        initial_energy = self.physics_computer.compute_total_energy(test_state)\n\n\n\n        for sim_time in time_points:\n\n            state = test_state.copy()\n\n            num_steps = int(sim_time / dt)\n\n\n\n            for _ in range(num_steps):\n"
      },
      {
        "file": "tests\\test_physics\\test_energy_conservation_bounds.py",
        "line": 250,
        "pattern": "state = test_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        initial_energy = self.physics_computer.compute_total_energy(test_state)\n\n\n\n        for dt in dt_values:\n\n            state = test_state.copy()\n\n            num_steps = int(sim_time / dt)\n\n\n\n            for _ in range(num_steps):\n"
      },
      {
        "file": "tests\\test_physics\\test_energy_conservation_bounds.py",
        "line": 328,
        "pattern": "state = test_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        control = 0.0\n\n\n\n        initial_energy = self.physics_computer.compute_total_energy(test_state)\n\n        state = test_state.copy()\n\n\n\n        num_steps = int(sim_time / dt)\n\n        for _ in range(num_steps):\n"
      },
      {
        "file": "tests\\test_physics\\test_energy_conservation_bounds.py",
        "line": 412,
        "pattern": "state = initial_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    sim_time = 10.0\n\n\n\n    initial_energy = physics.compute_total_energy(initial_state)\n\n    state = initial_state.copy()\n\n\n\n    # Use physics computer for simulation instead of direct numba calls\n\n    num_steps = int(sim_time / dt)\n"
      },
      {
        "file": "tests\\test_physics\\test_integration_stability.py",
        "line": 351,
        "pattern": "state = initial_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        Returns:\n\n            Tuple of (is_stable, final_state, final_energy)\n\n        \"\"\"\n\n        state = initial_state.copy()\n\n        initial_energy = self.physics_computer.compute_total_energy(initial_state)\n\n\n\n        num_steps = int(simulation_time / dt)\n"
      },
      {
        "file": "tests\\test_physics\\test_integration_stability.py",
        "line": 524,
        "pattern": "state = test_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    print(\"-\" * 40)\n\n\n\n    for dt, category in test_cases:\n\n        state = test_state.copy()\n\n        simulation_time = 3.0\n\n        num_steps = int(simulation_time / dt)\n\n\n"
      },
      {
        "file": "tests\\test_physics\\test_mathematical_properties.py",
        "line": 173,
        "pattern": "state = test_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        reality_check = []\n\n\n\n        for test in conservation_tests:\n\n            state = test_state.copy()\n\n            num_steps = int(test['time'] / test['dt'])\n\n\n\n            for _ in range(num_steps):\n"
      },
      {
        "file": "tests\\test_physics\\test_mathematical_properties.py",
        "line": 293,
        "pattern": "state_history = [test_state.copy()]",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        simulation_time = 2.0\n\n        num_steps = int(simulation_time / dt)\n\n\n\n        state_history = [test_state.copy()]\n\n        energy_history = [initial_energy]\n\n\n\n        state = test_state.copy()\n"
      },
      {
        "file": "tests\\test_physics\\test_mathematical_properties.py",
        "line": 296,
        "pattern": "state = test_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        state_history = [test_state.copy()]\n\n        energy_history = [initial_energy]\n\n\n\n        state = test_state.copy()\n\n        for i in range(num_steps):\n\n            state = step_rk4_numba(state, 0.0, dt, self.params)\n\n            state_history.append(state.copy())\n"
      },
      {
        "file": "tests\\test_physics\\test_mathematical_properties.py",
        "line": 299,
        "pattern": "state_history.append(state.copy())",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        state = test_state.copy()\n\n        for i in range(num_steps):\n\n            state = step_rk4_numba(state, 0.0, dt, self.params)\n\n            state_history.append(state.copy())\n\n\n\n            current_energy = self.physics_computer.compute_total_energy(state)\n\n            energy_history.append(current_energy)\n"
      },
      {
        "file": "tests\\test_physics\\test_mathematical_properties.py",
        "line": 355,
        "pattern": "perturbed_state = base_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        base_state = np.array([0.0, 0.5, 0.5, 0.0, 0.0, 0.0])  # Larger angles for nonlinearity\n\n        perturbation = 1e-10  # Tiny perturbation\n\n\n\n        perturbed_state = base_state.copy()\n\n        perturbed_state[1] += perturbation  # Perturb first angle\n\n\n\n        print(f\"\\nChaos sensitivity analysis:\")\n"
      },
      {
        "file": "tests\\test_physics\\test_mathematical_properties.py",
        "line": 367,
        "pattern": "state1 = base_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        simulation_time = 5.0\n\n        num_steps = int(simulation_time / dt)\n\n\n\n        state1 = base_state.copy()\n\n        state2 = perturbed_state.copy()\n\n\n\n        divergence_history = []\n"
      },
      {
        "file": "tests\\test_physics\\test_mathematical_properties.py",
        "line": 368,
        "pattern": "state2 = perturbed_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        num_steps = int(simulation_time / dt)\n\n\n\n        state1 = base_state.copy()\n\n        state2 = perturbed_state.copy()\n\n\n\n        divergence_history = []\n\n        time_points = []\n"
      },
      {
        "file": "tests\\test_physics\\test_mathematical_properties.py",
        "line": 585,
        "pattern": "state = test_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n    # Test 1: Energy conservation bounds (realistic expectations)\n\n    initial_energy = physics.compute_total_energy(test_state)\n\n    state = test_state.copy()\n\n    dt = 0.01\n\n\n\n    for _ in range(500):  # 5 seconds\n"
      },
      {
        "file": "tests\\test_physics\\test_mathematical_properties.py",
        "line": 614,
        "pattern": "test_state_stability = test_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    # Test 3: Integration stability (practical dt bounds)\n\n    stable_dt = 0.01\n\n    test_stable = True\n\n    test_state_stability = test_state.copy()\n\n\n\n    try:\n\n        for _ in range(300):  # 3 seconds\n"
      },
      {
        "file": "tests\\test_physics\\test_parameter_realism.py",
        "line": 413,
        "pattern": "config_dict = self.reference_params.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "\n\n    def _create_base_config(self) -> SimplifiedDIPConfig:\n\n        \"\"\"Create base realistic configuration.\"\"\"\n\n        config_dict = self.reference_params.copy()\n\n        config_dict.update({\n\n            'regularization_alpha': 1e-6,\n\n            'max_condition_number': 1e12,\n"
      },
      {
        "file": "tests\\test_physics\\test_parameter_realism.py",
        "line": 508,
        "pattern": "state = initial_state.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "                return False\n\n\n\n            # Short simulation\n\n            state = initial_state.copy()\n\n            dt = 0.01\n\n            num_steps = 100  # 1 second\n\n\n"
      },
      {
        "file": "tests\\test_simulation\\core\\test_stateful_simulation.py",
        "line": 55,
        "pattern": "x_next = x.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "        x = np.asarray(x, dtype=float).reshape(-1)\n\n        u = float(u)\n\n        dt = float(dt)\n\n        x_next = x.copy()\n\n        x_next[0] = x[0] + dt * u\n\n        return x_next\n\n\n"
      },
      {
        "file": "tests\\test_utils\\reproducibility\\test_determinism.py",
        "line": 93,
        "pattern": "env = os.environ.copy()",
        "category": "NECESSARY",
        "reason": "",
        "confidence": 0.0,
        "context": "    The seeding logic is handled inside simulate.py; this helper\n\n    simply forwards the seed argument to the CLI entrypoint.\n\n    \"\"\"\n\n    env = os.environ.copy()\n\n    env[\"PYTHONUNBUFFERED\"] = \"1\"\n\n    app_path = _find_simulate_py()\n\n    cmd = [\n"
      }
    ],
    "CONVERTIBLE": []
  },
  "hotspots": [
    {
      "file": "tests\\test_optimization\\test_pso_config_validation.py",
      "copy_count": 30,
      "impact": "high"
    },
    {
      "file": "src\\plant\\models\\full\\dynamics.py",
      "copy_count": 15,
      "impact": "high"
    },
    {
      "file": "src\\optimization\\algorithms\\evolutionary\\genetic.py",
      "copy_count": 14,
      "impact": "high"
    },
    {
      "file": "src\\optimization\\algorithms\\swarm\\pso.py",
      "copy_count": 14,
      "impact": "high"
    },
    {
      "file": "src\\optimization\\algorithms\\evolutionary\\differential.py",
      "copy_count": 13,
      "impact": "high"
    },
    {
      "file": "src\\plant\\models\\simplified\\dynamics.py",
      "copy_count": 12,
      "impact": "high"
    },
    {
      "file": "src\\plant\\models\\lowrank\\dynamics.py",
      "copy_count": 11,
      "impact": "high"
    },
    {
      "file": "tests\\test_physics\\test_mathematical_properties.py",
      "copy_count": 9,
      "impact": "medium"
    },
    {
      "file": "src\\optimization\\objectives\\multi\\pareto.py",
      "copy_count": 8,
      "impact": "medium"
    },
    {
      "file": "src\\optimization\\algorithms\\multi_objective_pso.py",
      "copy_count": 7,
      "impact": "medium"
    },
    {
      "file": "tests\\test_physics\\test_energy_conservation_bounds.py",
      "copy_count": 7,
      "impact": "medium"
    },
    {
      "file": "src\\analysis\\fault_detection\\residual_generators.py",
      "copy_count": 6,
      "impact": "medium"
    },
    {
      "file": "src\\interfaces\\hil\\enhanced_hil.py",
      "copy_count": 6,
      "impact": "medium"
    },
    {
      "file": "src\\optimization\\algorithms\\gradient_based\\bfgs.py",
      "copy_count": 6,
      "impact": "medium"
    },
    {
      "file": "src\\optimization\\algorithms\\gradient_based\\nelder_mead.py",
      "copy_count": 6,
      "impact": "medium"
    },
    {
      "file": "src\\optimization\\objectives\\multi\\weighted_sum.py",
      "copy_count": 6,
      "impact": "medium"
    },
    {
      "file": "src\\plant\\core\\state_validation.py",
      "copy_count": 6,
      "impact": "medium"
    },
    {
      "file": "tests\\test_controllers\\factory\\test_controller_factory.py",
      "copy_count": 6,
      "impact": "medium"
    },
    {
      "file": "tests\\test_optimization\\test_algorithm_comparison.py",
      "copy_count": 6,
      "impact": "medium"
    },
    {
      "file": "tests\\test_optimization\\test_pso_convergence_validation.py",
      "copy_count": 6,
      "impact": "medium"
    }
  ]
}