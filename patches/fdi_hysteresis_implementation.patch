diff --git a/src/analysis/fault_detection/fdi.py b/src/analysis/fault_detection/fdi.py
index 2647e41..35c8c32 100644
--- a/src/analysis/fault_detection/fdi.py
+++ b/src/analysis/fault_detection/fdi.py
@@ -88,6 +88,18 @@ class FDIsystem:
     cusum_threshold : float
         Threshold for the cumulative sum.  When the cumulative sum
         exceeds this value a fault is declared.
+    hysteresis_enabled : bool
+        Enable hysteresis mechanism to prevent rapid oscillation
+        between OK and FAULT states near threshold boundaries.
+        When False, uses original single-threshold behavior.
+    hysteresis_upper : float
+        Upper threshold for fault detection when hysteresis is enabled.
+        Residual must exceed this value to trigger fault state.
+        Typically set to threshold * 1.1 (10% deadband).
+    hysteresis_lower : float
+        Lower threshold for potential fault recovery (future use).
+        Residual must drop below this value for recovery.
+        Typically set to threshold * 0.9 (10% deadband).
 
     Notes
     -----
@@ -95,6 +107,9 @@ class FDIsystem:
     * When both methods are enabled the residual must exceed either
       the adaptive threshold persistently or the CUSUM threshold to
       trigger a fault.
+    * Hysteresis prevents rapid state oscillations near threshold
+      boundaries by creating a deadband between fault trigger and
+      recovery thresholds (Issue #18).
     * The FDI system reports status only ("OK"/"FAULT") and does not modify
       the control command path; external supervisors decide safe-state actions.  # [CIT-064]
     """
@@ -110,6 +125,11 @@ class FDIsystem:
     cusum_enabled: bool = False
     cusum_threshold: float = 5.0  # [CIT-049]
 
+    # Hysteresis mechanism for threshold oscillation prevention [Issue #18]
+    hysteresis_enabled: bool = False
+    hysteresis_upper: float = 0.154  # Upper threshold (triggers fault detection)
+    hysteresis_lower: float = 0.126  # Lower threshold (for potential recovery)
+
     # Internal state - safety-critical components
     _counter: int = field(default=0, repr=False, init=False)
     _last_state: Optional[npt.NDArray[np.floating]] = field(default=None, repr=False, init=False)
@@ -297,8 +317,17 @@ class FDIsystem:
                 )
                 return "FAULT", residual_norm
 
-        # Update persistence counter using dynamic threshold
-        if residual_norm > dynamic_threshold:
+        # Hysteresis state machine for threshold oscillation prevention [Issue #18]
+        # Determine which threshold to use based on hysteresis configuration
+        if self.hysteresis_enabled:
+            # Use upper threshold for fault detection (prevents oscillation)
+            detection_threshold = self.hysteresis_upper
+        else:
+            # Original single-threshold behavior (backward compatible)
+            detection_threshold = dynamic_threshold
+
+        # Update persistence counter using appropriate threshold
+        if residual_norm > detection_threshold:
             self._counter += 1
             # Don't update _last_state when fault is detected to prevent
             # corrupted measurements from becoming the prediction base
@@ -310,7 +339,7 @@ class FDIsystem:
         # Check for fault condition based on persistence count
         if self._counter >= self.persistence_counter:
             self.tripped_at = t
-            threshold_used = dynamic_threshold
+            threshold_used = detection_threshold
             logging.info(
                 f"FDI fault detected at t={t:.2f}s after {self._counter} consecutive "
                 f"violations (residual_norm={residual_norm:.4f} > threshold={threshold_used:.4f})"
