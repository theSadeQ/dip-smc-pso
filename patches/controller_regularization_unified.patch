diff --git a/src/controllers/factory.py b/src/controllers/factory.py
index d490c3d..2f40e74 100644
--- a/src/controllers/factory.py
+++ b/src/controllers/factory.py
@@ -649,11 +649,18 @@ def create_controller(controller_type: str,
             # Add controller-specific required parameters
             if controller_type == 'classical_smc':
                 config_params.setdefault('boundary_layer', 0.02)  # Required parameter
+                config_params.setdefault('regularization_alpha', 1e-4)
+                config_params.setdefault('min_regularization', 1e-10)
+                config_params.setdefault('max_condition_number', 1e14)
+                config_params.setdefault('use_adaptive_regularization', True)
             elif controller_type == 'sta_smc':
                 # STA-SMC uses gains directly, no separate K1/K2 parameters
                 # The gains array is [K1, K2, k1, k2, lam1, lam2]
                 config_params.setdefault('power_exponent', 0.5)
-                config_params.setdefault('regularization', 1e-6)
+                config_params.setdefault('regularization_alpha', 1e-4)
+                config_params.setdefault('min_regularization', 1e-10)
+                config_params.setdefault('max_condition_number', 1e14)
+                config_params.setdefault('use_adaptive_regularization', True)
                 config_params.setdefault('boundary_layer', 0.01)
                 config_params.setdefault('switch_method', 'tanh')
                 config_params.setdefault('damping_gain', 0.0)
@@ -754,11 +761,18 @@ def create_controller(controller_type: str,
             # Add controller-specific required parameters
             if controller_type == 'classical_smc':
                 fallback_params['boundary_layer'] = 0.02  # Required parameter
+                fallback_params['regularization_alpha'] = 1e-4
+                fallback_params['min_regularization'] = 1e-10
+                fallback_params['max_condition_number'] = 1e14
+                fallback_params['use_adaptive_regularization'] = True
             elif controller_type == 'sta_smc':
                 # STA-SMC uses gains directly, no separate K1/K2 parameters
                 fallback_params.update({
                     'power_exponent': 0.5,
-                    'regularization': 1e-6,
+                    'regularization_alpha': 1e-4,
+                    'min_regularization': 1e-10,
+                    'max_condition_number': 1e14,
+                    'use_adaptive_regularization': True,
                     'boundary_layer': 0.01,
                     'switch_method': 'tanh',
                     'damping_gain': 0.0
diff --git a/src/controllers/smc/algorithms/classical/config.py b/src/controllers/smc/algorithms/classical/config.py
index 8a8bb15..a1ac7dc 100644
--- a/src/controllers/smc/algorithms/classical/config.py
+++ b/src/controllers/smc/algorithms/classical/config.py
@@ -38,8 +38,11 @@ class ClassicalSMCConfig:
     # Switching function
     switch_method: Literal["tanh", "linear", "sign"] = field(default="tanh")
 
-    # Numerical parameters
-    regularization: float = field(default=1e-10)           # Matrix regularization
+    # Numerical stability parameters (standardized with AdaptiveRegularizer)
+    regularization_alpha: float = field(default=1e-4)      # Base regularization scaling factor
+    min_regularization: float = field(default=1e-10)       # Minimum regularization
+    max_condition_number: float = field(default=1e14)      # Maximum acceptable condition number
+    use_adaptive_regularization: bool = field(default=True) # Use adaptive vs fixed regularization
     controllability_threshold: Optional[float] = field(default=None)  # Equivalent control threshold
 
     # Optional dynamics model
@@ -96,7 +99,9 @@ class ClassicalSMCConfig:
             'dt': self.dt,
             'boundary_layer': self.boundary_layer,
             'boundary_layer_slope': self.boundary_layer_slope,
-            'regularization': self.regularization
+            'regularization_alpha': self.regularization_alpha,
+            'min_regularization': self.min_regularization,
+            'max_condition_number': self.max_condition_number
         }
 
         for name, value in params_to_check.items():
@@ -119,8 +124,13 @@ class ClassicalSMCConfig:
         if self.boundary_layer_slope < 0:
             raise ValueError("boundary_layer_slope must be non-negative")
 
-        if self.regularization <= 0:
-            raise ValueError("regularization must be positive")
+        # Validate regularization parameters
+        if self.regularization_alpha <= 0:
+            raise ValueError("regularization_alpha must be positive")
+        if self.min_regularization <= 0:
+            raise ValueError("min_regularization must be positive")
+        if self.max_condition_number <= 0:
+            raise ValueError("max_condition_number must be positive")
 
         if self.controllability_threshold is not None:
             if not np.isfinite(self.controllability_threshold):
@@ -178,7 +188,10 @@ class ClassicalSMCConfig:
             'boundary_layer': self.boundary_layer,
             'boundary_layer_slope': self.boundary_layer_slope,
             'switch_method': self.switch_method,
-            'regularization': self.regularization,
+            'regularization_alpha': self.regularization_alpha,
+            'min_regularization': self.min_regularization,
+            'max_condition_number': self.max_condition_number,
+            'use_adaptive_regularization': self.use_adaptive_regularization,
             'controllability_threshold': self.controllability_threshold
         }
 
diff --git a/src/controllers/smc/algorithms/classical/controller.py b/src/controllers/smc/algorithms/classical/controller.py
index 6e93c43..b4f16ad 100644
--- a/src/controllers/smc/algorithms/classical/controller.py
+++ b/src/controllers/smc/algorithms/classical/controller.py
@@ -50,7 +50,10 @@ class ModularClassicalSMC:
         self._surface = LinearSlidingSurface(config.get_surface_gains())
         self._equivalent = EquivalentControl(
             dynamics_model=config.dynamics_model,
-            regularization=config.regularization,
+            regularization_alpha=config.regularization_alpha,
+            min_regularization=config.min_regularization,
+            max_condition_number=config.max_condition_number,
+            use_fixed_regularization=not config.use_adaptive_regularization,
             controllability_threshold=config.get_effective_controllability_threshold()
         )
         self._boundary_layer = BoundaryLayer(
diff --git a/src/controllers/smc/algorithms/super_twisting/config.py b/src/controllers/smc/algorithms/super_twisting/config.py
index 1326401..2e1f92f 100644
--- a/src/controllers/smc/algorithms/super_twisting/config.py
+++ b/src/controllers/smc/algorithms/super_twisting/config.py
@@ -43,7 +43,12 @@ class SuperTwistingSMCConfig:
     # Boundary layer and switching
     boundary_layer: float = field(default=0.01)            # Chattering reduction
     switch_method: str = field(default="tanh")             # Switching function type
-    regularization: float = field(default=1e-10)           # Numerical regularization
+
+    # Numerical stability parameters (standardized with AdaptiveRegularizer)
+    regularization_alpha: float = field(default=1e-4)      # Base regularization scaling factor
+    min_regularization: float = field(default=1e-10)       # Minimum regularization
+    max_condition_number: float = field(default=1e14)      # Maximum acceptable condition number
+    use_adaptive_regularization: bool = field(default=True) # Use adaptive vs fixed regularization
 
     # Optional dynamics model
     dynamics_model: Optional[object] = field(default=None, compare=False)
@@ -100,8 +105,13 @@ class SuperTwistingSMCConfig:
         if self.boundary_layer <= 0:
             raise ValueError("boundary_layer must be positive")
 
-        if self.regularization <= 0:
-            raise ValueError("regularization must be positive")
+        # Validate regularization parameters
+        if self.regularization_alpha <= 0:
+            raise ValueError("regularization_alpha must be positive")
+        if self.min_regularization <= 0:
+            raise ValueError("min_regularization must be positive")
+        if self.max_condition_number <= 0:
+            raise ValueError("max_condition_number must be positive")
 
         if self.switch_method not in ("tanh", "linear", "sign"):
             raise ValueError("switch_method must be 'tanh', 'linear', or 'sign'")
@@ -194,7 +204,10 @@ class SuperTwistingSMCConfig:
             'power_exponent': self.power_exponent,
             'boundary_layer': self.boundary_layer,
             'switch_method': self.switch_method,
-            'regularization': self.regularization
+            'regularization_alpha': self.regularization_alpha,
+            'min_regularization': self.min_regularization,
+            'max_condition_number': self.max_condition_number,
+            'use_adaptive_regularization': self.use_adaptive_regularization
         }
 
     @classmethod
diff --git a/src/controllers/smc/algorithms/super_twisting/controller.py b/src/controllers/smc/algorithms/super_twisting/controller.py
index 5df69ac..e9e2db1 100644
--- a/src/controllers/smc/algorithms/super_twisting/controller.py
+++ b/src/controllers/smc/algorithms/super_twisting/controller.py
@@ -58,7 +58,7 @@ class ModularSuperTwistingSMC:
             K2=config.K2,
             alpha=config.power_exponent,
             anti_windup_limit=config.get_effective_anti_windup_gain(),
-            regularization=config.regularization
+            regularization=config.min_regularization  # Use min_regularization for backward compatibility
         )
 
         # Internal state
diff --git a/src/controllers/smc/core/equivalent_control.py b/src/controllers/smc/core/equivalent_control.py
index df2a246..21e63ad 100644
--- a/src/controllers/smc/core/equivalent_control.py
+++ b/src/controllers/smc/core/equivalent_control.py
@@ -34,18 +34,23 @@ class EquivalentControl:
 
     def __init__(self,
                  dynamics_model: Optional[Any] = None,
-                 regularization: float = 1e-10,
+                 regularization_alpha: float = 1e-4,
+                 min_regularization: float = 1e-10,
+                 max_condition_number: float = 1e14,
+                 use_fixed_regularization: bool = False,
                  controllability_threshold: float = 1e-4):
         """
         Initialize equivalent control computation.
 
         Args:
             dynamics_model: System dynamics model with get_dynamics() method
-            regularization: Matrix regularization for numerical stability
+            regularization_alpha: Base regularization scaling factor (adaptive mode)
+            min_regularization: Minimum regularization for numerical stability
+            max_condition_number: Maximum acceptable condition number
+            use_fixed_regularization: Use fixed rather than adaptive regularization
             controllability_threshold: Minimum |LM^{-1}B| for equivalent control
         """
         self.dynamics_model = dynamics_model
-        self.regularization = regularization
         self.controllability_threshold = controllability_threshold
 
         # Control input matrix for cart force [force affects cart position only]
@@ -54,12 +59,12 @@ class EquivalentControl:
         # Setup logging
         self.logger = logging.getLogger(self.__class__.__name__)
 
-        # Initialize robust matrix inversion infrastructure
+        # Initialize robust matrix inversion infrastructure with centralized AdaptiveRegularizer
         self.adaptive_regularizer = AdaptiveRegularizer(
-            regularization_alpha=regularization,
-            max_condition_number=1e14,
-            min_regularization=regularization,
-            use_fixed_regularization=False
+            regularization_alpha=regularization_alpha,
+            max_condition_number=max_condition_number,
+            min_regularization=min_regularization,
+            use_fixed_regularization=use_fixed_regularization
         )
         self.matrix_inverter = MatrixInverter(regularizer=self.adaptive_regularizer)
 
@@ -173,20 +178,6 @@ class EquivalentControl:
                 # Fallback: assume unit gains
                 return np.array([0.0, 1.0, 1.0], dtype=float)
 
-    def _regularize_matrix(self, M: np.ndarray) -> np.ndarray:
-        """
-        Add regularization to matrix for numerical stability.
-
-        Args:
-            M: Matrix to regularize
-
-        Returns:
-            Regularized matrix M + Îµ*I
-        """
-        if M.ndim != 2 or M.shape[0] != M.shape[1]:
-            raise ValueError("Matrix must be square for regularization")
-
-        return M + self.regularization * np.eye(M.shape[0])
 
     def check_controllability(self, state: np.ndarray, sliding_surface) -> dict:
         """
