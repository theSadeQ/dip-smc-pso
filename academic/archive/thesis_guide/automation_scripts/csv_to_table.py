#!/usr/bin/env python
"""
CSV to LaTeX Table Converter

Converts CSV benchmark files to professionally formatted LaTeX tables
using booktabs package for publication-quality output.

Usage:
    python csv_to_table.py input.csv output.tex "Caption" "label"

Example:
    python csv_to_table.py benchmarks/baseline_performance.csv \
                          thesis/tables/baseline.tex \
                          "Baseline Performance Comparison" \
                          "tab:baseline"

Saves ~10 hours of manual table formatting!
"""

import argparse
import sys
from pathlib import Path
import pandas as pd
import re


def format_column_name(col):
    """
    Format column names for LaTeX headers.

    Args:
        col (str): Original column name

    Returns:
        str: Formatted column name
    """
    # Replace underscores with spaces
    col = col.replace('_', ' ')
    # Capitalize each word
    col = ' '.join(word.capitalize() for word in col.split())
    return col


def format_number(value):
    """
    Format numeric values for LaTeX output.

    Args:
        value: Number to format

    Returns:
        str: Formatted string
    """
    if pd.isna(value):
        return '--'

    if isinstance(value, (int, float)):
        # Scientific notation for very small/large numbers
        if abs(value) < 0.001 and value != 0:
            return f"{value:.2e}"
        # Regular formatting for normal numbers
        elif abs(value) < 1000:
            return f"{value:.3f}"
        else:
            return f"{value:.1f}"

    return str(value)


def escape_latex(text):
    """
    Escape special LaTeX characters in text.

    Args:
        text (str): Text to escape

    Returns:
        str: Escaped text
    """
    if not isinstance(text, str):
        return text

    replacements = {
        '%': '\\%',
        '&': '\\&',
        '#': '\\#',
        '_': '\\_',
        '{': '\\{',
        '}': '\\}',
        '~': '\\textasciitilde{}',
        '^': '\\textasciicircum{}',
    }

    for char, escaped in replacements.items():
        text = text.replace(char, escaped)

    return text


def generate_column_format(num_cols, has_row_names=True):
    """
    Generate LaTeX column format string.

    Args:
        num_cols (int): Number of columns
        has_row_names (bool): Whether first column is row names

    Returns:
        str: Column format (e.g., "lcccc")
    """
    if has_row_names:
        # First column left-aligned, rest center-aligned
        return 'l' + 'c' * (num_cols - 1)
    else:
        # All columns center-aligned
        return 'c' * num_cols


def csv_to_latex_table(csv_path, output_path, caption, label,
                       bold_best=False, precision=3):
    """
    Convert CSV file to LaTeX table with booktabs formatting.

    Args:
        csv_path (Path): Input CSV file path
        output_path (Path): Output .tex file path
        caption (str): Table caption
        label (str): LaTeX label (e.g., "tab:baseline")
        bold_best (bool): Bold minimum values in each numeric column
        precision (int): Decimal precision for floats

    Returns:
        bool: True if successful
    """
    try:
        # Read CSV
        print(f"[INFO] Reading: {csv_path}")
        df = pd.read_csv(csv_path)

        if df.empty:
            print(f"[ERROR] CSV file is empty: {csv_path}")
            return False

        print(f"[INFO] Loaded {len(df)} rows × {len(df.columns)} columns")

        # Generate column format
        num_cols = len(df.columns)
        col_format = generate_column_format(num_cols)

        # Start building LaTeX
        latex_lines = []
        latex_lines.append("% Auto-generated LaTeX table from CSV")
        latex_lines.append("% Generated by csv_to_table.py")
        latex_lines.append("")
        latex_lines.append("\\begin{table}[htbp]")
        latex_lines.append("\\centering")
        latex_lines.append(f"\\caption{{{caption}}}")
        latex_lines.append(f"\\label{{{label}}}")
        latex_lines.append(f"\\begin{{tabular}}{{{col_format}}}")
        latex_lines.append("\\toprule")

        # Header row
        headers = [format_column_name(col) for col in df.columns]
        latex_lines.append(" & ".join(headers) + " \\\\")
        latex_lines.append("\\midrule")

        # Find minimum values for bolding (if enabled)
        min_values = {}
        if bold_best:
            for col in df.columns:
                if pd.api.types.is_numeric_dtype(df[col]):
                    min_values[col] = df[col].min()

        # Data rows
        for idx, row in df.iterrows():
            row_values = []
            for col in df.columns:
                value = row[col]

                # Format value
                if pd.api.types.is_numeric_dtype(df[col]):
                    formatted = format_number(value)

                    # Bold if minimum value
                    if bold_best and col in min_values and value == min_values[col]:
                        formatted = f"\\textbf{{{formatted}}}"
                else:
                    formatted = escape_latex(str(value))

                row_values.append(formatted)

            latex_lines.append(" & ".join(row_values) + " \\\\")

        # Close table
        latex_lines.append("\\bottomrule")
        latex_lines.append("\\end{tabular}")
        latex_lines.append("\\end{table}")
        latex_lines.append("")

        # Write output
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(latex_lines))

        print(f"[OK] Written to: {output_path}")
        print(f"[INFO] Table: {len(df)} rows × {len(df.columns)} columns")

        return True

    except Exception as e:
        print(f"[ERROR] Failed to convert: {e}")
        return False


def main():
    parser = argparse.ArgumentParser(
        description='Convert CSV to LaTeX table with booktabs formatting',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python csv_to_table.py benchmarks/baseline_performance.csv \\
                        thesis/tables/baseline.tex \\
                        "Baseline Performance Comparison" \\
                        "tab:baseline"

  python csv_to_table.py benchmarks/comprehensive_benchmark.csv \\
                        thesis/tables/comprehensive.tex \\
                        "Comprehensive Controller Benchmark" \\
                        "tab:comprehensive" \\
                        --bold-best

Features:
  - Automatic column formatting (left for names, center for numbers)
  - Scientific notation for very small/large numbers
  - LaTeX special character escaping
  - Optional bold formatting for best (minimum) values
  - Booktabs styling (professional horizontal rules)
        """
    )

    parser.add_argument('input', help='Input CSV file')
    parser.add_argument('output', help='Output LaTeX file')
    parser.add_argument('caption', help='Table caption')
    parser.add_argument('label', help='LaTeX label (e.g., "tab:baseline")')
    parser.add_argument('--bold-best', action='store_true',
                       help='Bold minimum values in numeric columns')
    parser.add_argument('--precision', type=int, default=3,
                       help='Decimal precision for floats (default: 3)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Print output instead of writing to file')

    args = parser.parse_args()

    # Validate input
    input_path = Path(args.input)
    if not input_path.exists():
        print(f"[ERROR] Input file not found: {args.input}")
        sys.exit(1)

    output_path = Path(args.output)

    # Convert
    if args.dry_run:
        print("[INFO] Dry run mode - output preview:")
        print("=" * 80)

        # Read and display first few rows
        df = pd.read_csv(input_path)
        print(f"CSV Preview ({len(df)} rows × {len(df.columns)} columns):")
        print(df.head())
        print()
        print("LaTeX output would be written to:", args.output)
    else:
        success = csv_to_latex_table(
            input_path,
            output_path,
            args.caption,
            args.label,
            bold_best=args.bold_best,
            precision=args.precision
        )

        if not success:
            sys.exit(1)


if __name__ == '__main__':
    main()
