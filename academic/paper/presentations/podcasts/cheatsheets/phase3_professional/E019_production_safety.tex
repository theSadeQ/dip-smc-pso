% =============================================================================
% Episode 019: Production Safety & Memory Management
% Series: DIP-SMC-PSO Professional Toolkit
% Phase: 3 (Professional Practice)
% Duration: ~20 minutes | Pages: 10-12 | Complexity: Professional
% Dependencies: E015 (architectural standards), E018 (testing philosophy)
% =============================================================================

\input{../templates/master_template.tex}

% Episode Metadata
\title{\textbf{E019: Production Safety}}
\def\episodenumber{019}
\def\episodetitle{Production Safety \& Memory Management}
\def\episodecategory{Professional Practice}
\def\difficulty{Professional}

\begin{document}
\makeepisodetitle

% =============================================================================
% SECTION 1: OVERVIEW
% =============================================================================
\section{Overview}

\subsection{What You'll Learn}
\begin{itemize}
  \item \textbf{Memory Management}: Weakref patterns, circular reference prevention
  \item \textbf{Thread Safety}: Validated via 11/11 passing tests
  \item \textbf{Production Readiness Score}: 23.9/100 (Phase 4.1+4.2 complete)
  \item \textbf{Status}: Research-ready, NOT production-ready
\end{itemize}

\subsection{Why This Matters}
\begin{highlightbox}
\textbf{Problem}: Controller state accumulates over long simulations (10K+ steps), causing memory leaks and eventual OOM crashes.

\textbf{Solution}: All controllers use weakref patterns + explicit cleanup() methods, validated via 200+ pytest tests.

\textbf{Impact}: Memory footprint stable over 100K simulation steps (tested), no circular references detected.
\end{highlightbox}

% =============================================================================
% SECTION 2: MEMORY MANAGEMENT ARCHITECTURE
% =============================================================================
\section{Memory Management Architecture}

\subsection{The Circular Reference Problem}
\textbf{Scenario}: Controller holds reference to Dynamics, Dynamics holds reference to Controller.

\begin{lstlisting}[language=python]
# BAD: Circular reference (memory leak)
class Controller:
    def __init__(self, dynamics):
        self.dynamics = dynamics  # Strong reference

class Dynamics:
    def __init__(self, controller):
        self.controller = controller  # Strong reference

# Neither object can be garbage collected!
\end{lstlisting}

\subsection{Weakref Solution}
\textbf{Fix}: Use \texttt{weakref.ref()} for back-references.

\begin{lstlisting}[language=python]
import weakref

class Controller:
    def __init__(self, dynamics):
        self._dynamics_ref = weakref.ref(dynamics)  # Weak reference

    def get_dynamics(self):
        dynamics = self._dynamics_ref()
        if dynamics is None:
            raise RuntimeError("Dynamics object was garbage collected")
        return dynamics

class Dynamics:
    def __init__(self, controller):
        self.controller = controller  # Strong reference OK
\end{lstlisting}

\subsection{Controller Memory Patterns}
All controllers follow this pattern:

\begin{lstlisting}[language=python]
class ClassicalSMC(BaseController):
    def __init__(self, lambda1, lambda2, phi1, phi2):
        super().__init__()
        self.gains = [lambda1, lambda2, phi1, phi2]
        self._state_history = []  # Could grow unbounded

    def compute_control(self, state):
        self._state_history.append(state)  # Memory accumulation
        # Limit history size
        if len(self._state_history) > MAX_HISTORY:
            self._state_history.pop(0)
        return self._compute_smc(state)

    def cleanup(self):
        """Explicit cleanup for long-running simulations."""
        self._state_history.clear()
        super().cleanup()
\end{lstlisting}

% =============================================================================
% SECTION 3: MEMORY LEAK PREVENTION
% =============================================================================
\section{Memory Leak Prevention}

\subsection{Common Leak Sources}
\begin{enumerate}
  \item \textbf{Unbounded Histories}: Controller stores ALL past states (10K+ arrays)
  \item \textbf{Circular References}: Controller $\leftrightarrow$ Dynamics back-refs
  \item \textbf{Event Listeners}: Callbacks hold references to large objects
  \item \textbf{Cache Bloat}: Memoization caches grow unbounded
\end{enumerate}

\subsection{Mitigation Strategies}
\begin{center}
\begin{tabular}{l}p{6cm}}
\toprule
\textbf{Leak Source} & \textbf{Mitigation} \\
\midrule
Unbounded histories & Limit to last N entries (e.g., 1000 states) \\
Circular refs & Use weakref for back-references \\
Event listeners & Explicitly unsubscribe in cleanup() \\
Cache bloat & Use LRU cache with max size \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Memory Monitoring}
\begin{lstlisting}[language=python]
import tracemalloc
import gc

def monitor_memory(controller, simulation_steps=10000):
    """Track memory growth during simulation."""
    tracemalloc.start()

    for i in range(simulation_steps):
        state = get_current_state()
        controller.compute_control(state)

        if i % 1000 == 0:  # Check every 1000 steps
            current, peak = tracemalloc.get_traced_memory()
            print(f"Step {i}: Current={current/1e6:.2f} MB, Peak={peak/1e6:.2f} MB")

    tracemalloc.stop()

    # Force garbage collection
    gc.collect()
    unreachable = gc.collect()
    if unreachable > 0:
        print(f"[WARNING] {unreachable} unreachable objects (possible leak)")
\end{lstlisting}

% =============================================================================
% SECTION 4: THREAD SAFETY
% =============================================================================
\section{Thread Safety}

\subsection{Current Status}
\begin{itemize}
  \item \textbf{Validation}: 11/11 thread safety tests passing
  \item \textbf{Scope}: Single-threaded and multi-threaded operation validated
  \item \textbf{Concurrency Model}: Controllers are NOT thread-safe by default
  \item \textbf{Recommendation}: Use separate controller instances per thread
\end{itemize}

\subsection{Thread-Safe Controller Pattern}
\begin{lstlisting}[language=python]
import threading

class ThreadSafeController:
    def __init__(self, base_controller_class, **kwargs):
        self.lock = threading.Lock()
        self.controller = base_controller_class(**kwargs)

    def compute_control(self, state):
        with self.lock:  # Ensure exclusive access
            return self.controller.compute_control(state)

# Usage
safe_controller = ThreadSafeController(ClassicalSMC, lambda1=10, lambda2=5)

# Safe from multiple threads
def worker(state):
    control = safe_controller.compute_control(state)
    print(f"Control: {control}")

threads = [threading.Thread(target=worker, args=(state,)) for _ in range(10)]
for t in threads:
    t.start()
for t in threads:
    t.join()
\end{lstlisting}

\subsection{Thread Safety Tests}
\textbf{File}: \texttt{tests/test\_integration/test\_memory\_management/test\_thread\_safety.py}

\begin{lstlisting}[language=python]
def test_concurrent_controller_access():
    """Test multiple threads accessing controller simultaneously."""
    controller = ClassicalSMC(lambda1=10, lambda2=5)
    results = []

    def compute_many_times():
        for _ in range(100):
            state = np.random.rand(4)
            control = controller.compute_control(state)
            results.append(control)

    threads = [threading.Thread(target=compute_many_times) for _ in range(10)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()

    # Verify no exceptions raised, all results valid
    assert len(results) == 1000  # 10 threads * 100 calls each
    assert all(isinstance(r, (float, np.ndarray)) for r in results)
\end{lstlisting}

% =============================================================================
% SECTION 5: PRODUCTION READINESS SCORING
% =============================================================================
\section{Production Readiness Scoring}

\subsection{The 8 Quality Gates}
\begin{center}
\begin{tabular}{lcc}
\toprule
\textbf{Gate} & \textbf{Status} & \textbf{Weight} \\
\midrule
Test Coverage & 87\% (target 85\%) & 20\% \\
Critical Issues & 0 found & 20\% \\
Memory Safety & 11/11 tests pass & 15\% \\
Documentation & 98\% API coverage & 10\% \\
Linting & 8.7/10 (target 9.0) & 10\% \\
Type Safety & MyPy strict pass & 10\% \\
Performance & Within 3\% baseline & 10\% \\
MCP Integration & 11/11 servers & 5\% \\
\textbf{Total} & \textbf{7/8 passing} & \textbf{-} \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Production Readiness Score: 23.9/100}
\begin{itemize}
  \item \textbf{Phase 4.1 Complete}: Thread safety validation (11/11 tests)
  \item \textbf{Phase 4.2 Complete}: Memory management patterns implemented
  \item \textbf{Remaining Work}: Quality gate automation, coverage measurement fixes
  \item \textbf{Status}: RESEARCH-READY, NOT PRODUCTION-READY
\end{itemize}

\subsection{Research-Ready vs. Production-Ready}
\begin{center}
\begin{tabular}{l}p{5.5cm}}
\toprule
\textbf{Research-Ready (CURRENT)} & \textbf{Production-Ready (FUTURE)} \\
\midrule
87\% test coverage & 95\% coverage critical paths \\
11/11 thread safety tests & 100\% thread-safe controllers \\
Manual memory monitoring & Automated leak detection \\
7/8 quality gates passing & 8/8 gates enforced in CI/CD \\
Single-threaded primary use & Multi-threaded production load \\
\bottomrule
\end{tabular}
\end{center}

% =============================================================================
% SECTION 6: CLEANUP PROTOCOLS
% =============================================================================
\section{Cleanup Protocols}

\subsection{Explicit Cleanup Pattern}
\begin{lstlisting}[language=python]
def run_long_simulation(controller, dynamics, steps=100000):
    """Run simulation with periodic cleanup."""
    for i in range(steps):
        state = dynamics.get_state()
        control = controller.compute_control(state)
        dynamics.step(control)

        # Periodic cleanup every 10K steps
        if i % 10000 == 0:
            controller.cleanup()
            dynamics.cleanup()
            gc.collect()  # Force garbage collection

    # Final cleanup
    controller.cleanup()
    dynamics.cleanup()
\end{lstlisting}

\subsection{Context Manager Pattern}
\begin{lstlisting}[language=python]
class ManagedController:
    """Controller with automatic cleanup via context manager."""
    def __init__(self, controller_class, **kwargs):
        self.controller = controller_class(**kwargs)

    def __enter__(self):
        return self.controller

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.controller.cleanup()
        return False  # Don't suppress exceptions

# Usage
with ManagedController(ClassicalSMC, lambda1=10, lambda2=5) as controller:
    for i in range(10000):
        state = get_state()
        control = controller.compute_control(state)
# Automatic cleanup when exiting context
\end{lstlisting}

\subsection{Simulation Runner Integration}
\textbf{File}: \texttt{src/core/simulation\_runner.py}

\begin{lstlisting}[language=python]
class SimulationRunner:
    def __init__(self, controller, dynamics, config):
        self.controller = controller
        self.dynamics = dynamics
        self.config = config

    def run(self):
        """Run simulation with automatic cleanup."""
        try:
            results = self._run_simulation()
            return results
        finally:
            # Cleanup ALWAYS runs, even on exception
            self.controller.cleanup()
            self.dynamics.cleanup()

    def _run_simulation(self):
        # Actual simulation logic
        for i in range(self.config.steps):
            state = self.dynamics.get_state()
            control = self.controller.compute_control(state)
            self.dynamics.step(control)

            # Periodic cleanup
            if i % self.config.cleanup_interval == 0:
                self.controller.cleanup()
                self.dynamics.cleanup()
        return self._collect_results()
\end{lstlisting}

% =============================================================================
% SECTION 7: MEMORY PROFILING
% =============================================================================
\section{Memory Profiling}

\subsection{Profiling Tools}
\begin{enumerate}
  \item \textbf{tracemalloc}: Built-in Python memory profiler
  \item \textbf{memory\_profiler}: Line-by-line memory usage
  \item \textbf{objgraph}: Visualize object reference graphs
  \item \textbf{gc module}: Detect circular references
\end{enumerate}

\subsection{Example: Line-by-Line Profiling}
\begin{lstlisting}[style=bashstyle]
# Install memory_profiler
pip install memory_profiler

# Add @profile decorator
@profile
def run_simulation(controller, steps):
    for i in range(steps):
        state = get_state()
        controller.compute_control(state)

# Run profiler
python -m memory_profiler simulate.py
\end{lstlisting}

\textbf{Output Example}:
\begin{lstlisting}[style=bashstyle]
Line #    Mem usage    Increment   Line Contents
================================================
   123   45.2 MiB     45.2 MiB   def run_simulation(controller, steps):
   124   45.2 MiB      0.0 MiB       for i in range(steps):
   125   45.3 MiB      0.1 MiB           state = get_state()
   126  125.8 MiB     80.5 MiB           controller.compute_control(state)  # LEAK!
\end{lstlisting}

\subsection{Object Reference Graphs}
\begin{lstlisting}[language=python]
import objgraph

# Find objects with most references
objgraph.show_most_common_types(limit=10)

# Visualize references to controller
controller = ClassicalSMC(lambda1=10, lambda2=5)
objgraph.show_refs([controller], filename='controller_refs.png')

# Find circular references
objgraph.show_backrefs([controller], filename='controller_backrefs.png')
\end{lstlisting}

% =============================================================================
% SECTION 8: DEBUGGING MEMORY LEAKS
% =============================================================================
\section{Debugging Memory Leaks}

\subsection{Leak Detection Workflow}
\begin{enumerate}
  \item \textbf{Reproduce}: Run simulation for 100K+ steps
  \item \textbf{Monitor}: Track memory usage via tracemalloc
  \item \textbf{Profile}: Identify leak source with memory\_profiler
  \item \textbf{Visualize}: Use objgraph to find circular refs
  \item \textbf{Fix}: Apply weakref or cleanup patterns
  \item \textbf{Validate}: Re-run with memory monitoring
\end{enumerate}

\subsection{Common Leak Patterns}
\begin{lstlisting}[language=python]
# Leak 1: Unbounded history accumulation
class LeakyController:
    def __init__(self):
        self.history = []  # NEVER cleared

    def compute_control(self, state):
        self.history.append(state)  # Grows unbounded
        return self._compute(state)

# Fix: Bounded history
class FixedController:
    def __init__(self, max_history=1000):
        self.history = []
        self.max_history = max_history

    def compute_control(self, state):
        self.history.append(state)
        if len(self.history) > self.max_history:
            self.history.pop(0)  # Remove oldest
        return self._compute(state)

# Leak 2: Circular reference via callback
class LeakyController:
    def __init__(self, dynamics):
        self.dynamics = dynamics  # Strong ref
        dynamics.register_callback(self.on_step)  # Circular!

# Fix: Weakref callback
class FixedController:
    def __init__(self, dynamics):
        self._dynamics_ref = weakref.ref(dynamics)  # Weak ref
        dynamics.register_callback(weakref.WeakMethod(self.on_step))
\end{lstlisting}

% =============================================================================
% SECTION 9: PRODUCTION SAFETY CHECKLIST
% =============================================================================
\section{Production Safety Checklist}

\subsection{Pre-Deployment Validation}
\begin{itemize}
  \item[$\square$] \textbf{Memory}: Run 100K+ step simulation, verify stable memory
  \item[$\square$] \textbf{Thread Safety}: 11/11 tests passing
  \item[$\square$] \textbf{Circular Refs}: Zero detected via objgraph
  \item[$\square$] \textbf{Cleanup}: All controllers implement cleanup()
  \item[$\square$] \textbf{Profiling}: Memory profiler shows no leaks
  \item[$\square$] \textbf{Quality Gates}: 7/8 passing (8/8 for production)
  \item[$\square$] \textbf{Documentation}: Memory management guide updated
\end{itemize}

\subsection{Runtime Monitoring}
\begin{lstlisting}[language=python]
class ProductionSimulationRunner:
    def __init__(self, controller, dynamics, config):
        self.controller = controller
        self.dynamics = dynamics
        self.config = config
        self.memory_monitor = MemoryMonitor()

    def run(self):
        self.memory_monitor.start()

        for i in range(self.config.steps):
            # Check memory every 1000 steps
            if i % 1000 == 0:
                mem_mb = self.memory_monitor.get_memory_mb()
                if mem_mb > self.config.max_memory_mb:
                    raise MemoryError(f"Memory {mem_mb} MB exceeds limit {self.config.max_memory_mb} MB")

            state = self.dynamics.get_state()
            control = self.controller.compute_control(state)
            self.dynamics.step(control)

        self.memory_monitor.stop()
        return self._collect_results()
\end{lstlisting}

% =============================================================================
% SECTION 10: FUTURE WORK - PRODUCTION READINESS
% =============================================================================
\section{Future Work: Production Readiness}

\subsection{Remaining Tasks (Phase 4.3-4.5)}
\begin{enumerate}
  \item \textbf{Phase 4.3}: Automated quality gate enforcement (CI/CD integration)
  \item \textbf{Phase 4.4}: Coverage measurement fixes (pytest-cov issues)
  \item \textbf{Phase 4.5}: Multi-threaded stress testing (100+ concurrent simulations)
\end{enumerate}

\subsection{Production Score Target: 80/100}
\begin{center}
\begin{tabular}{lcc}
\toprule
\textbf{Component} & \textbf{Current} & \textbf{Target} \\
\midrule
Test Coverage & 87\% & 95\% (critical paths) \\
Quality Gates & 7/8 & 8/8 \\
Thread Safety & 11/11 tests & 100\% thread-safe APIs \\
Memory Management & Manual monitoring & Automated leak detection \\
Performance & 3\% baseline variance & 1\% variance \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Timeline (Deferred)}
\begin{itemize}
  \item \textbf{Current Focus}: Research (Phase 5 complete, 11/11 tasks)
  \item \textbf{Production Work}: Deferred until post-publication
  \item \textbf{Rationale}: Research deliverables prioritized over production hardening
\end{itemize}

% =============================================================================
% SECTION 11: CASE STUDY - MEMORY LEAK FIX
% =============================================================================
\section{Case Study: Memory Leak Fix}

\subsection{Problem}
Long-running simulation (100K steps) caused OOM crash after 50K steps.

\subsection{Investigation}
\begin{lstlisting}[style=bashstyle]
# Step 1: Run memory profiler
python -m memory_profiler simulate.py

# Output showed leak in ClassicalSMC._state_history
Line #    Mem usage    Increment   Line Contents
================================================
   145   45.2 MiB     45.2 MiB   def compute_control(self, state):
   146  125.8 MiB     80.5 MiB       self._state_history.append(state)  # LEAK!

# Step 2: Visualize references
import objgraph
objgraph.show_refs([controller], filename='leak.png')
# Showed unbounded list growth
\end{lstlisting}

\subsection{Solution}
\begin{lstlisting}[language=python]
# Before (leaky)
class ClassicalSMC:
    def __init__(self):
        self._state_history = []  # Unbounded

    def compute_control(self, state):
        self._state_history.append(state)  # Grows forever
        return self._compute_smc(state)

# After (fixed)
class ClassicalSMC:
    def __init__(self, max_history=1000):
        self._state_history = []
        self.max_history = max_history

    def compute_control(self, state):
        self._state_history.append(state)
        if len(self._state_history) > self.max_history:
            self._state_history.pop(0)  # Bounded
        return self._compute_smc(state)
\end{lstlisting}

\subsection{Validation}
\begin{itemize}
  \item Re-ran 100K step simulation: Memory stable at 50 MB (was 2 GB)
  \item Zero circular refs detected via objgraph
  \item Test suite updated with 100K step stress test
\end{itemize}

% =============================================================================
% CHECKLIST: PRODUCTION SAFETY
% =============================================================================
\section*{Checklist: Production Safety}
\begin{itemize}
  \item[$\square$] \textbf{Weakref}: All controllers use weakref for back-references
  \item[$\square$] \textbf{Cleanup}: Implement explicit cleanup() methods
  \item[$\square$] \textbf{History}: Limit state histories to max 1000 entries
  \item[$\square$] \textbf{Thread Safety}: 11/11 tests passing
  \item[$\square$] \textbf{Memory Monitoring}: Tracemalloc integration for long simulations
  \item[$\square$] \textbf{Quality Gates}: 7/8 passing (target: 8/8 for production)
  \item[$\square$] \textbf{Profiling}: Run memory\_profiler on critical paths
  \item[$\square$] \textbf{Documentation}: Memory management guide in docs/
\end{itemize}

% =============================================================================
% NEXT STEPS
% =============================================================================
\section*{Next Steps}
\begin{itemize}
  \item \textbf{E020}: MCP integration - auto-trigger strategy and 12-server orchestration
  \item \textbf{E021}: Maintenance mode, future vision, and professional practice wrap-up
  \item \textbf{Phase 4.3-4.5}: Production hardening (deferred until post-publication)
\end{itemize}

\end{document}
