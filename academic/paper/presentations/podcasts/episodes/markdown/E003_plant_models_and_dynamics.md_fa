# E003: مدل‌های گیاه و دینامیک

**[یادداشت صوتی: این قسمت درباره فیزیک است — معادلات واقعی حرکت آونگ دوگانه ما. مستقیم سراغ شهود می‌رویم و جبر خسته‌کننده را حذف می‌کنیم. اگر مشتاق هستید مشتقات کامل در توضیحات آمده‌اند، اما برای فهم کارکرد لازم نیست.]**

## مقدمه: گیاه چیست؟

در نظریه کنترل، «گیاه» همان چیزی است که می‌خواهید کنترل کنید — خود سامانه فیزیکی. در E001 و E002 درباره کنترل‌گرها (مغز تصمیم‌گیر) صحبت کردیم. حالا درباره گیاه (بدنِ اجراکننده تصمیم‌ها) حرف می‌زنیم.

برای آونگ دوگانه وارونه، مدل گیاه مجموعه‌ای از معادلات است که به این سؤال جواب می‌دهد: «اگر همین حالا به گاری نیروی F وارد کنم، زاویه‌ها و سرعت‌های آونگ در میلی‌ثانیه بعد چگونه تغییر می‌کنند؟»

**همان موشک SpaceX را یادتان هست؟** مدل گیاه برای موشک توضیح می‌دهد نیروهای رانش چگونه به تغییرات موقعیت و سرعت تبدیل می‌شوند، با درنظرگرفتن جرم، ممان اینرسی، درگ آیرودینامیکی و گرانش. مفهوم یکی است، سیستم فرق دارد.

این قسمت پوشش می‌دهد:
- چرا از مکانیک لاگرانژی استفاده می‌کنیم (و جبر دردناک را رد می‌کنیم)
- سه مدل: دونده سریع، شبیه‌ساز، و حرفه‌ای کارا
- دقت مدل در برابر هزینه محاسباتی
- تکینی‌ها (جایی که ریاضی قفل می‌کند) و معنای فیزیکی آن
- اجرای همه این‌ها در کد پایتون

## توصیف سیستم فیزیکی: دو جاروب دوباره

تصویر سیستم: یک گاری که روی ریل افقی چپ و راست می‌لغزد. روی گاری یک آونگ عمودی است (جاروب پایینی). روی بالای آن، آونگ دوم متصل است (جاروب بالایی). هر دو آزادانه می‌چرخند.

**نمودار ASCII** در توضیحات آمده، اما شهود این است:
- **گاری**: جرم دارد، روی ریل با اصطکاک کم حرکت می‌کند، با نیروی افقی کنترل می‌شود
- **آونگ 1** (پایینی): جرم و طول دارد، حول مفصل روی گاری می‌چرخد
- **آونگ 2** (بالایی): جرم و طول دارد، حول مفصل بالای آونگ 1 می‌چرخد

**سه مختصه‌ای که دنبال می‌کنیم:**
1. **x**: موقعیت گاری (چقدر روی ریل جابجا شده)
2. **theta-1**: زاویه آونگ اول (نسبت به عمود — صفر یعنی کاملاً قائم)
3. **theta-2**: زاویه آونگ دوم (نسبت به عمود)

**اعداد واقعی:**
پیکربندی پیش‌فرض ما یک نمونه آزمایشگاهی واقع‌گرایانه است:
- گاری: 1.5 کیلوگرم (تقریباً وزن یک لپ‌تاپ)
- آونگ 1: 0.2 کیلوگرم، 40 سانتی‌متر (مثل یک خط‌کش چوبی)
- آونگ 2: 0.15 کیلوگرم، 30 سانتی‌متر (کمی سبک‌تر و کوتاه‌تر)
- اصطکاک: کم اما غیرصفر (مقداری مقاومت در مفصل‌ها و گاری)

این اعداد تصادفی نیستند — مشابه تجهیزاتی هستند که در آزمایشگاه‌های کنترل دانشگاه‌ها می‌بینید.

## مکانیک لاگرانژی: میان‌بر زیبا

**[یادداشت صوتی: جبر را کنار می‌گذاریم. تمرکز روی این است که چرا این روش عالی است، نه اینکه چگونه مشتق‌گیری کنیم]**

### چرا لاگرانژ به‌جای قوانین نیوتن؟

اگر بخواهید با F=ma مستقیم تحلیل کنید، باید:

1. برای گاری، آونگ اول، آونگ دوم نمودار نیروی آزاد بکشید
2. همه نیروهای داخلی را حساب کنید — نیروی پین، واکنش‌ها، و غیره
3. برای هر جزء معادله نیرو بنویسید
4. یک دستگاه معادلات کوپل‌شده با تعداد زیادی مجهول داخلی حل کنید

این یک **کابوس** است؛ ده‌ها متغیر که حتی برایتان مهم نیستند. شما فقط می‌خواهید بدانید سامانه چگونه حرکت می‌کند.

**رویکرد لاگرانژی: چسب داخلی را نادیده بگیر**

مکانیک لاگرانژی میان‌بری درخشان است. نکته کلیدی: اگر روی انرژی تمرکز کنید، لازم نیست نیروهای قیودی داخلی (مثل نیروهای پین) را بدانید. دستورالعمل:

1. **انرژی جنبشی کل را حساب کن**: حرکت گاری + حرکت و دوران دو آونگ. پیچیده است چون حرکت آونگ 2 به آونگ 1 وابسته است، اما شدنی است.
2. **انرژی پتانسیل کل را حساب کن**: انرژی گرانشی سیستم.
3. **لاگرانژین بساز**: L = انرژی جنبشی - انرژی پتانسیل. این تابع کل دینامیک را در خود دارد.
4. **معادلات اویلر-لاگرانژ**: یک دستورالعمل منظم که معادلات حرکت را می‌دهد — بدون نیروهای داخلی.

**نتیجه زیبا:**

پس از محاسبات (که انجام نمی‌دهیم)، به یک معادله ماتریسی می‌رسید:

**M(q) أ— acceleration + C(q,qج‡) أ— velocity + G(q) = B أ— control force + disturbances**

معنای هر ماتریس:

- **M(q) - ماتریس جرم**: توزیع جرم و اینرسی. «اگر بخواهم گاری را با 1 m/s² شتاب دهم و آونگ‌ها در این زاویه‌ها باشند، چه نیرویی لازم است؟» پاسخ به زاویه‌ها وابسته است.

- **C(q,qج‡) - نیروهای چرخشی**: ترم‌های کوریولیس و گریز از مرکز. مثل وقتی ماشین پیچ می‌زند و به در فشار می‌آورید (گریز از مرکز)، یا وقتی روی گردونه مسیرتان منحرف می‌شود (کوریولیس).

- **G(q) - گرانش**: گرانش روی هر جزء چقدر گشتاور ایجاد می‌کند؟ بسته به زاویه‌ها.

- **B - توزیع ورودی**: نیرو مستقیم فقط به گاری وارد می‌شود، اما اثر آن به‌طور غیرمستقیم به آونگ‌ها می‌رسد.

## ساختار ماتریس جرم: کنش و واکنش

**[یادداشت صوتی: اینجا کوپل‌شدن اجزا به‌صورت ریاضی ظاهر می‌شود]**

ماتریس جرم یک ماتریس 3×3 است که با زاویه‌های آونگ تغییر می‌کند. شهود:

**درایه‌های قطری** (M11, M22, M33):
این‌ها «اینرسی خودی» هستند — سختی شتاب دادن هر جزء به‌تنهایی. M11 جرم کل است (گاری + آونگ‌ها). M22 اینرسی دورانی آونگ 1 و M33 اینرسی دورانی آونگ 2 است.

**درایه‌های خارج از قطر** (M12, M13, M23):
این‌ها **ترم‌های کوپل‌شده** هستند — حرکت یک جزء چگونه دیگری را تحت تاثیر قرار می‌دهد. مثلا M12 می‌گوید: «اگر گاری را شتاب بدهم، چه گشتاوری به آونگ 1 وارد می‌شود؟» این به cos(theta-1) وابسته است.

**ویژگی کلیدی — تقارن:**
ماتریس متقارن است: M12=M21، M13=M31، M23=M32. این همان قانون سوم نیوتن است — کنش و واکنش برابر.

**در کد:**
پیاده‌سازی پایتون همه این درایه‌ها را بر اساس زاویه‌ها محاسبه می‌کند و یک آرایه 3×3 برمی‌گرداند که معکوس می‌کنیم.

### تکینی‌ها: وقتی ریاضی قفل می‌کند

**[یادداشت صوتی: اینجا فیزیک می‌شکند — و یک معنای واضح دارد]**

به بازوی خود فکر کنید. وقتی آرنج را کاملا صاف می‌کنید، دیگر در آن جهت نمی‌توانید هل دهید. هندسه «قفل» شده است. همین اتفاق برای آونگ در برخی پیکربندی‌ها رخ می‌دهد.

**چه چیزی تکینی ایجاد می‌کند؟**

برای آونگ دوگانه، تکینی‌ها وقتی رخ می‌دهند که آونگ‌ها در وضعیت‌های خاصی هم‌راستا می‌شوند. مثلا وقتی هر دو کاملا افقی باشند، ماتریس جرم نزدیک به تکین می‌شود؛ چون برخی حرکات از نظر مکانیکی قفل شده‌اند و برای شتاب دادن به آن‌ها نیروی بی‌نهایت لازم می‌شود.

**عدد شرط — معاینه سلامت:**

عدد شرط نشان می‌دهد ماتریس چقدر به تکین نزدیک است:
- **خ؛ حدود 1 تا 100**: سالم
- **خ؛ بالای 1 میلیون**: بیمار (خطای عددی تقویت می‌شود)
- **خ؛ نزدیک بی‌نهایت**: مرده (تکین)

**در کد چگونه مدیریت می‌کنیم؟**

قبل از معکوس گرفتن، عدد شرط را چک می‌کنیم. اگر خیلی بزرگ باشد (مثلا بالای 100 میلیون)، به‌جای معکوس مستقیم از شبه‌معکوس با منظم‌سازی استفاده می‌کنیم — کمی «بالشتک عددی» برای جلوگیری از تقسیم بر نزدیک صفر.

**در عمل:**

نزدیک وضعیت قائم، عدد شرط سالم است (10 تا 100). خطر زمانی است که آونگ‌ها به سمت افق می‌روند. کنترل‌گر طوری طراحی شده که از این وضعیت‌ها دوری کند.

## ترم‌های کوریولیس و گریز از مرکز

### ماتریس کوریولیس/گریز از مرکز

```python
def _compute_coriolis_matrix(self, theta1: float, theta2: float,
                            theta1_dot: float, theta2_dot: float) -> np.ndarray:
    """
    Compute C(q,qج‡) matrix.

    Contains:
    - Coriolis terms (velocity-dependent coupling)
    - Centrifugal terms (velocity-squared terms)
    """
    s1 = np.sin(theta1)
    s2 = np.sin(theta2)
    s12 = np.sin(theta1 - theta2)

    # Coriolis/centrifugal coefficients
    c1 = self.m1 * self.lc1 + self.m2 * self.L1
    c2 = self.m2 * self.lc2
    c12 = self.m2 * self.L1 * self.lc2

    C = np.zeros((3, 3))

    # First row (cart equation)
    C[0, 1] = -c1 * s1 * theta1_dot
    C[0, 2] = -c2 * s2 * theta2_dot

    # Second row (pendulum 1 equation)
    C[1, 0] = -c1 * s1 * theta1_dot
    C[1, 2] = -c12 * s12 * theta2_dot

    # Third row (pendulum 2 equation)
    C[2, 0] = -c2 * s2 * theta2_dot
    C[2, 1] = c12 * s12 * theta1_dot

    return C
```

**تفسیر فیزیکی:**

**نیروی کوریولیس**: نیروی ظاهری ناشی از چرخش
- مثال: وقتی آونگ 1 می‌چرخد، نیروهایی روی گاری و آونگ 2 القا می‌شود
- ترم: `-c12 * sin(خ¸â‚پ - خ¸â‚‚) * خ¸ج‡â‚‚` سرعت آونگ‌ها را کوپل می‌کند

**نیروی گریز از مرکز**: نیروی رو به بیرون ناشی از چرخش
- مثال: آونگ در حال چرخش به گاری فشار جانبی وارد می‌کند
- ترم: `-c1 * sin(خ¸â‚پ) * خ¸ج‡â‚پآ²` گاری را از آونگ دور می‌کند

## بردار گرانش

```python
def _compute_gravity_vector(self, theta1: float, theta2: float) -> np.ndarray:
    """
    Compute gravity vector G(q).

    G = -âˆ‚V/âˆ‚q where V = potential energy
    """
    s1 = np.sin(theta1)
    s2 = np.sin(theta2)

    g1 = self.m1 * self.lc1 + self.m2 * self.L1
    g2 = self.m2 * self.lc2

    return np.array([
        0,                          # No gravity on cart (horizontal)
        -g1 * self.g * s1,         # Pendulum 1 torque
        -g2 * self.g * s2          # Pendulum 2 torque
    ])
```

**قرارداد علامت**: حالت قائم (خ¸=0) تعادل ناپایدار است
- گرانش آونگ را از عمود دور می‌کند
- کنترل باید این گشتاور ناپایدارکننده را خنثی کند

## سه مدل: شخصیت‌ها را بشناسید

**[یادداشت صوتی: این سه مدل را مثل سه هم‌تیمی با شخصیت متفاوت ببینید]**

سه مدل ریاضی از یک سیستم داریم. چرا؟ چون بین **سرعت** و **دقت** همیشه معامله وجود دارد. بیایید شخصیت‌سازی کنیم:

### مدل 1: دونده سریع (مدل خطی ساده)

**شخصیت**: سریع، چابک، فرض می‌کند همه چیز تقریبا ایده‌آل است

دونده سریع دوست نمونه‌سازی سریع شماست. فرض‌های ساده‌کننده دارد:
- **زاویه‌های کوچک**: sin(theta) ≈ theta، cos(theta) ≈ 1 (فقط نزدیک قائم)
- **اثرات کوپل‌شده را نادیده می‌گیرد**
- **ماتریس جرم ثابت**: یک‌بار محاسبه می‌شود

**ابرقدرت‌ها:**
- **خیلی سریع**: 10 تا 100 برابر سریع‌تر از مدل کامل
- **مناسب برای PSO**: برای 1500 شبیه‌سازی عالی است
- **عالی برای آموزش**: ساده‌تر برای فهم دستی

**نقطه‌ضعف:**
- **زاویه‌های بزرگ را خراب می‌کند**: برای swing-up بی‌اعتبار
- **غیرخطی‌ها را کم‌برآورد می‌کند**

**چه زمانی مناسب است؟** نمونه‌سازی اولیه، PSO، نمایش آموزشی، زمانی که نزدیک قائم هستید.

**روند کد**: ماتریس جرم ثابت، دینامیک خطی، حل سریع.

### مدل 2: شبیه‌ساز (مدل غیرخطی کامل)

**شخصیت**: کند، سنگین، صادق و دقیق

شبیه‌ساز دوست واقع‌گرای شماست. هیچ میان‌بری ندارد. تمام ترم‌های مثلثاتی و کوپل‌شده دقیق محاسبه می‌شوند.

**ابرقدرت‌ها:**
- **کاملا دقیق**: در کل دامنه کار
- **تمام فیزیک**: کوریولیس، گریز از مرکز، ژیروسکوپی
- **معیار نهایی**: برای نتایج قابل انتشار

**نقطه‌ضعف:**
- **محاسبات سنگین**: 10 تا 100 برابر کندتر از مدل ساده
- **برای کار ساده بیش‌ازحد است**

**چه زمانی مناسب است؟** اعتبارسنجی نهایی، swing-up، بنچمارک پژوهشی.

### مدل 3: حرفه‌ای کارا (تقریب کم‌رتبه)

**شخصیت**: مصالحه هوشمند — سریع مثل دونده، دقیق مثل شبیه‌ساز (اغلب)

حرفه‌ای کارا از تکنیک POD استفاده می‌کند. ایده: شبیه‌ساز کامل را بارها اجرا کنید، داده جمع کنید، سپس با SVD الگوهای مهم را نگه دارید و باقی را حذف کنید.

**ابرقدرت‌ها:**
- **10 تا 50 برابر سرعت** با حفظ دقت مهم
- **عالی برای مونت‌کارلو**
- **مناسب برای HIL** با نیاز زمانی میلی‌ثانیه

**نقطه‌ضعف:**
- **نیاز به آموزش**: ابتدا باید داده جمع شود
- **ممکن است رخدادهای نادر را از دست بدهد**

**چه زمانی مناسب است؟** پیمایش گسترده پارامترها، تحلیل حساسیت، HIL.

**جمع‌بندی**:
- نمونه‌سازی سریع؟ دونده.
- اعتبارسنجی نهایی؟ شبیه‌ساز.
- پردازش حجیم؟ حرفه‌ای کارا.

## مقایسه دقت مدل‌ها

### آزمون اعتبارسنجی (بنچمارک MT-6)

**تنظیمات:**
- شرایط اولیه: `خ¸â‚پ = 10آ°`, `خ¸â‚‚ = 5آ°`
- کنترل‌گر: Classical SMC با بهره‌های بهینه
- مدت: 10 ثانیه
- معیار: زمان نشست، فراجهش، خطای RMS

**نتایج:**

| مدل | زمان نشست [s] | فراجهش [آ°] | خطای RMS [آ°] | سرعت [sims/sec] |
|-------|-------------------|---------------|---------------|------------------|
| ساده‌شده | 2.31 | 4.2 | 0.12 | 450 |
| غیرخطی کامل | 2.58 | 5.1 | 0.15 | 8 |
| کم‌رتبه (k=10) | 2.54 | 4.9 | 0.14 | 95 |

**مشاهدات:**
1. مدل ساده زمان نشست را کم‌برآورد می‌کند
2. مدل کامل محافظه‌کارانه‌تر است
3. مدل کم‌رتبه مصالحه خوب دارد (2٪ خطا، 12× سرعت)

### اعتبارسنجی دامنه زاویه

**آزمون**: swing-up از خ¸â‚پ = 180آ° (آویزان)

| مدل | قابل شبیه‌سازی؟ | حداکثر خطای زاویه |
|-------|---------------|-----------------|
| ساده‌شده | NO (برای خ¸>10آ° نامعتبر) | N/A |
| غیرخطی کامل | YES | Reference |
| کم‌رتبه | YES (اگر با swing-up آموزش دیده باشد) | 3.5آ° |

**نتیجه**: مدل ساده فقط نزدیک قائم معتبر است!

## جزئیات پیاده‌سازی

### انتگرال‌گیری عددی

**انتگرال‌گیرهای موجود** (از `config.yaml`):

```yaml
verification:
  integrators:
    - euler    # 1st order, fast, inaccurate
    - rk4      # 4th order, good balance
    - rk45     # Adaptive, most accurate
```

**Euler (مرتبه اول):**
```python
def euler_step(f, state, u, dt):
    state_dot = f(state, u)
    return state + state_dot * dt
```

**RK4 (مرتبه چهارم):**
```python
def rk4_step(f, state, u, dt):
    k1 = f(state, u)
    k2 = f(state + 0.5*dt*k1, u)
    k3 = f(state + 0.5*dt*k2, u)
    k4 = f(state + dt*k3, u)
    return state + (dt/6) * (k1 + 2*k2 + 2*k3 + k4)
```

**RK45 (تطبیقی):**
- `solve_ivp` از SciPy با گام تطبیقی
- کنترل خطا: `rtol=1e-6`, `atol=1e-9`
- بهترین گزینه برای اعتبارسنجی دقیق

**انتخاب معمول**: RK4 با `dt = 0.001s` (۱ کیلوهرتز)

### مدیریت تکینی

**مشکل**: `M(q)` در برخی پیکربندی‌ها بدشرط می‌شود.

**راه‌حل‌ها:**

**1. پایش عدد شرط:**
```python
cond = np.linalg.cond(M)
if cond > threshold:
    logger.warning(f"Ill-conditioned mass matrix: خ؛={cond:.2e}")
```

**2. معکوس منظم‌شده:**
```python
# Add small diagonal perturbation
M_reg = M + epsilon * np.eye(3)
M_inv = np.linalg.inv(M_reg)
```

**3. شبه‌معکوس:**
```python
M_inv = np.linalg.pinv(M, rcond=1e-6)
```

**از `config.yaml`:**
```yaml
stability_monitoring:
  conditioning:
    median_threshold: 10000000.0      # Warn if median خ؛ > 1e7
    spike_threshold: 1000000000.0     # Warn if p99 خ؛ > 1e9
    fallback_threshold: 3             # Max pseudoinverse uses per episode
```

## خطاهای رایج و نکات

### خطای 1: قرارداد زاویه اشتباه

**مشکل**: خطای علامت در sin/cos.

**قرارداد ما**: خ¸ = 0 در حالت قائم (تعادل ناپایدار)
- ترم گرانش: `-mآ·gآ·lآ·sin(خ¸)` (از قائم دور می‌کند)
- آونگ وقتی خ¸=0 رو به بالا است

**قرارداد جایگزین**: خ¸ = 0 در حالت آویزان (تعادل پایدار)
- علامت‌های گرانش فرق می‌کند
- کمتر رایج برای کنترل آونگ وارونه

### خطای 2: ناهماهنگی واحدها

**مشکل**: مخلوط کردن رادیان و درجه.

**راه‌حل**: همیشه واحدهای SI در داخل:
- زاویه: رادیان
- سرعت زاویه‌ای: rad/s
- طول: متر
- جرم: کیلوگرم
- نیرو: نیوتن

**تبدیل برای نمایش:**
```python
theta_deg = np.rad2deg(theta)  # For plotting
theta_rad = np.deg2rad(theta_deg)  # From user input
```

### خطای 3: نادیده گرفتن کران‌های پارامتر

**مشکل**: پارامترهای غیرواقعی باعث مشکل عددی می‌شوند.

**اعتبارسنجی** (از `src/config.py`):
```python
@validator('cart_mass')
def validate_cart_mass(cls, v):
    if v <= 0:
        raise ValueError("Cart mass must be positive")
    if v < 0.5 or v > 10.0:
        logger.warning(f"Unusual cart mass: {v} kg")
    return v

@validator('pendulum1_inertia')
def validate_inertia(cls, v, values):
    # Minimum: point mass at COM
    m = values.get('pendulum1_mass', 0.2)
    l = values.get('pendulum1_com', 0.2)
    I_min = m * l**2

    if v < I_min:
        raise ValueError(f"Inertia {v} < minimum {I_min} for point mass")
    return v
```

### نکته 1: اعتبارسنجی با پاسخ شناخته‌شده

**آزمون**: نوسان آونگ بدون میرایی

```python
def test_conservation_of_energy():
    # No friction, no control
    config = get_config(cart_friction=0, joint1_friction=0, joint2_friction=0)

    # Initial condition: خ¸â‚پ = 10آ°, zero velocity
    state0 = np.array([0, 0.174, 0, 0, 0, 0])  # 10آ° = 0.174 rad

    # Simulate for 10 seconds
    result = simulate(state0, u=0, duration=10.0, dt=0.001)

    # Compute total energy at each timestep
    E = [kinetic_energy(s) + potential_energy(s) for s in result.states]

    # Energy should be conserved (E(t) = E(0))
    energy_drift = abs(E[-1] - E[0]) / E[0]
    assert energy_drift < 0.01  # <1% drift acceptable
```

### نکته 2: تطبیق با مدل ساده

**روند:**
1. کنترل‌گر را با مدل ساده توسعه دهید (سریع)
2. با مدل کامل اعتبارسنجی کنید (واقعی)
3. نتایج را مقایسه کنید — برای زاویه‌های کوچک باید نزدیک باشد

**مثال:**
```python
# Simplified model
result_simple = simulate_simplified(state0, controller, duration=5.0)

# Full nonlinear model
result_full = simulate_full(state0, controller, duration=5.0)

# Compare
theta1_diff = np.mean(np.abs(result_simple.theta1 - result_full.theta1))
print(f"Mean خ¸â‚پ difference: {np.rad2deg(theta1_diff):.2f}آ°")

# Should be <1آ° for |خ¸| < 5آ°
assert theta1_diff < np.deg2rad(1.0)
```

## نتیجه‌گیری: از معادلات تا موشک

**همان موشک SpaceX در E001 و E002؟** حالا می‌دانید داخل مدل گیاه آن چه می‌گذرد:

**مدل گیاه موشک:**
1. **ماتریس جرم**: با سوخت‌سوزی تغییر می‌کند — اینرسی مؤثر از میلیون‌ها کیلو به ده‌ها هزار می‌رسد. کنترل‌گر صدها بار در ثانیه M(q) را محاسبه می‌کند.
2. **ترم‌های کوریولیس/گریز از مرکز**: هنگام چرخش برای جهت‌گیری، این نیروها تعیین می‌کنند رانش چگونه به حرکت تبدیل شود.
3. **تکینی‌ها**: برخی وضعیت‌های گیمبال قفل می‌کنند (مثل آرنج) — کامپیوتر پرواز از آن‌ها دوری می‌کند.
4. **تعویض مدل**: هنگام صعود از مدل ساده‌تر استفاده می‌شود (زاویه‌های کوچک). در فرود و مانور شدید، مدل کامل لازم است. سرعت در برابر دقت — درست مثل سه مدل ما.

**آنچه یاد گرفتید:**

1. **مکانیک لاگرانژی**: میان‌بر زیبا برای حذف نیروهای قیودی داخلی و تمرکز بر انرژی.
2. **معادله دینامیک**: M(q)أ—acceleration + C(q,qج‡)أ—velocity + G(q) = control. همه چیز در یک معادله.
3. **تکینی‌ها**: قفل‌شدن فیزیکی در برخی وضعیت‌ها. عدد شرط معیار سلامت است.
4. **سه مدل، سه شخصیت**:
   - **دونده**: سریع برای نمونه‌سازی و PSO، فرض زاویه کوچک
   - **شبیه‌ساز**: دقیق و واقعی، معیار نهایی
   - **حرفه‌ای کارا**: مصالحه هوشمند، مناسب مونت‌کارلو
5. **ابزار مناسب**: برای هر کار ابزار درست را انتخاب کنید.

**بعدی چیست؟**

E004 وارد بهینه‌سازی PSO می‌شود — الگوریتمی که بهره‌های کنترل‌گر را خودکار تنظیم می‌کند. گفتیم دونده سریع برای PSO عالی است؟ حالا می‌بینید چرا. درباره الگوریتم ذرات، طراحی تابع هزینه، و بهبودهای واقعی عملکرد (تا 360٪ افزایش بهره با حفظ پایداری) صحبت می‌کنیم.

**جمع‌بندی**: فیزیکی که امروز دیدیم — لاگرانژ، دینامیک کوپل‌شده، تکینی‌ها — نتیجه قرن‌ها کار فیزیک‌دانان است. اما در قلب خود، همه چیز درباره فهم حرکت اجسام هنگام اعمال نیروست. شهودهای فیزیکی (پیچ ماشین، گردونه، قفل آرنج) را حفظ کنید تا ریاضی ابزار باشد نه مانع.

در E004 می‌بینمتان!

---

**فرا‌داده قسمت:**
- **طول**: ~529 خط (بهینه‌شده برای وضوح صوتی، کاهش از ~1000 خط)
- **زمان صوتی**: 25-30 دقیقه (با سرعت مکالمه)
- **پیش‌نیازها**: مکانیک کلاسیک، جبر خطی، پایتون پایه (یا شهود فیزیکی قوی)
- **بعدی**: E004 - PSO Optimization
- **بهینه‌سازی**: بازبینی Gemini AI اعمال شد — مشتقات حذف شدند، چرایی لاگرانژ توضیح داده شد، تشبیه‌های فیزیکی اضافه شد، تکینی‌ها به «قفل فیزیکی» ربط داده شدند، سه مدل شخصیت‌سازی شدند، تم SpaceX تکرار شد
