# E005: معماری موتور شبیه‌سازی

**مجریان**: دکتر سارا چن (کنترل) و الکس ریورا (نرم‌افزار)

**[یادداشت صوتی: بخش‌های کدمحور با تشبیه‌های ملموس توضیح داده می‌شوند؛ بردارسازی و Numba به‌صورت روایی بیان می‌شوند.]**

---

## شروع

**الکس**: PSO با 30 ذره و 50 تکرار یعنی 1500 شبیه‌سازی. اگر هر شبیه‌سازی 10 ثانیه باشد، بیش از 4 ساعت طول می‌کشد.  
**سارا**: اما در سیستم ما 5 دقیقه‌ای تمام می‌شود. راز؟ موتور شبیه‌سازی.

---

## چرا سرعت مهم است؟

1. **تکرار سریع توسعه**  
کند: ساعت‌ها — سریع: چند دقیقه.

2. **اعتبارسنجی آماری**  
هزاران شبیه‌سازی برای بنچمارک‌ها.

3. **تعامل بلادرنگ**  
تاخیر 200ms حس «واکنش‌پذیر» ایجاد می‌کند.

---

## معماری سه‌لایه

**تشبیه رستوران**:
- لایه کاربردی = گارسون (CLI/UI)
- لایه شبیه‌سازی = سرآشپز (هماهنگ‌کننده)
- لایه هسته = آشپز خط (محاسبات فیزیک)

**اجزا**:
- `simulate.py`, `streamlit_app.py`
- `SimulationRunner`, `VectorizedSimulator`, `SimulationContext`
- کنترل‌گرها، دینامیک، انتگرال‌گیرها

مزایا: ماژولار بودن، تست‌پذیری، بهینه‌سازی مستقل.

---

## SimulationRunner (قلب سیستم)

### حلقه اصلی (خلاصه)
1. محاسبه کنترل `u`
2. اشباع عملگر
3. محاسبه دینامیک
4. انتگرال‌گیری
5. بررسی ناپایداری
6. ثبت داده‌ها

**بررسی ناپایداری** (نمونه):
```python
def _check_instability(state):
    theta1, theta2 = state[0], state[2]
    return np.abs(theta1) > np.deg2rad(45) or np.abs(theta2) > np.deg2rad(45)
```

**بهینه‌سازی مهم**: پیش‌اختصاص آرایه‌های NumPy به‌جای append لیست (≈2× سریع‌تر).

---

## روش‌های انتگرال‌گیری

### Euler (ساده، کم‌دقت)
```
state_next = state + dt * state_dot
```

### RK4 (پیش‌فرض)
چهار ارزیابی مشتق؛ دقت بالا با هزینه محاسباتی بیشتر.

### RK45 (تطبیقی)
برای تحلیل دقیق آفلاین؛ کندتر اما دقیق‌تر.

**قاعده سرانگشتی**:  
`dt ≤ 1 / (10 × بالاترین فرکانس طبیعی)`

---

## بردارسازی (Vectorization)

به‌جای حلقه‌های پایتونی برای هر ذره، همه ذره‌ها را یک‌جا با NumPy محاسبه کنید.  
نتیجه: حدود 5× سرعت.

نمونه (ایده):
```python
# states: (N, 6)
# gains:  (N, 6)
theta1 = states[:, 0]
theta1_dot = states[:, 1]
lambda1 = gains[:, 0]
s = theta1_dot + lambda1 * theta1  # عملیات برداری
```

---

## Numba JIT (ترجمه‌گر سرعت)

Numba کد پایتون عددی را به ماشین‌کد تبدیل می‌کند.  
با یک دکوراتور ساده:
```python
from numba import jit

@jit(nopython=True)
def compute_mass_matrix_numba(...):
    ...
```

**نتیجه**: تا 69× سریع‌تر برای محاسبات دینامیک.  
**نکته**: اولین اجرا هزینه کامپایل دارد؛ بعدی‌ها سریع‌اند.

---

## ترکیب بردارسازی + Numba

بردارسازی (≈5×) + Numba (≈3×) → **≈15×** سرعت کلی.  
برای PSO و مونت‌کارلو حیاتی است.

---

## نکات عملی

**کارایی حافظه**: برای تعداد ذرات زیاد، پردازش دسته‌ای.  
**پایداری عددی**: اگر ماتریس جرم بدشرط شد، از شبه‌معکوس استفاده کنید.

نمونه ایمن:
```python
def safe_mass_matrix_inverse(M, threshold=1e8):
    cond = np.linalg.cond(M)
    if cond < threshold:
        return np.linalg.inv(M)
    return np.linalg.pinv(M, rcond=1e-6)
```

---

## خطاهای رایج

- **dt خیلی بزرگ** → ناپایداری
- **فراموشی reset کنترل‌گر** در تست‌های دسته‌ای

نمونه درست:
```python
for state0 in test_conditions:
    controller.reset()
    result = simulate(controller, state0)
```

---

## جمع‌بندی

**پشته سرعت**:
1. پیش‌اختصاص آرایه‌ها
2. RK4 با dt مناسب
3. بردارسازی
4. Numba JIT

**پیام اصلی**: معماری درست، امکان بهینه‌سازی را فراهم می‌کند.  
**هشدار**: بهینه‌سازی زودهنگام ممنوع — اول کد خوانا، بعد پروفایل، سپس بهینه‌سازی.

---

## اتصال به SpaceX

برای بهینه‌سازی فرود، هزاران شبیه‌سازی لازم است. بدون موتور سریع، چرخه طراحی غیرممکن می‌شود. همان معماری سه‌لایه و بهینه‌سازی که ما داریم، در پروژه‌های هوافضا نیز استفاده می‌شود.

---

## قسمت بعدی

**E006: ابزارهای تحلیل و شاخص‌های عملکرد**

---

**طول قسمت**: ~1270 خط  
**زمان مطالعه**: 55-60 دقیقه  
**عمق فنی**: بالا  
**پیش‌نیازها**: E001-E004  
**بعدی**: E006
