# E002: مبانی نظریه کنترل

**[یادداشت صوتی: این قسمت وارد ریاضیات پشت نظریه کنترل می‌شود. اگر بعضی مفاهیم انتزاعی به نظر رسیدند نگران نباشید — اول شهود می‌سازیم، بعد معادله. تمرکزتان روی این باشد که چرا ریاضی کار می‌کند، نه حفظ فرمول‌ها. نمادگذاری دقیق در توضیحات آمده است.]**

## مقدمه‌ای بر سامانه‌های کنترل

نظریه کنترل چارچوب ریاضی برای این است که سامانه‌ها را مطابق خواستمان رفتار دهیم. در E001 درباره متعادل کردن جاروب دوگانه با چشم‌بند روی سکوی متحرک صحبت کردیم — همان مسئله موشک SpaceX. حالا می‌خواهیم ریاضیاتی را باز کنیم که این کار را ممکن می‌کند. از مفاهیم پایه تا کنترل مد لغزشی پیش می‌رویم — بنیان کل این پروژه.

**یادتان باشد**: این قسمت برای ساخت شهود است. اگر جایی ریاضی ترسناک شد، فقط روی تشبیه‌های فیزیکی تمرکز کنید. همه چیز را به همان فرود موشک برمی‌گردانیم.

## کنترل چیست؟

### مسئله بنیادی کنترل

**هدف**: خروجی سامانه را به یک مرجع مطلوب برسانیم، با وجود:
- اغتشاشات (نیروهای بیرونی، نویز)
- عدم‌قطعیت‌ها (خطای مدل، تغییر پارامترها)
- قیود (حدود عملگر، مرزهای ایمنی)

**مثال - کروز کنترل:**
```
هدف: حفظ سرعت 65 مایل بر ساعت
اغتشاشات: سربالایی، باد، اصطکاک جاده
عدم‌قطعیت: جرم خودرو (خالی یا پر)
قیود: محدودیت توان موتور
```

### کنترل حلقه‌باز در برابر حلقه‌بسته

**حلقه‌باز** (بدون بازخورد):
- اجرای فرمان‌های از پیش تعیین‌شده
- بدون اصلاح خطا
- مثال: تایمر مایکروویو (بدون بازخورد دما)

**حلقه‌بسته** (با بازخورد):
- خروجی را اندازه‌گیری می‌کند، با مرجع مقایسه می‌کند، ورودی را تنظیم می‌کند
- اغتشاشات را خودکار جبران می‌کند
- مثال: ترموستات (دما را می‌سنجد و گرمایش را تنظیم می‌کند)

**برای DIP**: کنترل حلقه‌باز غیرممکن است (سامانه ناپایدار به بازخورد پیوسته نیاز دارد)

## نمایش فضای حالت

### چرا فضای حالت؟

کنترل مدرن به‌جای تابع انتقال از مدل‌های فضای حالت استفاده می‌کند چون:
1. سامانه‌های چندورودی-چندخروجی (MIMO) را طبیعی مدیریت می‌کند
2. برای سامانه‌های غیرخطی هم کاربرد دارد
3. طراحی کنترل بهینه را ممکن می‌کند
4. تفسیر فیزیکی مستقیم دارد

### فرم کلی

**زمان پیوسته:**
```
ل؛‹(t) = f(x(t), u(t), t)  # دینامیک حالت
y(t) = h(x(t), u(t), t)  # معادله خروجی
```

که در آن:
- `x(t)` = بردار حالت (متغیرهای داخلی سامانه)
- `u(t)` = ورودی کنترل
- `y(t)` = خروجی اندازه‌گیری‌شده
- `f(آ·)` = تابع دینامیک
- `h(آ·)` = تابع اندازه‌گیری

### مدل فضای حالت برای DIP

برای آونگ دوگانه وارونه، بردار حالت فقط فهرستی از شش عدد است که سامانه را در هر لحظه به‌طور کامل توصیف می‌کند:

**شش متغیر حالت:**

این‌ها را مثل نمایشگر داشبورد موشک تصور کنید:

1. **موقعیت گاری**: گاری چقدر به چپ/راست رفته (متر)
2. **زاویه آونگ اول**: میله پایینی چقدر از عمود کج شده (رادیان)
3. **زاویه آونگ دوم**: میله بالایی چقدر از عمود کج شده (رادیان)
4. **سرعت گاری**: گاری با چه سرعتی حرکت می‌کند (متر بر ثانیه)
5. **سرعت زاویه‌ای آونگ اول**: میله پایینی با چه سرعتی می‌چرخد (رادیان بر ثانیه)
6. **سرعت زاویه‌ای آونگ دوم**: میله بالایی با چه سرعتی می‌چرخد (رادیان بر ثانیه)

اگر این شش عدد را در هر لحظه بدانید، همه چیز را درباره وضعیت سامانه می‌دانید. به همین دلیل به آن «بردار حالت» می‌گویند — کل وضعیت را در خود دارد.

**ورودی کنترل تک‌گانه:**

ما فقط یک کلید کنترل داریم — نیروی افقی وارد شده به گاری (نیوتن). یادتان باشد از E001: یک ورودی برای مدیریت سه چیز (موقعیت گاری، آونگ اول، آونگ دوم). این همان چالش کم‌عملگری است.

**معادله دینامیک — واقعاً چه می‌گذرد؟**

فیزیک با زبان ساده: دینامیک سامانه از قوانین نیوتن پیروی می‌کند، اما در قالب ماتریسی نوشته می‌شود. ماتریس جرم (توزیع جرم و اینرسی)، ترم‌های کوریولیس و گریز از مرکز (اثر چرخش)، ترم‌های گرانش (پایین کشیدن آونگ‌ها)، و ورودی کنترل (نیروی هل‌دادن).

معادله می‌گوید: «جرم و اینرسی را در شتاب ضرب کن، اثرات چرخشی و گرانش را اضافه کن، و این برابر نیروی اعمالی می‌شود.» همان F = ma است، اما برای چند جسم متصل.

**این در کد چطور اجرا می‌شود؟**

پیاده‌سازی پایتون دقیقا از فیزیک پیروی می‌کند. روند:

1. **بازکردن حالت**: شش عدد حالت را جدا می‌کند — موقعیت‌ها و سرعت‌ها
2. **ساخت ماتریس جرم**: توزیع جرم و اینرسی را با توجه به زاویه‌ها محاسبه می‌کند
3. **محاسبه ترم‌های غیرخطی**: کوریولیس، گریز از مرکز و گرانش
4. **اعمال ورودی کنترل**: نیرو فقط مستقیما به گاری وارد می‌شود
5. **حل شتاب**: با جبر خطی ماتریس جرم را معکوس می‌کند و شتاب‌ها را می‌یابد
6. **برگرداندن مشتق**: نرخ‌های تغییر (سرعت‌ها و شتاب‌ها) را برمی‌گرداند

در کد، این عملا یک خط NumPy است: «این نیروهاست، این ماتریس جرم است، شتاب را حل کن.» کامپیوتر جبر خطی سنگین را انجام می‌دهد. زیبایی فیزیکِ درست و کتابخانه‌های خوب همین است.

## نظریه پایداری

### پایداری لیاپانوف: توپ در کاسه

**[یادداشت صوتی: فعلا حروف یونانی را کنار بگذارید — اول با تصویر فیزیکی شهود بسازیم]**

فعلا تعریف کتابی را فراموش کنید. پایداری با یک تصویر درست بسیار ساده است.

**داستان کامل توپ در کاسه:**

تصور کنید یک تیله در ته یک کاسه صاف است — مثل کاسه صبحانه روی میز. حالا تیله را کمی به کنار هل دهید. چه می‌شود؟

1. **گرانش آن را پایین می‌کشد**: تیله به سمت ته کاسه می‌رود چون پایین‌ترین نقطه است
2. **بیش‌روی می‌کند**: به‌خاطر مومنتوم از ته رد می‌شود
3. **دوباره برمی‌گردد**: گرانش دوباره آن را پایین می‌کشد
4. **اصطکاک آن را کند می‌کند**: هر نوسان مقداری انرژی را می‌گیرد
5. **می‌ایستد**: در نهایت باید در ته کاسه بایستد

این یعنی پایداری. شکل کاسه «نیروی بازگرداننده» ایجاد می‌کند و اصطکاک «میرایی» می‌دهد. با هم تضمین می‌کنند که تیله در ته کاسه می‌ماند.

**بینش درخشان:**

لیا‌پانوف پرسید: «اگر بتوانیم ثابت کنیم سامانه کنترل هم همین ویژگی را دارد — یک شکل کاسه‌ای و میرایی — بدون حل معادلات دیفرانسیل؟» این قدرتمند است چون حل معادلات غیرخطی اغلب ممکن نیست.

**روش مستقیم لیاپانوف — تابع انرژی:**

ترفند این است که یک تابع «شبیه انرژی» پیدا کنیم که نشان دهد چقدر از حالت ایده‌آل دوریم. برای تیله:
- **در ته کاسه (تعادل)**: انرژی صفر — کامل است
- **دور از ته**: انرژی مثبت — هرچه بالاتر، انرژی بیشتر
- **در زمان**: انرژی همیشه کم می‌شود (به‌خاطر اصطکاک)

اگر این سه ویژگی را برای سامانه کنترل ثابت کنید، پایداری را بدون حل معادلات ثابت کرده‌اید. یعنی «کاسه + اصطکاک» دارید و سیستم حتما به تعادل می‌رسد.

**این برای موشک چه معنایی دارد؟**

کنترل‌گر موشک SpaceX با یک تابع لیاپانوف طراحی می‌شود. مهندسان یک «کاسه ریاضی» می‌سازند که حالت عمودی در ته آن است و قانون کنترل مثل اصطکاک انرژی را کم می‌کند. اگر وجود کاسه و کارکرد اصطکاک ثابت شود، موشک پایدار می‌شود — حتی با باد و اغتشاشات.

**تعریف ریاضی (برای کامل بودن):**

در نمادگذاری ریاضی، تعادل پایدار است اگر انحراف کوچک کوچک بماند، و پایدار مجانبی است اگر انحراف با زمان به صفر برسد. یعنی «تیله را کمی هل بده، در کاسه می‌ماند و به ته می‌رسد.»

تابعی V پیدا می‌کنیم که همه‌جا مثبت است جز در تعادل (صفر)، و مشتق زمانی آن منفی است (انرژی همیشه کم می‌شود). این ترجمه ریاضیِ شهود کاسه و اصطکاک است.

## مبانی کنترل مد لغزشی (SMC)

### کنترل مد لغزشی چیست؟ تشبیه نرده محافظ

**[یادداشت صوتی: قلب پروژه همین است — استراتژی کنترلی که همه چیز را ممکن می‌کند. از تشبیه کوهنوردی استفاده می‌کنیم.]**

تصور کنید در مه از کوه پایین می‌آیید تا به کلبه‌ای در پایین برسید. دیدتان کم است و باد می‌خواهد شما را منحرف کند. اما یک مسیر با نرده محافظ ساخته شده است. استراتژی شما:

1. **اول مسیر را پیدا کنید** (فاز رسیدن): ممکن است هرجا باشید. هدف اول فقط رسیدن به مسیر نرده‌دار است، مهم نیست از کدام راه.

2. **بعد مسیر را دنبال کنید** (فاز لغزش): وقتی روی مسیر هستید، هندسه نرده شما را امن به پایین می‌برد. حتی با باد، نرده شما را نگه می‌دارد — شما فقط به آن تکیه می‌دهید و ادامه می‌دهید.

این خلاصه SMC است. «سطح لغزش» همان مسیر نرده‌دار است که طوری طراحی می‌شود که ماندن روی آن تضمین می‌کند به تعادل برسید.

**خاصیت جادویی کلیدی:**

وقتی روی سطح لغزش هستید، سامانه نسبت به **عدم‌قطعیت‌های هم‌راستا** حساس نیست. یعنی اغتشاشاتی که از کانال کنترل وارد می‌شوند، شما را از مسیر خارج نمی‌کنند — فقط کمی بیشتر به نرده فشار می‌دهید. هندسه سطح لغزش این اغتشاشات را رد می‌کند.

### طراحی دو مرحله‌ای: ساخت نرده

**مرحله 1 - طراحی مسیر (سطح لغزش):**

باید مسیر نرده را ریاضی تعریف کنیم. برای آونگ دوگانه، می‌خواهیم زاویه‌ها به صفر برسند. سطح لغزش زاویه‌ها و نرخ‌هایشان را با ضرایب مشخص ترکیب می‌کند — یعنی «مسیر از رابطه بین موقعیت و سرعت تعریف می‌شود».

ریاضی یک معادله دیفرانسیل مرتبه اول می‌سازد که حل نمایی دارد. یعنی اگر روی مسیر باشید (سطح لغزش صفر)، زاویه‌ها با ثابت زمانی مشخص نمایی به صفر می‌روند. این ثابت زمانی به بهره‌ها بستگی دارد — یعنی چقدر تهاجمی همگرا شویم.

**مرحله 2 - طراحی فشار به مسیر (قانون رسیدن):**

حالا باید قانونی بسازیم که سامانه را به سطح لغزش برساند و آنجا نگه دارد. این «قانون رسیدن» است و دو بخش دارد:

1. **ترم رسیدن**: فشار قوی به سمت سطح (مثل دویدن به سمت نرده). تابع sign جهت را تعیین می‌کند — اگر راست مسیر هستید، به چپ هل می‌دهد و بالعکس.

2. **ترم میرایی**: جلوگیری از بیش‌روی (مثل کم کردن سرعت نزدیک نرده تا به آن برخورد نکنید).

**قانون کنترل کلی:**

کنترل ما دو جزء دارد:

1. **کنترل معادل**: پیش‌خور مبتنی بر مدل که اگر روی سطح باشید و مدل کامل باشد، شما را روی سطح نگه می‌دارد. مثل کروز کنترل.

2. **کنترل سوئیچینگ**: بازخورد مقاوم برای خطای مدل و اغتشاشات. مثل بخش «تصحیح».

با هم تضمین می‌کنند در زمان متناهی به سطح برسید و روی آن بمانید.

### کد در عمل چگونه کار می‌کند

پیاده‌سازی پایتون مرحله به مرحله از همین طراحی پیروی می‌کند:

1. **محاسبه سطح لغزش**: «چقدر از مسیر فاصله داریم؟»
2. **برآورد مشتق سطح**: «به سمت مسیر می‌رویم یا دور می‌شویم؟»
3. **کنترل معادل**: «اگر روی مسیر بودیم، چه نیرویی لازم بود؟»
4. **کنترل سوئیچینگ**: «برای رفتن به مسیر چه تصحیحی لازم است؟»
5. **کنترل مشتقی**: «میرایی اضافه کن تا نوسان کم شود»
6. **جمع همه**: اجزا را ترکیب کن
7. **اشباع خروجی**: بیش از توان عملگر نخواهیم

کد ماژولار است — هر جزء تابع خودش را دارد و به‌راحتی تست و اصلاح می‌شود. و در نهایت همیشه اشباع داریم — عملگرهای واقعی محدودیت دارند.

### روش لایه مرزی: حل مشکل چترینگ

**[یادداشت صوتی: اینجا نظریه با واقعیت خشن روبه‌رو می‌شود — و باید راه‌حل هوشمندانه بدهیم]**

**مسئله — چترینگ با تشبیه صوتی:**

تصور کنید روی طناب بند بازی می‌روید. در تئوری باید بی‌نهایت سریع اصلاح کنید: چپ، راست، چپ، راست. اما در عمل عضلات پاسخ زمان‌دار دارند. اندازه‌گیری‌ها نویز دارند. سیستم عصبی شما نمونه‌برداری گسسته دارد.

نتیجه؟ نوسان سریع چپ-راست با حرکت‌های تند. این چترینگ است و صدای بدی دارد. اگر سیگنال کنترل را به بلندگو وصل کنید، صدای وزوز یا ساییدگی می‌شنوید. این نوسان فرکانس بالا برای عملگر بد است، انرژی را هدر می‌دهد و دینامیک مدل‌نشده را تحریک می‌کند.

**راه‌حل — تقریب نرم:**

به‌جای سوئیچ سخت، نزدیک سطح لغزش تقریب نرم می‌زنیم. یک «لایه مرزی» نازک دور مسیر ایجاد می‌کنیم که داخل آن تغییر نرم باشد.

دور از مسیر، همچنان کنترل سوئیچینگ قوی داریم تا سریع به مسیر برسیم. اما نزدیک مسیر، کنترل را نرم می‌کنیم — مثل ترمز تدریجی به‌جای قطع و وصل.

**معامله (Trade-Off):**

- **لایه مرزی پهن‌تر**: کنترل نرم‌تر، چترینگ کمتر، اما دقت کمتر و روباستی ضعیف‌تر
- **لایه مرزی باریک‌تر**: کنترل تهاجمی‌تر، دقت بهتر، روباستی بیشتر، اما چترینگ بیشتر

برای آونگ دوگانه معمولا لایه 0.3 تا 0.5 استفاده می‌کنیم — کافی برای حذف بیشتر چترینگ و حفظ عملکرد خوب. مقدار دقیق را PSO تنظیم می‌کند.

## الگوریتم Super-Twisting (STA): اپراتور نرم

**[یادداشت صوتی: همان «اپراتورهای نرم» از E001؟ اینجا می‌فهمیم چرا Super-Twisting این لقب را گرفت]**

### مشکل SMC کلاسیک

SMC کلاسیک شما را در زمان متناهی به سطح لغزش می‌رساند — عالی. اما یک مشکل باقی است: حتی اگر سطح لغزش صفر شود، مشتق آن صفر نمی‌شود. هنوز یک ناپیوستگی وجود دارد که پیوسته رخ می‌دهد. همین باعث چترینگ می‌شود.

به تشبیه طناب برگردید: هنوز چپ-راست سریع دارید. لایه مرزی آن را نرم می‌کند، اما اصل رفتار قطع‌و‌وصل پابرجاست.

### راه‌حل Super-Twisting: مد لغزشی مرتبه دوم

اگر بتوانیم هم سطح لغزش و هم مشتقش را صفر کنیم، سوئیچینگ از بین می‌رود و کنترل نرم می‌شود. این دقیقا کاری است که Super-Twisting می‌کند — «مد لغزشی مرتبه دوم».

**در طناب‌بازی**: به‌جای نوسان، نرم به مرکز می‌روید و می‌ایستید.

**سه مزیت بزرگ:**

1. **کاهش شدید چترینگ**: سیگنال کنترل پیوسته است
2. **همگرایی در زمان متناهی**: مثل SMC کلاسیک
3. **روباستی نسبت به اغتشاشات نرم**: اغتشاشات لیپشیتز

### ترفند توان کسری

قانون کنترل Super-Twisting دو جزء دارد:

1. **ترم انتگرالی**: خطا را در زمان جمع می‌کند
2. **ترم تناسبی با توان کسری**: از ریشه دوم خطا استفاده می‌کند

چرا ریشه دوم؟ چون توازن دقیقی می‌دهد:
- **دور از سطح**: ریشه دوم هنوز بزرگ است — کنترل قوی
- **نزدیک سطح**: ریشه دوم خطا را کوچک‌تر می‌کند — کنترل نرم بدون نوسان

مثل تنظیم بهره خودکار است: هرچه نزدیک‌تر، اصلاحات نرم‌تر.

**نتیجه**: همان ترمز ABS — اصلاحات نرم و پیوسته بدون رفتار قطع‌و‌وصل.

### کد ساده‌تر از انتظار

پیاده‌سازی پایتون تمیز است:

1. **ترم تناسبی**: ریشه دوم قدرمطلق سطح لغزش، ضربدر K2 با علامت
2. **ترم انتگرالی**: جمع خطا در زمان، ضربدر K1
3. **جمع**: دو جزء را اضافه کنید

توان کسری و انتگرال همه کار را انجام می‌دهند. کد پیوسته است — بدون if، بدون سوئیچ سخت.

## کنترل مد لغزشی تطبیقی: یادگیرنده هوشمند

**[یادداشت صوتی: همان «سازگارهای هوشمند» از E001؟ اینجا کنترل‌گرها در لحظه یاد می‌گیرند]**

### مشکل بهره‌های ثابت

فرض کنید سیستم تعلیق برای کامیون طراحی می‌کنید. گاهی خالی است، گاهی پر. اگر برای حالت پر تنظیم کنید، حالت خالی خیلی خشک می‌شود. اگر برای خالی تنظیم کنید، در حالت پر نرم و ناپایدار می‌شود.

همین مسئله برای بهره‌های کنترل هم هست. باید برای بدترین حالت تنظیم کنید (اغتشاش شدید، عدم‌قطعیت بالا). اما بیشتر وقت‌ها شرایط نامی است و آن بهره‌ها زیادی تهاجمی‌اند. نتیجه؟ اتلاف انرژی و تلاش کنترلی غیرضروری.

### راه‌حل تطبیقی: یادگیری و تنظیم

اگر کنترل‌گر بتواند در لحظه بهره‌هایش را تنظیم کند چه؟ Adaptive SMC همین کار را می‌کند.

**قانون ساده:**
- **وقتی خطای سطح لغزش بزرگ است**: «هنوز به‌قدر کافی همگرا نشده‌ام — بهره را زیاد کن.»
- **وقتی خطا کوچک است**: «نزدیک هدفم — بهره را کم کن.»

**ناحیه مرده برای روباستی:**
یک آستانه کوچک می‌گذاریم که زیر آن تطبیق انجام نشود. چرا؟ چون نویز اندازه‌گیری می‌تواند نوسان‌های کوچک بسازد و نمی‌خواهیم بهره‌ها از نویز بالا بروند.

### ریاضیات پشت آن: تطبیق بر پایه لیاپانوف

**[یادداشت صوتی: توجیه نظری — شهود مهم است نه جبر]**

همان ایده تیله در کاسه. تابع لیاپانوفی می‌سازیم که هم خطای سطح لغزش و هم خطای بهره را شامل می‌شود. قانون تطبیق طوری انتخاب می‌شود که این «انرژی» همیشه کاهش یابد. پس پایداری تضمین است.

نکته زیبا: حتی اگر مقدار ایده‌آل بهره را ندانیم، قانون تطبیق بهره‌ها را به سمتی می‌برد که سامانه پایدار شود.

### در کد چگونه است

سه ویژگی مهم:

1. **ناحیه مرده**: اگر خطا خیلی کوچک است، تطبیق انجام نده
2. **نشتی بهره**: وقتی در ناحیه مرده هستی، بهره‌ها را کمی کاهش بده تا فقط زیاد نشوند
3. **تطبیق کراندار**: حداقل و حداکثر بهره را محدود کن

قانون به‌روزرسانی ساده است: خطای بزرگ → افزایش بهره. خطای کوچک → کاهش تدریجی. همیشه در حدود امن.

## خواص روباستی

### عدم‌قطعیت‌های هم‌راستا در برابر ناهم‌راستا

**عدم‌قطعیت هم‌راستا** (در کانال کنترل):
```
ل؛‹ = f(x) + (Bâ‚€ + خ”B)u + Bd

Where:
  خ”B = خطای مدل در ماتریس ورودی
  d = اغتشاش در کانال کنترل
```

**خاصیت SMC**: رد کامل عدم‌قطعیت‌های هم‌راستا وقتی روی سطح لغزش هستیم!

**طرح اثبات:**
وقتی روی سطح لغزش `s = 0`:
```
ل¹، = 0 = (âˆ‚s/âˆ‚x)[f(x) + Bu + Bd]

Solve for u:
u_eq = -(âˆ‚s/âˆ‚xآ·B)âپ»آ¹(âˆ‚s/âˆ‚xآ·f(x))

The disturbance d cancels out in ل¹، = 0 equation!
```

**عدم‌قطعیت ناهم‌راستا** (خارج از کانال کنترل):
```
ل؛‹ = f(x) + d_unmatched + Bu
```

SMC نمی‌تواند این‌ها را کامل حذف کند، اما می‌تواند کاهش دهد.

### مثال: DIP با عدم‌قطعیت جرم

فرض کنید جرم واقعی گاری `M = Mâ‚€(1 + خ”)` باشد و `|خ”| â‰¤ 0.2` (خطای 20٪).

**شبیه‌سازی از بنچمارک MT-6:**

| کنترل‌گر | نامی (خ”=0) | اغتشاش‌دار (خ”=0.2) | افزایش فراجهش |
|------------|---------------|-------------------|-------------------|
| Classical SMC | 4.2آ° | 5.8آ° | +1.6آ° |
| STA-SMC | 3.1آ° | 4.3آ° | +1.2آ° |
| Adaptive SMC | 3.8آ° | 4.1آ° | +0.3آ° |

**نتیجه**: Adaptive SMC مقاوم‌ترین به تغییرات پارامترهاست.

## تحلیل زمان همگرایی

### همگرایی در زمان متناهی

**تعریف**: `x(t) = 0` برای تمام `t â‰¥ T_f` که `T_f < âˆ‍`.

**تفاوت با همگرایی نمایی**:
- نمایی: `â€–x(t)â€– â‰¤ Ce^(-خ±t)` (هرگز دقیقا صفر نمی‌شود، tâ†’âˆ‍)
- زمان متناهی: `x(t) = 0` در یک زمان محدود

### زمان همگرایی SMC کلاسیک

برای قانون رسیدن `ل¹، = -خ·آ·sign(s)`:

```
|s(t)| = |s(0)| - خ·آ·t

Reaches s=0 at time: T_f = |s(0)|/خ·
```

**مثال**: `s(0) = 0.5`, `خ· = 2.0` â†’ `T_f = 0.25` ثانیه

### زمان همگرایی STA

برای Super-Twisting با `ل¹، = -Kâ‚پsign(s)` و `uâ‚‚ = -Kâ‚‚|s|^(1/2)sign(s)`:

```
T_f â‰¤ (2|s(0)|^(1/2))/Kâ‚‚ + 2Kâ‚‚/Kâ‚پ

Typically: T_f ~ 0.1 - 1.0 seconds for DIP
```

سریع‌تر از SMC کلاسیک برای بهره‌های مشابه!

## خطاهای رایج و نکات

### خطای 1: انفجار مشتق

**مشکل**: مشتق‌گیری عددی نویز را تقویت می‌کند.

```python
# BAD: Numerical derivative of noisy signal
s_dot = (s[k] - s[k-1]) / dt  # Noise amplified by 1/dt!
```

**راه‌حل**: مشتق مبتنی بر مدل یا فیلتر.

```python
# GOOD: Model-based estimate
s_dot = self._surface.compute_derivative(state, state_dot)

# ALTERNATIVE: Low-pass filter
s_dot_filtered = alpha * s_dot + (1-alpha) * s_dot_prev
```

### خطای 2: بیش‌تنظیمی بهره

**مشکل**: بهره‌ها بیش از حد بزرگ → تلاش کنترلی زیاد، چترینگ.

**قاعده سرانگشتی**:
- با بهره‌های کوچک شروع کنید (K ~ 1-5)
- آرام افزایش دهید تا عملکرد قابل قبول شود
- برای بهینه‌سازی نهایی از PSO استفاده کنید

**از نتایج PSO مقاوم MT-8:**
```yaml
# Before optimization (manual tuning)
classical_smc:
  gains: [5.0, 5.0, 5.0, 0.5, 0.5, 0.5]  # Conservative

# After PSO (optimal)
classical_smc:
  gains: [23.07, 12.85, 5.51, 3.49, 2.23, 0.15]  # +360% on some gains
```

### خطای 3: نادیده گرفتن اشباع

**مشکل**: طراحی فرض می‌کند کنترل نامحدود است، اما عملگر اشباع می‌شود!

**پیامد**: اگر بهره‌ها خیلی بزرگ باشند، ممکن است سطح لغزش دست‌نیافتنی شود.

**راه‌حل**: اشباع را در طراحی لحاظ کنید و با شبیه‌سازی اعتبارسنجی کنید.

```python
# Always saturate control
u_saturated = np.clip(u_total, -max_force, max_force)

# Check for excessive saturation (diagnostic)
saturation_duty = np.mean(np.abs(u_history) > 0.95 * max_force)
if saturation_duty > 0.2:  # >20% of time saturated
    print("[WARNING] Excessive saturation, reduce gains")
```

### نکته 1: با مدل ساده شروع کنید

مدل خطی برای PSO خیلی سریع‌تر است:

```bash
# Fast PSO with simplified model (minutes)
python simulate.py --ctrl classical_smc --run-pso --save gains.json

# Validate with full nonlinear model (seconds)
python simulate.py --load gains.json --plot --use-full-dynamics
```

### نکته 2: سطح لغزش را تجسم کنید

درک `s(t)` برای اشکال‌زدایی کلیدی است:

```python
# Plot sliding surface trajectory
plt.plot(t, s_history)
plt.axhline(y=0, color='r', linestyle='--', label='Target')
plt.axhline(y=boundary_layer, color='g', linestyle=':', label='Boundary Layer')
plt.axhline(y=-boundary_layer, color='g', linestyle=':')
plt.ylabel('Sliding Surface s(t)')
plt.xlabel('Time [s]')
plt.legend()
```

**رفتار خوب**: `s(t)` به صفر همگرا می‌شود و داخل لایه مرزی می‌ماند.
**رفتار بد**: `s(t)` نوسان می‌کند یا واگرا می‌شود → بهره‌ها را بررسی کنید!

## نتیجه‌گیری: از نظریه تا موشک

**[یادداشت صوتی: اگر ریاضی ترسناک بود نگران نباشید — شهود مهم‌تر است. ما پایه مفهومی لازم برای ادامه را ساختیم]**

بیایید دوباره به موشک SpaceX برگردیم. حالا می‌دانید در آن فرودهای نمایشی واقعا چه اتفاقی می‌افتد:

**وظیفه سامانه کنترل:**
1. **تخمین حالت**: شش عدد (موقعیت، سرعت، زاویه‌ها و نرخ‌های زاویه‌ای) هزاران بار در ثانیه
2. **پایداری لیاپانوف**: قانون کنترل با تابع انرژی پایدار بودن را ثابت می‌کند
3. **کنترل مد لغزشی**: مسیری ریاضی که اغتشاشات را رد می‌کند
4. **همگرایی در زمان متناهی**: موشک در زمان محدود عمودی می‌شود، نه فقط در حد
5. **کاهش چترینگ**: لایه مرزی و Super-Twisting از نوسان‌های مخرب جلوگیری می‌کنند

هر مفهومی که گفتیم — فضای حالت، لیاپانوف، سطح لغزش، لایه مرزی — در کامپیوتر کنترل موشک فعال است. این ریاضی صرفاً تئوری نیست — تفاوت بین فرود موفق و انفجار است.

**آنچه یاد گرفتید:**

1. **نمایش فضای حالت**: شش عدد وضعیت کامل آونگ را توصیف می‌کند
2. **پایداری لیاپانوف**: شهود توپ در کاسه — اثبات همگرایی بدون حل معادلات
3. **کنترل مد لغزشی**: نرده محافظ — اول مسیر را بساز، بعد به آن برس
4. **چترینگ**: صدای وزوز سوئیچینگ سریع و راه حذف آن
5. **سه نوع کنترل‌گر**: کلاسیک (پایه)، Super-Twisting (نرم)، تطبیقی (هوشمند)

**بعدی چیست؟**

E003 وارد فیزیک می‌شود — معادلات حرکت آونگ دوگانه. مکانیک لاگرانژ، ماتریس جرم، و تفاوت مدل ساده و کامل. از الگوریتم کنترل به خود گیاه (Plant) می‌رویم.

**جمع‌بندی**: ریاضیات امروز نتیجه دهه‌ها کار نظریه‌پردازان کنترل است. اما در قلب خود، همه چیز بر شهود فیزیکی ساده است: توپ در کاسه، نرده محافظ در کوه، و اصلاحات نرم در برابر اصلاحات تند. این شهود را حفظ کنید تا معادلات ابزار باشند نه مانع.

در E003 می‌بینیمتان!

## منابع

[1] Utkin, V., Guldner, J., & Shi, J. (2009). *Sliding Mode Control in Electro-Mechanical Systems*. CRC Press.

[2] Khalil, H. K. (2002). *Nonlinear Systems* (3rd ed.). Prentice Hall.

[3] Levant, A. (2005). Homogeneity approach to high-order sliding mode design. *Automatica*, 41(5), 823-830.

[4] Slotine, J. J. E., & Li, W. (1991). *Applied Nonlinear Control*. Prentice Hall.

---

**فرا‌داده قسمت:**
- **طول**: ~539 خط (بهینه‌شده برای وضوح صوتی، کاهش از ~700 خط)
- **زمان صوتی**: 30-35 دقیقه (با سرعت مکالمه)
- **پیش‌نیازها**: جبر خطی، معادلات دیفرانسیل، مبانی کنترل (یا شهود قوی)
- **بعدی**: E003 - Plant Models and Dynamics
- **بهینه‌سازی**: بازبینی Gemini AI اعمال شد — معادلات روایت شدند، تشبیه توپ در کاسه گسترش یافت، تشبیه نرده محافظ، تشبیه صدای چترینگ، روایت کد ساده‌تر شد، تم SpaceX تکرار شد، زمینه‌چینی اضافه شد
