# E001: مرور کلی پروژه و معرفی

## به پروژه DIP-SMC-PSO خوش آمدید

این قسمت یک معرفی جامع از پروژه «کنترل مد لغزشی آونگ دوگانه وارونه با بهینه‌سازی PSO» ارائه می‌دهد؛ یک چارچوب کامل پایتون برای پژوهش و آموزش سامانه‌های کنترل پیشرفته.

**[یادداشت صوتی: این قسمت پایه‌ای شماست — لازم نیست فرمان‌ها یا نام فایل‌ها را حفظ کنید. لینک مخزن GitHub را در توضیحات قرار می‌دهیم. فقط روی این تمرکز کنید که قطعات چگونه کنار هم قرار می‌گیرند و یادتان باشد: ما در حال ساخت شهود هستیم، نه نوشتن کد.]**

## این پروژه چیست؟

پروژه DIP-SMC-PSO یک چارچوب متن‌باز پایتون است که برای موارد زیر طراحی شده:

1. **پژوهش در سامانه‌های کنترل**: آزمون و اعتبارسنجی الگوریتم‌های پیشرفته کنترل مد لغزشی
2. **ابزار آموزشی**: یادگیری نظریه کنترل از طریق آزمایش‌های عملی
3. **زمین بازی بهینه‌سازی**: کاوش PSO و سایر الگوریتم‌های فراابتکاری
4. **تست سخت‌افزار-در-حلقه**: پل زدن بین شبیه‌سازی و سخت‌افزار واقعی

### چالش: کنترل آونگ دوگانه وارونه

تصور کنید یک جاروب را روی دستتان متعادل نگه داشته‌اید — این یک آونگ وارونه است. حالا تصور کنید دو جاروب به هم متصل‌اند و باید هر دو را همزمان متعادل نگه دارید، در حالی‌که دستتان هم به چپ و راست حرکت می‌کند. این همان مسئله آونگ دوگانه وارونه (DIP) است.

اما صبر کنید — سخت‌ترش کنیم. تصور کنید همان کار را **با چشم‌بند** انجام می‌دهید و فقط هر چند میلی‌ثانیه یک‌بار کسی به شما جهت می‌دهد. تازه باد هم تصادفی می‌وزد. و شما روی یک سکوی متحرک ایستاده‌اید. **این** همان هرج‌ومرجی است که ما می‌خواهیم با الگوریتم‌های ریاضی کنترل کنیم.

**نمونه واقعی:** هر بار که می‌شنوید یک موشک SpaceX در زمان پرتاب کاملا عمودی می‌ماند، در واقع همان مسئله آونگ وارونه روی یک پایه متحرک حل شده است — مبارزه با گرانش، باد و تغییرات رانش. ریاضیاتی که اینجا می‌سازیم همان چیزی است که مانع واژگونی این موشک‌های چند میلیون دلاری می‌شود.

**چرا این سخت است؟**

به این فکر کنید که از کامپیوتر چه می‌خواهیم:

- **سامانه کم‌عملگر (Underactuated)**: فقط یک ورودی کنترلی داریم (هل دادن گاری به چپ یا راست)، اما باید همزمان سه چیز را مدیریت کنیم: موقعیت گاری، زاویه آونگ اول و زاویه آونگ دوم. مثل این است که بخواهید ماشین را فقط با پدال گاز هدایت کنید — بدون فرمان!

- **تعادل ناپایدار**: وضعیت عمودی ذاتا ناپایدار است. مثل مدادی که روی نوک آن تعادل داده‌اید — کوچک‌ترین نسیم باعث سقوط می‌شود. اینجا هم همین‌طور است. هر خطای کوچک سیستم را فرو می‌ریزد.

- **دینامیک غیرخطی**: ریاضی اینجا خطی و ساده نیست. پر از سینوس و کسینوس‌های درهم‌تنیده است، یعنی وقتی یک آونگ حرکت می‌کند، دیگری را هم به شکل پیچیده‌ای تحت تاثیر قرار می‌دهد.

- **نیاز به پاسخ سریع**: الگوریتم کنترل باید هر ۱ تا ۱۰ میلی‌ثانیه تصمیم بگیرد — یعنی ۱۰۰ تا ۱۰۰۰ بار در ثانیه. یک چشم برهم زدن و ۳۰۰ چرخه کنترل از دست رفته است.

**کاربردهای دنیای واقعی:**

مسئله کنترل DIP در سامانه‌های زیادی دیده می‌شود، و موشک SpaceX فقط شروع ماجراست:

- **پایدارسازی موشک در زمان پرتاب**: هر بار که Falcon 9 به صورت عمودی فرود می‌آید، کنترل‌گر نسخه‌ای از همین مسئله را در زمان واقعی حل می‌کند.
- **تعادل ربات‌های انسان‌نما**: ربات‌های Boston Dynamics که پارکور انجام می‌دهند، از همین ریاضیات استفاده می‌کنند.
- **سگ‌وی و وسایل خودمتعادل**: اسکوتر برقی شما از کنترل آونگ وارونه بهره می‌برد.
- **پایدارسازی بار جرثقیل صنعتی**: وقتی جرثقیل بار سنگین را تاب می‌دهد و باید دقیق متوقف کند، همان مسئله آونگ است.
- **کنترل وضعیت هوافضا**: ماهواره‌ها برای حفظ جهت‌گیری با چالش‌های مشابه روبه‌رو هستند.

## مرور معماری سیستم

پروژه به اجزای ماژولار و متمرکز تقسیم شده — مانند بخش‌های مختلف یک کارخانه، هر کدام با یک وظیفه مشخص.

### 1. کنترل‌گرها: هفت مغز

ما هفت الگوریتم کنترل داریم. هر کدام مثل یک «مغز» با شخصیت و نقاط قوت خودش. بیایید آنها را بر اساس سطح پیچیدگی دسته‌بندی کنیم:

**پایه: Classical SMC**

این الگوریتم پدربزرگ خانواده است — معیار پایه ما. کنترل مد لغزشی کلاسیک ساده، مقاوم و بر اساس نظریه‌های آزموده‌شده دهه ۱۹۷۰ است. حجم کد آن حدود ۲۰۰ خط است و نقطه مرجع ما محسوب می‌شود. وقتی می‌گوییم «کنترل‌گر X بیست درصد بهتر است»، یعنی نسبت به این پایه. این خط‌کش استاندارد ماست.

**اپراتورهای نرم: Super-Twisting**

حالا یک سطح بالاتر. الگوریتم Super-Twisting یک «کنترل مد لغزشی مرتبه دوم» است. یعنی چه؟ تصور کنید کنترل‌گر کلاسیک مثل ضربه‌های کوتاه ترمز است — موثر اما تند و ناپیوسته. Super-Twisting مثل ترمز ABS است — اصلاحات نرم و پیوسته با همان نتیجه، بدون رفتار قطع‌و‌وصل خشن. این الگوریتم بر اساس کار Levant (2005) است و وقتی فرمان‌های نرم برای عملگر مهم هستند (مثل رباتیک) عالی عمل می‌کند.

**هوشمندان سازگار: Adaptive و Hybrid**

اینجا هوش وارد می‌شود. سه کنترل‌گر داریم که **یاد می‌گیرند و سازگار می‌شوند**:

1. **Adaptive SMC**: این کنترل‌گر در زمان واقعی بهره‌های خودش را بر اساس بزرگی خطا تنظیم می‌کند. اگر آونگ ناگهان نوسان شدید بگیرد (مثلا وزن اضافه شده باشد)، کنترل‌گر متوجه می‌شود و تهاجم خود را بالا می‌برد. بدون تنظیم دستی.

2. **Hybrid Adaptive STA-SMC**: بهترینِ هر دو دنیا — نرمی Super-Twisting و خودتنظیمی Adaptive. در بنچمارک MT-8 ما، این هیولا ۲۱.۴٪ بهبود نسبت به خط مبنا داشت. این در نظریه کنترل عدد بزرگی است.

3. **Conditional Hybrid**: نسخه «ایمن‌محور». هوشمندانه بین Adaptive و Super-Twisting جابه‌جا می‌شود. چرا؟ چون برخی پیکربندی‌های ریاضی (تکینی‌ها) می‌توانند مشکل عددی ایجاد کنند. این کنترل‌گر آن نواحی خطر را تشخیص می‌دهد و استراتژی را عوض می‌کند.

**واقع‌گرا: Swing-Up SMC**

کنترل‌گرهای قبلی فرض می‌کنند آونگ از نزدیک وضعیت عمودی شروع می‌کند — مثل یک جاروب که از قبل تقریبا تعادل دارد. اما اگر آونگ از پایین آویزان شروع کند چه؟ Swing-Up SMC ابتدا با کنترل مبتنی بر انرژی آونگ را بالا می‌آورد (مثل تاب خوردن روی تاب) و سپس به حالت پایدارسازی می‌رود. این سناریو واقعی‌ترین حالت برای سخت‌افزار است.

**بیگانه آزمایشی: Model Predictive Control (MPC)**

این یکی متفاوت است. MPC از خانواده کنترل مد لغزشی نیست — از یک خانواده کاملا متفاوت می‌آید. ما آن را برای مقایسه پژوهشی و به‌خاطر قابلیت اعمال محدودیت‌ها (مثل «گاری به دیوار نخورد») اضافه کرده‌ایم. نیاز به کتابخانه‌های بهینه‌سازی سنگین دارد، بنابراین آزمایشی است. مثل یک مهمان از سریال دیگر.

### 2. مدل‌های گیاه (Plant): سه سطح واقعیت

برای شبیه‌سازی آونگ به یک مدل ریاضی نیاز داریم. اما اینجا یک معامله وجود دارد: مدل دقیق‌تر کندتر است، مدل ساده‌تر سریع‌تر اما کم‌دقت‌تر. سه مدل ارائه می‌کنیم — مثل تنظیمات کیفیت در بازی‌های ویدیویی:

**DIP ساده‌شده: نمونه‌سازی سریع**

این مدل فرض می‌کند زاویه‌های آونگ کوچک هستند (حدود ۵ درجه از عمود). با این فرض، سینوس و کسینوس به خط تبدیل می‌شوند (sin(theta) ≈ theta). سریع‌ترین مدل است چون محاسبات مثلثاتی ندارد. برای تست اولیه و بهینه‌سازی PSO که هزاران شبیه‌سازی نیاز دارد مناسب است.

**DIP غیرخطی کامل: استاندارد طلایی**

این نسخه کامل معادلات حرکت را با تمام ترم‌های غیرخطی دارد. نیروهای کوریولیس، گریز از مرکز، و اثرات ژیروسکوپی را شامل می‌شود. در کل دامنه کاری دقیق است — از آویزان رو به پایین تا کاملا عمودی. برای اعتبارسنجی نهایی و نتایج قابل انتشار در مقاله‌ها استفاده می‌شود.

**DIP با رتبه پایین: دیو سرعت**

این یک مدل کاهش‌یافته است — با تحلیل ریاضی مشخص کرده‌ایم کدام بخش‌های دینامیک مهم‌ترند و کدام را می‌توان ساده‌تر کرد. نتیجه؟ ۱۰ تا ۵۰ برابر سریع‌تر از مدل کامل، در حالی‌که دینامیک غالب حفظ می‌شود. برای مطالعات مونت‌کارلو با ۱۰۰۰ شبیه‌سازی یا تحلیل حساسیت استفاده می‌شود.

### 3. موتور شبیه‌سازی مرکزی: قلب عملیات

موتور شبیه‌سازی مثل کف کارخانه است که کار اصلی آنجا انجام می‌شود. سه جزء اصلی داریم:

**Simulation Runner: استادکار دقیق**

این بخش شبیه‌سازی تک‌اجرا با لاگ‌گیری دقیق را مدیریت می‌کند. مثل یک استادکار که یک آزمایش را با دقت انجام می‌دهد و همه چیز را یادداشت می‌کند. می‌توانید روش‌های انتگرال‌گیری مختلف انتخاب کنید — Euler (ساده اما خشن)، RK4 (استاندارد صنعتی)، یا RK45 (گام تطبیقی که در بخش‌های آسان سریع‌تر و در بخش‌های سخت کندتر می‌شود). خروجی مانیتورینگ زنده و تصویرسازی لحظه‌ای دارد و اگر مشکلی پیش بیاید خروجی تشخیصی می‌دهد.

**Vectorized Simulator: خط مونتاژ**

اگر ۱۰۰ یا ۱۰۰۰ شبیه‌سازی لازم دارید، نمی‌خواهید یکی‌یکی صبر کنید. اینجاست که شبیه‌ساز برداری وارد می‌شود. با broadcasting در NumPy چندین شبیه‌سازی را همزمان اجرا می‌کند و ۱۰ تا ۱۰۰ برابر سرعت می‌دهد. برای حلقه‌های داخلی از Numba JIT استفاده می‌کنیم که پایتون را در لحظه به کد ماشین تبدیل می‌کند. از نظر حافظه هم بهینه است تا RAM منفجر نشود.

**Simulation Context: مدیر پروژه**

این بخش مدیریت پیکربندی است — مدیری که مطمئن می‌شود همه با پارامترهای یکسان کار می‌کنند. اعتبارسنجی نوع پارامترها را انجام می‌دهد (تا به‌جای عدد، رشته ندهید)، قابلیت بازتولید از طریق seed تصادفی فراهم می‌کند و از checkpoint/resume پشتیبانی می‌کند تا بتوانید اجراهای طولانی را متوقف و ادامه دهید.

### 4. بهینه‌سازی PSO: تنظیم‌گر هوشمند

PSO مخفف Particle Swarm Optimization است — الگوریتمی الهام‌گرفته از رفتار جمعی پرندگان یا ماهی‌ها برای یافتن غذا. سازوکار آن:

**ایده پایه**

تصور کنید چشم‌بند دارید و در یک دشت دنبال بلندترین نقطه می‌گردید. اگر فقط تصادفی حرکت کنید، خیلی کند است. حالا تصور کنید ۳۰ تا ۵۰ نفر دوست همزمان جست‌وجو می‌کنند و به هم می‌گویند کجا بالاتر است. هر نفر بر اساس دو چیز حرکت می‌کند: (۱) بهترین جای خودش و (۲) بهترین جای هر کسی در گروه. این همان PSO است. هر «ذره» یک مجموعه از بهره‌های کنترل‌گر است که می‌خواهیم تنظیم کنیم.

**تابع هزینه چندهدفه**

ما فقط یک چیز را بهینه نمی‌کنیم — سه هدف را همزمان داریم:
1. **خطای حالت**: چقدر آونگ نزدیک عمود است؟
2. **تلاش کنترلی**: چقدر انرژی مصرف می‌شود؟ (کمتر بهتر)
3. **چترینگ**: نوسان‌های فرکانس بالا در سیگنال کنترل (برای سخت‌افزار بد است)

الگوریتم PSO بهره‌هایی را پیدا می‌کند که این سه هدف را متعادل کنند.

**بهبودهای واقعی عملکرد**

آیا کار می‌کند؟ قطعا. در بنچمارک MT-8، برای Classical SMC تا ۳۶۰٪ بهبود در برخی بهره‌ها دیدیم. Hybrid Adaptive STA کاهش هزینه ۲۱.۴٪ داشت. و با PSO مقاوم (که چند سناریوی اغتشاش را تست می‌کند) بهبود میانگین ۶.۳۵٪ برای همه هفت کنترل‌گر به دست آمد. همان موشک SpaceX؟ چنین درصدهایی می‌تواند تفاوت بین فرود موفق و یک آتش‌سوزی گران باشد.

### 5. تحلیل و تصویرسازی: معنا دادن به داده‌ها

پس از شبیه‌سازی، حجم عظیمی از داده‌ها دارید. ابزار تحلیل و تصویرسازی کمک می‌کند معنای آنها را بفهمید:

**تحلیل عملکرد: کارنامه**

متریک‌های استاندارد کنترل را محاسبه می‌کنیم — زمان نشست (چقدر طول می‌کشد پایدار شود؟)، فراجهش (چقدر از عمود عبور می‌کند؟)، و خطای ماندگار (در بلندمدت چقدر دقیق است؟). تحلیل پایداری و روباستی هم داریم: حاشیه بهره و حاشیه فاز (چقدر می‌توان بهره‌ها را بالا برد قبل از ناپایداری). همچنین توابع لیاپانوف را مانیتور می‌کنیم تا پایداری ریاضی را لحظه‌ای بررسی کنیم.

**تصویرسازی: دیدن یعنی باور کردن**

انیماتور زمان واقعی داریم که حرکت آونگ را نشان می‌دهد — عالی برای اشکال‌زدایی و تحت تاثیر قرار دادن استاد راهنما. نمودارهای مسیر حالت، تلاش کنترلی در زمان، و رفتار سطح لغزش تولید می‌کنیم. برای مقاله‌ها، نمودارهای مقایسه‌ای داریم که چند کنترل‌گر را کنار هم می‌گذارد. همه چیز با matplotlib و seaborn آماده انتشار است.

**ابزارهای آماری: اثبات اینکه تصادفی نیست**

یک اجرای موفق چیزی را ثابت نمی‌کند — ممکن است شانس بوده باشد. بنابراین ابزارهای آماری دقیق داریم: بازه اطمینان با bootstrap، آزمون فرضیه با Welch t-test و ANOVA، مطالعات مونت‌کارلو با بیش از ۱۰۰۰ شبیه‌سازی، و اعتبارسنجی متقابل برای PSO تا مطمئن شویم نتایج تعمیم‌پذیرند.

## جریان کار پروژه: از نصب تا مقاله

اجازه بدهید مسیر معمول از «تازه شنیده‌ام این پروژه چیست» تا «نتایج پژوهشی چاپ می‌کنم» را قدم‌به‌قدم مرور کنیم. فرمان‌های دقیق در GitHub هست، پس فقط روی جریان کلی تمرکز کنید.

### فاز 1: آماده‌سازی آزمایشگاه (15 دقیقه)

ابتدا باید محیط پایتون را آماده کنید. مثل جمع‌آوری تجهیزات آزمایشگاه:

1. **کلون کردن مخزن**: دانلود کد از GitHub به رایانه شما
2. **ساخت محیط مجازی**: یک محیط ایزوله برای پایتون ایجاد کنید تا با پروژه‌های دیگر تداخل نداشته باشد
3. **نصب وابستگی‌ها**: کتابخانه‌هایی مثل NumPy, SciPy, matplotlib و چندین بسته دیگر را نصب کنید
4. **اعتبارسنجی نصب**: یک دستور سریع اجرا کنید تا مطمئن شوید همه چیز درست کار می‌کند

اگر همه چیز درست باشد، خروجی پارامترهای پیش‌فرض پیکربندی را می‌بینید. این یعنی آماده اجرای شبیه‌سازی هستید.

### فاز 2: اولین آزمایش‌ها (30 دقیقه)

حالا بخش جذاب شروع می‌شود. اولین شبیه‌سازی‌ها:

با **کنترل‌گر Classical SMC** شروع کنید و از شبیه‌ساز بخواهید نمودارها را بسازد. وضعیت آونگ در زمان، نیروی کنترلی اعمال‌شده، و رفتار سطح لغزش را می‌بینید. نگاه کنید — آیا آونگ سریع به عمود می‌رسد؟ آیا فراجهش دارد؟ فرمان‌ها چقدر تهاجمی‌اند؟

بعد **الگوریتم Super-Twisting** را تست کنید. همان فرمان، فقط نام کنترل‌گر را عوض کنید. نتایج را مقایسه کنید — می‌بینید سیگنال کنترل نرم‌تر است؟ این همان کاهش چترینگ است.

در نهایت **کنترل‌گر Adaptive SMC** را امتحان کنید. دقت کنید چگونه بهره‌ها در طول شبیه‌سازی تغییر می‌کنند.

**به چه چیزهایی توجه کنیم:**
- **زمان نشست**: چقدر طول می‌کشد به حالت عمودی برسد؟ سریع بهتر است، اما نه با فراجهش زیاد.
- **فراجهش**: آیا از عمود عبور می‌کند؟ کمی قابل قبول است، اما زیاد نه.
- **تلاش کنترلی**: فرمان‌های عملگر چقدر تهاجمی‌اند؟ کمتر بهتر است برای مصرف انرژی و عمر سخت‌افزار.
- **چترینگ**: نوسان‌های فرکانس بالا در سیگنال کنترل را بررسی کنید — دشمن سخت‌افزار واقعی.

### فاز 3: تنظیم هوشمند (2-4 ساعت)

تا اینجا از بهره‌های پیش‌فرض استفاده کردید — حدس‌های آگاهانه. حالا PSO را برای بهینه‌سازی خودکار استفاده کنید.

به شبیه‌ساز بگویید PSO را برای کنترل‌گر Classical SMC اجرا کند و نتایج را ذخیره کند. روند تکرارها را می‌بینید:
- **تکرار 0**: شروع تصادفی — ذرات پراکنده‌اند، هزینه شاید صدها یا هزاران باشد
- **تکرارهای 10-20**: همگرایی آغاز می‌شود — ذرات اطراف نواحی خوب جمع می‌شوند، هزینه به بازه 10-50 می‌رسد
- **تکرارهای 40-50**: ریزتنظیم — بهبودهای کوچک، هزینه حدود 1-5

این مرحله ۲ تا ۴ ساعت طول می‌کشد. قهوه بگیرید، تکالیف انجام دهید. وقتی تمام شد، بهره‌های بهینه‌شده را در یک فایل دارید.

حالا آن بهره‌ها را تست کنید — بارگذاری کنید و شبیه‌سازی با نمودار انجام دهید. با فاز 2 مقایسه کنید. باید بهبود قابل توجه ببینید: زمان نشست کمتر، فراجهش کمتر، کنترل نرم‌تر.

### فاز 4: بنچمارک جدی (1-2 روز)

حالا جدی می‌شوید. مجموعه بنچمارک جامع را اجرا کنید — همه هفت کنترل‌گر را در سناریوهای متعدد تست می‌کند (شرایط اولیه، اغتشاشات، عدم‌قطعیت‌ها). جدول‌های متریک عملکرد، تحلیل چترینگ و نمودارهای مقایسه‌ای تولید می‌شود که مناسب مقاله هستند.

اینجاست که به بینش‌هایی مثل «Hybrid Adaptive STA بهبود ۲۱.۴٪ دارد» یا «Classical SMC بیشترین شاخص چترینگ را دارد» می‌رسید. شما فقط شبیه‌سازی نمی‌کنید — علم انجام می‌دهید.
