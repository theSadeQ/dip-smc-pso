#!/usr/bin/env python
"""
[OK] Podcast Episode Generator
Creates individual PDF files for each podcast episode by combining
presentation slides with detailed speaker scripts.

Usage:
    python create_podcast_episodes.py --parts all --output ../episodes/
    python create_podcast_episodes.py --parts part1 --output ../episodes/
    python create_podcast_episodes.py --episode E001 --output ../episodes/
"""

import argparse
import os
import subprocess
from pathlib import Path
from typing import List, Dict

# Episode definitions (matches PODCAST_PRODUCTION_PLAN.md)
EPISODE_PLAN = {
    "part1_foundations": [
        {"id": "E001", "section": "01", "title": "What is DIP-SMC-PSO? The Double Inverted Pendulum Challenge"},
        {"id": "E002", "section": "01", "title": "Seven Controllers: From Classical SMC to Hybrid Adaptive"},
        {"id": "E003", "section": "01", "title": "PSO Automation: Why Manual Tuning Is Dead"},
        {"id": "E004", "section": "01", "title": "Architecture Overview: 328 Files, 85% Test Coverage"},
        {"id": "E005", "section": "02", "title": "Sliding Mode Control Fundamentals: Reaching and Sliding"},
        {"id": "E006", "section": "02", "title": "Lyapunov Stability: Why Controllers Don't Blow Up"},
        {"id": "E007", "section": "02", "title": "Chattering Problem: The Dark Side of SMC"},
        {"id": "E008", "section": "02", "title": "Super-Twisting Algorithm: Smooth Yet Robust Control"},
        {"id": "E009", "section": "03", "title": "DIP Dynamics: Equations of Motion Deep Dive"},
        {"id": "E010", "section": "03", "title": "Simplified vs Full Models: The Accuracy Tradeoff"},
        {"id": "E011", "section": "03", "title": "State Space Representation: Why 6 States Matter"},
        {"id": "E012", "section": "03", "title": "Model Validation: How We Know Our Physics Is Right"},
        {"id": "E013", "section": "04", "title": "Particle Swarm Intelligence: Nature-Inspired Algorithms"},
        {"id": "E014", "section": "04", "title": "50 Particles, 200 Iterations: The PSO Workflow"},
        {"id": "E015", "section": "04", "title": "Cost Functions: Designing Objective Functions for Control"},
        {"id": "E016", "section": "04", "title": "Convergence Proof: Why PSO Works for Gain Tuning"},
        {"id": "E017", "section": "05", "title": "RK45 Integration: Numerically Solving Nonlinear ODEs"},
        {"id": "E018", "section": "05", "title": "Numba Vectorization: 50x Speedup for Batch Simulations"},
        {"id": "E019", "section": "05", "title": "Monte Carlo Validation: 1000 Trials Per Controller"},
        {"id": "E020", "section": "05", "title": "Real-Time Constraints: 10ms Control Loops"},
    ],
    # Add more parts as needed (Part 2, 3, 4, Appendix)
}


def create_episode_tex(episode: Dict, output_dir: Path, base_dir: Path) -> Path:
    """
    Create a standalone LaTeX file for one episode.

    Args:
        episode: Episode metadata (id, section, title)
        output_dir: Directory to save episode .tex file
        base_dir: Base directory of presentations (for relative paths)

    Returns:
        Path to generated .tex file
    """
    episode_id = episode["id"]
    section_num = episode["section"]
    title = episode["title"]

    # Create episode-specific .tex file
    tex_filename = output_dir / f"{episode_id}_{title.replace(' ', '_').replace(':', '').lower()}.tex"

    # LaTeX template for episode
    tex_content = f"""% ============================================================================
% Podcast Episode {episode_id}: {title}
% ============================================================================
% Auto-generated by create_podcast_episodes.py
% Part of DIP-SMC-PSO comprehensive podcast series (100+ episodes, 30+ hours)
% ============================================================================

\\documentclass[11pt,a4paper]{{article}}

% Load presentation config (packages, commands)
\\input{{../../speaker_config.tex}}

% Title information
\\title{{%
    \\Large\\textbf{{Podcast Episode {episode_id}}} \\\\[0.5em]
    \\large {title} \\\\[1em]
    \\normalsize DIP-SMC-PSO Project
}}
\\author{{Generated from comprehensive presentation materials}}
\\date{{\\today}}

\\begin{{document}}

\\maketitle
\\thispagestyle{{empty}}

% ============================================================================
% EPISODE CONTENT
% ============================================================================
% This episode covers Section {section_num} content
% Estimated duration: 15-20 minutes when converted to audio via NotebookLM
% ============================================================================

\\section*{{Episode Overview}}

This episode is part of a comprehensive 100+ episode podcast series covering
the Double-Inverted Pendulum Sliding Mode Control with PSO Optimization project.

\\textbf{{Topic:}} {title}

\\textbf{{Section:}} {section_num}

\\textbf{{Duration:}} 15-20 minutes (estimated)

\\textbf{{Format:}} Conversational AI-generated audio via Google NotebookLM

% ============================================================================
% MAIN CONTENT (placeholder - needs expansion)
% ============================================================================

\\section{{Introduction}}

[TODO: Add detailed content for this episode]

This episode should cover the following key points:
\\begin{{itemize}}
    \\item Overview of the topic
    \\item Technical deep-dive with examples
    \\item Connections to other parts of the project
    \\item Practical insights and lessons learned
\\end{{itemize}}

\\section{{Technical Details}}

[TODO: Extract relevant slides from sections/part1\\_foundations/{section_num}\\_*.tex]

\\section{{Key Takeaways}}

[TODO: Summarize main points]

\\section{{Next Episode Preview}}

[TODO: Transition to next episode topic]

% ============================================================================
% METADATA FOR NOTEBOOKLM
% ============================================================================

\\section*{{Production Notes}}

\\textbf{{NotebookLM Processing:}}
\\begin{{enumerate}}
    \\item Compile this .tex file to PDF: \\texttt{{pdflatex {episode_id}\\_...}}
    \\item Upload PDF to NotebookLM notebook
    \\item Click "Generate Audio Overview"
    \\item Download resulting .mp3 file
    \\item Rename to: \\texttt{{{episode_id}\\_{title.replace(' ', '_')}.mp3}}
\\end{{enumerate}}

\\textbf{{Target Audience:}} Graduate students, control engineers, Python developers

\\textbf{{Prerequisites:}} Basic understanding of control theory and Python

\\textbf{{Related Episodes:}}
\\begin{{itemize}}
    \\item Previous: [Episode ID]
    \\item Next: [Episode ID]
\\end{{itemize}}

\\end{{document}}
"""

    # Write .tex file
    tex_filename.parent.mkdir(parents=True, exist_ok=True)
    with open(tex_filename, 'w', encoding='utf-8') as f:
        f.write(tex_content)

    print(f"[OK] Created {tex_filename.name}")
    return tex_filename


def compile_episode_pdf(tex_file: Path, output_dir: Path) -> Path:
    """
    Compile episode .tex file to PDF using pdflatex.

    Args:
        tex_file: Path to .tex file
        output_dir: Directory for PDF output

    Returns:
        Path to generated PDF
    """
    try:
        # Run pdflatex twice (for references)
        for _ in range(2):
            result = subprocess.run(
                ['pdflatex', '-interaction=nonstopmode', '-output-directory',
                 str(output_dir), str(tex_file)],
                capture_output=True,
                text=True,
                check=False
            )

        pdf_file = output_dir / tex_file.with_suffix('.pdf').name
        if pdf_file.exists():
            print(f"[OK] Compiled {pdf_file.name}")

            # Cleanup auxiliary files
            for ext in ['.aux', '.log', '.out', '.toc']:
                aux_file = output_dir / tex_file.with_suffix(ext).name
                if aux_file.exists():
                    aux_file.unlink()

            return pdf_file
        else:
            print(f"[ERROR] PDF compilation failed for {tex_file.name}")
            print(result.stdout)
            return None

    except FileNotFoundError:
        print("[ERROR] pdflatex not found. Install MiKTeX or TeX Live.")
        return None


def main():
    parser = argparse.ArgumentParser(description='Generate podcast episode PDFs')
    parser.add_argument('--parts', nargs='+', choices=['all', 'part1', 'part2', 'part3', 'part4', 'appendix'],
                        default=['all'], help='Which parts to process')
    parser.add_argument('--episode', type=str, help='Generate single episode (e.g., E001)')
    parser.add_argument('--output', type=str, required=True, help='Output directory for episodes')
    parser.add_argument('--no-compile', action='store_true', help='Skip PDF compilation (just create .tex)')

    args = parser.parse_args()

    # Setup paths
    script_dir = Path(__file__).parent
    base_dir = script_dir.parent.parent  # presentations/
    output_dir = Path(args.output)
    output_dir.mkdir(parents=True, exist_ok=True)

    print(f"[INFO] Base directory: {base_dir}")
    print(f"[INFO] Output directory: {output_dir}")

    # Determine which episodes to generate
    episodes_to_generate = []

    if args.episode:
        # Single episode mode
        for part, episodes in EPISODE_PLAN.items():
            for ep in episodes:
                if ep['id'] == args.episode:
                    episodes_to_generate.append((part, ep))
                    break
    else:
        # Multiple parts mode
        parts_to_process = args.parts
        if 'all' in parts_to_process:
            parts_to_process = list(EPISODE_PLAN.keys())

        for part in parts_to_process:
            if part in EPISODE_PLAN:
                for ep in EPISODE_PLAN[part]:
                    episodes_to_generate.append((part, ep))

    print(f"[INFO] Generating {len(episodes_to_generate)} episodes...")

    # Generate episodes
    for part, episode in episodes_to_generate:
        part_dir = output_dir / part
        tex_file = create_episode_tex(episode, part_dir, base_dir)

        if not args.no_compile and tex_file:
            pdf_file = compile_episode_pdf(tex_file, part_dir)

    print(f"\n[OK] Generated {len(episodes_to_generate)} episodes in {output_dir}")
    print(f"\n[NEXT STEPS]")
    print(f"1. Review generated PDFs in {output_dir}")
    print(f"2. Upload each PDF to NotebookLM separately")
    print(f"3. Generate audio for each episode (20 min per episode)")
    print(f"4. Download .mp3 files and organize in podcasts/audio/")


if __name__ == '__main__':
    main()
